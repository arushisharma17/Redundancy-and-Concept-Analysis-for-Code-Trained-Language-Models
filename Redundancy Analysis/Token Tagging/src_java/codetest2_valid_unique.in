addParam ( DX , String . valueOf ( xspace ) ) ; 
addParam ( DY , String . valueOf ( xspace ) ) ; 
case EQUIDISTANT : 
xrowi = 1. ; 
xcoli = 1. ; 
xspace = vals [ 37 ] / 1000. ; 
yspace = vals [ 38 ] / 1000. ; 
addParam ( LA1 , String . valueOf ( glamx ) ) ; 
addParam ( LO1 , String . valueOf ( glomx ) ) ; 
addParam ( DY , String . valueOf ( yspace ) ) ; 
case LAMBERT_CONFORMAL_TANGENT : 
if ( Double . compare ( xt2 , ( double ) McIDASUtil . MCMISSING ) == 0 || ( xt2 == 0 ) ) { 
xt2 = xt1 ; 
} public String getProjName ( int type ) { 
String projName ; 
projName = "MERC" ; 
projName = ( vals [ 38 ] == vals [ 39 ] ) 
? "PS" 
: "CONF" ; 
projName = "EQUI" ; 
projName = "CONF" ; 
projName = "NAV" + type ; 
return projName ; 
} private void sendMessage ( int port , String message ) { 
Socket connection = null ; 
connection = new Socket ( "localhost" , port ) ; 
IO . writeContents ( message , connection . getOutputStream ( ) ) ; 
System . err . println ( e ) ; 
try { if ( connection != null ) connection . close ( ) ; } 
catch ( IOException e ) { } 
new SocketMessage ( 9999 , "startNewServer" ) ; 
raw = true ; 
String url = "http://localhost:8080/thredds/test/it" 
+ "?" + EscapeStrings . escapeOGC ( "quuery[1]" ) ; 
try ( HTTPMethod method = HTTPFactory . Head ( url ) ) { 
method . execute ( ) ; 
int status = method . getStatusCode ( ) ; 
System . out . printf ( "%d%n" , status ) ; 
} public void move ( int deltax , int deltay ) { 
anchorPt . x = current . x + deltax ; 
anchorPt . y = current . y + deltay ; 
stretchedPt . x = current . x + current . width + deltax ; 
stretchedPt . y = current . y + current . height + deltay ; 
} private void showDDS ( Message m1 ) { 
Formatter f1 = new Formatter ( ) ; 
m1 . dump ( f1 ) ; 
TextHistoryPane ta = new TextHistoryPane ( ) ; 
info . setBounds ( ( Rectangle ) prefs . getBean ( "InfoWindowBounds" , new Rectangle ( 300 , 300 , 500 , 300 ) ) ) ; 
ta . appendLine ( f1 . toString ( ) ) ; 
ta . gotoTop ( ) ; 
info . show ( ) ; 
messageTable . saveState ( false ) ; 
ddsTable . saveState ( false ) ; 
obsTable . saveState ( false ) ; 
prefs . putBeanObject ( "InfoWindowBounds2" , infoWindow2 . getBounds ( ) ) ; 
prefs . putInt ( "splitPos2" , split2 . getDividerLocation ( ) ) ; 
} public List getStations ( ucar . unidata . geoloc . LatLonRect boundingBox ) throws IOException { 
return typical . getStations ( boundingBox ) ; 
} public ucar . unidata . geoloc . Station getStation ( String name ) { 
return typical . getStation ( name ) ; 
} public DataIterator getDataIterator ( ucar . unidata . geoloc . Station s ) throws IOException { 
return new StationDataIterator ( s ) ; 
} public DataIterator getDataIterator ( ucar . unidata . geoloc . Station s , Date start , Date end ) throws IOException { 
return new StationDateDataIterator ( s , start , end ) ; 
} public void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { 
long offset = rayOffset ; 
offset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; 
int dataCount = getGateCount ( abbrev ) ; 
byte [ ] data = new byte [ dataCount * 2 ] ; 
ii . setShortNext ( uf_header2 . missing ) ; 
b2 [ 0 ] = data [ gateIdx * 2 ] ; 
b2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; 
short value = getShort ( b2 , 0 ) ; 
ii . setShortNext ( value ) ; 
return vars . size ( ) ; 
if ( index < vars . size ( ) ) 
return ( ( BaseType ) vars . elementAt ( index ) ) ; 
throw new NoSuchVariableException ( 
if ( e . hasMoreElements ( ) ) 
DStructure s = ( DStructure ) super . cloneDAG ( map ) ; 
s . vars = new Vector ( ) ; 
BaseType bt = ( BaseType ) vars . elementAt ( i ) ; 
s . vars . addElement ( btclone ) ; 
sink . writeFloat ( vals [ i ] ) ; 
public static LatLon2DCoord getLatLon2DcoordType ( int discipline , int category , int parameter ) { 
if ( ( discipline != 0 ) || ( category != 2 ) || ( parameter < 198 || parameter > 203 ) ) return null ; 
switch ( parameter ) { 
case 198 : 
return LatLon2DCoord . U_Latitude ; 
case 199 : 
return LatLon2DCoord . U_Longitude ; 
case 200 : 
return LatLon2DCoord . V_Latitude ; 
case 201 : 
return LatLon2DCoord . V_Longitude ; 
case 202 : 
return LatLon2DCoord . P_Latitude ; 
case 203 : 
return LatLon2DCoord . P_Longitude ; 
} public static LatLonCoordType getLatLon2DcoordType ( String desc ) { 
LatLonCoordType type ; 
if ( desc . contains ( "u-component" ) ) type = LatLonCoordType . U ; 
else if ( desc . contains ( "v-component" ) ) type = LatLonCoordType . V ; 
else type = LatLonCoordType . P ; 
} public static void compareTables ( String name1 , String name2 , List < ? extends GribTables . Parameter > test , Grib2Tables reference , Formatter f ) { 
for ( GribTables . Parameter p1 : test ) { 
GribTables . Parameter p2 = reference . getParameter ( p1 . getDiscipline ( ) , p1 . getCategory ( ) , p1 . getNumber ( ) ) ; 
if ( p1 . getCategory ( ) < 192 && p1 . getNumber ( ) < 192 ) { 
String p1n = Util . cleanName ( p1 . getName ( ) ) ; 
String p2n = Util . cleanName ( p2 . getName ( ) ) ; 
if ( ! p1n . equalsIgnoreCase ( p2n ) ) { 
int local = 0 ; 
local ++ ; 
} public double cos ( MAVector v ) { 
if ( nelems != v . getNelems ( ) ) 
double norm = norm ( ) ; 
double normV = v . norm ( ) ; 
if ( ( norm == 0.0 ) || ( normV == 0.0 ) ) 
return 0.0 ; 
return dot ( v ) / ( norm * normV ) ; 
} public double dot ( MAVector v ) { 
for ( int k = 0 ; k < nelems ; k ++ ) 
sum += getDouble ( k ) * v . getDouble ( k ) ; 
} public double norm ( ) { 
for ( int k = 0 ; k < nelems ; k ++ ) { 
double val = getDouble ( k ) ; 
sum += val * val ; 
return Math . sqrt ( sum ) ; 
} public void normalize ( ) { 
if ( norm <= 0.0 ) 
setDouble ( k , val / norm ) ; 
} public Catalog makeCatalog ( ) { 
setServices ( getDatasets ( ) ) ; 
Map < String , Object > flds = setFields ( ) ; 
return new Catalog ( baseURI , name , flds , datasetBuilders ) ; 
} private void setServices ( Iterable < DatasetBuilder > dsIter ) { 
for ( DatasetBuilder dsb : dsIter ) { 
for ( Service s : dsb . getServices ( ) ) { 
addService ( s ) ; 
setServices ( dsb . getDatasets ( ) ) ; 
} private void readXML ( String location ) throws IOException { 
SAXBuilder saxBuilder = new SAXBuilder ( ) ; 
Document jdomDoc = saxBuilder . build ( location ) ; 
readCatalog ( jdomDoc . getRootElement ( ) ) ; 
catch ( Exception e ) { 
if ( logger . isTraceEnabled ( ) ) { 
} private void readCatalog ( Element catalogElem ) { 
String name = catalogElem . getAttributeValue ( "name" ) ; 
String catSpecifiedBaseURL = catalogElem . getAttributeValue ( "base" ) ; 
String expiresS = catalogElem . getAttributeValue ( "expires" ) ; 
String version = catalogElem . getAttributeValue ( "version" ) ; 
CalendarDate expires = null ; 
if ( expiresS != null ) { 
expires = CalendarDateFormatter . isoStringToCalendarDate ( null , expiresS ) ; 
if ( catSpecifiedBaseURL != null ) { 
URI userSpecifiedBaseUri = new URI ( catSpecifiedBaseURL ) ; 
this . baseURI = userSpecifiedBaseUri ; 
setName ( name ) ; 
setExpires ( expires ) ; 
setVersion ( version ) ; 
java . util . List < Element > sList = catalogElem . getChildren ( "service" , Catalog . defNS ) ; 
for ( Element e : sList ) { 
addService ( readService ( e ) ) ; 
java . util . List < Element > pList = catalogElem . getChildren ( "property" , Catalog . defNS ) ; 
for ( Element e : pList ) { 
addProperty ( readProperty ( e ) ) ; 
java . util . List < Element > allChildren = catalogElem . getChildren ( ) ; 
for ( Element e : allChildren ) { 
if ( e . getName ( ) . equals ( "dataset" ) ) { 
addDataset ( readDataset ( null , e ) ) ; 
else if ( e . getName ( ) . equals ( "catalogRef" ) ) { 
addDataset ( readCatalogRef ( null , e ) ) ; 
addDataset ( buildOtherDataset ( null , e ) ) ; 
} protected AccessBuilder readAccess ( DatasetBuilder dataset , Element accessElem ) { 
Service s = serviceMap . get ( serviceName ) ; 
return new AccessBuilder ( dataset , urlPath , s , dataFormat , readDataSize ( accessElem ) ) ; 
} protected Service readService ( Element s ) { 
String name = s . getAttributeValue ( "name" ) ; 
String typeS = s . getAttributeValue ( "serviceType" ) ; 
String serviceBase = s . getAttributeValue ( "base" ) ; 
String suffix = s . getAttributeValue ( "suffix" ) ; 
String desc = s . getAttributeValue ( "desc" ) ; 
String accessType = s . getAttributeValue ( "accessType" ) ; 
ServiceType type = ServiceType . getServiceTypeIgnoreCase ( typeS ) ; 
desc = type . getDescription ( ) ; 
if ( accessType == null ) { 
accessType = type . getAccessType ( ) ; 
List < Property > properties = null ; 
List < Element > propertyList = s . getChildren ( "property" , Catalog . defNS ) ; 
for ( Element e : propertyList ) { 
properties . add ( readProperty ( e ) ) ; 
List < Service > services = null ; 
java . util . List < Element > serviceList = s . getChildren ( "service" , Catalog . defNS ) ; 
for ( Element e : serviceList ) { 
services = new ArrayList < > ( ) ; 
services . add ( readService ( e ) ) ; 
Service result = new Service ( name , serviceBase , typeS , desc , suffix , services , properties , accessType ) ; 
serviceMap . put ( name , result ) ; 
} protected DatasetBuilder readCatalogRef ( DatasetBuilder parent , Element catRefElem ) { 
String title = catRefElem . getAttributeValue ( "title" , Catalog . xlinkNS ) ; 
title = catRefElem . getAttributeValue ( "name" ) ; 
String href = catRefElem . getAttributeValue ( "href" , Catalog . xlinkNS ) ; 
CatalogRefBuilder catRef = new CatalogRefBuilder ( parent ) ; 
readDatasetInfo ( catRef , catRefElem ) ; 
catRef . setTitle ( title ) ; 
catRef . setHref ( href ) ; 
return catRef ; 
} protected DatasetBuilder readDataset ( DatasetBuilder parent , Element dsElem ) { 
DatasetBuilder dataset = new DatasetBuilder ( parent ) ; 
readDatasetInfo ( dataset , dsElem ) ; 
java . util . List < Element > aList = dsElem . getChildren ( "access" , Catalog . defNS ) ; 
for ( Element e : aList ) { 
dataset . addAccess ( readAccess ( dataset , e ) ) ; 
java . util . List < Element > allChildren = dsElem . getChildren ( ) ; 
dataset . addDataset ( readDataset ( dataset , e ) ) ; 
dataset . addDataset ( readCatalogRef ( dataset , e ) ) ; 
dataset . addDataset ( buildOtherDataset ( dataset , e ) ) ; 
} protected void readThreddsMetadataGroup ( Map < String , Object > flds , DatasetBuilder dataset , Element parent ) { 
List < Element > list ; 
list = parent . getChildren ( "creator" , Catalog . defNS ) ; 
for ( Element e : list ) { 
DatasetBuilder . addToList ( flds , Dataset . Creators , readSource ( e ) ) ; 
list = parent . getChildren ( "contributor" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Contributors , readContributor ( e ) ) ; 
list = parent . getChildren ( "date" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Dates , readDate ( e , null ) ) ; 
list = parent . getChildren ( "documentation" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Documentation , readDocumentation ( e ) ) ; 
list = parent . getChildren ( "keyword" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Keywords , readControlledVocabulary ( e ) ) ; 
list = parent . getChildren ( "metadata" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . MetadataOther , readMetadata ( flds , dataset , e ) ) ; 
list = parent . getChildren ( "project" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Projects , readControlledVocabulary ( e ) ) ; 
list = parent . getChildren ( "property" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Properties , readProperty ( e ) ) ; 
list = parent . getChildren ( "publisher" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . Publishers , readSource ( e ) ) ; 
list = parent . getChildren ( "variables" , Catalog . defNS ) ; 
DatasetBuilder . addToList ( flds , Dataset . VariableGroups , readVariables ( e ) ) ; 
ThreddsMetadata . GeospatialCoverage gc = readGeospatialCoverage ( parent . getChild ( "geospatialCoverage" , Catalog . defNS ) ) ; 
flds . put ( Dataset . GeospatialCoverage , gc ) ; 
DateRange tc = readTimeCoverage ( parent . getChild ( "timeCoverage" , Catalog . defNS ) ) ; 
Element serviceNameElem = parent . getChild ( "serviceName" , Catalog . defNS ) ; 
if ( serviceNameElem != null ) { 
flds . put ( Dataset . ServiceName , serviceNameElem . getText ( ) ) ; 
Element authElem = parent . getChild ( "authority" , Catalog . defNS ) ; 
if ( authElem != null ) { 
flds . put ( Dataset . Authority , authElem . getText ( ) ) ; 
Element dataTypeElem = parent . getChild ( "dataType" , Catalog . defNS ) ; 
if ( dataTypeElem != null ) { 
String dataTypeName = dataTypeElem . getText ( ) ; 
flds . put ( Dataset . FeatureType , dataTypeName ) ; 
if ( ( dataTypeName != null ) && ( dataTypeName . length ( ) > 0 ) ) { 
FeatureType dataType = FeatureType . getType ( dataTypeName . toUpperCase ( ) ) ; 
if ( dataType == null ) { 
Element dataFormatElem = parent . getChild ( "dataFormat" , Catalog . defNS ) ; 
if ( dataFormatElem != null ) { 
String dataFormatTypeName = dataFormatElem . getText ( ) ; 
if ( ( dataFormatTypeName != null ) && ( dataFormatTypeName . length ( ) > 0 ) ) { 
DataFormatType dataFormatType = DataFormatType . getType ( dataFormatTypeName ) ; 
if ( dataFormatType == null ) { 
flds . put ( Dataset . DataFormatType , dataFormatTypeName ) ; 
long size = readDataSize ( parent ) ; 
if ( size > 0 ) { 
flds . put ( Dataset . DataSize , size ) ; 
ThreddsMetadata . UriResolved mapUri = readUri ( parent . getChild ( "variableMap" , Catalog . defNS ) , "variableMap" ) ; 
if ( mapUri != null ) { 
flds . put ( Dataset . VariableMapLinkURI , mapUri ) ; 
} protected Documentation readDocumentation ( Element s ) { 
String href = s . getAttributeValue ( "href" , Catalog . xlinkNS ) ; 
String title = s . getAttributeValue ( "title" , Catalog . xlinkNS ) ; 
String type = s . getAttributeValue ( "type" ) ; 
String content = s . getTextNormalize ( ) ; 
URI uri = null ; 
if ( href != null ) { 
uri = Catalog . resolveUri ( baseURI , href ) ; 
return new Documentation ( href , uri , title , type , content ) ; 
} protected ThreddsMetadata . MetadataOther readMetadata ( Map < String , Object > flds , DatasetBuilder dataset , Element mdataElement ) { 
Namespace namespace ; 
List inlineElements = mdataElement . getChildren ( ) ; 
if ( inlineElements . size ( ) > 0 ) { 
namespace = ( ( Element ) inlineElements . get ( 0 ) ) . getNamespace ( ) ; 
namespace = mdataElement . getNamespace ( ) ; 
String mtype = mdataElement . getAttributeValue ( "metadataType" ) ; 
String href = mdataElement . getAttributeValue ( "href" , Catalog . xlinkNS ) ; 
String title = mdataElement . getAttributeValue ( "title" , Catalog . xlinkNS ) ; 
String inheritedS = mdataElement . getAttributeValue ( "inherited" ) ; 
boolean inherited = ( inheritedS != null ) && inheritedS . equalsIgnoreCase ( "true" ) ; 
boolean isThreddsNamespace = ( ( mtype == null ) || mtype . equalsIgnoreCase ( "THREDDS" ) ) && namespace . getURI ( ) . equals ( Catalog . CATALOG_NAMESPACE_10 ) ; 
if ( ! isThreddsNamespace ) { 
return new ThreddsMetadata . MetadataOther ( mtype , namespace . getURI ( ) , namespace . getPrefix ( ) , inherited , mdataElement ) ; 
return new ThreddsMetadata . MetadataOther ( href , title , mtype , namespace . getURI ( ) , namespace . getPrefix ( ) , inherited ) ; 
Map < String , Object > useFlds ; 
if ( inherited ) { 
ThreddsMetadata tmi = ( ThreddsMetadata ) dataset . get ( Dataset . ThreddsMetadataInheritable ) ; 
dataset . put ( Dataset . ThreddsMetadataInheritable , tmi ) ; 
useFlds = tmi . getFlds ( ) ; 
useFlds = flds ; 
readThreddsMetadataGroup ( useFlds , dataset , mdataElement ) ; 
URI xlinkUri = Catalog . resolveUri ( baseURI , href ) ; 
Element remoteMdata = readMetadataFromUrl ( xlinkUri ) ; 
return readMetadata ( useFlds , dataset , remoteMdata ) ; 
catch ( Exception ioe ) { 
} protected ThreddsMetadata . Source readSource ( Element elem ) { 
if ( elem == null ) { 
ThreddsMetadata . Vocab name = readControlledVocabulary ( elem . getChild ( "name" , Catalog . defNS ) ) ; 
Element contact = elem . getChild ( "contact" , Catalog . defNS ) ; 
if ( contact == null ) { 
return new ThreddsMetadata . Source ( name , contact . getAttributeValue ( "url" ) , contact . getAttributeValue ( "email" ) ) ; 
} protected DateRange readTimeCoverage ( Element tElem ) { 
if ( tElem == null ) { 
Calendar calendar = readCalendar ( tElem . getAttributeValue ( "calendar" ) ) ; 
DateType start = readDate ( tElem . getChild ( "start" , Catalog . defNS ) , calendar ) ; 
DateType end = readDate ( tElem . getChild ( "end" , Catalog . defNS ) , calendar ) ; 
TimeDuration duration = readDuration ( tElem . getChild ( "duration" , Catalog . defNS ) ) ; 
TimeDuration resolution = readDuration ( tElem . getChild ( "resolution" , Catalog . defNS ) ) ; 
return new DateRange ( start , end , duration , resolution ) ; 
catch ( java . lang . IllegalArgumentException e ) { 
} protected ThreddsMetadata . VariableGroup readVariables ( Element varsElem ) { 
if ( varsElem == null ) { 
String vocab = varsElem . getAttributeValue ( "vocabulary" ) ; 
java . util . List < Element > vlist = varsElem . getChildren ( "variable" , Catalog . defNS ) ; 
if ( ( variableMap != null ) && vlist . size ( ) > 0 ) { 
List < ThreddsMetadata . Variable > variables = new ArrayList < > ( ) ; 
for ( Element e : vlist ) { 
variables . add ( readVariable ( e ) ) ; 
return new ThreddsMetadata . VariableGroup ( vocab , variableVocabUri , variableMap , variables ) ; 
} static public TimeDuration parseW3CDuration ( String text ) throws java . text . ParseException { 
TimeDuration td = new TimeDuration ( ) ; 
td . text = text ; 
DatatypeFactory factory = DatatypeFactory . newInstance ( ) ; 
Duration d = factory . newDuration ( text ) ; 
Calendar c = Calendar . getInstance ( ) ; 
c . set ( 1900 , 0 , 1 , 0 , 0 , 0 ) ; 
long secs = d . getTimeInMillis ( c . getTime ( ) ) / 1000 ; 
throw new java . text . ParseException ( e . getMessage ( ) , 0 ) ; 
} private static void doDuration ( String s ) { 
TimeDuration d = new TimeDuration ( s ) ; 
catch ( java . text . ParseException e ) { 
} private int writeBytes ( WritableByteChannel wbc , byte [ ] b ) throws IOException { 
return wbc . write ( ByteBuffer . wrap ( b ) ) ; 
} public Grib1Parameter getParameter ( int id ) { 
if ( parameters == null ) { 
parameters = readParameterTable ( ) ; 
return parameters . get ( id ) ; 
} public Grib1Parameter getLocalParameter ( int id ) { 
} private synchronized Map < Integer , Grib1Parameter > readParameterTable ( ) { 
throw new IllegalStateException ( name ) ; 
if ( name . startsWith ( "table_2_" ) || name . startsWith ( "local_table_2_" ) ) { 
return readParameterTableEcmwf ( ) ; 
} else if ( name . startsWith ( "US058" ) ) { 
return readParameterTableXml ( new FnmocParser ( ) ) ; 
} else if ( name . endsWith ( ".tab" ) ) { 
return readParameterTableTab ( ) ; 
} else if ( name . endsWith ( ".wrf" ) ) { 
return readParameterTableSplit ( "\\|" , new int [ ] { 0 , 3 , 1 , 2 } ) ; 
} else if ( name . endsWith ( ".h" ) ) { 
return readParameterTableNcl ( ) ; 
} else if ( name . endsWith ( ".dss" ) ) { 
return readParameterTableSplit ( "\t" , new int [ ] { 0 , - 1 , 1 , 2 } ) ; 
} else if ( name . endsWith ( ".xml" ) ) { 
return readParameterTableXml ( new DssParser ( Namespace . NO_NAMESPACE ) ) ; 
} else if ( name . startsWith ( "2.98" ) ) { 
return readParameterTableEcmwfEcCodes ( ) ; 
path , ioError . getMessage ( ) ) ; 
throw new RuntimeException ( ioError ) ; 
} private Map < Integer , Grib1Parameter > readParameterTableEcmwf ( ) throws IOException { 
HashMap < Integer , Grib1Parameter > result = new HashMap < > ( ) ; 
BufferedReader br = new BufferedReader ( new InputStreamReader ( is , StandardCharsets . UTF_8 ) ) ) { 
if ( ! line . startsWith ( "..." ) ) { 
this . desc = line ; 
while ( line != null && ! line . startsWith ( "..." ) ) { 
if ( line . startsWith ( "..." ) ) { 
String num = line . trim ( ) ; 
String name = ( line != null ) ? line . trim ( ) : null ; 
String desc = ( line != null ) ? line . trim ( ) : null ; 
String units1 = ( line != null ) ? line . trim ( ) : null ; 
String notes = ( line == null || line . startsWith ( "..." ) ) ? null : line . trim ( ) ; 
if ( desc != null && desc . equalsIgnoreCase ( "undefined" ) ) { 
int p1 ; 
p1 = Integer . parseInt ( num ) ; 
Grib1Parameter parameter = new Grib1Parameter ( this , p1 , name , desc , units1 ) ; 
result . put ( parameter . getNumber ( ) , parameter ) ; 
} private Map < Integer , Grib1Parameter > readParameterTableEcmwfEcCodes ( ) throws IOException { 
String [ ] splitPath = path . split ( "/" ) ; 
String tableNum = splitPath [ splitPath . length - 1 ] . replace ( ".table" , "" ) ; 
while ( line != null && ! line . startsWith ( "#" ) ) { 
String [ ] tmpUnitArray = line . split ( "\\(" ) ; 
String tmpUnit = tmpUnitArray [ tmpUnitArray . length - 1 ] ; 
int lastUnitIndex ; 
while ( ( lastUnitIndex = tmpUnit . lastIndexOf ( ")" ) ) > 0 ) { 
tmpUnit = tmpUnit . substring ( 0 , lastUnitIndex ) . trim ( ) ; 
String unit = tmpUnit . trim ( ) ; 
String [ ] lineArray = line . trim ( ) . split ( "\\s+" ) ; 
String num = lineArray [ 0 ] ; 
String name = lineArray [ 1 ] . trim ( ) ; 
int startDesc = line . indexOf ( "[" ) ; 
int endDesc = line . indexOf ( "]" ) ; 
String desc = line . substring ( startDesc , endDesc ) . trim ( ) ; 
Grib1Parameter parameter = new Grib1Parameter ( this , p1 , name , desc , unit ) ; 
} private Map < Integer , Grib1Parameter > readParameterTableSplit ( String regexp , int [ ] order ) 
String [ ] flds = line . split ( regexp ) ; 
int p1 = Integer . parseInt ( flds [ order [ 0 ] ] . trim ( ) ) ; 
String name = ( order [ 1 ] >= 0 ) ? flds [ order [ 1 ] ] . trim ( ) : null ; 
String desc = flds [ order [ 2 ] ] . trim ( ) ; 
String units = ( flds . length > order [ 3 ] ) ? flds [ order [ 3 ] ] . trim ( ) : "" ; 
Grib1Parameter parameter = new Grib1Parameter ( this , p1 , name , desc , units ) ; 
} public void addName ( final String name , final double value ) 
throws PrefixExistsException { 
final Prefix prefix = new PrefixName ( name , value ) ; 
nameSet . add ( prefix ) ; 
} public void addSymbol ( final String symbol , final double value ) 
final Prefix prefix = new PrefixSymbol ( symbol , value ) ; 
symbolSet . add ( prefix ) ; 
valueMap . put ( new Double ( value ) , prefix ) ; 
} private static Prefix getPrefix ( final String string , final Set < Prefix > set ) { 
for ( final Iterator < Prefix > iter = set . iterator ( ) ; iter . hasNext ( ) ; ) { 
final Prefix prefix = iter . next ( ) ; 
final int comp = prefix . compareTo ( string ) ; 
if ( comp == 0 ) { 
if ( comp > 0 ) { 
} protected boolean emailOK ( ThreddsMetadata . Source p ) { 
String email = p . getEmail ( ) ; 
return email . indexOf ( '@' ) >= 0 ; 
} private static void doOne ( InvCatalogFactory fac , String url ) { 
InvCatalogImpl cat = fac . readXML ( url ) ; 
ADNWriter w = new ADNWriter ( ) ; 
w . writeDatasetEntries ( cat , "C:/temp/adn3" , sbuff ) ; 
} private char peek ( ) throws ParseException { 
reader . mark ( 10 ) ; 
int aChar = reader . read ( ) ; 
reader . reset ( ) ; 
if ( aChar < 0 ) { 
return ( char ) 0 ; 
return ( char ) aChar ; 
} catch ( java . io . IOException e1 ) { 
} private char getChar ( ) throws ParseException { 
int val = reader . read ( ) ; 
position ++ ; 
if ( val < 0 ) { 
position ) ; 
return ( char ) val ; 
throw new ParseException ( e1 . toString ( ) , position ) ; 
} private void eatLiteral ( String literal ) throws ParseException { 
int n = literal . length ( ) ; 
char v = getChar ( ) ; 
if ( v != literal . charAt ( i ) ) { 
} private double eatReal ( ) throws ParseException { 
char t = peek ( ) ; 
if ( Character . isDigit ( t ) || ( t == 'e' ) || ( t == 'E' ) 
|| ( t == '.' ) || ( t == '-' ) || ( t == '+' ) ) { 
b . append ( getChar ( ) ) ; 
return Double . parseDouble ( b . toString ( ) ) ; 
} catch ( NumberFormatException e1 ) { 
} private String eatString ( ) throws ParseException { 
if ( getChar ( ) != '"' ) { 
char t = getChar ( ) ; 
if ( t == '"' ) { 
b . append ( t ) ; 
} private String eatTerm ( ) throws ParseException { 
char val = peek ( ) ; 
if ( ! Character . isJavaIdentifierPart ( val ) ) { 
} private void parseProjcs ( ) throws ParseException { 
eatLiteral ( "PROJCS[" ) ; 
projName = eatString ( ) ; 
eatComma ( ) ; 
parseGeogcs ( ) ; 
char next = getChar ( ) ; 
if ( next == ']' ) { 
} else if ( next != ',' ) { 
String term = eatTerm ( ) ; 
if ( "PARAMETER" . equals ( term ) ) { 
eatParameter ( ) ; 
} else if ( "UNIT" . equals ( term ) ) { 
eatProjcsUnit ( ) ; 
} else if ( "PROJECTION" . equals ( term ) ) { 
eatProjectionType ( ) ; 
} private void eatParameter ( ) throws ParseException { 
eatOpenBrace ( ) ; 
String parameterName = eatString ( ) ; 
Double value = eatReal ( ) ; 
eatCloseBrace ( ) ; 
parameters . put ( parameterName . toLowerCase ( ) , value ) ; 
} private void parseGeogcs ( ) throws ParseException { 
eatLiteral ( "GEOGCS[" ) ; 
geogcsName = eatString ( ) ; 
if ( t == ']' ) { 
} else if ( t != ',' ) { 
if ( "DATUM" . equals ( term ) ) { 
eatDatum ( ) ; 
} else if ( "PRIMEM" . equals ( term ) ) { 
eatPrimem ( ) ; 
eatUnit ( ) ; 
} private void eatSpheroid ( ) throws ParseException { 
eatLiteral ( "SPHEROID" ) ; 
spheroidName = eatString ( ) ; 
majorAxis = eatReal ( ) ; 
inverseMinor = eatReal ( ) ; 
} public double getParameter ( String name ) { 
Double val = ( Double ) parameters . get ( name . toLowerCase ( ) ) ; 
return val . doubleValue ( ) ; 
} public static ProjectionImpl convertWKTToProjection ( WKTParser srp ) { 
if ( ! srp . isPlanarProjection ( ) ) { 
return new ucar . unidata . geoloc . projection . LatLonProjection ( ) ; 
String projectionType = srp . getProjectionType ( ) ; 
double falseEasting = 0 ; 
double falseNorthing = 0 ; 
if ( srp . hasParameter ( "False_Easting" ) ) { 
falseEasting = srp . getParameter ( "False_Easting" ) ; 
if ( srp . hasParameter ( "False_Northing" ) ) { 
falseNorthing = srp . getParameter ( "False_Northing" ) ; 
if ( ( falseEasting != 0.0 ) || ( falseNorthing != 0.0 ) ) { 
if ( srp . getProjUnitName ( ) != null ) { 
SimpleUnit unit = 
SimpleUnit . factoryWithExceptions ( 
srp . getProjUnitName ( ) ) ; 
scalef = unit . convertTo ( srp . getProjUnitValue ( ) , 
SimpleUnit . kmUnit ) ; 
+ srp . getProjUnitName ( ) 
falseEasting *= scalef ; 
falseNorthing *= scalef ; 
if ( srp . getProjName ( ) . contains ( "UTM_Zone_" ) ) 
return processUTM ( srp ) ; 
if ( "Transverse_Mercator" . equals ( projectionType ) ) { 
double lat0 = srp . getParameter ( "Latitude_Of_Origin" ) ; 
double scale = srp . getParameter ( "Scale_Factor" ) ; 
double tangentLon = srp . getParameter ( "Central_Meridian" ) ; 
proj = new TransverseMercator ( lat0 , tangentLon , scale , falseEasting , falseNorthing ) ; 
} else if ( "Lambert_Conformal_Conic" . equals ( projectionType ) ) { 
double lon0 = srp . getParameter ( "Central_Meridian" ) ; 
double par1 = srp . getParameter ( "Standard_Parallel_1" ) ; 
double par2 = par1 ; 
if ( srp . hasParameter ( "Standard_Parallel_2" ) ) { 
par2 = srp . getParameter ( "Standard_Parallel_2" ) ; 
return new LambertConformal ( lat0 , lon0 , par1 , par2 , falseEasting , falseNorthing ) ; 
} else if ( "Albers" . equals ( projectionType ) ) { 
return new AlbersEqualArea ( lat0 , lon0 , par1 , par2 , falseEasting , falseNorthing ) ; 
} else if ( "Stereographic" . equals ( projectionType ) ) { 
double lont = srp . getParameter ( "Central_Meridian" ) ; 
double latt = srp . getParameter ( "Latitude_Of_Origin" ) ; 
return new Stereographic ( latt , lont , scale , falseEasting , falseNorthing ) ; 
} else if ( "Mercator" . equals ( projectionType ) ) { 
proj = new Mercator ( lon0 , lat0 , falseEasting , falseNorthing ) ; 
} else if ( "Universal_Transverse_Mercator" . equals ( projectionType ) ) { 
return proj ; 
} public long calcCRC ( ) { 
long crc ; 
if ( rawData == null ) 
crc = predefinedGridDefinitionCenter << 16 + predefinedGridDefinition ; 
CRC32 crc32 = new CRC32 ( ) ; 
crc32 . update ( rawData ) ; 
crc = crc32 . getValue ( ) ; 
return crc ; 
} public final boolean isThin ( ) { 
if ( rawData == null ) return false ; 
int octet5 = getOctet ( 5 ) ; 
int nv = getOctet ( 4 ) ; 
return ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; 
} private int [ ] getNptsInLine ( Grib1Gds gds ) { 
int numPts ; 
if ( ( gds . getScanMode ( ) & 32 ) == 0 ) { 
numPts = gds . getNy ( ) ; 
numPts = gds . getNx ( ) ; 
int [ ] parallels = new int [ numPts ] ; 
int offset = getOctet ( 5 ) ; 
for ( int i = 0 ; i < numPts ; i ++ ) { 
parallels [ i ] = GribNumbers . int2 ( getOctet ( offset ++ ) , getOctet ( offset ++ ) ) ; 
return parallels ; 
} public boolean hasVerticalCoordinateParameters ( ) { 
return ( octet5 != 255 ) && ( nv != 0 && nv != 255 ) ; 
public int fieldIndex ( String name ) 
DapStructure ds ; 
if ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) 
ds = ( DapStructure ) getTemplate ( ) ; 
else if ( getTemplate ( ) . getSort ( ) . isVar ( ) 
&& ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) 
ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; 
int i = ds . indexByName ( name ) ; 
} static public Scheme 
schemeFor ( DapVariable field ) 
DapType ftype = field . getBaseType ( ) ; 
Scheme scheme = null ; 
boolean isscalar = field . getRank ( ) == 0 ; 
if ( ftype . getTypeSort ( ) . isAtomic ( ) ) 
scheme = Scheme . ATOMIC ; 
if ( ftype . getTypeSort ( ) . isStructType ( ) ) scheme = Scheme . STRUCTARRAY ; 
else if ( ftype . getTypeSort ( ) . isSeqType ( ) ) scheme = Scheme . SEQARRAY ; 
return scheme ; 
} private boolean shouldAddLatLon2D ( boolean tryToAddLatLon2D , CoverageCollection subsetDataset ) { 
if ( ! tryToAddLatLon2D ) { 
HorizCoordSys horizCoordSys = subsetDataset . getHorizCoordSys ( ) ; 
if ( horizCoordSys . isLatLon2D ( ) ) { 
if ( ! horizCoordSys . isProjection ( ) ) { 
Projection proj = horizCoordSys . getTransform ( ) . getProjection ( ) ; 
} public static String getTimeTypeName ( int timeRangeIndicator ) { 
String timeRange ; 
return timeRange ; 
} public String getTimeCoord ( ) { 
if ( isInterval ( ) ) { 
int [ ] intv = getInterval ( ) ; 
return intv [ 0 ] + "-" + intv [ 1 ] ; 
return Integer . toString ( getForecastTime ( ) ) ; 
} public void appendErrorMessage ( String message , boolean fatal ) { 
errLog . append ( message ) ; 
errLog . append ( "\n" ) ; 
fatalError = fatalError || fatal ; 
} protected String [ ] 
getparamset ( String key ) 
String [ ] values = this . params . get ( key ) ; 
return ( values == null ? new String [ 0 ] : values ) ; 
} public static int setOffsets ( StructureMembers members ) { 
m . setDataParam ( offset ) ; 
offset += m . getSizeBytes ( ) ; 
if ( m . getStructureMembers ( ) != null ) 
setOffsets ( m . getStructureMembers ( ) ) ; 
members . setStructureSize ( offset ) ; 
} public void setNext ( Polygon next ) { 
if ( next instanceof CFPolygon ) { 
setNext ( ( CFPolygon ) next ) ; 
} public void setPrev ( Polygon prev ) { 
if ( prev instanceof CFPolygon ) { 
setPrev ( ( CFPolygon ) prev ) ; 
} public Polygon setupPolygon ( NetcdfDataset dataset , Variable polyvar , int index ) 
Variable interiorRings = null ; 
String nodeCoStr = polyvar . findAttValueIgnoreCase ( CF . NODE_COUNT , "" ) ; 
if ( ! nodeCoStr . equals ( "" ) ) { 
nodeCounts = dataset . findVariable ( nodeCoStr ) ; 
String pNodeCoStr = polyvar . findAttValueIgnoreCase ( CF . PART_NODE_COUNT , "" ) ; 
String interiorRingsStr = polyvar . findAttValueIgnoreCase ( CF . PART_NODE_COUNT , "" ) ; 
if ( ! interiorRingsStr . equals ( "" ) ) { 
interiorRings = dataset . findVariable ( interiorRingsStr ) ; 
this . isInteriorRing = false ; 
switch ( polyvar . getRank ( ) ) { 
this . setData ( polyvar . read ( CFSimpleGeometryHelper . getSubsetString ( polyvar , index ) ) . reduce ( ) ) ; 
this . setData ( polyvar . read ( "" + index ) ) ; 
Polygon tail = this ; 
Array ir = null ; 
if ( interiorRings != null ) ir = interiorRings . read ( ) ; 
if ( interiorRings != null ) 
int interiorRingValue = ir . getInt ( pncInd ) ; 
switch ( interiorRingValue ) { 
this . setInteriorRing ( false ) ; 
this . setInteriorRing ( true ) ; 
} else this . isInteriorRing = false ; 
tail . setData ( polyvar . read ( CFSimpleGeometryHelper . getSubsetString ( polyvar , index ) ) . reduce ( ) ) ; 
tail . setData ( polyvar . read ( "" + index ) ) ; 
tail . setNext ( new CFPolygon ( ) ) ; 
cfpl . error ( e . getMessage ( ) ) ; 
} public String findProperty ( String name ) { 
InvProperty result = null ; 
for ( InvProperty p : properties ) { 
result = p ; 
return ( result == null ) ? null : result . getValue ( ) ; 
if ( getServiceType ( ) == ServiceType . COMPOUND ) 
if ( uri == null ) { 
uri = new java . net . URI ( base ) ; 
} public void setCurrentProjection ( ProjectionImpl proj ) { 
int row ; 
if ( 0 <= ( row = model . search ( proj ) ) ) { 
selectedRow = row ; 
setRowSelectionInterval ( row , row ) ; 
selectedRow = - 1 ; 
clearSelection ( ) ; 
} public Optional < TimeOffsetAxis > subsetFromTime ( SubsetParams params , CalendarDate runDate ) { 
CoverageCoordAxisBuilder builder = null ; 
if ( params . isTrue ( SubsetParams . timePresent ) ) { 
double offset = getOffsetInTimeUnits ( runDate , CalendarDate . present ( ) ) ; 
builder = helper . subsetClosest ( offset ) ; 
CalendarDate dateWanted = ( CalendarDate ) params . get ( SubsetParams . time ) ; 
if ( dateWanted != null ) { 
double offset = getOffsetInTimeUnits ( runDate , dateWanted ) ; 
double min = getOffsetInTimeUnits ( runDate , dateRange . getStart ( ) ) ; 
double max = getOffsetInTimeUnits ( runDate , dateRange . getEnd ( ) ) ; 
Optional < CoverageCoordAxisBuilder > buildero = helper . subset ( min , max , stride ) ; 
if ( buildero . isPresent ( ) ) builder = buildero . get ( ) ; 
else return Optional . empty ( buildero . getErrorMessage ( ) ) ; 
assert ( builder != null ) ; 
builder . setReferenceDate ( runDate ) ; 
return Optional . of ( new TimeOffsetAxis ( builder ) ) ; 
} static public void registerIOProvider ( String className ) throws IllegalAccessException , InstantiationException , ClassNotFoundException { 
Class ioClass = NetcdfFile . class . getClassLoader ( ) . loadClass ( className ) ; 
registerIOProvider ( ioClass ) ; 
} static public void registerIOProvider ( Class iospClass , boolean last ) 
throws IllegalAccessException , InstantiationException { 
IOServiceProvider spi ; 
spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; 
if ( userLoads && ! last ) 
registeredProviders . add ( 0 , spi ) ; 
else registeredProviders . add ( spi ) ; 
} static public void registerIOProviderPreferred ( Class iospClass , Class target ) 
throws IllegalAccessException , InstantiationException 
iospDeRegister ( iospClass ) ; 
for ( int i = 0 ; i < registeredProviders . size ( ) ; i ++ ) { 
IOServiceProvider candidate = registeredProviders . get ( i ) ; 
if ( candidate . getClass ( ) == target ) { 
if ( pos < i ) 
if ( pos < 0 ) pos = 0 ; 
IOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; 
registeredProviders . add ( pos , spi ) ; 
} static public boolean iospRegistered ( Class iospClass ) { 
for ( IOServiceProvider spi : registeredProviders ) { 
if ( spi . getClass ( ) == iospClass ) return true ; 
} static public boolean iospDeRegister ( Class iospClass ) { 
IOServiceProvider spi = registeredProviders . get ( i ) ; 
if ( spi . getClass ( ) == iospClass ) { 
registeredProviders . remove ( i ) ; 
debugSPI = debugFlag . isSet ( "NetcdfFile/debugSPI" ) ; 
debugCompress = debugFlag . isSet ( "NetcdfFile/debugCompress" ) ; 
debugStructureIterator = debugFlag . isSet ( "NetcdfFile/structureIterator" ) ; 
N3header . disallowFileTruncation = debugFlag . isSet ( "NetcdfFile/disallowFileTruncation" ) ; 
N3header . debugHeaderSize = debugFlag . isSet ( "NetcdfFile/debugHeaderSize" ) ; 
showRequest = debugFlag . isSet ( "NetcdfFile/showRequest" ) ; 
} static public NetcdfFile open ( String location , ucar . nc2 . util . CancelTask cancelTask ) throws IOException { 
return open ( location , - 1 , cancelTask ) ; 
} static public NetcdfFile open ( String location , int buffer_size , ucar . nc2 . util . CancelTask cancelTask , Object iospMessage ) throws IOException { 
ucar . unidata . io . RandomAccessFile raf = getRaf ( location , buffer_size ) ; 
return open ( raf , location , cancelTask , iospMessage ) ; 
} static public boolean canOpen ( String location ) throws IOException { 
ucar . unidata . io . RandomAccessFile raf = null ; 
raf = getRaf ( location , - 1 ) ; 
return ( raf != null ) && canOpen ( raf ) ; 
} static public NetcdfFile open ( String location , String iospClassName , int bufferSize , CancelTask cancelTask , Object iospMessage ) 
throws ClassNotFoundException , IllegalAccessException , InstantiationException , IOException { 
Class iospClass = NetcdfFile . class . getClassLoader ( ) . loadClass ( iospClassName ) ; 
if ( iospMessage != null ) 
spi . sendIospMessage ( iospMessage ) ; 
if ( bufferSize <= 0 ) 
bufferSize = default_buffersize ; 
ucar . unidata . io . RandomAccessFile raf = 
ucar . unidata . io . RandomAccessFile . acquire ( canonicalizeUriString ( location ) , bufferSize ) ; 
NetcdfFile result = new NetcdfFile ( spi , raf , location , cancelTask ) ; 
} public static String canonicalizeUriString ( String location ) { 
String uriString = location . trim ( ) ; 
if ( uriString . startsWith ( "file://" ) ) 
uriString = uriString . substring ( 7 ) ; 
else if ( uriString . startsWith ( "file:" ) ) 
uriString = uriString . substring ( 5 ) ; 
return StringUtil2 . replace ( uriString , '\\' , "/" ) ; 
} public static NetcdfFile openInMemory ( String name , byte [ ] data , String iospClassName ) throws IOException , ClassNotFoundException , IllegalAccessException , InstantiationException { 
ucar . unidata . io . InMemoryRandomAccessFile raf = new ucar . unidata . io . InMemoryRandomAccessFile ( name , data ) ; 
return new NetcdfFile ( spi , raf , name , null ) ; 
} public static NetcdfFile openInMemory ( String name , byte [ ] data ) throws IOException { 
return open ( raf , name , null , null ) ; 
} public static NetcdfFile openInMemory ( String filename ) throws IOException { 
ByteArrayOutputStream bos = new ByteArrayOutputStream ( ( int ) file . length ( ) ) ; 
try ( InputStream in = new BufferedInputStream ( new FileInputStream ( filename ) ) ) { 
IO . copy ( in , bos ) ; 
return openInMemory ( filename , bos . toByteArray ( ) ) ; 
} public static NetcdfFile openInMemory ( URI uri ) throws IOException { 
byte [ ] contents = IO . readContentsToByteArray ( url . openStream ( ) ) ; 
return openInMemory ( uri . toString ( ) , contents ) ; 
if ( null != spi ) { 
spi . close ( ) ; 
} public Group findGroup ( String fullName ) { 
if ( fullName == null || fullName . length ( ) == 0 ) 
return rootGroup ; 
Group g = rootGroup ; 
StringTokenizer stoke = new StringTokenizer ( fullName , "/" ) ; 
String groupName = NetcdfFile . makeNameUnescaped ( stoke . nextToken ( ) ) ; 
g = g . findGroup ( groupName ) ; 
if ( g == null ) return null ; 
} public Variable findVariable ( String fullNameEscaped ) { 
if ( fullNameEscaped == null || fullNameEscaped . isEmpty ( ) ) { 
String vars = fullNameEscaped ; 
int pos = fullNameEscaped . lastIndexOf ( '/' ) ; 
String groups = fullNameEscaped . substring ( 0 , pos ) ; 
vars = fullNameEscaped . substring ( pos + 1 ) ; 
StringTokenizer stoke = new StringTokenizer ( groups , "/" ) ; 
String token = NetcdfFile . makeNameUnescaped ( stoke . nextToken ( ) ) ; 
g = g . findGroup ( token ) ; 
List < String > snames = EscapeStrings . tokenizeEscapedName ( vars ) ; 
if ( snames . size ( ) == 0 ) return null ; 
String varShortName = NetcdfFile . makeNameUnescaped ( snames . get ( 0 ) ) ; 
Variable v = g . findVariable ( varShortName ) ; 
int memberCount = 1 ; 
while ( memberCount < snames . size ( ) ) { 
if ( ! ( v instanceof Structure ) ) return null ; 
String name = NetcdfFile . makeNameUnescaped ( snames . get ( memberCount ++ ) ) ; 
v = ( ( Structure ) v ) . findVariable ( name ) ; 
} public Dimension findDimension ( String fullName ) { 
if ( fullName == null || fullName . isEmpty ( ) ) { 
Group group = rootGroup ; 
String dimShortName = fullName ; 
int pos = fullName . lastIndexOf ( '/' ) ; 
String groups = fullName . substring ( 0 , pos ) ; 
dimShortName = fullName . substring ( pos + 1 ) ; 
group = group . findGroup ( token ) ; 
if ( group == null ) { 
return group . findDimensionLocal ( dimShortName ) ; 
} public Attribute findGlobalAttribute ( String name ) { 
for ( Attribute a : gattributes ) { 
if ( name . equals ( a . getShortName ( ) ) ) 
} public Attribute findGlobalAttributeIgnoreCase ( String name ) { 
if ( name . equalsIgnoreCase ( a . getShortName ( ) ) ) 
} public Attribute findAttribute ( String fullNameEscaped ) { 
if ( fullNameEscaped == null || fullNameEscaped . length ( ) == 0 ) { 
int posAtt = fullNameEscaped . indexOf ( '@' ) ; 
if ( posAtt < 0 || posAtt >= fullNameEscaped . length ( ) - 1 ) 
if ( posAtt == 0 ) { 
return findGlobalAttribute ( fullNameEscaped . substring ( 1 ) ) ; 
String path = fullNameEscaped . substring ( 0 , posAtt ) ; 
String attName = fullNameEscaped . substring ( posAtt + 1 ) ; 
int pos = path . lastIndexOf ( '/' ) ; 
String varName = ( pos > 0 && pos < path . length ( ) - 1 ) ? path . substring ( pos + 1 ) : null ; 
String groups = path . substring ( 0 , pos ) ; 
if ( varName == null ) 
return g . findAttribute ( attName ) ; 
List < String > snames = EscapeStrings . tokenizeEscapedName ( varName ) ; 
return v . findAttribute ( attName ) ; 
} public String findAttValueIgnoreCase ( Variable v , String attName , String defaultValue ) { 
String attValue = null ; 
Attribute att ; 
att = rootGroup . findAttributeIgnoreCase ( attName ) ; 
att = v . findAttributeIgnoreCase ( attName ) ; 
attValue = att . getStringValue ( ) ; 
if ( null == attValue ) 
attValue = defaultValue ; 
return attValue ; 
} public String toNcML ( String url ) throws IOException { 
ncmlWriter . setWriteVariablesPredicate ( NcMLWriter . writeNoVariablesPredicate ) ; 
Element netcdfElement = ncmlWriter . makeNetcdfElement ( this , url ) ; 
return ncmlWriter . writeToString ( netcdfElement ) ; 
} public void writeCDL ( OutputStream out , boolean strict ) { 
PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( out , CDM . utf8Charset ) ) ; 
toStringStart ( pw , strict ) ; 
toStringEnd ( pw ) ; 
} public void writeCDL ( PrintWriter pw , boolean strict ) { 
} protected void writeCDL ( Formatter f , Indent indent , boolean strict ) { 
toStringStart ( f , indent , strict ) ; 
f . format ( "%s}%n" , indent ) ; 
} public void writeNcML ( java . io . OutputStream os , String uri ) throws IOException { 
Element netcdfElem = ncmlWriter . makeNetcdfElement ( this , uri ) ; 
ncmlWriter . writeToStream ( netcdfElem , os ) ; 
} public void writeNcML ( java . io . Writer writer , String uri ) throws IOException { 
ncmlWriter . writeToWriter ( netcdfElem , writer ) ; 
public long getLastModified ( ) { 
if ( spi != null && spi instanceof AbstractIOServiceProvider ) { 
AbstractIOServiceProvider aspi = ( AbstractIOServiceProvider ) spi ; 
return aspi . getLastModified ( ) ; 
} public Attribute addAttribute ( Group parent , Attribute att ) { 
if ( parent == null ) parent = rootGroup ; 
parent . addAttribute ( att ) ; 
} public Attribute addAttribute ( Group parent , String name , String value ) { 
if ( value == null ) return null ; 
Attribute att = new Attribute ( name , value ) ; 
} public Group addGroup ( Group parent , Group g ) { 
parent . addGroup ( g ) ; 
} public Dimension addDimension ( Group parent , Dimension d ) { 
parent . addDimension ( d ) ; 
} public boolean removeDimension ( Group g , String dimName ) { 
if ( g == null ) g = rootGroup ; 
return g . removeDimension ( dimName ) ; 
} public Variable addVariable ( Group g , Variable v ) { 
if ( v != null ) g . addVariable ( v ) ; 
} public Variable addVariable ( Group g , String shortName , DataType dtype , String dims ) { 
Variable v = new Variable ( this , g , null , shortName ) ; 
} public Variable addStringVariable ( Group g , String shortName , String dims , int strlen ) { 
String dimName = shortName + "_strlen" ; 
addDimension ( g , new Dimension ( dimName , strlen ) ) ; 
} public boolean removeVariable ( Group g , String varName ) { 
return g . removeVariable ( varName ) ; 
} public Object sendIospMessage ( Object message ) { 
if ( null == message ) return null ; 
if ( message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) { 
Variable v = rootGroup . findVariable ( "record" ) ; 
boolean gotit = ( v != null ) && ( v instanceof Structure ) ; 
return gotit || makeRecordStructure ( ) ; 
} else if ( message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE ) { 
if ( gotit ) { 
rootGroup . remove ( v ) ; 
removeRecordStructure ( ) ; 
return ( gotit ) ; 
if ( spi != null ) 
return spi . sendIospMessage ( message ) ; 
} protected Boolean makeRecordStructure ( ) { 
Boolean didit = false ; 
if ( ( spi != null ) && ( spi instanceof N3iosp ) && hasUnlimitedDimension ( ) ) { 
didit = ( Boolean ) spi . sendIospMessage ( IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; 
return didit ; 
} public NetcdfFile setImmutable ( ) { 
if ( immutable ) return this ; 
immutable = true ; 
setImmutable ( rootGroup ) ; 
gattributes = Collections . unmodifiableList ( gattributes ) ; 
} public void empty ( ) { 
gattributes = new ArrayList < > ( ) ; 
dimensions = new ArrayList < > ( ) ; 
rootGroup = makeRootGroup ( ) ; 
finishGroup ( rootGroup ) ; 
} protected Array readData ( ucar . nc2 . Variable v , Section ranges ) throws IOException , InvalidRangeException { 
if ( showRequest ) { 
start = System . currentTimeMillis ( ) ; 
if ( spi == null ) { 
Array result = spi . readData ( v , ranges ) ; 
} public Array readSection ( String variableSection ) throws IOException , InvalidRangeException { 
ParsedSectionSpec cer = ParsedSectionSpec . parseVariableSection ( this , variableSection ) ; 
if ( cer . child == null ) { 
return cer . v . read ( cer . section ) ; 
if ( spi == null ) 
return IospHelper . readSection ( cer ) ; 
return spi . readSection ( cer ) ; 
} protected long readToByteChannel ( ucar . nc2 . Variable v , Section section , WritableByteChannel wbc ) 
if ( ( spi == null ) || v . hasCachedData ( ) ) 
return IospHelper . copyToByteChannel ( v . read ( section ) , wbc ) ; 
return spi . readToByteChannel ( v , section , wbc ) ; 
} public java . util . List < Array > readArrays ( java . util . List < Variable > variables ) throws IOException { 
java . util . List < Array > result = new java . util . ArrayList < > ( ) ; 
for ( Variable variable : variables ) 
} public Array read ( String variableSection , boolean flatten ) throws IOException , InvalidRangeException { 
if ( ! flatten ) 
return readSection ( variableSection ) ; 
} public static void main ( String [ ] arg ) throws Exception { 
int wide = 20 ; 
Formatter f = new Formatter ( System . out ) ; 
} static public String makeValidCdmObjectName ( String shortName ) { 
if ( shortName == null ) return null ; 
return StringUtil2 . makeValidCdmObjectName ( shortName ) ; 
} static protected String makeFullName ( CDMNode node , String reservedChars ) { 
Group parent = node . getParentGroup ( ) ; 
if ( ( ( parent == null ) || parent . isRoot ( ) ) 
&& ! node . isMemberOfStructure ( ) ) 
return EscapeStrings . backslashEscape ( node . getShortName ( ) , reservedChars ) ; 
appendGroupName ( sbuff , parent , reservedChars ) ; 
appendStructureName ( sbuff , node , reservedChars ) ; 
} protected String makeFullNameWithString ( Group parent , String name ) { 
name = makeValidPathName ( name ) ; 
appendGroupName ( sbuff , parent , null ) ; 
sbuff . append ( name ) ; 
} private boolean include ( MFile mfile ) { 
if ( includeFilters == null ) return true ; 
for ( MFileFilter filter : includeFilters ) { 
if ( filter . accept ( mfile ) ) 
} private boolean exclude ( MFile mfile ) { 
if ( excludeFilters == null ) return false ; 
for ( MFileFilter filter : excludeFilters ) { 
} private boolean andFilter ( MFile mfile ) { 
if ( andFilters == null ) return true ; 
for ( MFileFilter filter : andFilters ) { 
if ( ! filter . accept ( mfile ) ) 
} public DAP_T get ( CDM_T cdm ) 
cdm = ( CDM_T ) CDMNode . unwrap ( cdm ) ; 
int lh = cdm . localhash ( ) ; 
return dapmap . get ( lh ) ; 
} public void put ( CDM_T cdm , DAP_T dap ) 
assert ( dap != null && cdm != null ) ; 
dapmap . put ( lh , dap ) ; 
cdmmap . put ( dap , cdm ) ; 
} public void remove ( CDM_T cdm , DAP_T dap ) 
dapmap . remove ( cdm . localhash ( ) ) ; 
cdmmap . remove ( dap ) ; 
} public final String getTypeString ( ) 
case CONTAINER : 
return "Container" ; 
case ALIAS : 
return "Alias" ; 
return "Byte" ; 
case INT16 : 
return "Int16" ; 
case UINT16 : 
return "UInt16" ; 
case INT32 : 
return "Int32" ; 
case UINT32 : 
return "UInt32" ; 
case FLOAT32 : 
return "Float32" ; 
case FLOAT64 : 
return "Float64" ; 
return "String" ; 
return "Url" ; 
} public static final int getTypeVal ( String s ) 
if ( s . equalsIgnoreCase ( "Container" ) ) 
return CONTAINER ; 
else if ( s . equalsIgnoreCase ( "Byte" ) ) 
return BYTE ; 
else if ( s . equalsIgnoreCase ( "Int16" ) ) 
return INT16 ; 
else if ( s . equalsIgnoreCase ( "UInt16" ) ) 
return UINT16 ; 
else if ( s . equalsIgnoreCase ( "Int32" ) ) 
return INT32 ; 
else if ( s . equalsIgnoreCase ( "UInt32" ) ) 
return UINT32 ; 
else if ( s . equalsIgnoreCase ( "Float32" ) ) 
return FLOAT32 ; 
else if ( s . equalsIgnoreCase ( "Float64" ) ) 
return FLOAT64 ; 
else if ( s . equalsIgnoreCase ( "String" ) ) 
return STRING ; 
else if ( s . equalsIgnoreCase ( "URL" ) ) 
return URL ; 
} public String getValueAt ( int index ) throws NoSuchAttributeException 
checkVectorUsage ( ) ; 
return ( String ) ( ( Vector ) attr ) . elementAt ( index ) ; 
} public String getValueAtN ( int index ) 
if ( ! ( attr instanceof Vector ) ) return null ; 
} public void appendValue ( String value , boolean check ) 
throws NoSuchAttributeException , AttributeBadValueException 
if ( check ) 
value = forceValue ( type , value ) ; 
( ( Vector ) attr ) . addElement ( value ) ; 
} private static void dispatchCheckValue ( int type , String value ) 
throws AttributeBadValueException 
if ( ! checkByte ( value ) ) 
if ( ! checkShort ( value ) ) 
if ( ! checkUShort ( value ) ) 
if ( ! checkInt ( value ) ) 
if ( ! checkUInt ( value ) ) 
if ( ! checkFloat ( value ) ) 
if ( ! checkDouble ( value ) ) 
} private static String forceValue ( int type , String value ) 
dispatchCheckValue ( type , value ) ; 
} catch ( AttributeBadValueException abe ) { 
if ( type == BYTE ) { 
short val = Short . parseShort ( value ) ; 
if ( val > 255 && val < - 128 ) 
value = Integer . toString ( ( val & 0xFF ) ) ; 
} private static final boolean checkByte ( String s ) 
short val = Short . parseShort ( s ) ; 
if ( DebugValueChecking ) { 
if ( val > 0xFF || val < 0 ) 
} private static final boolean checkShort ( String s ) 
} private static final boolean checkInt ( String s ) 
int val = Integer . parseInt ( s ) ; 
} private static final boolean checkUInt ( String s ) 
long val = Long . parseLong ( s ) ; 
if ( val > 0xFFFFFFFFL ) 
} private static final boolean checkFloat ( String s ) 
float val = Float . parseFloat ( s ) ; 
if ( s . equalsIgnoreCase ( "nan" ) || s . equalsIgnoreCase ( "inf" ) ) 
} private static final boolean checkDouble ( String s ) 
double val = Double . parseDouble ( s ) ; 
Attribute a = ( Attribute ) super . cloneDAG ( map ) ; 
if ( type == CONTAINER ) 
a . attr = ( AttributeTable ) cloneDAG ( map , ( ( AttributeTable ) attr ) ) ; 
a . attr = ( ( Vector ) attr ) . clone ( ) ; 
} private DataType getAttributeDataType ( Attribute attribute ) { 
DataType dataType = attribute . getDataType ( ) ; 
if ( signedness == Signedness . UNSIGNED ) { 
dataType = dataType . withSignedness ( signedness ) ; 
} public static int rank ( DataType dataType ) { 
case BYTE : return 0 ; 
case UBYTE : return 1 ; 
case SHORT : return 2 ; 
case USHORT : return 3 ; 
case INT : return 4 ; 
case UINT : return 5 ; 
case LONG : return 6 ; 
case ULONG : return 7 ; 
case FLOAT : return 8 ; 
case DOUBLE : return 9 ; 
default : return - 1 ; 
} public static DataType largestOf ( DataType ... dataTypes ) { 
DataType widest = null ; 
for ( DataType dataType : dataTypes ) { 
if ( widest == null ) { 
widest = dataType ; 
} else if ( rank ( dataType ) > rank ( widest ) ) { 
return widest ; 
} public static DataType nextLarger ( DataType dataType ) { 
case BYTE : return SHORT ; 
case UBYTE : return USHORT ; 
case SHORT : return INT ; 
case USHORT : return UINT ; 
case INT : return LONG ; 
case UINT : return ULONG ; 
case LONG : return DOUBLE ; 
case ULONG : return DOUBLE ; 
default : return dataType ; 
public boolean isViewable ( Dataset ds ) { 
Access access = ds . getAccess ( ServiceType . WMS ) ; 
return access != null && ( ThreddsConfig . getBoolean ( "WMS.allow" , false ) ) ; 
} public static boolean validSingleLineString ( String singleLineString ) { 
if ( singleLineString == null ) return false ; 
Matcher m = INVALID_CHARACTERS_FOR_SINGLE_LINE_STRING_PATTERN . matcher ( singleLineString ) ; 
return ! m . find ( ) ; 
} @ SuppressWarnings ( { "SimplifiableIfStatement" } ) 
public static boolean validPath ( String path ) { 
if ( path . indexOf ( "/../" ) != - 1 || path . equals ( ".." ) 
|| path . startsWith ( "../" ) || path . endsWith ( "/.." ) ) 
return validSingleLineString ( path ) ; 
public static boolean validFilePath ( String path ) { 
if ( path . indexOf ( File . pathSeparatorChar ) != - 1 ) 
return validPath ( path ) ; 
} public static boolean validIdString ( String id ) { 
if ( id == null ) return false ; 
Matcher m = INVALID_CHARACTERS_FOR_ID_STRING_PATTERN . matcher ( id ) ; 
return ! ( m . find ( ) || ! validSingleLineString ( id ) ) ; 
} public static boolean containsAngleBracketCharacters ( String string ) { 
if ( string == null ) 
if ( string . indexOf ( "<" ) == - 1 
&& string . indexOf ( ">" ) == - 1 ) 
} public static boolean containsAmpersandCharacters ( String string ) { 
if ( string . indexOf ( "&" ) == - 1 ) 
} public static boolean containsBackslashCharacters ( String string ) { 
if ( string . indexOf ( "\\" ) == - 1 ) 
public static boolean validBooleanString ( String boolString ) { 
if ( boolString == null ) 
Matcher m = VALID_CHARACTERS_FOR_BOOLEAN_STRING_PATTERN . matcher ( boolString ) ; 
if ( ! m . matches ( ) ) 
return boolString . equalsIgnoreCase ( "true" ) 
|| boolString . equalsIgnoreCase ( "false" ) ; 
} public static boolean validAlphanumericString ( String alphNumString ) { 
if ( alphNumString == null ) 
Matcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; 
} public static boolean validAlphanumericStringConstrainedSet ( String alphNumString , 
String [ ] constrainedSet , 
boolean ignoreCase ) { 
if ( alphNumString == null || constrainedSet == null || constrainedSet . length == 0 ) 
for ( String s : constrainedSet ) { 
if ( ignoreCase ? alphNumString . equalsIgnoreCase ( s ) : alphNumString . equals ( s ) ) 
} @ SuppressWarnings ( { "UnnecessaryContinue" } ) 
public static boolean descendOnlyFilePath ( String path ) { 
String [ ] pathSegments = path . split ( "/" ) ; 
for ( int indxOrigSegs = 0 ; indxOrigSegs < pathSegments . length ; indxOrigSegs ++ ) { 
String s = pathSegments [ indxOrigSegs ] ; 
if ( s . equals ( "." ) ) 
else if ( s . equals ( ".." ) ) { 
if ( i == 0 ) 
} public static boolean validPercentHexOctetsString ( String percentHexOctetsString ) { 
if ( percentHexOctetsString == null ) 
Matcher m = VALID_PERCENT_HEX_OCTETS_PATTERN . matcher ( percentHexOctetsString ) ; 
} public static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { 
if ( ! Character . isDefined ( codePoint ) ) 
if ( Character . getType ( codePoint ) == Character . SURROGATE ) 
Charset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; 
if ( charset == null ) 
char [ ] chars = Character . toChars ( codePoint ) ; 
ByteBuffer byteBuffer = null ; 
byteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; 
throw new IllegalArgumentException ( message , e ) ; 
byteBuffer . rewind ( ) ; 
StringBuilder encodedString = new StringBuilder ( ) ; 
for ( int i = 0 ; i < byteBuffer . limit ( ) ; i ++ ) { 
String asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; 
encodedString . append ( "%" ) . append ( asHex . length ( ) == 1 ? "0" : "" ) . append ( asHex ) ; 
return encodedString . toString ( ) ; 
} public final void addParam ( String key , String value ) { 
paramStr . put ( key . trim ( ) , value ) ; 
paramsValues = paramsValues + "\t" + key + "\t" + value ; 
} public final void addParam ( String key , int value ) { 
paramInt . put ( key , new Integer ( value ) ) ; 
paramStr . put ( key , Integer . toString ( value ) ) ; 
} public final void addParam ( String key , float value ) { 
paramDbl . put ( key , new Double ( value ) ) ; 
paramStr . put ( key , Float . toString ( value ) ) ; 
} public final String getParam ( String key ) { 
String value = paramStr . get ( key ) ; 
Double result = paramDbl . get ( key ) ; 
value = result . toString ( ) ; 
Integer intResult = paramInt . get ( key ) ; 
if ( intResult != null ) { 
value = intResult . toString ( ) ; 
paramStr . put ( key , value ) ; 
if ( debug && value == null ) { 
} public static boolean compare ( GridDefRecord local , GridDefRecord other ) { 
java . util . Set < String > keys = local . getKeys ( ) ; 
java . util . Set < String > okeys = other . getKeys ( ) ; 
if ( keys . size ( ) != okeys . size ( ) ) 
if ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) 
|| key . equals ( GDS_KEY ) ) 
String val = local . getParam ( key ) ; 
String oval = other . getParam ( key ) ; 
if ( val . matches ( "^[0-9]+\\.[0-9]*" ) ) { 
double d = local . getDouble ( key ) ; 
double od = other . getDouble ( key ) ; 
if ( ! Misc . nearlyEquals ( d , od ) ) 
} else if ( val . matches ( "^[0-9]+" ) ) { 
if ( ! val . equals ( oval ) ) 
} public void process ( InputStream is ) throws IOException { 
pos = process ( b , is ) ; 
} private int process ( Buffer b , InputStream is ) throws IOException { 
while ( start < b . have ) { 
int matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; 
if ( matchPos < 0 ) { 
if ( start == 0 ) 
return b . have - 3 ; 
if ( matchPos + 6 >= b . have ) { 
int b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; 
int b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; 
int b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; 
int messLen = b1 << 16 | b2 << 8 | b3 ; 
MessageTask task = new MessageTask ( messLen ) ; 
task . header = extractHeader ( start , matchPos , b ) ; 
int last = matchPos + messLen ; 
if ( last > b . have ) { 
task . have = b . have - matchPos ; 
System . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; 
if ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { 
task . have = task . len ; 
for ( int i = task . len - 4 ; i < task . len ; i ++ ) { 
int bb = task . mess [ i ] ; 
if ( bb != 55 ) { 
bad_msgs ++ ; 
if ( ok ) messQ . put ( task ) ; 
start = matchPos + messLen + 1 ; 
} public NcStreamProto . DataRow encodeData3 ( String name , boolean isVlen , Section section , Array data ) { 
NcStreamProto . DataRow . Builder builder = NcStreamProto . DataRow . newBuilder ( ) ; 
encodeData3 ( builder , name , isVlen , section , data ) ; 
} NcStreamProto . ArrayStructureRow . Builder encodeStructureData ( String structName , Array data ) { 
assert data instanceof ArrayStructure ; 
int nelems = ( int ) as . getSize ( ) ; 
List < MemberData > memberData = new ArrayList < > ( ) ; 
StructureMembers sm = as . getStructureMembers ( ) ; 
memberData . add ( new MemberData ( m , nelems ) ) ; 
for ( int recno = 0 ; recno < nelems ; recno ++ ) { 
for ( MemberData md : memberData ) { 
if ( md . member . isVariableLength ( ) ) { 
md . vlenList . add ( as . getArray ( recno , md . member ) ) ; 
extractData ( as , recno , md ) ; 
NcStreamProto . ArrayStructureRow . Builder builder = NcStreamProto . ArrayStructureRow . newBuilder ( ) ; 
NcStreamProto . Member . Builder member = NcStreamProto . Member . newBuilder ( ) ; 
member . setShortName ( md . member . getName ( ) ) ; 
member . setDataType ( NcStream . convertDataType ( md . member . getDataType ( ) ) ) ; 
builder . addMembers ( member ) ; 
doonce ( HttpServletRequest req ) 
if ( this . uploaddir == null ) 
this . uploaddirname = new File ( this . uploaddir ) . getName ( ) ; 
File upform = null ; 
upform = tdsContext . getUploadForm ( ) ; 
if ( upform == null ) { 
upform = new File ( root , DEFAULTUPLOADFORM ) ; 
this . uploadform = loadForm ( upform ) ; 
case UPLOAD : 
String result = inquire ( ) ; 
sendOK ( result ) ; 
projections ( Ceparse state , Object list0 ) 
ast . projections = ( List < ASTprojection > ) list0 ; 
} Object 
clauselist ( Ceparse state , Object list0 , Object decl ) 
List < ASTclause > list = ( List < ASTclause > ) list0 ; 
if ( list == null ) list = new ArrayList < ASTclause > ( ) ; 
list . add ( ( ASTclause ) decl ) ; 
} String removeQuotes ( String s ) 
if ( s . startsWith ( "\"" ) && s . endsWith ( "\"" ) ) 
return s . substring ( 1 , s . length ( ) - 1 ) ; 
} void markStackedVariables ( Stack s ) 
Stack bts = new Stack ( ) ; 
while ( ! s . empty ( ) ) { 
bts . push ( s . pop ( ) ) ; 
while ( bts . size ( ) > 1 ) { 
ServerMethods ct = ( ServerMethods ) bts . pop ( ) ; 
ct . setProject ( true , false ) ; 
ServerMethods bt = ( ServerMethods ) bts . pop ( ) ; 
bt . setProject ( true , true ) ; 
} public boolean constraint_expression ( CEEvaluator ceEval , 
ClauseFactory clauseFactory ) 
if ( ! parse ( ) ) return false ; 
ast . init ( ceEval , factory , clauseFactory , sdds , getASTnodeset ( ) ) ; 
ast . walkConstraint ( ) ; 
} boolean writeNcml ( String location ) { 
closeOpenFiles ( ) ; 
final String result ; 
ds = openDataset ( location , addCoords , null ) ; 
final NcMLWriter ncmlWriter = new NcMLWriter ( ) ; 
final Element netcdfElem = ncmlWriter . makeNetcdfElement ( ds , null ) ; 
result = ncmlWriter . writeToString ( netcdfElem ) ; 
editor . setText ( result ) ; 
editor . setCaretPosition ( 0 ) ; 
final StringWriter sw = new StringWriter ( 10000 ) ; 
editor . setText ( sw . toString ( ) ) ; 
return ! err ; 
} void doTransform ( String text ) { 
final StringReader reader = new StringReader ( text ) ; 
final NetcdfDataset ncd = NcMLReader . readNcML ( reader , null ) ; 
ncd . writeNcML ( sw , null ) ; 
} private void checkNcml ( Formatter f ) { 
if ( ncmlLocation == null ) { return ; } 
NetcdfDataset ncd = NetcdfDataset . openDataset ( ncmlLocation ) ; 
ncd . check ( f ) ; 
} private static String getValueFromThreddsConfig ( String key , String alternateKey , String defaultValue ) { 
String value = ThreddsConfig . get ( key , null ) ; 
if ( value == null && alternateKey != null ) 
value = ThreddsConfig . get ( alternateKey , null ) ; 
static PartitionCollectionMutable openMutablePCFromIndex ( String name , RandomAccessFile raf , 
Grib2PartitionBuilderFromIndex builder = new Grib2PartitionBuilderFromIndex ( name , config , logger ) ; 
if ( builder . readIndex ( raf ) ) 
return builder . pc ; 
protected boolean readExtensions ( GribCollectionProto . GribCollection proto ) { 
pc . isPartitionOfPartitions = proto . getIsPartitionOfPartitions ( ) ; 
List < Integer > list = proto . getRun2PartList ( ) ; 
pc . run2part = new int [ list . size ( ) ] ; 
for ( int partno : list ) 
pc . run2part [ count ++ ] = partno ; 
List < ucar . nc2 . grib . collection . GribCollectionProto . Partition > partList = proto . getPartitionsList ( ) ; 
for ( ucar . nc2 . grib . collection . GribCollectionProto . Partition partProto : partList ) 
makePartition ( partProto ) ; 
return partList . size ( ) > 0 ; 
} public String lookupEnumString ( int e ) { 
String result = map . get ( e ) ; 
} public String writeCDL ( boolean strict ) { 
writeCDL ( out , new Indent ( 2 ) , strict ) ; 
return out . toString ( ) ; 
protected StationHelper createStationHelper ( ) throws IOException { 
StationHelper stationHelper = new StationHelper ( ) ; 
try ( InputStream in = CdmRemote . sendQuery ( null , uri , "req=stations" ) ) { 
PointStream . MessageType mtype = PointStream . readMagic ( in ) ; 
if ( mtype != PointStream . MessageType . StationList ) { 
int len = NcStream . readVInt ( in ) ; 
byte [ ] b = new byte [ len ] ; 
NcStream . readFully ( in , b ) ; 
PointStreamProto . StationList stationsp = PointStreamProto . StationList . parseFrom ( b ) ; 
for ( ucar . nc2 . ft . point . remote . PointStreamProto . Station sp : stationsp . getStationsList ( ) ) { 
stationHelper . addStation ( new StationFeatureStream ( null , null ) ) ; 
public StationTimeSeriesFeatureCollection subset ( List < StationFeature > stations ) throws IOException { 
if ( stations == null ) return this ; 
return new Subset ( this , null , null ) ; 
public PointFeatureCollection flatten ( LatLonRect boundingBox , CalendarDateRange dateRange ) throws IOException { 
PointFeatureCollection pfc = new PointCollectionStreamRemote ( uri , getTimeUnit ( ) , getAltUnits ( ) , null ) ; 
return pfc . subset ( boundingBox , dateRange ) ; 
} protected boolean validate ( StringBuilder out ) 
if ( this . getAccessPointHeader ( ) == null ) 
double g = sinLat0 * Math . sin ( fromLat ) 
double kPrime = Math . sqrt ( 2 / ( 1 + g ) ) ; 
toX = R * kPrime * Math . cos ( fromLat ) * Math . sin ( lonDiff ) 
+ falseEasting ; 
toY = R * kPrime 
- sinLat0 * Math . cos ( fromLat ) 
* Math . cos ( lonDiff ) ) + falseNorthing ; 
fromX = fromX - falseEasting ; 
fromY = fromY - falseNorthing ; 
double c = 2 * Math . asin ( rho / ( 2 * R ) ) ; 
} public float getAzimuth ( ) { 
if ( message_type != 1 ) return - 1.0f ; 
if ( Cinrad2IOServiceProvider . isSC ) 
return 360.0f * azimuth_ang / 65536.0f ; 
else if ( Cinrad2IOServiceProvider . isCC ) 
return 360.0f * azimuth_ang / 512.0f ; 
else if ( Cinrad2IOServiceProvider . isCC20 ) 
return azimuth_ang * 0.01f ; 
return 180.0f * azimuth_ang / 32768.0f ; 
} public float getElevation ( ) { 
return 120.0f * elevation_ang / 65536.0f ; 
return elevation_ang * 0.01f ; 
return 180.0f * elevation_ang / 32768.0f ; 
} public Date [ ] getTimes ( ) { 
if ( myRYIBs == null ) 
Date [ ] times = new Date [ nRays ] ; 
for ( int i = 0 ; i < nRays ; i ++ ) 
times [ i ] = myRYIBs [ i ] . getRayTime ( ) ; 
} public float [ ] getLatitudes ( ) { 
if ( myASIBs == null ) 
float [ ] lats = new float [ nRays ] ; 
lats [ i ] = myASIBs [ i ] . getLatitude ( ) ; 
return lats ; 
} public float [ ] getLongitudes ( ) { 
float [ ] lons = new float [ nRays ] ; 
lons [ i ] = myASIBs [ i ] . getLongitude ( ) ; 
return lons ; 
} public float [ ] getAltitudes ( ) { 
float [ ] alts = new float [ nRays ] ; 
alts [ i ] = myASIBs [ i ] . getAltitude ( ) ; 
return alts ; 
} public float [ ] getAzimuths ( ) { 
if ( azimuths == null ) { 
azimuths = new float [ nRays ] ; 
for ( int r = 0 ; r < nRays ; r ++ ) { 
azimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; 
return azimuths ; 
} public float [ ] getElevations ( ) { 
if ( elevations == null ) { 
elevations = new float [ nRays ] ; 
elevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; 
return elevations ; 
} public Structure select ( List < String > memberNames ) { 
Structure result = ( Structure ) copy ( ) ; 
} public Structure select ( String varName ) { 
List < String > memberNames = new ArrayList < > ( 1 ) ; 
memberNames . add ( varName ) ; 
return select ( memberNames ) ; 
} public Variable addMemberVariable ( Variable v ) { 
members . add ( v ) ; 
memberHash . put ( v . getShortName ( ) , v ) ; 
v . setParentStructure ( this ) ; 
} public void setMemberVariables ( List < Variable > vars ) { 
members = new ArrayList < > ( ) ; 
memberHash = new HashMap < > ( 2 * vars . size ( ) ) ; 
addMemberVariable ( v ) ; 
} public boolean removeMemberVariable ( Variable v ) { 
java . util . Iterator < Variable > iter = members . iterator ( ) ; 
Variable mv = iter . next ( ) ; 
if ( mv . getShortName ( ) . equals ( v . getShortName ( ) ) ) { 
memberHash . remove ( v . getShortName ( ) ) ; 
} public boolean replaceMemberVariable ( Variable newVar ) { 
for ( int i = 0 ; i < members . size ( ) ; i ++ ) { 
Variable v = members . get ( i ) ; 
if ( v . getShortName ( ) == null ) 
if ( v . getShortName ( ) . equals ( newVar . getShortName ( ) ) ) { 
members . set ( i , newVar ) ; 
members . add ( newVar ) ; 
public void setParentGroup ( Group group ) { 
if ( isImmutable ( ) ) 
super . setParentGroup ( group ) ; 
if ( members != null ) 
for ( Variable v : members ) { 
v . setParentGroup ( group ) ; 
} public Variable findVariable ( String shortName ) { 
return memberHash . get ( shortName ) ; 
} public StructureMembers makeStructureMembers ( ) { 
StructureMembers smembers = new StructureMembers ( getShortName ( ) ) ; 
for ( Variable v2 : getVariables ( ) ) { 
StructureMembers . Member m = smembers . addMember ( v2 . getShortName ( ) , v2 . getDescription ( ) , 
v2 . getUnitsString ( ) , v2 . getDataType ( ) , v2 . getShape ( ) ) ; 
m . setStructureMembers ( ( ( Structure ) v2 ) . makeStructureMembers ( ) ) ; 
return smembers ; 
} public void calcElementSize ( ) { 
total += v . getElementSize ( ) * v . getSize ( ) ; 
elementSize = total ; 
} public StructureData readStructure ( ) throws IOException { 
Array dataArray = read ( ) ; 
ArrayStructure data = ( ArrayStructure ) dataArray ; 
} public StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { 
Section section = null ; 
if ( getRank ( ) == 1 ) { 
section = new Section ( ) . appendRange ( index , index ) ; 
} else if ( getRank ( ) > 1 ) { 
Index ii = Index . factory ( shape ) ; 
ii . setCurrentCounter ( index ) ; 
int [ ] origin = ii . getCurrentCounter ( ) ; 
section = new Section ( ) ; 
for ( int anOrigin : origin ) 
section . appendRange ( anOrigin , anOrigin ) ; 
Array dataArray = read ( section ) ; 
} public ArrayStructure readStructure ( int start , int count ) throws IOException , ucar . ma2 . InvalidRangeException { 
int [ ] origin = new int [ ] { start } ; 
int [ ] shape = new int [ ] { count } ; 
if ( NetcdfFile . debugStructureIterator ) 
return ( ArrayStructure ) read ( origin , shape ) ; 
} public StructureDataIterator getStructureIterator ( int bufferSize ) throws java . io . IOException { 
return ( getRank ( ) < 2 ) ? new Structure . IteratorRank1 ( bufferSize ) : new Structure . Iterator ( bufferSize ) ; 
getNameAndDimensions ( sbuff , false , true ) ; 
} static private void init ( ) { 
String filename = BufrTables . RESOURCE_PATH + TABLEA_FILENAME ; 
HashMap < Integer , String > map = new HashMap < > ( 100 ) ; 
String desc = elem . getChildText ( "Meaning_en" ) ; 
int code = Integer . parseInt ( codeS ) ; 
map . put ( code , desc ) ; 
tableA = map ; 
} static public String getDataCategory ( int cat ) { 
if ( tableA == null ) init ( ) ; 
String result = tableA . get ( cat ) ; 
} public String getClassName ( ) { 
String className = getClass ( ) . getName ( ) ; 
int index = className . lastIndexOf ( "." ) ; 
if ( index >= 0 ) { 
className = className . substring ( index + 1 ) ; 
} protected void addParameter ( String name , String value ) { 
atts . add ( new Parameter ( name , value ) ) ; 
} public static String getHeader ( ) { 
StringBuilder headerB = new StringBuilder ( 60 ) ; 
headerB . append ( "Name" ) ; 
Format . tab ( headerB , 20 , true ) ; 
headerB . append ( "Class" ) ; 
Format . tab ( headerB , 40 , true ) ; 
headerB . append ( "Parameters" ) ; 
return headerB . toString ( ) ; 
if ( ( from == null ) || ( from . length != 2 ) ) { 
throw new IllegalArgumentException ( "ProjectionImpl.projToLatLon:" 
if ( ( to == null ) || ( to . length != 2 ) ) { 
if ( from [ 0 ] . length != to [ 0 ] . length ) { 
for ( int i = 0 ; i < from [ 0 ] . length ; i ++ ) { 
LatLonPoint endL = projToLatLon ( from [ 0 ] [ i ] , from [ 1 ] [ i ] ) ; 
to [ 0 ] [ i ] = endL . getLatitude ( ) ; 
to [ 1 ] [ i ] = endL . getLongitude ( ) ; 
ProjectionPointImpl ppi = new ProjectionPointImpl ( ) ; 
LatLonPointImpl llpi = new LatLonPointImpl ( ) ; 
ppi . setLocation ( ( double ) from [ 0 ] [ i ] , ( double ) from [ 1 ] [ i ] ) ; 
projToLatLon ( ppi , llpi ) ; 
to [ 0 ] [ i ] = ( float ) llpi . getLatitude ( ) ; 
to [ 1 ] [ i ] = ( float ) llpi . getLongitude ( ) ; 
} public float [ ] [ ] latLonToProj ( float [ ] [ ] from , int latIndex , 
return latLonToProj ( from , new float [ 2 ] [ from [ 0 ] . length ] , latIndex , 
lonIndex ) ; 
throw new IllegalArgumentException ( "ProjectionImpl.latLonToProj:" 
llpi . setLatitude ( from [ latIndex ] [ i ] ) ; 
llpi . setLongitude ( from [ lonIndex ] [ i ] ) ; 
latLonToProj ( llpi , ppi ) ; 
to [ 0 ] [ i ] = ( float ) ppi . getX ( ) ; 
to [ 1 ] [ i ] = ( float ) ppi . getY ( ) ; 
} ProjectionRect latLonToProjBB2 ( LatLonRect latlonRect ) { 
LatLonPointImpl llpt = latlonRect . getLowerLeftPoint ( ) ; 
LatLonPointImpl urpt = latlonRect . getUpperRightPoint ( ) ; 
LatLonPointImpl lrpt = latlonRect . getLowerRightPoint ( ) ; 
LatLonPointImpl ulpt = latlonRect . getUpperLeftPoint ( ) ; 
ProjectionPoint ll = latLonToProj ( llpt , new ProjectionPointImpl ( ) ) ; 
ProjectionPoint ur = latLonToProj ( urpt , new ProjectionPointImpl ( ) ) ; 
ProjectionPoint lr = latLonToProj ( lrpt , new ProjectionPointImpl ( ) ) ; 
ProjectionPoint ul = latLonToProj ( ulpt , new ProjectionPointImpl ( ) ) ; 
minx = Math . min ( ll . getX ( ) , ul . getX ( ) ) ; 
miny = Math . min ( ll . getY ( ) , lr . getY ( ) ) ; 
maxx = Math . max ( ur . getX ( ) , lr . getX ( ) ) ; 
maxy = Math . max ( ul . getY ( ) , ur . getY ( ) ) ; 
return new ProjectionRect ( minx , miny , maxx , maxy ) ; 
} public ProjectionRect latLonToProjBB ( LatLonRect latlonRect ) { 
LatLonProjection llp = ( LatLonProjection ) this ; 
llp . setCenterLon ( latlonRect . getCenterLon ( ) ) ; 
ProjectionPointImpl w1 = new ProjectionPointImpl ( ) ; 
ProjectionPointImpl w2 = new ProjectionPointImpl ( ) ; 
LatLonPoint ll = latlonRect . getLowerLeftPoint ( ) ; 
LatLonPoint ur = latlonRect . getUpperRightPoint ( ) ; 
latLonToProj ( ll , w1 ) ; 
latLonToProj ( ur , w2 ) ; 
ProjectionRect world = new ProjectionRect ( w1 . getX ( ) , w1 . getY ( ) , w2 . getX ( ) , w2 . getY ( ) ) ; 
LatLonPointImpl la = new LatLonPointImpl ( ) ; 
LatLonPointImpl lb = new LatLonPointImpl ( ) ; 
la . setLatitude ( ur . getLatitude ( ) ) ; 
la . setLongitude ( ll . getLongitude ( ) ) ; 
latLonToProj ( la , w1 ) ; 
world . add ( w1 ) ; 
lb . setLatitude ( ll . getLatitude ( ) ) ; 
lb . setLongitude ( ur . getLongitude ( ) ) ; 
latLonToProj ( lb , w2 ) ; 
world . add ( w2 ) ; 
return world ; 
} public LatLonRect projToLatLonBBold ( ProjectionRect world ) { 
ProjectionPoint min = world . getMinPoint ( ) ; 
ProjectionPoint max = world . getMaxPoint ( ) ; 
LatLonPointImpl llmin = new LatLonPointImpl ( ) ; 
LatLonPointImpl llmax = new LatLonPointImpl ( ) ; 
projToLatLon ( min , llmin ) ; 
projToLatLon ( max , llmax ) ; 
llbb = new LatLonRect ( llmin , llmax ) ; 
w1 . setLocation ( min . getX ( ) , max . getY ( ) ) ; 
projToLatLon ( w1 , llmin ) ; 
llbb . extend ( llmin ) ; 
w2 . setLocation ( max . getX ( ) , min . getY ( ) ) ; 
projToLatLon ( w2 , llmax ) ; 
llbb . extend ( llmax ) ; 
} public LatLonRect projToLatLonBB ( ProjectionRect bb ) { 
LatLonPoint llpt = projToLatLon ( bb . getLowerLeftPoint ( ) , new LatLonPointImpl ( ) ) ; 
LatLonPoint lrpt = projToLatLon ( bb . getLowerRightPoint ( ) , new LatLonPointImpl ( ) ) ; 
LatLonPoint urpt = projToLatLon ( bb . getUpperRightPoint ( ) , new LatLonPointImpl ( ) ) ; 
LatLonPoint ulpt = projToLatLon ( bb . getUpperLeftPoint ( ) , new LatLonPointImpl ( ) ) ; 
LatLonPointImpl min = new LatLonPointImpl ( latMin , lonMin ) ; 
LatLonPointImpl max = new LatLonPointImpl ( latMax , lonMax ) ; 
llbb = new LatLonRect ( min , max ) ; 
} public static double dmsToRad ( double d , double m , double s ) { 
if ( d >= 0 ) 
return ( d + m / 60 + s / 3600 ) * Math . PI / 180.0 ; 
return ( d - m / 60 - s / 3600 ) * Math . PI / 180.0 ; 
} public static double dmsToDeg ( double d , double m , double s ) { 
return ( d + m / 60 + s / 3600 ) ; 
return ( d - m / 60 - s / 3600 ) ; 
} public static double greatCircleDistance ( double lon1 , double lat1 , double lon2 , double lat2 ) { 
double dlat = Math . sin ( ( lat2 - lat1 ) / 2 ) ; 
double dlon = Math . sin ( ( lon2 - lon1 ) / 2 ) ; 
double r = Math . sqrt ( dlat * dlat + Math . cos ( lat1 ) * Math . cos ( lat2 ) * dlon * dlon ) ; 
return 2.0 * Math . asin ( r ) ; 
} public static double niceNumber ( double x , boolean round ) { 
int expv ; 
double f ; 
double nf ; 
expv = ( int ) Math . floor ( Math . log ( x ) / Math . log ( 10 ) ) ; 
f = x / Math . pow ( 10. , expv ) ; 
if ( round ) { 
if ( f < 1.5 ) 
nf = 1. ; 
else if ( f < 3. ) 
nf = 2. ; 
else if ( f < 7. ) 
nf = 5. ; 
nf = 10. ; 
} else if ( f <= 1. ) 
else if ( f <= 2. ) 
else if ( f <= 5. ) 
return nf * Math . pow ( 10. , expv ) ; 
VertCoordType result = wmoTable3 . get ( code ) ; 
result = new VertCoordType ( code , "unknownLayer" + code , null , "unknownLayer" + code , null , false , false ) ; 
} public static int getVersion ( String hasConvName ) { 
int result = extractVersion ( hasConvName ) ; 
if ( result >= 0 ) return result ; 
List < String > names = breakupConventionNames ( hasConvName ) ; 
result = extractVersion ( name ) ; 
} public static String getZisPositive ( String zaxisName , String vertCoordUnits ) { 
if ( vertCoordUnits == null ) return CF . POSITIVE_UP ; 
if ( vertCoordUnits . isEmpty ( ) ) return CF . POSITIVE_UP ; 
if ( SimpleUnit . isCompatible ( "millibar" , vertCoordUnits ) ) 
return CF . POSITIVE_DOWN ; 
if ( SimpleUnit . isCompatible ( "m" , vertCoordUnits ) ) 
return CF . POSITIVE_UP ; 
} private void makeAtmLnCoordinate ( NetcdfDataset ds , Variable v ) { 
String formula = ds . findAttValueIgnoreCase ( v , CF . formula_terms , null ) ; 
if ( null == formula ) { 
parseInfo . format ( msg ) ; 
userAdvice . format ( msg ) ; 
Variable p0Var = null , levelVar = null ; 
if ( toke . equalsIgnoreCase ( "p0" ) ) { 
p0Var = ds . findVariable ( name ) ; 
} else if ( toke . equalsIgnoreCase ( "lev" ) ) { 
levelVar = ds . findVariable ( name ) ; 
if ( null == p0Var ) { 
if ( null == levelVar ) { 
String units = ds . findAttValueIgnoreCase ( p0Var , CDM . UNITS , "hPa" ) ; 
double p0 = p0Var . readScalarDouble ( ) ; 
Array levelData = levelVar . read ( ) ; 
Array pressureData = Array . factory ( DataType . DOUBLE , levelData . getShape ( ) ) ; 
IndexIterator ii = levelData . getIndexIterator ( ) ; 
IndexIterator iip = pressureData . getIndexIterator ( ) ; 
double val = p0 * Math . exp ( - 1.0 * ii . getDoubleNext ( ) ) ; 
iip . setDoubleNext ( val ) ; 
CoordinateAxis1D p = new CoordinateAxis1D ( ds , null , v . getShortName ( ) + "_pressure" , DataType . DOUBLE , 
levelVar . getDimensionsString ( ) , units , 
p . setCachedData ( pressureData , false ) ; 
p . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . toString ( ) ) ) ; 
p . addAttribute ( new Attribute ( _Coordinate . AliasForDimension , p . getDimensionsString ( ) ) ) ; 
ds . addVariable ( null , p ) ; 
String sname = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . STANDARD_NAME , null ) ; 
if ( sname != null ) { 
sname = sname . trim ( ) ; 
for ( String vertical_coord : vertical_coords ) 
if ( sname . equalsIgnoreCase ( vertical_coord ) ) 
AxisType at = super . getAxisType ( ncDataset , v ) ; 
if ( at != null ) return at ; 
if ( sname . equalsIgnoreCase ( CF . ENSEMBLE ) ) 
return AxisType . Ensemble ; 
if ( sname . equalsIgnoreCase ( CF . LATITUDE ) ) 
if ( sname . equalsIgnoreCase ( CF . LONGITUDE ) ) 
if ( sname . equalsIgnoreCase ( CF . PROJECTION_X_COORDINATE ) || sname . equalsIgnoreCase ( CF . GRID_LONGITUDE ) || sname . equalsIgnoreCase ( "rotated_longitude" ) ) 
if ( sname . equalsIgnoreCase ( CF . PROJECTION_Y_COORDINATE ) || sname . equalsIgnoreCase ( CF . GRID_LATITUDE ) || sname . equalsIgnoreCase ( "rotated_latitude" ) ) 
if ( sname . equalsIgnoreCase ( CF . TIME_REFERENCE ) ) 
return AxisType . RunTime ; 
if ( sname . equalsIgnoreCase ( CF . TIME_OFFSET ) ) 
return AxisType . TimeOffset ; 
String axis = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . AXIS , null ) ; 
if ( axis != null ) { 
axis = axis . trim ( ) ; 
if ( axis . equalsIgnoreCase ( "X" ) ) { 
} else if ( axis . equalsIgnoreCase ( "Y" ) ) { 
} else if ( axis . equalsIgnoreCase ( "Z" ) ) { 
if ( unit == null ) return AxisType . GeoZ ; 
else if ( SimpleUnit . isCompatible ( "mbar" , unit ) ) 
if ( avhrr_oiv2 ) { 
if ( v . getShortName ( ) . equals ( "zlev" ) ) 
CalendarDateUnit cd = CalendarDateUnit . of ( null , units ) ; 
if ( cd != null ) return AxisType . Time ; 
} public boolean delete ( ) { 
if ( nextFile == null ) return false ; 
fileList . remove ( nextFile ) ; 
File f = new File ( "C:/tmp/deleted/" + nextFile . getName ( ) ) ; 
return nextFile . renameTo ( f ) ; 
} public DataState setCoverage ( CoverageCollection coverageDataset , Coverage grid ) { 
this . dataState = new DataState ( coverageDataset , grid ) ; 
this . lastGrid = null ; 
isNewField = true ; 
return this . dataState ; 
} public String getXYvalueStr ( ProjectionPoint loc ) { 
if ( ( lastGrid == null ) || ( geodata == null ) ) 
if ( ! sameProjection ) { 
LatLonPoint llpt = drawProjection . projToLatLon ( loc ) ; 
loc = dataProjection . latLonToProj ( llpt ) ; 
HorizCoordSys hcs = lastGrid . getCoordSys ( ) . getHorizCoordSys ( ) ; 
Optional < HorizCoordSys . CoordReturn > opt = hcs . findXYindexFromCoord ( loc . getX ( ) , loc . getY ( ) ) ; 
return opt . getErrorMessage ( ) ; 
HorizCoordSys . CoordReturn cr = opt . get ( ) ; 
Index imaH = geodata . getIndex ( ) ; 
double dataValue = geodata . getDouble ( imaH . set ( cr . y , cr . x ) ) ; 
return makeXYZvalueStr ( dataValue , cr ) ; 
} private GeoReferencedArray readHSlice ( int level , int time , int ensemble , int runtime ) { 
if ( dataState . grid . equals ( lastGrid ) && ( time == lastTime ) && ( level == lastLevel ) && ( horizStride == lastStride ) 
&& ( ensemble == lastEnsemble ) && ( runtime == lastRunTime ) ) 
return dataH ; 
if ( level >= 0 && dataState . zaxis != null ) { 
double levelVal = dataState . zaxis . getCoordMidpoint ( level ) ; 
subset . set ( SubsetParams . vertCoord , levelVal ) ; 
if ( time >= 0 && dataState . taxis != null ) { 
double timeVal = dataState . taxis . getCoordMidpoint ( time ) ; 
CalendarDate date = dataState . taxis . makeDate ( timeVal ) ; 
if ( runtime >= 0 && dataState . rtaxis != null ) { 
double rtimeVal = dataState . rtaxis . getCoordMidpoint ( runtime ) ; 
CalendarDate date = dataState . rtaxis . makeDate ( rtimeVal ) ; 
subset . set ( SubsetParams . runtime , date ) ; 
if ( ensemble >= 0 && dataState . ensaxis != null ) { 
double ensVal = dataState . ensaxis . getCoordMidpoint ( ensemble ) ; 
subset . set ( SubsetParams . ensCoord , ensVal ) ; 
if ( horizStride != 1 ) 
subset . setHorizStride ( horizStride ) ; 
dataH = dataState . grid . readData ( subset ) ; 
geodata = dataH . getData ( ) . reduce ( ) ; 
} catch ( IOException | InvalidRangeException e ) { 
lastGrid = dataState . grid ; 
lastTime = time ; 
lastLevel = level ; 
lastEnsemble = ensemble ; 
lastRunTime = runtime ; 
lastStride = horizStride ; 
} private void setColorScaleParams ( ) { 
if ( dataMinMaxType == ColorScale . MinMaxType . hold && ! isNewField ) 
isNewField = false ; 
GeoReferencedArray dataArr = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; 
if ( dataArr != null ) { 
MAMath . MinMax minmax = MAMath . getMinMaxSkipMissingData ( dataArr . getData ( ) , dataState . grid ) ; 
colorScale . setMinMax ( minmax . min , minmax . max ) ; 
colorScale . setGeoGrid ( dataState . grid ) ; 
} public void renderPlanView ( java . awt . Graphics2D g , AffineTransform dFromN ) { 
if ( ( dataState . grid == null ) || ( colorScale == null ) || ( drawProjection == null ) ) 
if ( ! drawGrid && ! drawContours ) 
dataH = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; 
if ( dataH == null ) 
setColorScaleParams ( ) ; 
if ( drawGrid ) 
drawGridHoriz ( g , dataH ) ; 
if ( drawGridLines ) 
drawGridLines ( g , dataH ) ; 
if ( drawBB ) 
drawGridBB ( g , this . dataState . coverageDataset . getLatlonBoundingBox ( ) ) ; 
} private void drawGridHorizRegular ( java . awt . Graphics2D g , GeoReferencedArray array ) { 
CoverageCoordSys gsys = array . getCoordSysForData ( ) ; 
CoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gsys . getXAxis ( ) ; 
CoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gsys . getYAxis ( ) ; 
if ( data . getRank ( ) != 2 ) { 
int nx = xaxis . getNcoords ( ) ; 
int ny = yaxis . getNcoords ( ) ; 
sameProjection = drawProjection . equals ( dataProjection ) ; 
if ( drawProjection . isLatLon ( ) ) { 
projectll = ( LatLonProjection ) drawProjection ; 
double centerLon = projectll . getCenterLon ( ) ; 
colorScale . resetHist ( ) ; 
IndexIterator iiter = array . getData ( ) . getIndexIterator ( ) ; 
while ( iiter . hasNext ( ) ) { 
double val = iiter . getDoubleNext ( ) ; 
colorScale . getIndexFromValue ( val ) ; 
int modeColor = colorScale . getHistMax ( ) ; 
if ( sameProjection ) { 
double xmin = Math . min ( xaxis . getCoordEdge1 ( 0 ) , xaxis . getCoordEdgeLast ( ) ) ; 
double xmax = Math . max ( xaxis . getCoordEdge1 ( 0 ) , xaxis . getCoordEdgeLast ( ) ) ; 
double ymin = Math . min ( yaxis . getCoordEdge1 ( 0 ) , yaxis . getCoordEdgeLast ( ) ) ; 
double ymax = Math . max ( yaxis . getCoordEdge1 ( 0 ) , yaxis . getCoordEdgeLast ( ) ) ; 
count += drawRect ( g , modeColor , xmin , ymin , xmax , ymax , drawProjection . isLatLon ( ) ) ; 
} else if ( useModeForProjections ) 
drawPathShape ( g , modeColor , xaxis , yaxis ) ; 
debugPts = Debug . isSet ( "GridRenderer/showPts" ) ; 
Index imaH = data . getIndex ( ) ; 
double ybeg = yaxis . getCoordEdge1 ( y ) ; 
double yend = yaxis . getCoordEdge2 ( y ) ; 
int thisColor , lastColor = 0 ; 
int run = 0 ; 
int xbeg = 0 ; 
double val = data . getDouble ( imaH . set ( y , x ) ) ; 
thisColor = colorScale . getIndexFromValue ( val ) ; 
if ( ( run == 0 ) || ( lastColor == thisColor ) ) { 
run ++ ; 
if ( lastColor != modeColor ) 
count += drawRect ( g , lastColor , xaxis . getCoordEdge1 ( xbeg ) , ybeg , xaxis . getCoordEdge2 ( x ) , yend , drawProjection . isLatLon ( ) ) ; 
if ( ! useModeForProjections || ( lastColor != modeColor ) ) 
count += drawPathRun ( g , lastColor , ybeg , yend , xaxis , xbeg , x - 1 , debugPts ) ; 
xbeg = x ; 
lastColor = thisColor ; 
count += drawRect ( g , lastColor , xaxis . getCoordEdge1 ( xbeg ) , ybeg , xaxis . getCoordEdgeLast ( ) , yend , drawProjection . isLatLon ( ) ) ; 
count += drawPathRun ( g , lastColor , ybeg , yend , xaxis , xbeg , nx - 1 , false ) ; 
} boolean isChildOf ( H5Group that ) { 
if ( parent == null ) return false ; 
if ( parent == that ) return true ; 
return parent . isChildOf ( that ) ; 
} public static MessageType getType ( String name ) { 
} int read ( long filePos , int version , boolean creationOrderPresent , String objectName ) throws IOException { 
this . start = filePos ; 
if ( debugPos ) { 
if ( version == 1 ) { 
type = raf . readShort ( ) ; 
size = DataType . unsignedShortToInt ( raf . readShort ( ) ) ; 
headerMessageFlags = raf . readByte ( ) ; 
raf . skipBytes ( 3 ) ; 
header_length = 8 ; 
type = ( short ) raf . readByte ( ) ; 
header_length = 4 ; 
if ( creationOrderPresent ) { 
creationOrder = raf . readShort ( ) ; 
header_length += 2 ; 
mtype = MessageType . getType ( type ) ; 
if ( debug1 ) { 
if ( creationOrderPresent && debugCreationOrder ) { 
if ( ( headerMessageFlags & 2 ) != 0 ) { 
messData = getSharedDataObject ( mtype ) . mdt ; 
return header_length + size ; 
if ( mtype == MessageType . NIL ) { 
} else if ( mtype == MessageType . SimpleDataspace ) { 
MessageDataspace data = new MessageDataspace ( ) ; 
data . read ( ) ; 
messData = data ; 
} else if ( mtype == MessageType . GroupNew ) { 
MessageGroupNew data = new MessageGroupNew ( ) ; 
} else if ( mtype == MessageType . Datatype ) { 
MessageDatatype data = new MessageDatatype ( ) ; 
data . read ( objectName ) ; 
} else if ( mtype == MessageType . FillValueOld ) { 
MessageFillValueOld data = new MessageFillValueOld ( ) ; 
} else if ( mtype == MessageType . FillValue ) { 
MessageFillValue data = new MessageFillValue ( ) ; 
} else if ( mtype == MessageType . Link ) { 
MessageLink data = new MessageLink ( ) ; 
} else if ( mtype == MessageType . Layout ) { 
MessageLayout data = new MessageLayout ( ) ; 
} else if ( mtype == MessageType . GroupInfo ) { 
MessageGroupInfo data = new MessageGroupInfo ( ) ; 
} else if ( mtype == MessageType . FilterPipeline ) { 
MessageFilter data = new MessageFilter ( ) ; 
} else if ( mtype == MessageType . Attribute ) { 
MessageAttribute data = new MessageAttribute ( ) ; 
data . read ( raf . getFilePointer ( ) ) ; 
} else if ( mtype == MessageType . Comment ) { 
MessageComment data = new MessageComment ( ) ; 
} else if ( mtype == MessageType . LastModifiedOld ) { 
MessageLastModifiedOld data = new MessageLastModifiedOld ( ) ; 
} else if ( mtype == MessageType . ObjectHeaderContinuation ) { 
MessageContinue data = new MessageContinue ( ) ; 
} else if ( mtype == MessageType . Group ) { 
MessageGroup data = new MessageGroup ( ) ; 
} else if ( mtype == MessageType . LastModified ) { 
MessageLastModified data = new MessageLastModified ( ) ; 
} else if ( mtype == MessageType . AttributeInfo ) { 
MessageAttributeInfo data = new MessageAttributeInfo ( ) ; 
} else if ( mtype == MessageType . ObjectReferenceCount ) { 
MessageObjectReferenceCount data = new MessageObjectReferenceCount ( ) ; 
} public void showCompression ( Formatter f ) { 
if ( mtype != H5header . MessageType . AttributeInfo ) { 
MessageAttributeInfo info = ( MessageAttributeInfo ) messData ; 
info . showFractalHeap ( f ) ; 
} public static void installInAllColumns ( JTable table , int alignment ) { 
for ( int colViewIndex = 0 ; colViewIndex < table . getColumnCount ( ) ; ++ colViewIndex ) { 
installInOneColumn ( table , colViewIndex , alignment ) ; 
} public static void installInOneColumn ( JTable table , int colViewIndex , int alignment ) { 
TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( colViewIndex ) ; 
TableCellRenderer headerRenderer = tableColumn . getHeaderRenderer ( ) ; 
if ( headerRenderer == null ) { 
headerRenderer = table . getTableHeader ( ) . getDefaultRenderer ( ) ; 
if ( ! ( headerRenderer instanceof RendererAlignmentDecorator ) ) { 
tableColumn . setHeaderRenderer ( new RendererAlignmentDecorator ( headerRenderer , alignment ) ) ; 
TableCellRenderer cellRenderer = tableColumn . getCellRenderer ( ) ; 
if ( cellRenderer == null ) { 
cellRenderer = table . getDefaultRenderer ( table . getColumnClass ( colViewIndex ) ) ; 
if ( ! ( cellRenderer instanceof RendererAlignmentDecorator ) ) { 
tableColumn . setCellRenderer ( new RendererAlignmentDecorator ( cellRenderer , alignment ) ) ; 
} public String getKeyWithTrailingDelimiter ( ) { 
return key + S3_DELIMITER ; 
} public S3URI getParent ( ) { 
int lastDelimPos = key . lastIndexOf ( S3_DELIMITER ) ; 
if ( lastDelimPos == - 1 ) { 
return new S3URI ( bucket , null ) ; 
return new S3URI ( bucket , key . substring ( 0 , lastDelimPos ) ) ; 
} public S3URI getChild ( String relativePath ) throws IllegalArgumentException { 
if ( relativePath . isEmpty ( ) ) { 
} else if ( relativePath . startsWith ( S3_DELIMITER ) ) { 
throw new IllegalArgumentException ( String . format ( 
relativePath , S3_DELIMITER ) ) ; 
return new S3URI ( bucket , relativePath ) ; 
return new S3URI ( bucket , key + S3_DELIMITER + relativePath ) ; 
} public File getTempFile ( ) { 
File parentDir = new File ( S3ObjectTempDir , String . valueOf ( hashCode ( ) ) ) ; 
return new File ( parentDir , getBaseName ( ) ) ; 
} public static void initDialog ( BooleanProperty openProperty , final Stage parentStage , Supplier < Parent > rootSupplier ) { 
final Stage dialogStage = new Stage ( StageStyle . UTILITY ) ; 
dialogStage . initOwner ( parentStage ) ; 
dialogStage . initModality ( Modality . APPLICATION_MODAL ) ; 
openProperty . addListener ( ( obs , oldValue , newValue ) -> { 
if ( newValue ) { 
if ( dialogStage . getScene ( ) == null ) { 
Scene dialogScene = new Scene ( rootSupplier . get ( ) ) ; 
dialogScene . getStylesheets ( ) . add ( "/contacts.css" ) ; 
dialogStage . setScene ( dialogScene ) ; 
dialogStage . toFront ( ) ; 
dialogStage . sizeToScene ( ) ; 
dialogStage . show ( ) ; 
dialogStage . close ( ) ; 
dialogStage . setOnCloseRequest ( event -> openProperty . set ( false ) ) ; 
} public SelectableStringList selectablePersonsProperty ( ) { 
if ( selectablePersons == null ) { 
selectablePersons = new SelectableItemList < > ( 
FXCollections . observableArrayList ( repository . getPersons ( ) ) , 
return selectablePersons ; 
} public final void init ( ) throws Exception { 
List < Module > modules = new ArrayList < > ( ) ; 
modules . add ( new MvvmfxModule ( ) ) ; 
modules . add ( new AbstractModule ( ) { 
protected void configure ( ) { 
bind ( HostServices . class ) . toProvider ( MvvmfxGuiceApplication . this :: getHostServices ) ; 
bind ( Stage . class ) . toProvider ( ( ) -> primaryStage ) ; 
bind ( Parameters . class ) . toProvider ( MvvmfxGuiceApplication . this :: getParameters ) ; 
this . initGuiceModules ( modules ) ; 
final Injector injector = Guice . createInjector ( modules ) ; 
MvvmFX . setCustomDependencyInjector ( injector :: getInstance ) ; 
injector . injectMembers ( this ) ; 
this . initMvvmfx ( ) ; 
} static void injectResourceBundle ( Object target , ResourceBundle resourceBundle ) { 
final List < Field > fieldsWithAnnotation = ReflectionUtils 
. getFieldsWithAnnotation ( target , InjectResourceBundle . class ) ; 
final boolean notAssignableFieldPresent = fieldsWithAnnotation . stream ( ) 
. anyMatch ( field -> ! field . getType ( ) . isAssignableFrom ( ResourceBundle . class ) ) ; 
if ( notAssignableFieldPresent ) { 
+ target 
if ( resourceBundle == null || resourceBundle . equals ( EMPTY_RESOURCE_BUNDLE ) ) { 
if ( ! fieldsWithAnnotation . isEmpty ( ) ) { 
final boolean nonOptionalFieldsPresent = fieldsWithAnnotation . stream ( ) 
. flatMap ( field -> Arrays . stream ( field . getAnnotationsByType ( InjectResourceBundle . class ) ) ) 
. anyMatch ( annotation -> ! annotation . optional ( ) ) ; 
if ( nonOptionalFieldsPresent ) { 
fieldsWithAnnotation 
. forEach ( field -> { 
if ( field . getType ( ) . isAssignableFrom ( ResourceBundle . class ) ) { 
ReflectionUtils . setField ( field , target , resourceBundle ) ; 
} public static void setFixedClock ( ZonedDateTime zonedDateTime ) { 
CentralClock . clock = Clock . fixed ( zonedDateTime . toInstant ( ) , ZoneId . systemDefault ( ) ) ; 
} public Optional < ValidationMessage > getHighestMessage ( ) { 
final Optional < ValidationMessage > error = getMessages ( ) . stream ( ) 
. filter ( message -> message . getSeverity ( ) . equals ( Severity . ERROR ) ) 
. findFirst ( ) ; 
if ( error . isPresent ( ) ) { 
final Optional < ValidationMessage > warning = getMessages ( ) . stream ( ) 
. filter ( message -> message . getSeverity ( ) . equals ( Severity . WARNING ) ) 
return warning ; 
} public ResourceBundle mergeWithGlobal ( ResourceBundle resourceBundle ) { 
if ( globalResourceBundle == null ) { 
if ( resourceBundle == null ) { 
return EMPTY_RESOURCE_BUNDLE ; 
return new ResourceBundleWrapper ( resourceBundle ) ; 
return new ResourceBundleWrapper ( globalResourceBundle ) ; 
return merge ( resourceBundle , globalResourceBundle ) ; 
} public ResourceBundle mergeListWithGlobal ( List < ResourceBundle > bundles ) { 
if ( bundles == null ) { 
return reduce ( bundles ) ; 
final List < ResourceBundle > resourceBundles = new ArrayList < > ( ) ; 
resourceBundles . add ( globalResourceBundle ) ; 
resourceBundles . addAll ( bundles ) ; 
return reduce ( resourceBundles ) ; 
public < T > T getInstanceOf ( Class < ? extends T > type ) { 
if ( isCustomInjectorDefined ( ) ) { 
return ( T ) customInjector . call ( type ) ; 
return type . newInstance ( ) ; 
} private void initListEvents ( ) { 
this . listChangeListener = new ListChangeListener < SourceType > ( ) { 
public void onChanged ( 
Change < ? extends SourceType > listEvent ) { 
List < TargetType > deleteStaging = new ArrayList < > ( ) ; 
while ( listEvent . next ( ) ) { 
if ( listEvent . wasUpdated ( ) ) { 
processUpdateEvent ( listEvent ) ; 
} else if ( listEvent . wasReplaced ( ) ) { 
processReplaceEvent ( listEvent , deleteStaging ) ; 
} else if ( listEvent . wasAdded ( ) ) { 
processAddEvent ( listEvent ) ; 
} else if ( listEvent . wasRemoved ( ) ) { 
processRemoveEvent ( listEvent , deleteStaging ) ; 
processStagingLists ( deleteStaging ) ; 
modelListProperty ( ) . addListener ( 
new WeakListChangeListener < > ( listChangeListener ) ) ; 
} private void processAddEvent ( 
ListChangeListener . Change < ? extends SourceType > listEvent ) { 
final List < TargetType > toAdd = new ArrayList < > ( ) ; 
for ( int index = listEvent . getFrom ( ) ; index < listEvent . getTo ( ) ; index ++ ) { 
final SourceType item = listEvent . getList ( ) . get ( index ) ; 
toAdd . add ( function . apply ( item ) ) ; 
viewModelList . addAll ( listEvent . getFrom ( ) , toAdd ) ; 
} private void processRemoveEvent ( 
ListChangeListener . Change < ? extends SourceType > listEvent , 
List < TargetType > deleteStaging ) { 
for ( int i = 0 ; i < listEvent . getRemovedSize ( ) ; i ++ ) { 
deleteStaging . add ( viewModelList . get ( listEvent . getFrom ( ) + i ) ) ; 
} private void processUpdateEvent ( ListChangeListener . Change < ? extends SourceType > listEvent ) { 
for ( int i = listEvent . getFrom ( ) ; i < listEvent . getTo ( ) ; i ++ ) { 
SourceType item = listEvent . getList ( ) . get ( i ) ; 
viewModelList . set ( i , ListTransformation . this . function . apply ( item ) ) ; 
} private void processReplaceEvent ( 
ListChangeListener . Change < ? extends SourceType > listEvent , List < TargetType > deletedStaging ) { 
processRemoveEvent ( listEvent , deletedStaging ) ; 
processStagingLists ( deletedStaging ) ; 
} public Person getPersonById ( final int id ) { 
for ( Person person : persons ) { 
if ( id == person . getId ( ) ) { 
return person ; 
} public BuilderFactory mergeWith ( List < BuilderFactory > factories ) { 
GlobalBuilderFactory factory = new GlobalBuilderFactory ( ) ; 
factory . factories . addAll ( factories ) ; 
return factory ; 
public Object put ( Object key , Object value ) { 
processQueue ( ) ; 
WeakValue oldValue = ( WeakValue ) super . put ( key , WeakValue . create ( key , value , queue ) ) ; 
return getReferenceObject ( oldValue ) ; 
} private void processQueue ( ) { 
WeakValue wv = null ; 
while ( ( wv = ( WeakValue ) this . queue . poll ( ) ) != null ) { 
super . remove ( wv . key ) ; 
public Set entrySet ( ) { 
if ( entrySet == null ) { 
hashEntrySet = super . entrySet ( ) ; 
entrySet = new EntrySet ( ) ; 
return entrySet ; 
public Collection values ( ) { 
values = new AbstractCollection ( ) { 
public Iterator iterator ( ) { 
return new Iterator ( ) { 
private final Iterator i = entrySet ( ) . iterator ( ) ; 
return i . hasNext ( ) ; 
public Object next ( ) { 
return ( ( Entry ) i . next ( ) ) . getValue ( ) ; 
i . remove ( ) ; 
public int size ( ) { 
return WeakValueHashMap . this . size ( ) ; 
public boolean contains ( Object v ) { 
return WeakValueHashMap . this . containsValue ( v ) ; 
} void addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { 
if ( messages . isEmpty ( ) ) { 
final int validatorHash = System . identityHashCode ( validator ) ; 
if ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) { 
validatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; 
final List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; 
messages . stream ( ) 
. map ( System :: identityHashCode ) 
. forEach ( messageHashesOfThisValidator :: add ) ; 
getMessagesInternal ( ) . addAll ( messages ) ; 
} void removeMessage ( final Validator validator , final List < ? extends ValidationMessage > messages ) { 
if ( validatorToMessagesMap . containsKey ( validatorHash ) ) { 
final List < Integer > hashesOfMessagesToRemove = messages . stream ( ) 
. filter ( m -> { 
int hash = System . identityHashCode ( m ) ; 
return messageHashesOfThisValidator . contains ( hash ) ; 
getMessagesInternal ( ) . removeIf ( message -> { 
int hash = System . identityHashCode ( message ) ; 
return hashesOfMessagesToRemove . contains ( hash ) ; 
messageHashesOfThisValidator . removeAll ( hashesOfMessagesToRemove ) ; 
if ( messageHashesOfThisValidator . isEmpty ( ) ) { 
validatorToMessagesMap . remove ( validatorHash ) ; 
} void removeMessage ( final Validator validator ) { 
} public void setPersonId ( int personId ) { 
person = repository . getPersonById ( personId ) ; 
StringBinding salutationBinding 
= Bindings . when ( person . genderProperty ( ) . isEqualTo ( Gender . NOT_SPECIFIED ) ) 
. otherwise ( 
Bindings . when ( person . genderProperty ( ) . isEqualTo ( Gender . MALE ) ) 
welcomeString . unbind ( ) ; 
person . lastNameProperty ( ) ) ) ; 
} public < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewTuple < ViewType , ViewModelType > loadJavaViewTuple ( 
Class < ? extends ViewType > viewType , ResourceBundle resourceBundle , final ViewModelType existingViewModel , 
ViewType codeBehind , Context parentContext , Collection < Scope > providedScopes ) { 
ContextImpl context = ViewLoaderScopeUtils . prepareContext ( parentContext , providedScopes ) ; 
DependencyInjector injectionFacade = DependencyInjector . getInstance ( ) ; 
final ViewType view = codeBehind == null ? injectionFacade . getInstanceOf ( viewType ) : codeBehind ; 
if ( ! ( view instanceof Parent ) ) { 
ViewModelType viewModel = null ; 
if ( existingViewModel == null ) { 
viewModel = ViewLoaderReflectionUtils . createViewModel ( view ) ; 
viewModel = existingViewModel ; 
ResourceBundleInjector . injectResourceBundle ( view , resourceBundle ) ; 
if ( viewModel == null ) { 
final List < Field > viewModelFields = ViewLoaderReflectionUtils . getViewModelFields ( viewType ) ; 
if ( ! viewModelFields . isEmpty ( ) ) { 
ResourceBundleInjector . injectResourceBundle ( viewModel , resourceBundle ) ; 
ViewLoaderReflectionUtils . createAndInjectScopes ( viewModel , context ) ; 
ViewLoaderReflectionUtils . initializeViewModel ( viewModel ) ; 
ViewLoaderReflectionUtils . injectViewModel ( view , viewModel ) ; 
if ( view instanceof Initializable ) { 
Initializable initializable = ( Initializable ) view ; 
initializable . initialize ( null , resourceBundle ) ; 
injectResourceBundle ( view , resourceBundle ) ; 
callInitialize ( view ) ; 
return new ViewTuple < > ( view , ( Parent ) view , viewModel ) ; 
} < ViewModelType extends ViewModel > void callInitialize ( View < ? extends ViewModelType > view ) { 
final Method initializeMethod = view . getClass ( ) . getMethod ( NAMING_CONVENTION_INITIALIZE_IDENTIFIER ) ; 
AccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { 
return initializeMethod . invoke ( view ) ; 
NAMING_CONVENTION_INITIALIZE_IDENTIFIER , view ) ; 
if ( cause instanceof RuntimeException ) { 
throw ( RuntimeException ) cause ; 
throw new RuntimeException ( cause ) ; 
} < ViewModelType extends ViewModel > void injectResourceBundle ( View < ? extends ViewModelType > view , 
ResourceBundle resourceBundle ) { 
Field resourcesField = view . getClass ( ) . getField ( NAMING_CONVENTION_RESOURCES_IDENTIFIER ) ; 
if ( resourcesField . getType ( ) . isAssignableFrom ( ResourceBundle . class ) ) { 
resourcesField . set ( view , resourceBundle ) ; 
} catch ( NoSuchFieldException e ) { 
} private StringBinding emptyStringOnNull ( ObservableValue < String > source ) { 
return Bindings . createStringBinding ( ( ) -> { 
if ( source . getValue ( ) == null ) { 
return source . getValue ( ) ; 
} , source ) ; 
} public static Optional < Field > getViewModelField ( Class < ? extends View > viewType , Class < ? > viewModelType ) { 
List < Field > allViewModelFields = getViewModelFields ( viewType ) ; 
if ( allViewModelFields . isEmpty ( ) ) { 
if ( allViewModelFields . size ( ) > 1 ) { 
Field field = allViewModelFields . get ( 0 ) ; 
if ( ! ViewModel . class . isAssignableFrom ( field . getType ( ) ) ) { 
if ( ! field . getType ( ) . isAssignableFrom ( viewModelType ) ) { 
+ field . getType ( ) + ">." ) ; 
return Optional . of ( field ) ; 
public static < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewModelType getExistingViewModel ( 
ViewType view ) { 
final Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; 
Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModelType ) ; 
if ( fieldOptional . isPresent ( ) ) { 
Field field = fieldOptional . get ( ) ; 
return ReflectionUtils . accessMember ( field , ( ) -> ( ViewModelType ) field . get ( view ) , 
} public static void injectViewModel ( final View view , ViewModel viewModel ) { 
final Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModel . getClass ( ) ) ; 
ReflectionUtils . accessMember ( field , ( ) -> { 
Object existingViewModel = field . get ( view ) ; 
field . set ( view , viewModel ) ; 
public static < V extends View < ? extends VM > , VM extends ViewModel > void createAndInjectViewModel ( final V view , 
Consumer < ViewModel > newVmConsumer ) { 
if ( viewModelType == ViewModel . class ) { 
final List < Field > viewModelFields = ViewLoaderReflectionUtils . getViewModelFields ( view . getClass ( ) ) ; 
if ( viewModelType == TypeResolver . Unknown . class ) { 
final Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModelType ) ; 
final Object newViewModel = DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; 
field . set ( view , newViewModel ) ; 
newVmConsumer . accept ( ( ViewModel ) newViewModel ) ; 
public static < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewModelType createViewModel ( 
if ( TypeResolver . Unknown . class == viewModelType ) { 
return ( ViewModelType ) DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; 
} public static < ViewModelType extends ViewModel > void initializeViewModel ( ViewModelType viewModel ) { 
final Collection < Method > initializeMethods = getInitializeMethods ( viewModel . getClass ( ) ) ; 
initializeMethods . forEach ( initMethod -> { 
final boolean postConstructPresent = Arrays . stream ( initMethod . getAnnotations ( ) ) 
. map ( Annotation :: annotationType ) 
. map ( Class :: getName ) 
. anyMatch ( "javax.annotation.PostConstruct" :: equals ) ; 
if ( postConstructPresent ) { 
"https://github.com/sialcasa/mvvmFX/wiki/Dependency-Injection#lifecycle-postconstruct" , viewModel ) ) ; 
} private static Collection < Method > getInitializeMethods ( Class < ? > classType ) { 
final List < Method > initializeMethods = new ArrayList < > ( ) ; 
Arrays . stream ( classType . getMethods ( ) ) 
. filter ( method -> "initialize" . equals ( method . getName ( ) ) ) 
. filter ( method -> void . class . equals ( method . getReturnType ( ) ) ) 
. filter ( method -> method . getParameterCount ( ) == 0 ) 
. forEach ( initializeMethods :: add ) ; 
Arrays . stream ( classType . getDeclaredMethods ( ) ) 
. filter ( method -> method . isAnnotationPresent ( Initialize . class ) ) 
return initializeMethods ; 
} static void addSceneLifecycleHooks ( ViewModel viewModel , ObservableBooleanValue viewInSceneProperty ) { 
if ( viewModel != null ) { 
if ( viewModel instanceof SceneLifecycle ) { 
SceneLifecycle lifecycleViewModel = ( SceneLifecycle ) viewModel ; 
PreventGarbageCollectionStore . getInstance ( ) . put ( viewInSceneProperty ) ; 
viewInSceneProperty . addListener ( ( observable , oldValue , newValue ) -> { 
lifecycleViewModel . onViewAdded ( ) ; 
lifecycleViewModel . onViewRemoved ( ) ; 
PreventGarbageCollectionStore . getInstance ( ) . remove ( viewInSceneProperty ) ; 
} static void checkScopesInView ( View codeBehind ) { 
List < Field > scopeFields = ReflectionUtils . getFieldsWithAnnotation ( codeBehind , InjectScope . class ) ; 
if ( ! scopeFields . isEmpty ( ) ) { 
public void setCountry ( Country country ) { 
if ( country == null ) { 
subdivisionLabel . set ( null ) ; 
subdivisions . clear ( ) ; 
subdivisionLabel . set ( countryCodeSubdivisionNameMap . get ( country ) ) ; 
if ( countryCodeSubdivisionMap . containsKey ( country ) ) { 
subdivisions . addAll ( countryCodeSubdivisionMap . get ( country ) ) ; 
} void loadCountries ( ) { 
InputStream iso3166Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_LOCATION ) ; 
if ( iso3166Resource == null ) { 
+ ISO_3166_LOCATION ) ; 
XmlConverter < Country > countryConverter = new XmlConverter < > ( "iso_3166_entry" , Country . class ) ; 
DataReader < Country > dataSource = new InputStreamSource < > ( iso3166Resource , countryConverter ) ; 
ListDataProvider < Country > listDataProvider = new ListDataProvider < > ( dataSource ) ; 
listDataProvider . setResultObservableList ( countries ) ; 
Worker < ObservableList < Country > > worker = listDataProvider . retrieve ( ) ; 
worker . stateProperty ( ) . addListener ( obs -> { 
if ( worker . getState ( ) == Worker . State . SUCCEEDED ) { 
loadSubdivisions ( ) ; 
} void loadSubdivisions ( ) { 
InputStream iso3166_2Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_2_LOCATION ) ; 
if ( iso3166_2Resource == null ) { 
+ ISO_3166_2_LOCATION ) ; 
XmlConverter < ISO3166_2_CountryEntity > converter = new XmlConverter < > ( "iso_3166_country" , 
ISO3166_2_CountryEntity . class ) ; 
ObservableList < ISO3166_2_CountryEntity > subdivisionsEntities = FXCollections . observableArrayList ( ) ; 
DataReader < ISO3166_2_CountryEntity > dataSource = 
new InputStreamSource < > ( iso3166_2Resource , converter ) ; 
ListDataProvider < ISO3166_2_CountryEntity > listDataProvider = new ListDataProvider < > ( dataSource ) ; 
listDataProvider . setResultObservableList ( subdivisionsEntities ) ; 
Worker < ObservableList < ISO3166_2_CountryEntity > > worker = listDataProvider . retrieve ( ) ; 
subdivisionsEntities . forEach ( entity -> { 
if ( entity . subsets != null && ! entity . subsets . isEmpty ( ) ) { 
Country country = findCountryByCode ( entity . code ) ; 
if ( ! countryCodeSubdivisionMap . containsKey ( country ) ) { 
countryCodeSubdivisionMap . put ( country , new ArrayList < > ( ) ) ; 
List < Subdivision > subdivisionList = countryCodeSubdivisionMap . get ( country ) ; 
entity . subsets . forEach ( subset -> { 
subset . entryList . forEach ( entry -> { 
subdivisionList . add ( new Subdivision ( entry . name , entry . code , country ) ) ; 
String subdivisionName = entity . subsets . stream ( ) 
. map ( subset -> subset . subdivisionType ) 
. collect ( Collectors . joining ( "/" ) ) ; 
countryCodeSubdivisionNameMap . put ( country , subdivisionName ) ; 
inProgress . set ( false ) ; 
public void publish ( Object channel , String messageName , Object [ ] payload ) { 
if ( channelObserverMap . containsKey ( channel ) ) { 
final ObserverMap observerMap = channelObserverMap . get ( channel ) ; 
if ( shouldPublishInThisThread ( ) ) { 
publish ( messageName , payload , observerMap ) ; 
Platform . runLater ( ( ) -> publish ( messageName , payload , observerMap ) ) ; 
} private static void publish ( String messageName , Object [ ] payload , ObserverMap observerMap ) { 
Collection < NotificationObserver > notificationReceivers = observerMap . get ( messageName ) ; 
if ( notificationReceivers != null ) { 
for ( NotificationObserver observer : notificationReceivers ) { 
observer . receivedNotification ( messageName , payload ) ; 
public final void init ( ) throws Exception { 
ctx = SpringApplication . run ( this . getClass ( ) ) ; 
MvvmFX . setCustomDependencyInjector ( ctx :: getBean ) ; 
ctx . getBeanFactory ( ) . autowireBean ( this ) ; 
initMvvmfx ( ) ; 
fields . forEach ( PropertyField :: resetToDefault ) ; 
immutableFields . forEach ( PropertyField :: resetToDefault ) ; 
calculateDifferenceFlag ( ) ; 
} public void useCurrentValuesAsDefaults ( ) { 
M wrappedModelInstance = model . get ( ) ; 
if ( wrappedModelInstance != null ) { 
for ( final PropertyField < ? , M , ? > field : fields ) { 
field . updateDefault ( wrappedModelInstance ) ; 
for ( final ImmutablePropertyField < ? , M , ? > field : immutableFields ) { 
if ( model . get ( ) != null ) { 
inCommitPhase = true ; 
fields . forEach ( field -> field . commit ( model . get ( ) ) ) ; 
if ( ! immutableFields . isEmpty ( ) ) { 
M tmp = model . get ( ) ; 
for ( ImmutablePropertyField < ? , M , ? > immutableField : immutableFields ) { 
tmp = immutableField . commitImmutable ( tmp ) ; 
model . set ( tmp ) ; 
inCommitPhase = false ; 
dirtyFlag . set ( false ) ; 
} public void reload ( ) { 
fields . forEach ( field -> field . reload ( wrappedModelInstance ) ) ; 
immutableFields . forEach ( field -> field . reload ( wrappedModelInstance ) ) ; 
} public void copyValuesTo ( M model ) { 
Objects . requireNonNull ( model ) ; 
fields . forEach ( field -> field . commit ( model ) ) ; 
} public StringProperty field ( StringGetter < M > getter , StringSetter < M > setter ) { 
return add ( new BeanPropertyField < > ( this :: propertyWasChanged , getter , setter , SimpleStringProperty :: new ) ) ; 
} public StringProperty immutableField ( StringGetter < M > getter , StringImmutableSetter < M > immutableSetter ) { 
return addImmutable ( new ImmutableBeanPropertyField < > ( this :: propertyWasChanged , getter , immutableSetter , SimpleStringProperty :: new ) ) ; 
} public StringProperty field ( StringPropertyAccessor < M > accessor ) { 
return add ( new FxPropertyField < > ( this :: propertyWasChanged , accessor , SimpleStringProperty :: new ) ) ; 
} public StringProperty field ( String identifier , StringGetter < M > getter , StringSetter < M > setter ) { 
return addIdentified ( identifier , new BeanPropertyField < > ( this :: propertyWasChanged , getter , setter , 
( ) -> new SimpleStringProperty ( null , identifier ) ) ) ; 
} public StringProperty immutableField ( String identifier , StringGetter < M > getter , StringImmutableSetter < M > immutableSetter ) { 
return addIdentifiedImmutable ( identifier , new ImmutableBeanPropertyField < > ( this :: propertyWasChanged , getter , immutableSetter , ( ) -> new SimpleStringProperty ( null , identifier ) ) ) ; 
} public StringProperty field ( String identifier , StringPropertyAccessor < M > accessor ) { 
return addIdentified ( identifier , new FxPropertyField < > ( this :: propertyWasChanged , accessor , 
} public BooleanProperty field ( BooleanGetter < M > getter , BooleanSetter < M > setter ) { 
return add ( new BeanPropertyField < > ( this :: propertyWasChanged , getter , setter , SimpleBooleanProperty :: new ) ) ; 
} public DoubleProperty field ( DoubleGetter < M > getter , DoubleSetter < M > setter ) { 
return add ( new BeanPropertyField < > ( 
this :: propertyWasChanged , 
getter :: apply , ( m , number ) -> setter . accept ( m , number . doubleValue ( ) ) , 
SimpleDoubleProperty :: new ) ) ; 
} public FloatProperty field ( FloatGetter < M > getter , FloatSetter < M > setter ) { 
getter :: apply , ( m , number ) -> setter . accept ( m , number . floatValue ( ) ) , 
SimpleFloatProperty :: new ) ) ; 
} public IntegerProperty field ( IntGetter < M > getter , IntSetter < M > setter ) { 
getter :: apply , ( m , number ) -> setter . accept ( m , number . intValue ( ) ) , 
SimpleIntegerProperty :: new ) ) ; 
} public LongProperty field ( LongGetter < M > getter , LongSetter < M > setter ) { 
getter :: apply , ( m , number ) -> setter . accept ( m , number . longValue ( ) ) , 
SimpleLongProperty :: new ) ) ; 
} public < T > ObjectProperty < T > field ( ObjectGetter < M , T > getter , ObjectSetter < M , T > setter ) { 
return add ( new BeanPropertyField < > ( this :: propertyWasChanged , getter , setter , SimpleObjectProperty :: new ) ) ; 
} public < E > ListProperty < E > field ( ListGetter < M , E > getter , ListSetter < M , E > setter ) { 
return add ( new BeanListPropertyField < > ( this :: propertyWasChanged , getter , 
( m , list ) -> setter . accept ( m , FXCollections . observableArrayList ( list ) ) , SimpleListProperty :: new ) ) ; 
} private static < T > ObservableSet < T > observableHashSet ( Set < T > source ) { 
return FXCollections . observableSet ( new HashSet < > ( source ) ) ; 
} public < K , V > MapProperty < K , V > field ( MapGetter < M , K , V > getter , MapSetter < M , K , V > setter ) { 
return add ( new BeanMapPropertyField < > ( this :: propertyWasChanged , getter , 
( m , map ) -> setter . accept ( m , FXCollections . observableMap ( map ) ) , SimpleMapProperty :: new ) ) ; 
} public void addRule ( ObservableValue < Boolean > rule , ValidationMessage message ) { 
booleanRules . add ( rule ) ; 
rule . addListener ( ( observable , oldValue , newValue ) -> { 
validateBooleanRule ( newValue , message ) ; 
validateBooleanRule ( rule . getValue ( ) , message ) ; 
} public void addRule ( ObservableValue < ValidationMessage > rule ) { 
complexRules . add ( rule ) ; 
validationStatus . removeMessage ( oldValue ) ; 
if ( newValue != null ) { 
validationStatus . addMessage ( newValue ) ; 
if ( rule . getValue ( ) != null ) { 
validationStatus . addMessage ( rule . getValue ( ) ) ; 
} static ObservableList < String > createListWithNothingSelectedMarker ( ObservableList < String > source ) { 
final ObservableList < String > result = FXCollections . observableArrayList ( ) ; 
result . add ( NOTHING_SELECTED_MARKER ) ; 
result . addAll ( source ) ; 
source . addListener ( ( ListChangeListener < String > ) c -> { 
} public static < ViewType extends JavaView < ? extends ViewModelType > , ViewModelType extends ViewModel > JavaViewStep < ViewType , ViewModelType > javaView ( 
Class < ? extends ViewType > viewType ) { 
return new JavaViewStep < > ( viewType ) ; 
} public static < ViewType extends FxmlView < ? extends ViewModelType > , ViewModelType extends ViewModel > FxmlViewStep < ViewType , ViewModelType > fxmlView ( 
return new FxmlViewStep < > ( viewType ) ; 
} public < T > void register ( ObservableValue < T > observable , ChangeListener < ? super T > listener ) { 
if ( ! simpleChangeListeners . containsKey ( observable ) ) { 
this . simpleChangeListeners . put ( observable , Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ) ; 
Set < ChangeListener > observers = this . simpleChangeListeners . get ( observable ) ; 
observers . add ( listener ) ; 
observable . addListener ( listener ) ; 
} public < T > void register ( ObservableList < T > observable , ListChangeListener < ? super T > listener ) { 
if ( ! listChangeListeners . containsKey ( observable ) ) { 
this . listChangeListeners . put ( observable , Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ) ; 
Set < ListChangeListener > observers = this . listChangeListeners . get ( observable ) ; 
} public void register ( Observable observable , InvalidationListener listener ) { 
if ( ! invalidationListeners . containsKey ( observable ) ) { 
this . invalidationListeners . put ( observable , Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ) ; 
Set < InvalidationListener > observers = this . invalidationListeners . get ( observable ) ; 
} private < T , U > void clearMap ( Map < T , Set < U > > map , BiConsumer < T , U > consumer ) { 
for ( T observable : map . keySet ( ) ) { 
for ( U listener : map . get ( observable ) ) { 
consumer . accept ( observable , listener ) ; 
map . clear ( ) ; 
public final void start ( Stage primaryStage ) throws Exception { 
producer . setPrimaryStage ( primaryStage ) ; 
startMvvmfx ( primaryStage ) ; 
ctx = beanManager . createCreationalContext ( null ) ; 
injectionTarget = beanManager . createInjectionTarget ( 
beanManager . createAnnotatedType ( ( Class < MvvmfxCdiApplication > ) this . getClass ( ) ) ) ; 
injectionTarget . inject ( this , ctx ) ; 
injectionTarget . postConstruct ( this ) ; 
producer . setApplicationParameters ( getParameters ( ) ) ; 
public final void stop ( ) throws Exception { 
stopMvvmfx ( ) ; 
injectionTarget . preDestroy ( this ) ; 
injectionTarget . dispose ( this ) ; 
ctx . release ( ) ; 
container . close ( ) ; 
} private void createIndexEvents ( ) { 
selectionModel 
. selectedIndexProperty ( ) 
. addListener ( ( bean , oldVal , newVal ) -> { 
int index = newVal . intValue ( ) ; 
ListType item = index == - 1 ? null : modelListProperty ( ) 
. get ( index ) ; 
selectedItem . set ( item ) ; 
selectedItem . addListener ( ( observable , oldVal , newVal ) -> { 
if ( newVal == null ) { 
selectionModel . select ( - 1 ) ; 
selectedItem . set ( null ) ; 
int index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; 
selectionModel . select ( index ) ; 
selectedItem . set ( oldVal ) ; 
} public static List < Field > getFieldsWithAnnotation ( Object target , Class < ? extends Annotation > annotationType ) { 
return ReflectionUtils . getFieldsFromClassHierarchy ( target . getClass ( ) ) 
. stream ( ) 
. filter ( field -> field . isAnnotationPresent ( annotationType ) ) 
} public static List < Field > getFieldsFromClassHierarchy ( Class < ? > type ) { 
final List < Field > classFields = new ArrayList < > ( ) ; 
classFields . addAll ( Arrays . asList ( type . getDeclaredFields ( ) ) ) ; 
final Class < ? > parentClass = type . getSuperclass ( ) ; 
if ( parentClass != null && ! ( parentClass . equals ( Object . class ) ) ) { 
List < Field > parentClassFields = getFieldsFromClassHierarchy ( parentClass ) ; 
classFields . addAll ( parentClassFields ) ; 
return classFields ; 
} public static < T > T accessMember ( final AccessibleObject member , final Callable < T > callable , String errorMessage ) { 
if ( callable == null ) { 
return AccessController . doPrivileged ( ( PrivilegedAction < T > ) ( ) -> { 
boolean wasAccessible = member . isAccessible ( ) ; 
member . setAccessible ( true ) ; 
return callable . call ( ) ; 
} catch ( Exception exception ) { 
throw new IllegalStateException ( errorMessage , exception ) ; 
member . setAccessible ( wasAccessible ) ; 
} public static void setField ( final Field field , Object target , Object value ) { 
accessMember ( field , ( ) -> field . set ( target , value ) , 
} public static void accessMember ( final AccessibleObject member , final SideEffectWithException sideEffect , String errorMessage ) { 
if ( sideEffect == null ) { 
AccessController . doPrivileged ( ( PrivilegedAction < ? > ) ( ) -> { 
sideEffect . call ( ) ; 
} public < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewTuple < ViewType , ViewModelType > loadFxmlViewTuple ( 
Class < ? extends ViewType > viewType , ResourceBundle resourceBundle , ViewType codeBehind , Object root , 
ViewModelType viewModel , Context context , Collection < Scope > providedScopes , 
List < BuilderFactory > builderFactories ) { 
final String pathToFXML = createFxmlPath ( viewType ) ; 
return loadFxmlViewTuple ( viewType , pathToFXML , resourceBundle , codeBehind , root , viewModel , context , providedScopes , builderFactories ) ; 
} private String createFxmlPath ( Class < ? > viewType ) { 
final StringBuilder pathBuilder = new StringBuilder ( ) ; 
final FxmlPath pathAnnotation = viewType . getDeclaredAnnotation ( FxmlPath . class ) ; 
final String fxmlPath = Optional . ofNullable ( pathAnnotation ) 
. map ( FxmlPath :: value ) 
. map ( String :: trim ) 
. orElse ( "" ) ; 
if ( fxmlPath . isEmpty ( ) ) { 
pathBuilder . append ( "/" ) ; 
if ( viewType . getPackage ( ) != null ) { 
pathBuilder . append ( viewType . getPackage ( ) . getName ( ) . replaceAll ( "\\." , "/" ) ) ; 
pathBuilder . append ( viewType . getSimpleName ( ) ) ; 
pathBuilder . append ( ".fxml" ) ; 
pathBuilder . append ( fxmlPath ) ; 
return pathBuilder . toString ( ) ; 
final String resource , ResourceBundle resourceBundle , final ViewType codeBehind , final Object root , 
ViewModelType viewModel , Context parentContext , Collection < Scope > providedScopes , 
return loadFxmlViewTuple ( 
resource , 
resourceBundle , 
codeBehind , 
root , 
viewModel , 
parentContext , 
providedScopes , 
builderFactories 
} private < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewTuple < ViewType , ViewModelType > loadFxmlViewTuple ( 
final Class < ? > resourceLoader , final String resource , ResourceBundle resourceBundle , final ViewType codeBehind , final Object root , 
BooleanProperty viewInSceneProperty = new SimpleBooleanProperty ( ) ; 
final FXMLLoader loader = createFxmlLoader ( resourceLoader , resource , resourceBundle , codeBehind , root , viewModel , context , viewInSceneProperty , builderFactories ) ; 
loader . load ( ) ; 
final ViewType loadedController = loader . getController ( ) ; 
final Parent loadedRoot = loader . getRoot ( ) ; 
viewInSceneProperty . bind ( loadedRoot . sceneProperty ( ) . isNotNull ( ) ) ; 
if ( loadedController == null ) { 
ViewModelType actualViewModel ; 
actualViewModel = ViewLoaderReflectionUtils . getExistingViewModel ( loadedController ) ; 
if ( actualViewModel == null ) { 
actualViewModel = ViewLoaderReflectionUtils . createViewModel ( loadedController ) ; 
if ( actualViewModel != null ) { 
ViewLoaderReflectionUtils . initializeViewModel ( actualViewModel ) ; 
actualViewModel = viewModel ; 
return new ViewTuple < > ( loadedController , loadedRoot , actualViewModel ) ; 
} catch ( final IOException ex ) { 
} static public int convert ( ILoggingEvent event ) { 
Level level = event . getLevel ( ) ; 
switch ( level . levelInt ) { 
case Level . ERROR_INT : 
return SyslogConstants . ERROR_SEVERITY ; 
case Level . WARN_INT : 
return SyslogConstants . WARNING_SEVERITY ; 
case Level . INFO_INT : 
return SyslogConstants . INFO_SEVERITY ; 
case Level . DEBUG_INT : 
case Level . TRACE_INT : 
return SyslogConstants . DEBUG_SEVERITY ; 
} public AutoFlushingObjectWriter newAutoFlushingObjectWriter ( OutputStream outputStream ) throws IOException { 
return new AutoFlushingObjectWriter ( new ObjectOutputStream ( outputStream ) , CoreConstants . OOS_RESET_FREQUENCY ) ; 
} protected void subAppend ( CyclicBuffer < ILoggingEvent > cb , ILoggingEvent event ) { 
if ( includeCallerData ) { 
event . getCallerData ( ) ; 
event . prepareForDeferredProcessing ( ) ; 
cb . add ( event ) ; 
} private URL findConfigFileFromSystemProperties ( boolean updateStatus ) { 
String logbackConfigFile = OptionHelper . getSystemProperty ( CONFIG_FILE_PROPERTY ) ; 
if ( logbackConfigFile != null ) { 
URL result = null ; 
File file = new File ( logbackConfigFile ) ; 
if ( file . exists ( ) && file . isFile ( ) ) { 
if ( updateStatus ) { 
statusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; 
result = file . toURI ( ) . toURL ( ) ; 
result = new URL ( logbackConfigFile ) ; 
result = Loader . getResource ( logbackConfigFile , this . classLoader ) ; 
statusOnResourceSearch ( logbackConfigFile , this . classLoader , result != null ? result . toString ( ) : null ) ; 
} private URL getResource ( String filename , ClassLoader myClassLoader , boolean updateStatus ) { 
URL url = myClassLoader . getResource ( filename ) ; 
String resourcePath = null ; 
if ( url != null ) { 
resourcePath = filename ; 
statusOnResourceSearch ( filename , myClassLoader , resourcePath ) ; 
} public void autoConfig ( ) throws JoranException { 
StatusListenerConfigHelper . installIfAsked ( loggerContext ) ; 
new AndroidContextUtil ( ) . setupProperties ( loggerContext ) ; 
boolean verbose = true ; 
boolean configured = false ; 
JoranConfigurator configurator = new JoranConfigurator ( ) ; 
configurator . setContext ( loggerContext ) ; 
if ( ! configured ) { 
URL url = findConfigFileFromSystemProperties ( verbose ) ; 
configurator . doConfigure ( url ) ; 
configured = true ; 
URL assetsConfigUrl = findConfigFileURLFromAssets ( verbose ) ; 
if ( assetsConfigUrl != null ) { 
configurator . doConfigure ( assetsConfigUrl ) ; 
} private void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { 
StatusManager sm = loggerContext . getStatusManager ( ) ; 
loggerContext ) ) ; 
} public T acceptClient ( ) throws IOException { 
Socket socket = serverSocket . accept ( ) ; 
return createClient ( 
socketAddressToString ( socket . getRemoteSocketAddress ( ) ) , socket ) ; 
} private String socketAddressToString ( SocketAddress address ) { 
String addr = address . toString ( ) ; 
int i = addr . indexOf ( "/" ) ; 
if ( i >= 0 ) { 
addr = addr . substring ( i + 1 ) ; 
} static public ExecutorService newExecutorService ( ) { 
return new ThreadPoolExecutor ( CoreConstants . CORE_POOL_SIZE , 
CoreConstants . MAX_POOL_SIZE , 
0L , TimeUnit . MILLISECONDS , 
new SynchronousQueue < Runnable > ( ) , 
THREAD_FACTORY ) ; 
} public static < E > void startConverters ( Converter < E > head ) { 
Converter < E > c = head ; 
while ( c != null ) { 
if ( c instanceof CompositeConverter ) { 
CompositeConverter < E > cc = ( CompositeConverter < E > ) c ; 
Converter < E > childConverter = cc . childConverter ; 
startConverters ( childConverter ) ; 
cc . start ( ) ; 
} else if ( c instanceof DynamicConverter ) { 
DynamicConverter < E > dc = ( DynamicConverter < E > ) c ; 
dc . start ( ) ; 
c = c . getNext ( ) ; 
protected void subAppend ( E event ) { 
synchronized ( triggeringPolicy ) { 
if ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) { 
rollover ( ) ; 
super . subAppend ( event ) ; 
public void setRollingPolicy ( RollingPolicy policy ) { 
rollingPolicy = policy ; 
if ( rollingPolicy instanceof TriggeringPolicy ) { 
triggeringPolicy = ( TriggeringPolicy < E > ) policy ; 
} public void addSubstitutionProperty ( String key , String value ) { 
if ( key == null || value == null ) { 
value = value . trim ( ) ; 
propertiesMap . put ( key , value ) ; 
String v = propertiesMap . get ( key ) ; 
return context . getProperty ( key ) ; 
protected ServerSocketFactory getServerSocketFactory ( ) throws Exception { 
if ( socketFactory == null ) { 
SSLContext sslContext = getSsl ( ) . createContext ( this ) ; 
SSLParametersConfiguration parameters = getSsl ( ) . getParameters ( ) ; 
parameters . setContext ( getContext ( ) ) ; 
socketFactory = new ConfigurableSSLServerSocketFactory ( 
parameters , sslContext . getServerSocketFactory ( ) ) ; 
return socketFactory ; 
} public static String escapeTags ( final String input ) { 
if ( input == null || input . length ( ) == 0 || ! UNSAFE_XML_CHARS . matcher ( input ) . find ( ) ) { 
return input ; 
StringBuffer buf = new StringBuffer ( input ) ; 
return escapeTags ( buf ) ; 
} public static String escapeTags ( final StringBuffer buf ) { 
char ch = buf . charAt ( i ) ; 
switch ( ch ) { 
buf . replace ( i , i + 1 , "&amp;" ) ; 
buf . replace ( i , i + 1 , "&lt;" ) ; 
buf . replace ( i , i + 1 , "&gt;" ) ; 
buf . replace ( i , i + 1 , "&quot;" ) ; 
buf . replace ( i , i + 1 , "&#39;" ) ; 
buf . replace ( i , i + 1 , "" ) ; 
} public static void appendEscapingCDATA ( StringBuilder output , String str ) { 
if ( str == null ) { 
int end = str . indexOf ( CDATA_END ) ; 
output . append ( str ) ; 
while ( end > - 1 ) { 
output . append ( str . substring ( start , end ) ) ; 
output . append ( CDATA_EMBEDED_END ) ; 
start = end + CDATA_END_LEN ; 
if ( start < str . length ( ) ) { 
end = str . indexOf ( CDATA_END , start ) ; 
output . append ( str . substring ( start ) ) ; 
} public static void retainMatching ( Collection < String > values , 
String ... patterns ) { 
retainMatching ( values , Arrays . asList ( patterns ) ) ; 
Collection < String > patterns ) { 
if ( patterns . isEmpty ( ) ) return ; 
List < String > matches = new ArrayList < String > ( values . size ( ) ) ; 
for ( String p : patterns ) { 
Pattern pattern = Pattern . compile ( p ) ; 
for ( String value : values ) { 
if ( pattern . matcher ( value ) . matches ( ) ) { 
matches . add ( value ) ; 
values . retainAll ( matches ) ; 
} public static void removeMatching ( Collection < String > values , 
removeMatching ( values , Arrays . asList ( patterns ) ) ; 
values . removeAll ( matches ) ; 
} static void writeInt ( byte [ ] byteArray , int offset , int i ) { 
for ( int j = 0 ; j < 4 ; j ++ ) { 
int shift = 24 - j * 8 ; 
byteArray [ offset + j ] = ( byte ) ( i > > > shift ) ; 
} static int readInt ( byte [ ] byteArray , int offset ) { 
i += ( byteArray [ offset + j ] & 0xFF ) << shift ; 
} public Converter < E > compile ( final Node top , Map < String , String > converterMap ) { 
Compiler < E > compiler = new Compiler < E > ( top , converterMap ) ; 
compiler . setContext ( context ) ; 
return compiler . compile ( ) ; 
} Node E ( ) throws ScanException { 
Node t = T ( ) ; 
Node eOpt = Eopt ( ) ; 
if ( eOpt != null ) { 
t . setNext ( eOpt ) ; 
} Node Eopt ( ) throws ScanException { 
Token next = getCurentToken ( ) ; 
return E ( ) ; 
} Node T ( ) throws ScanException { 
Token t = getCurentToken ( ) ; 
switch ( t . getType ( ) ) { 
case Token . LITERAL : 
advanceTokenPointer ( ) ; 
return new Node ( Node . LITERAL , t . getValue ( ) ) ; 
case Token . PERCENT : 
FormatInfo fi ; 
Token u = getCurentToken ( ) ; 
FormattingNode c ; 
if ( u . getType ( ) == Token . FORMAT_MODIFIER ) { 
fi = FormatInfo . valueOf ( ( String ) u . getValue ( ) ) ; 
c = C ( ) ; 
c . setFormatInfo ( fi ) ; 
} public String doLayout ( ILoggingEvent event ) { 
if ( buf . capacity ( ) > UPPER_LIMIT ) { 
buf = new StringBuilder ( DEFAULT_SIZE ) ; 
buf . append ( Transform . escapeTags ( event . getLoggerName ( ) ) ) ; 
buf . append ( "\"\r\n" ) ; 
buf . append ( event . getTimeStamp ( ) ) ; 
buf . append ( event . getLevel ( ) ) ; 
buf . append ( Transform . escapeTags ( event . getThreadName ( ) ) ) ; 
buf . append ( "\">\r\n" ) ; 
buf . append ( Transform . escapeTags ( event . getFormattedMessage ( ) ) ) ; 
buf . append ( "</log4j:message>\r\n" ) ; 
IThrowableProxy tp = event . getThrowableProxy ( ) ; 
if ( tp != null ) { 
StackTraceElementProxy [ ] stepArray = tp . getStackTraceElementProxyArray ( ) ; 
for ( StackTraceElementProxy step : stepArray ) { 
buf . append ( CoreConstants . TAB ) ; 
buf . append ( step . toString ( ) ) ; 
buf . append ( "\r\n" ) ; 
buf . append ( "]]></log4j:throwable>\r\n" ) ; 
if ( locationInfo ) { 
StackTraceElement [ ] callerDataArray = event . getCallerData ( ) ; 
if ( callerDataArray != null && callerDataArray . length > 0 ) { 
StackTraceElement immediateCallerData = callerDataArray [ 0 ] ; 
buf . append ( immediateCallerData . getClassName ( ) ) ; 
buf . append ( Transform . escapeTags ( immediateCallerData . getMethodName ( ) ) ) ; 
buf . append ( Transform . escapeTags ( immediateCallerData . getFileName ( ) ) ) ; 
buf . append ( immediateCallerData . getLineNumber ( ) ) ; 
buf . append ( "\"/>\r\n" ) ; 
if ( this . getProperties ( ) ) { 
Map < String , String > propertyMap = event . getMDCPropertyMap ( ) ; 
if ( ( propertyMap != null ) && ( propertyMap . size ( ) != 0 ) ) { 
Set < Entry < String , String > > entrySet = propertyMap . entrySet ( ) ; 
for ( Entry < String , String > entry : entrySet ) { 
buf . append ( "\r\n</log4j:event>\r\n\r\n" ) ; 
} public void escape ( String escapeChars , StringBuffer buf , char next , 
int pointer ) { 
super . escape ( "" + CoreConstants . PERCENT_CHAR + CoreConstants . RIGHT_PARENTHESIS_CHAR , buf , next , pointer ) ; 
} public String toRegexForFixedDate ( Date date ) { 
Converter < Object > p = headTokenConverter ; 
while ( p != null ) { 
if ( p instanceof LiteralConverter ) { 
buf . append ( p . convert ( null ) ) ; 
} else if ( p instanceof IntegerTokenConverter ) { 
buf . append ( FileFinder . regexEscapePath ( "(\\d+)" ) ) ; 
} else if ( p instanceof DateTokenConverter ) { 
DateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; 
if ( dtc . isPrimary ( ) ) { 
buf . append ( p . convert ( date ) ) ; 
buf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; 
p = p . getNext ( ) ; 
public ServerSocket createServerSocket ( int port , int backlog ) 
SSLServerSocket socket = ( SSLServerSocket ) delegate . createServerSocket ( 
port , backlog ) ; 
parameters . configure ( new SSLConfigurableServerSocket ( socket ) ) ; 
return socket ; 
} public void begin ( InterpretationContext ec , String name , Attributes attributes ) { 
inError = false ; 
evaluator = null ; 
String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; 
if ( OptionHelper . isEmpty ( className ) ) { 
className = defaultClassName ( ) ; 
inError = true ; 
String evaluatorName = attributes . getValue ( Action . NAME_ATTRIBUTE ) ; 
if ( OptionHelper . isEmpty ( evaluatorName ) ) { 
evaluator = ( EventEvaluator < ? > ) OptionHelper . instantiateByClassName ( 
className , ch . qos . logback . core . boolex . EventEvaluator . class , context ) ; 
evaluator . setContext ( this . context ) ; 
evaluator . setName ( evaluatorName ) ; 
ec . pushObject ( evaluator ) ; 
} catch ( Exception oops ) { 
public void end ( InterpretationContext ec , String e ) { 
if ( inError ) { 
if ( evaluator instanceof LifeCycle ) { 
( ( LifeCycle ) evaluator ) . start ( ) ; 
Object o = ec . peekObject ( ) ; 
if ( o != evaluator ) { 
ec . popObject ( ) ; 
Map < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context 
. getObject ( CoreConstants . EVALUATOR_MAP ) ; 
if ( evaluatorMap == null ) { 
evaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; 
} public void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , 
NoSuchMethodException , InstantiationException , IllegalAccessException , 
InvocationTargetException { 
if ( this . key == null ) { 
this . key = key ; 
} else if ( this . key != key ) { 
String contextSelectorStr = OptionHelper 
. getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; 
if ( contextSelectorStr == null ) { 
contextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; 
} else if ( contextSelectorStr . equals ( "JNDI" ) ) { 
contextSelector = dynamicalContextSelector ( defaultLoggerContext , 
contextSelectorStr ) ; 
} static ContextSelector dynamicalContextSelector ( 
LoggerContext defaultLoggerContext , String contextSelectorStr ) 
throws ClassNotFoundException , SecurityException , NoSuchMethodException , 
IllegalArgumentException , InstantiationException , IllegalAccessException , 
Class < ? > contextSelectorClass = Loader . loadClass ( contextSelectorStr ) ; 
Constructor cons = contextSelectorClass 
. getConstructor ( new Class [ ] { LoggerContext . class } ) ; 
return ( ContextSelector ) cons . newInstance ( defaultLoggerContext ) ; 
} public void setupProperties ( LoggerContext context ) { 
props . setProperty ( CoreConstants . DATA_DIR_KEY , getFilesDirectoryPath ( ) ) ; 
final String extDir = getMountedExternalStorageDirectoryPath ( ) ; 
if ( extDir != null ) { 
props . setProperty ( CoreConstants . EXT_DIR_KEY , extDir ) ; 
props . setProperty ( CoreConstants . PACKAGE_NAME_KEY , getPackageName ( ) ) ; 
props . setProperty ( CoreConstants . VERSION_CODE_KEY , getVersionCode ( ) ) ; 
props . setProperty ( CoreConstants . VERSION_NAME_KEY , getVersionName ( ) ) ; 
context . putProperties ( props ) ; 
} public String getMountedExternalStorageDirectoryPath ( ) { 
String path = null ; 
String state = Environment . getExternalStorageState ( ) ; 
if ( state . equals ( Environment . MEDIA_MOUNTED ) || 
state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { 
path = absPath ( Environment . getExternalStorageDirectory ( ) ) ; 
} @ TargetApi ( 21 ) 
public String getNoBackupFilesDirectoryPath ( ) { 
return Build . VERSION . SDK_INT >= 21 && 
this . context != null 
? absPath ( this . context . getNoBackupFilesDir ( ) ) 
} public String getDatabaseDirectoryPath ( ) { 
return this . context != null 
&& this . context . getDatabasePath ( "x" ) != null 
? this . context . getDatabasePath ( "x" ) . getParent ( ) 
} public void setFile ( String file ) { 
fileName = null ; 
fileName = file . trim ( ) ; 
int errors = 0 ; 
String file = getFile ( ) ; 
file = getAbsoluteFilePath ( file ) ; 
if ( prudent ) { 
if ( ! isAppend ( ) ) { 
setAppend ( true ) ; 
if ( ! lazyInit ) { 
if ( checkForFileCollisionInPreviousFileAppenders ( ) ) { 
addError ( COLLISION_WITH_EARLIER_APPENDER_URL ) ; 
errors ++ ; 
openFile ( file ) ; 
setOutputStream ( new NOPOutputStream ( ) ) ; 
if ( errors == 0 ) { 
super . start ( ) ; 
} protected boolean openFile ( String filename ) throws IOException { 
boolean successful = false ; 
filename = getAbsoluteFilePath ( filename ) ; 
boolean result = FileUtil . createMissingParentDirectories ( file ) ; 
if ( ! result ) { 
+ file . getAbsolutePath ( ) + "]" ) ; 
ResilientFileOutputStream resilientFos = new ResilientFileOutputStream ( file , append , bufferSize . getSize ( ) ) ; 
resilientFos . setContext ( context ) ; 
setOutputStream ( resilientFos ) ; 
successful = true ; 
return successful ; 
} private String getAbsoluteFilePath ( String filename ) { 
if ( EnvUtil . isAndroidOS ( ) && ! new File ( filename ) . isAbsolute ( ) ) { 
String dataDir = context . getProperty ( CoreConstants . DATA_DIR_KEY ) ; 
filename = FileUtil . prefixRelativePath ( dataDir , filename ) ; 
return filename ; 
} public boolean evaluate ( ILoggingEvent event ) throws NullPointerException , 
EvaluationException { 
return event . getLevel ( ) . levelInt >= Level . ERROR_INT ; 
} public String getDiscriminatingValue ( ILoggingEvent event ) { 
Map < String , String > mdcMap = event . getMDCPropertyMap ( ) ; 
if ( mdcMap == null ) { 
String mdcValue = mdcMap . get ( key ) ; 
if ( mdcValue == null ) { 
return mdcValue ; 
} private void updateMaskIfNecessary ( long now ) { 
final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; 
lastMaskCheck = now ; 
if ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { 
mask = ( mask << 1 ) | 1 ; 
} else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { 
mask = mask > > > 2 ; 
} public FilterReply getFilterChainDecision ( E event ) { 
final Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; 
final int len = filterArrray . length ; 
final FilterReply r = filterArrray [ i ] . decide ( event ) ; 
if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { 
return FilterReply . NEUTRAL ; 
} public void run ( ) { 
addInfo ( clientId + "connected" ) ; 
ObjectOutputStream oos = null ; 
oos = createObjectOutputStream ( ) ; 
while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
Serializable event = queue . take ( ) ; 
oos . writeObject ( event ) ; 
oos . flush ( ) ; 
if ( ++ counter >= CoreConstants . OOS_RESET_FREQUENCY ) { 
counter = 0 ; 
oos . reset ( ) ; 
catch ( InterruptedException ex ) { 
catch ( SocketException ex ) { 
addInfo ( clientId + ex ) ; 
catch ( IOException ex ) { 
addError ( clientId + ex ) ; 
catch ( RuntimeException ex ) { 
if ( oos != null ) { 
CloseUtil . closeQuietly ( oos ) ; 
} public SecureRandom createSecureRandom ( ) throws NoSuchProviderException , 
NoSuchAlgorithmException { 
return getProvider ( ) != null ? 
SecureRandom . getInstance ( getAlgorithm ( ) , getProvider ( ) ) 
: SecureRandom . getInstance ( getAlgorithm ( ) ) ; 
catch ( NoSuchProviderException ex ) { 
+ getProvider ( ) ) ; 
catch ( NoSuchAlgorithmException ex ) { 
+ getAlgorithm ( ) ) ; 
} public void begin ( InterpretationContext ec , String localName , Attributes attributes ) { 
String errorMsg ; 
String pattern = attributes . getValue ( Action . PATTERN_ATTRIBUTE ) ; 
String actionClass = attributes . getValue ( Action . ACTION_CLASS_ATTRIBUTE ) ; 
if ( OptionHelper . isEmpty ( pattern ) ) { 
addError ( errorMsg ) ; 
if ( OptionHelper . isEmpty ( actionClass ) ) { 
+ actionClass + "]." ) ; 
ec . getJoranInterpreter ( ) . getRuleStore ( ) . addRule ( new ElementSelector ( pattern ) , 
actionClass ) ; 
+ actionClass + "]" ; 
} public SSLContext createContext ( ContextAware context ) throws NoSuchProviderException , 
NoSuchAlgorithmException , KeyManagementException , 
UnrecoverableKeyException , KeyStoreException , CertificateException { 
SSLContext sslContext = getProvider ( ) != null ? 
SSLContext . getInstance ( getProtocol ( ) , getProvider ( ) ) 
: SSLContext . getInstance ( getProtocol ( ) ) ; 
KeyManager [ ] keyManagers = createKeyManagers ( context ) ; 
TrustManager [ ] trustManagers = createTrustManagers ( context ) ; 
SecureRandom secureRandom = createSecureRandom ( context ) ; 
sslContext . init ( keyManagers , trustManagers , secureRandom ) ; 
return sslContext ; 
} private KeyManager [ ] createKeyManagers ( ContextAware context ) 
throws NoSuchProviderException , NoSuchAlgorithmException , 
UnrecoverableKeyException , KeyStoreException { 
if ( getKeyStore ( ) == null ) return null ; 
KeyStore keyStore = getKeyStore ( ) . createKeyStore ( ) ; 
context . addInfo ( 
KeyManagerFactory kmf = getKeyManagerFactory ( ) . createKeyManagerFactory ( ) ; 
char [ ] passphrase = getKeyStore ( ) . getPassword ( ) . toCharArray ( ) ; 
kmf . init ( keyStore , passphrase ) ; 
return kmf . getKeyManagers ( ) ; 
} private TrustManager [ ] createTrustManagers ( ContextAware context ) 
KeyStoreException { 
if ( getTrustStore ( ) == null ) return null ; 
KeyStore trustStore = getTrustStore ( ) . createKeyStore ( ) ; 
TrustManagerFactory tmf = getTrustManagerFactory ( ) 
. createTrustManagerFactory ( ) ; 
tmf . init ( trustStore ) ; 
return tmf . getTrustManagers ( ) ; 
} private KeyStoreFactoryBean keyStoreFromSystemProperties ( String property ) { 
if ( System . getProperty ( property ) == null ) return null ; 
KeyStoreFactoryBean keyStore = new KeyStoreFactoryBean ( ) ; 
keyStore . setLocation ( locationFromSystemProperty ( property ) ) ; 
keyStore . setProvider ( System . getProperty ( property + "Provider" ) ) ; 
keyStore . setPassword ( System . getProperty ( property + "Password" ) ) ; 
keyStore . setType ( System . getProperty ( property + "Type" ) ) ; 
return keyStore ; 
} private String locationFromSystemProperty ( String name ) { 
String location = System . getProperty ( name ) ; 
if ( location != null && ! location . startsWith ( "file:" ) ) { 
location = "file:" + location ; 
} public static URL urlForResource ( String location ) 
throws MalformedURLException , FileNotFoundException { 
if ( location == null ) { 
if ( ! location . matches ( SCHEME_PATTERN ) ) { 
url = Loader . getResourceBySelfClassLoader ( location ) ; 
else if ( location . startsWith ( CLASSPATH_SCHEME ) ) { 
String path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; 
if ( path . startsWith ( "/" ) ) { 
if ( path . length ( ) == 0 ) { 
url = Loader . getResourceBySelfClassLoader ( path ) ; 
url = new URL ( location ) ; 
if ( url == null ) { 
throw new FileNotFoundException ( location ) ; 
public void begin ( InterpretationContext ec , String localName , Attributes attributes ) { 
String conversionWord = 
attributes . getValue ( ActionConst . CONVERSION_WORD_ATTRIBUTE ) ; 
String converterClass = 
attributes . getValue ( ActionConst . CONVERTER_CLASS_ATTRIBUTE ) ; 
if ( OptionHelper . isEmpty ( conversionWord ) ) { 
if ( OptionHelper . isEmpty ( converterClass ) ) { 
ec . addError ( errorMsg ) ; 
Map < String , String > ruleRegistry = ( Map < String , String > ) context . getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; 
if ( ruleRegistry == null ) { 
ruleRegistry = new HashMap < String , String > ( ) ; 
context . putObject ( CoreConstants . PATTERN_RULE_REGISTRY , ruleRegistry ) ; 
ruleRegistry . put ( conversionWord , converterClass ) ; 
} public void process ( Context context , Converter < ILoggingEvent > head ) { 
if ( head == null ) { 
if ( ! chainHandlesThrowable ( head ) ) { 
Converter < ILoggingEvent > tail = ConverterUtil . findTail ( head ) ; 
Converter < ILoggingEvent > exConverter = null ; 
LoggerContext loggerContext = ( LoggerContext ) context ; 
if ( loggerContext . isPackagingDataEnabled ( ) ) { 
exConverter = new ExtendedThrowableProxyConverter ( ) ; 
exConverter = new ThrowableProxyConverter ( ) ; 
tail . setNext ( exConverter ) ; 
} public boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { 
Converter < ILoggingEvent > c = head ; 
if ( c instanceof ThrowableHandlingConverter ) { 
} protected void stop ( ) { 
Context hookContext = getContext ( ) ; 
if ( hookContext instanceof ContextBase ) { 
ContextBase context = ( ContextBase ) hookContext ; 
context . stop ( ) ; 
} public static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { 
if ( context == null ) { 
StatusManager sm = context . getStatusManager ( ) ; 
if ( sm == null ) { 
StatusUtil statusUtil = new StatusUtil ( context ) ; 
if ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) { 
print ( sm , threshold ) ; 
} public static void printIfErrorsOccured ( Context context ) { 
if ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) { 
print ( sm ) ; 
} public static void print ( Context context , long threshold ) { 
} private static void appendThrowable ( StringBuilder sb , Throwable t ) { 
String [ ] stringRep = ThrowableToStringArray . convert ( t ) ; 
for ( String s : stringRep ) { 
if ( s . startsWith ( CoreConstants . CAUSED_BY ) ) { 
} else if ( Character . isDigit ( s . charAt ( 0 ) ) ) { 
sb . append ( s ) . append ( CoreConstants . LINE_SEPARATOR ) ; 
if ( isStarted ( ) ) return ; 
int errorCount = 0 ; 
if ( port <= 0 ) { 
errorCount ++ ; 
+ name 
if ( remoteHost == null ) { 
if ( queueSize == 0 ) { 
if ( queueSize < 0 ) { 
if ( errorCount == 0 ) { 
address = InetAddress . getByName ( remoteHost ) ; 
} catch ( UnknownHostException ex ) { 
deque = queueFactory . newLinkedBlockingDeque ( queueSize ) ; 
connector = createConnector ( address , port , 0 , reconnectionDelay . getMilliseconds ( ) ) ; 
task = getContext ( ) . getScheduledExecutorService ( ) . submit ( new Runnable ( ) { 
connectSocketAndDispatchEvents ( ) ; 
public void stop ( ) { 
if ( ! isStarted ( ) ) return ; 
CloseUtil . closeQuietly ( socket ) ; 
task . cancel ( true ) ; 
super . stop ( ) ; 
protected void append ( E event ) { 
if ( event == null || ! isStarted ( ) ) return ; 
final boolean inserted = deque . offer ( event , eventDelayLimit . getMilliseconds ( ) , TimeUnit . MILLISECONDS ) ; 
if ( ! inserted ) { 
} public void connectionFailed ( SocketConnector connector , Exception ex ) { 
if ( ex instanceof InterruptedException ) { 
} else if ( ex instanceof ConnectException ) { 
addInfo ( peerId + ex ) ; 
public int getSeverityForEvent ( Object eventObject ) { 
ILoggingEvent event = ( ILoggingEvent ) eventObject ; 
return LevelToSyslogSeverity . convert ( event ) ; 
} private void handleThrowableFirstLine ( OutputStream sw , IThrowableProxy tp , String stackTracePrefix , boolean isRootException ) throws IOException { 
StringBuilder sb = new StringBuilder ( ) . append ( stackTracePrefix ) ; 
if ( ! isRootException ) { 
sb . append ( CoreConstants . CAUSED_BY ) ; 
sw . write ( sb . toString ( ) . getBytes ( ) ) ; 
sw . flush ( ) ; 
} private Entry < C > getFromEitherMap ( String key ) { 
Entry < C > entry = liveMap . get ( key ) ; 
return lingerersMap . get ( key ) ; 
} public synchronized C find ( String key ) { 
Entry < C > entry = getFromEitherMap ( key ) ; 
if ( entry == null ) return null ; 
else return entry . component ; 
} public synchronized C getOrCreate ( String key , long timestamp ) { 
if ( entry == null ) { 
C c = buildComponent ( key ) ; 
entry = new Entry < C > ( key , c , timestamp ) ; 
liveMap . put ( key , entry ) ; 
entry . setTimestamp ( timestamp ) ; 
return entry . component ; 
} public void endOfLife ( String key ) { 
Entry < C > entry = liveMap . remove ( key ) ; 
lingerersMap . put ( key , entry ) ; 
} public static FormatInfo valueOf ( String str ) throws IllegalArgumentException { 
FormatInfo fi = new FormatInfo ( ) ; 
int indexOfDot = str . indexOf ( '.' ) ; 
String minPart = null ; 
String maxPart = null ; 
if ( indexOfDot != - 1 ) { 
minPart = str . substring ( 0 , indexOfDot ) ; 
if ( indexOfDot + 1 == str . length ( ) ) { 
maxPart = str . substring ( indexOfDot + 1 ) ; 
minPart = str ; 
if ( minPart != null && minPart . length ( ) > 0 ) { 
int min = Integer . parseInt ( minPart ) ; 
if ( min >= 0 ) { 
fi . min = min ; 
fi . min = - min ; 
fi . leftPad = false ; 
if ( maxPart != null && maxPart . length ( ) > 0 ) { 
int max = Integer . parseInt ( maxPart ) ; 
if ( max >= 0 ) { 
fi . max = max ; 
fi . max = - max ; 
fi . leftTruncate = false ; 
return fi ; 
} public void rename ( String src , String target ) throws RolloverFailure { 
if ( src . equals ( target ) ) { 
File srcFile = new File ( src ) ; 
if ( srcFile . exists ( ) ) { 
File targetFile = new File ( target ) ; 
createMissingTargetDirsIfNecessary ( targetFile ) ; 
boolean result = srcFile . renameTo ( targetFile ) ; 
Boolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; 
if ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) { 
renameByCopying ( src , target ) ; 
} Boolean areOnDifferentVolumes ( File srcFile , File targetFile ) throws RolloverFailure { 
if ( ! EnvUtil . isJDK7OrHigher ( ) ) { 
File parentOfTarget = targetFile . getAbsoluteFile ( ) . getParentFile ( ) ; 
if ( parentOfTarget == null ) { 
if ( ! parentOfTarget . exists ( ) ) { 
boolean onSameFileStore = FileStoreUtil . areOnSameFileStore ( srcFile , parentOfTarget ) ; 
return ! onSameFileStore ; 
} catch ( RolloverFailure rf ) { 
} public static String substVars ( String input , PropertyContainer pc0 , PropertyContainer pc1 ) { 
return NodeToStringTransformer . substituteVariable ( input , pc0 , pc1 ) ; 
} catch ( ScanException e ) { 
} public static String getSystemProperty ( String key , String def ) { 
return System . getProperty ( key , def ) ; 
} catch ( SecurityException e ) { 
return def ; 
} public static String getEnv ( String key ) { 
return System . getenv ( key ) ; 
} public static String getAndroidSystemProperty ( String key ) { 
return SystemPropertiesProxy . getInstance ( ) . get ( key , null ) ; 
} public static String getSystemProperty ( String key ) { 
String prop = System . getProperty ( key ) ; 
return ( prop == null ) ? getAndroidSystemProperty ( key ) : prop ; 
} static public String [ ] extractDefaultReplacement ( String key ) { 
String [ ] result = new String [ 2 ] ; 
result [ 0 ] = key ; 
int d = key . indexOf ( DELIM_DEFAULT ) ; 
if ( d != - 1 ) { 
result [ 0 ] = key . substring ( 0 , d ) ; 
result [ 1 ] = key . substring ( d + DELIM_DEFAULT_LEN ) ; 
} public static boolean toBoolean ( String value , boolean defaultValue ) { 
String trimmedVal = value . trim ( ) ; 
if ( "true" . equalsIgnoreCase ( trimmedVal ) ) { 
if ( "false" . equalsIgnoreCase ( trimmedVal ) ) { 
public void reset ( ) { 
resetCount ++ ; 
super . reset ( ) ; 
initEvaluatorMap ( ) ; 
initCollisionMaps ( ) ; 
root . recursiveReset ( ) ; 
resetTurboFilterList ( ) ; 
cancelScheduledTasks ( ) ; 
fireOnReset ( ) ; 
resetListenersExceptResetResistant ( ) ; 
resetStatusListeners ( ) ; 
} public StackTraceElement [ ] getCallerData ( ) { 
if ( callerDataArray == null ) { 
callerDataArray = CallerData . extract ( new Throwable ( ) , fqnOfLoggerClass , 
loggerContext . getMaxCallerDataDepth ( ) , loggerContext . getFrameworkPackages ( ) ) ; 
return callerDataArray ; 
} public void setMDCPropertyMap ( Map < String , String > map ) { 
if ( mdcPropertyMap != null ) { 
this . mdcPropertyMap = map ; 
} private String outputMDCForAllKeys ( Map < String , String > mdcPropertyMap ) { 
for ( Map . Entry < String , String > entry : mdcPropertyMap . entrySet ( ) ) { 
buf . append ( entry . getKey ( ) ) . append ( '=' ) . append ( entry . getValue ( ) ) ; 
} public String getPropertyValue ( ) { 
if ( OptionHelper . isEmpty ( path ) ) { 
File file = new File ( path ) ; 
return booleanAsStr ( file . exists ( ) ) ; 
protected boolean configureClient ( RemoteReceiverClient client ) { 
client . setContext ( getContext ( ) ) ; 
client . setQueue ( new ArrayBlockingQueue < Serializable > ( clientQueueSize ) ) ; 
} public static StackTraceElement [ ] extract ( Throwable t , 
String fqnOfInvokingClass , final int maxDepth , 
List < String > frameworkPackageList ) { 
StackTraceElement [ ] steArray = t . getStackTrace ( ) ; 
StackTraceElement [ ] callerDataArray ; 
int found = LINE_NA ; 
for ( int i = 0 ; i < steArray . length ; i ++ ) { 
if ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , 
fqnOfInvokingClass , frameworkPackageList ) ) { 
found = i + 1 ; 
if ( found != LINE_NA ) { 
if ( found == LINE_NA ) { 
return EMPTY_CALLER_DATA_ARRAY ; 
int availableDepth = steArray . length - found ; 
int desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; 
callerDataArray = new StackTraceElement [ desiredDepth ] ; 
for ( int i = 0 ; i < desiredDepth ; i ++ ) { 
callerDataArray [ i ] = steArray [ found + i ] ; 
} private static boolean isInFrameworkSpaceList ( String currentClass , List < String > frameworkPackageList ) { 
if ( frameworkPackageList == null ) 
for ( String s : frameworkPackageList ) { 
if ( currentClass . startsWith ( s ) ) 
} public void add ( Status newStatus ) { 
fireStatusAddEvent ( newStatus ) ; 
if ( newStatus . getLevel ( ) > level ) { 
level = newStatus . getLevel ( ) ; 
synchronized ( statusListLock ) { 
if ( statusList . size ( ) < MAX_HEADER_COUNT ) { 
statusList . add ( newStatus ) ; 
tailBuffer . add ( newStatus ) ; 
} public boolean add ( StatusListener listener ) { 
synchronized ( statusListenerListLock ) { 
if ( listener instanceof OnConsoleStatusListener ) { 
boolean alreadyPresent = checkForPresence ( statusListenerList , listener . getClass ( ) ) ; 
if ( alreadyPresent ) { 
statusListenerList . add ( listener ) ; 
} List < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , 
InterpretationContext ec ) { 
int len = implicitActions . size ( ) ; 
ImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; 
if ( ia . isApplicable ( elementPath , attributes , ec ) ) { 
List < Action > actionList = new ArrayList < Action > ( 1 ) ; 
actionList . add ( ia ) ; 
return actionList ; 
} List < Action > getApplicableActionList ( ElementPath elementPath , Attributes attributes ) { 
List < Action > applicableActionList = ruleStore . matchActions ( elementPath ) ; 
if ( applicableActionList == null ) { 
applicableActionList = lookupImplicitAction ( elementPath , attributes , 
interpretationContext ) ; 
return applicableActionList ; 
} public void setClassLoader ( ClassLoader cl ) 
throws ClassNotFoundException , SecurityException , NoSuchMethodException { 
if ( cl == null ) cl = this . getClass ( ) . getClassLoader ( ) ; 
SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; 
getString = SystemProperties . getMethod ( "get" , new Class [ ] { String . class , String . class } ) ; 
getBoolean = SystemProperties . getMethod ( "getBoolean" , new Class [ ] { String . class , boolean . class } ) ; 
} public String get ( String key , String def ) 
if ( SystemProperties == null || getString == null ) return null ; 
String ret = null ; 
ret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { key , def } ) ; 
if ( ret == null || ret . length ( ) == 0 ) { 
ret = def ; 
} public Boolean getBoolean ( String key , boolean def ) 
if ( SystemProperties == null || getBoolean == null ) return def ; 
Boolean ret = def ; 
ret = ( Boolean ) getBoolean . invoke ( SystemProperties , new Object [ ] { key , def } ) ; 
} static public String decapitalize ( String name ) { 
if ( name == null || name . length ( ) == 0 ) { 
String nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; 
if ( name . length ( ) > 1 ) { 
nm += name . substring ( 1 ) ; 
return nm ; 
} static public MethodDescriptor [ ] getMethodDescriptors ( Class < ? > clazz ) { 
ArrayList < MethodDescriptor > methods = new ArrayList < MethodDescriptor > ( ) ; 
for ( Method m : clazz . getMethods ( ) ) { 
methods . add ( new MethodDescriptor ( m . getName ( ) , m ) ) ; 
return methods . toArray ( new MethodDescriptor [ 0 ] ) ; 
} static public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { 
final String SETTER_PREFIX = "set" ; 
final String GETTER_PREFIX = "get" ; 
final int LEN_PREFIX = SETTER_PREFIX . length ( ) ; 
Map < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; 
PropertyDescriptor pd = null ; 
String mName = m . getName ( ) ; 
boolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
boolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
if ( isGet || isSet ) { 
String propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; 
pd = map . get ( propName ) ; 
if ( pd == null ) { 
pd = new PropertyDescriptor ( propName ) ; 
map . put ( propName , pd ) ; 
Class < ? > [ ] parmTypes = m . getParameterTypes ( ) ; 
if ( isSet ) { 
if ( parmTypes . length == 1 ) { 
pd . setWriteMethod ( m ) ; 
pd . setPropertyType ( parmTypes [ 0 ] ) ; 
} else if ( isGet ) { 
if ( parmTypes . length == 0 ) { 
pd . setReadMethod ( m ) ; 
if ( pd . getPropertyType ( ) == null ) { 
pd . setPropertyType ( m . getReturnType ( ) ) ; 
return map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; 
} protected boolean shouldStart ( ) { 
if ( port == 0 ) { 
if ( reconnectionDelay == 0 ) { 
reconnectionDelay = AbstractSocketAppender . DEFAULT_RECONNECTION_DELAY ; 
return errorCount == 0 ; 
LoggerContext lc = ( LoggerContext ) getContext ( ) ; 
SocketConnector connector = createConnector ( address , port , 0 , 
reconnectionDelay ) ; 
connectorTask = activateConnector ( connector ) ; 
if ( connectorTask == null ) { 
socket = waitForConnectorToReturnASocket ( ) ; 
if ( socket == null ) 
dispatchEvents ( lc ) ; 
assert true ; 
} public void setTarget ( String value ) { 
ConsoleTarget t = ConsoleTarget . findByName ( value . trim ( ) ) ; 
targetWarn ( value ) ; 
target = t ; 
if ( this . encoder == null ) { 
+ name + "\"." , this ) ) ; 
if ( this . outputStream == null ) { 
addStatus ( new ErrorStatus ( 
} protected void closeOutputStream ( ) { 
if ( this . outputStream != null ) { 
encoderClose ( ) ; 
this . outputStream . close ( ) ; 
this . outputStream = null ; 
} public void setOutputStream ( OutputStream outputStream ) { 
closeOutputStream ( ) ; 
this . outputStream = outputStream ; 
if ( encoder == null ) { 
encoderInit ( ) ; 
} protected void subAppend ( E event ) { 
if ( ! isStarted ( ) ) { 
if ( event instanceof DeferredProcessingAware ) { 
( ( DeferredProcessingAware ) event ) . prepareForDeferredProcessing ( ) ; 
byte [ ] byteArray = this . encoder . encode ( event ) ; 
writeBytes ( byteArray ) ; 
for ( LifeCycle component : components ) { 
if ( component . isStarted ( ) ) { 
component . stop ( ) ; 
components . clear ( ) ; 
} static public void addOnConsoleListenerInstance ( Context context , OnConsoleStatusListener onConsoleStatusListener ) { 
onConsoleStatusListener . setContext ( context ) ; 
boolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; 
if ( effectivelyAdded ) { 
onConsoleStatusListener . start ( ) ; 
} public void end ( InterpretationContext ec , String name ) { 
if ( o != definer ) { 
String propertyValue = definer . getPropertyValue ( ) ; 
if ( propertyValue != null ) { 
ActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; 
String contextName = event . getLoggerContextVO ( ) . getName ( ) ; 
if ( contextName == null ) { 
return contextName ; 
buf . append ( "\\" ) ; 
buf . append ( next ) ; 
} protected boolean isDiscardable ( ILoggingEvent event ) { 
return level . toInt ( ) <= Level . INFO_INT ; 
public void begin ( InterpretationContext ic , String name , Attributes attributes ) throws ActionException { 
hook = null ; 
className = DefaultShutdownHook . class . getName ( ) ; 
hook = ( ShutdownHookBase ) OptionHelper . instantiateByClassName ( className , 
ShutdownHookBase . class , context ) ; 
hook . setContext ( context ) ; 
ic . pushObject ( hook ) ; 
throw new ActionException ( e ) ; 
public void end ( InterpretationContext ic , String name ) throws ActionException { 
Object o = ic . peekObject ( ) ; 
if ( o != hook ) { 
ic . popObject ( ) ; 
context . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; 
Runtime . getRuntime ( ) . addShutdownHook ( hookThread ) ; 
} public KeyManagerFactory createKeyManagerFactory ( ) 
throws NoSuchProviderException , NoSuchAlgorithmException { 
KeyManagerFactory . getInstance ( getAlgorithm ( ) , getProvider ( ) ) 
: KeyManagerFactory . getInstance ( getAlgorithm ( ) ) ; 
} public static void closeQuietly ( Closeable closeable ) { 
if ( closeable == null ) return ; 
closeable . close ( ) ; 
} public static void closeQuietly ( Socket socket ) { 
if ( socket == null ) return ; 
socket . close ( ) ; 
} public static void closeQuietly ( ServerSocket serverSocket ) { 
if ( serverSocket == null ) return ; 
serverSocket . close ( ) ; 
} public void configure ( SSLConfigurable socket ) { 
socket . setEnabledProtocols ( enabledProtocols ( 
socket . getSupportedProtocols ( ) , socket . getDefaultProtocols ( ) ) ) ; 
socket . setEnabledCipherSuites ( enabledCipherSuites ( 
socket . getSupportedCipherSuites ( ) , socket . getDefaultCipherSuites ( ) ) ) ; 
if ( isNeedClientAuth ( ) != null ) { 
socket . setNeedClientAuth ( isNeedClientAuth ( ) ) ; 
if ( isWantClientAuth ( ) != null ) { 
socket . setWantClientAuth ( isWantClientAuth ( ) ) ; 
} private String [ ] enabledProtocols ( String [ ] supportedProtocols , 
String [ ] defaultProtocols ) { 
if ( enabledProtocols == null ) { 
if ( OptionHelper . isEmpty ( getIncludedProtocols ( ) ) 
&& OptionHelper . isEmpty ( getExcludedProtocols ( ) ) ) { 
enabledProtocols = Arrays . copyOf ( defaultProtocols , 
defaultProtocols . length ) ; 
enabledProtocols = includedStrings ( supportedProtocols , 
getIncludedProtocols ( ) , getExcludedProtocols ( ) ) ; 
for ( String protocol : enabledProtocols ) { 
return enabledProtocols ; 
} private String [ ] enabledCipherSuites ( String [ ] supportedCipherSuites , 
String [ ] defaultCipherSuites ) { 
if ( enabledCipherSuites == null ) { 
if ( OptionHelper . isEmpty ( getIncludedCipherSuites ( ) ) 
&& OptionHelper . isEmpty ( getExcludedCipherSuites ( ) ) ) { 
enabledCipherSuites = Arrays . copyOf ( defaultCipherSuites , 
defaultCipherSuites . length ) ; 
enabledCipherSuites = includedStrings ( supportedCipherSuites , 
getIncludedCipherSuites ( ) , getExcludedCipherSuites ( ) ) ; 
for ( String cipherSuite : enabledCipherSuites ) { 
return enabledCipherSuites ; 
} private String [ ] includedStrings ( String [ ] defaults , String included , 
String excluded ) { 
List < String > values = new ArrayList < String > ( defaults . length ) ; 
values . addAll ( Arrays . asList ( defaults ) ) ; 
if ( included != null ) { 
StringCollectionUtil . retainMatching ( values , stringToArray ( included ) ) ; 
if ( excluded != null ) { 
StringCollectionUtil . removeMatching ( values , stringToArray ( excluded ) ) ; 
return values . toArray ( new String [ values . size ( ) ] ) ; 
} public < E > LinkedBlockingDeque < E > newLinkedBlockingDeque ( int capacity ) { 
final int actualCapacity = capacity < 1 ? 1 : capacity ; 
return new LinkedBlockingDeque < E > ( actualCapacity ) ; 
} static public Scope stringToScope ( String scopeStr ) { 
if ( Scope . SYSTEM . toString ( ) . equalsIgnoreCase ( scopeStr ) ) 
return Scope . SYSTEM ; 
if ( Scope . CONTEXT . toString ( ) . equalsIgnoreCase ( scopeStr ) ) 
return Scope . CONTEXT ; 
return Scope . LOCAL ; 
} static public void setProperties ( InterpretationContext ic , Properties props , 
Scope scope ) { 
switch ( scope ) { 
case LOCAL : 
ic . addSubstitutionProperties ( props ) ; 
case CONTEXT : 
ContextUtil cu = new ContextUtil ( ic . getContext ( ) ) ; 
cu . addProperties ( props ) ; 
case SYSTEM : 
OptionHelper . setSystemProperties ( ic , props ) ; 
} public void addAppender ( Appender < E > newAppender ) { 
if ( newAppender == null ) { 
appenderList . addIfAbsent ( newAppender ) ; 
} public int appendLoopOnAppenders ( E e ) { 
final Appender < E > [ ] appenderArray = appenderList . asTypedArray ( ) ; 
final int len = appenderArray . length ; 
appenderArray [ i ] . doAppend ( e ) ; 
} public boolean isAttached ( Appender < E > appender ) { 
if ( appender == null ) { 
for ( Appender < E > a : appenderList ) { 
if ( a == appender ) return true ; 
} public boolean detachAppender ( Appender < E > appender ) { 
result = appenderList . remove ( appender ) ; 
} public boolean detachAppender ( String name ) { 
if ( name . equals ( ( a ) . getName ( ) ) ) { 
removed = appenderList . remove ( a ) ; 
} private synchronized void handleParentLevelChange ( int newParentLevelInt ) { 
if ( level == null ) { 
effectiveLevelInt = newParentLevelInt ; 
if ( childrenList != null ) { 
int len = childrenList . size ( ) ; 
Logger child = ( Logger ) childrenList . get ( i ) ; 
child . handleParentLevelChange ( newParentLevelInt ) ; 
} public synchronized void addAppender ( Appender < ILoggingEvent > newAppender ) { 
if ( aai == null ) { 
aai = new AppenderAttachableImpl < ILoggingEvent > ( ) ; 
aai . addAppender ( newAppender ) ; 
} public void callAppenders ( ILoggingEvent event ) { 
int writes = 0 ; 
for ( Logger l = this ; l != null ; l = l . parent ) { 
writes += l . appendLoopOnAppenders ( event ) ; 
if ( ! l . additive ) { 
if ( writes == 0 ) { 
loggerContext . noAppenderDefinedWarning ( this ) ; 
} public boolean detachAppender ( Appender < ILoggingEvent > appender ) { 
return aai . detachAppender ( appender ) ; 
} Logger createChildByLastNamePart ( final String lastPart ) { 
int i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; 
if ( i_index != - 1 ) { 
if ( childrenList == null ) { 
childrenList = new CopyOnWriteArrayList < Logger > ( ) ; 
Logger childLogger ; 
if ( this . isRootLogger ( ) ) { 
childLogger = new Logger ( lastPart , this , this . loggerContext ) ; 
childLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , 
this . loggerContext ) ; 
childrenList . add ( childLogger ) ; 
childLogger . effectiveLevelInt = this . effectiveLevelInt ; 
return childLogger ; 
} private void filterAndLog_0_Or3Plus ( final String localFQCN , 
final Marker marker , final Level level , final String msg , 
final Object [ ] params , final Throwable t ) { 
final FilterReply decision = loggerContext 
. getTurboFilterChainDecision_0_3OrMore ( marker , this , level , msg , 
params , t ) ; 
if ( decision == FilterReply . NEUTRAL ) { 
if ( effectiveLevelInt > level . levelInt ) { 
} else if ( decision == FilterReply . DENY ) { 
buildLoggingEventAndAppend ( localFQCN , marker , level , msg , params , t ) ; 
} private FilterReply callTurboFilters ( Marker marker , Level level ) { 
return loggerContext . getTurboFilterChainDecision_0_3OrMore ( marker , this , 
level , null , null , null ) ; 
} public void log ( org . slf4j . event . LoggingEvent slf4jEvent ) { 
Level level = Level . fromLocationAwareLoggerInteger ( slf4jEvent . getLevel ( ) . toInt ( ) ) ; 
filterAndLog_0_Or3Plus ( FQCN , slf4jEvent . getMarker ( ) , level , slf4jEvent . getMessage ( ) , slf4jEvent . getArgumentArray ( ) , slf4jEvent . getThrowable ( ) ) ; 
} public Socket call ( ) throws InterruptedException { 
useDefaultsForMissingFields ( ) ; 
Socket socket = createSocket ( ) ; 
while ( socket == null && ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
Thread . sleep ( delayStrategy . nextDelay ( ) ) ; 
socket = createSocket ( ) ; 
} static public boolean createMissingParentDirectories ( File file ) { 
parent . mkdirs ( ) ; 
return parent . exists ( ) ; 
} public static String prefixRelativePath ( String prefix , String path ) { 
if ( prefix != null && ! OptionHelper . isEmpty ( prefix . trim ( ) ) && ! new File ( path ) . isAbsolute ( ) ) { 
path = prefix + "/" + path ; 
} public Integer toInteger ( ) { 
switch ( levelInt ) { 
case ALL_INT : 
return ALL_INTEGER ; 
case TRACE_INT : 
return TRACE_INTEGER ; 
case DEBUG_INT : 
return DEBUG_INTEGER ; 
case INFO_INT : 
return INFO_INTEGER ; 
case WARN_INT : 
return WARN_INTEGER ; 
case ERROR_INT : 
return ERROR_INTEGER ; 
case OFF_INT : 
return OFF_INTEGER ; 
} public static Level toLevel ( int val , Level defaultLevel ) { 
switch ( val ) { 
return ALL ; 
return TRACE ; 
return DEBUG ; 
return INFO ; 
return WARN ; 
return ERROR ; 
return OFF ; 
return defaultLevel ; 
} public static Level toLevel ( final String sArg , Level defaultLevel ) { 
if ( sArg == null ) { 
final String in = sArg . trim ( ) ; 
if ( in . equalsIgnoreCase ( "ALL" ) ) { 
return Level . ALL ; 
if ( in . equalsIgnoreCase ( "TRACE" ) ) { 
return Level . TRACE ; 
if ( in . equalsIgnoreCase ( "DEBUG" ) ) { 
return Level . DEBUG ; 
if ( in . equalsIgnoreCase ( "INFO" ) ) { 
return Level . INFO ; 
if ( in . equalsIgnoreCase ( "WARN" ) ) { 
return Level . WARN ; 
if ( in . equalsIgnoreCase ( "ERROR" ) ) { 
return Level . ERROR ; 
if ( in . equalsIgnoreCase ( "OFF" ) ) { 
return Level . OFF ; 
} public static Level fromLocationAwareLoggerInteger ( int levelInt ) { 
Level level ; 
case LocationAwareLogger . TRACE_INT : 
level = TRACE ; 
case LocationAwareLogger . DEBUG_INT : 
level = DEBUG ; 
case LocationAwareLogger . INFO_INT : 
level = INFO ; 
case LocationAwareLogger . WARN_INT : 
level = WARN ; 
case LocationAwareLogger . ERROR_INT : 
level = ERROR ; 
} public static int toLocationAwareLoggerInteger ( Level level ) { 
if ( level == null ) 
switch ( level . toInt ( ) ) { 
return LocationAwareLogger . TRACE_INT ; 
return LocationAwareLogger . DEBUG_INT ; 
return LocationAwareLogger . INFO_INT ; 
return LocationAwareLogger . WARN_INT ; 
return LocationAwareLogger . ERROR_INT ; 
} static public boolean notMarkedWithNoAutoStart ( Object o ) { 
Class < ? > clazz = o . getClass ( ) ; 
NoAutoStart a = clazz . getAnnotation ( NoAutoStart . class ) ; 
return a == null ; 
} public KeyStore createKeyStore ( ) throws NoSuchProviderException , 
NoSuchAlgorithmException , KeyStoreException { 
if ( getLocation ( ) == null ) { 
InputStream inputStream = null ; 
URL url = LocationUtil . urlForResource ( getLocation ( ) ) ; 
inputStream = url . openStream ( ) ; 
KeyStore keyStore = newKeyStore ( ) ; 
keyStore . load ( inputStream , getPassword ( ) . toCharArray ( ) ) ; 
+ getType ( ) ) ; 
catch ( FileNotFoundException ex ) { 
if ( inputStream != null ) { 
inputStream . close ( ) ; 
ex . printStackTrace ( System . err ) ; 
} private KeyStore newKeyStore ( ) throws NoSuchAlgorithmException , 
NoSuchProviderException , KeyStoreException { 
KeyStore . getInstance ( getType ( ) , getProvider ( ) ) 
: KeyStore . getInstance ( getType ( ) ) ; 
} public static Set < URL > getResourceOccurrenceCount ( String resource , 
ClassLoader classLoader ) throws IOException { 
Set < URL > urlSet = new HashSet < URL > ( ) ; 
Enumeration < URL > urlEnum = classLoader . getResources ( resource ) ; 
while ( urlEnum . hasMoreElements ( ) ) { 
URL url = urlEnum . nextElement ( ) ; 
urlSet . add ( url ) ; 
return urlSet ; 
} public static URL getResource ( String resource , ClassLoader classLoader ) { 
return classLoader . getResource ( resource ) ; 
} public static ClassLoader getClassLoaderOfObject ( Object o ) { 
return getClassLoaderOfClass ( o . getClass ( ) ) ; 
} public static ClassLoader getClassLoaderAsPrivileged ( final Class < ? > clazz ) { 
if ( ! HAS_GET_CLASS_LOADER_PERMISSION ) 
return AccessController . doPrivileged ( 
new PrivilegedAction < ClassLoader > ( ) { 
public ClassLoader run ( ) { 
return clazz . getClassLoader ( ) ; 
} public static ClassLoader getClassLoaderOfClass ( final Class < ? > clazz ) { 
ClassLoader cl = clazz . getClassLoader ( ) ; 
if ( cl == null ) { 
return ClassLoader . getSystemClassLoader ( ) ; 
return cl ; 
} public static Class < ? > loadClass ( String clazz ) throws ClassNotFoundException { 
if ( ignoreTCL ) { 
return Class . forName ( clazz ) ; 
return getTCL ( ) . loadClass ( clazz ) ; 
public void start ( ) { 
if ( ( this . encoder == null ) || ( this . encoder . getLayout ( ) == null ) ) { 
if ( this . tagEncoder != null ) { 
final Layout < ? > layout = this . tagEncoder . getLayout ( ) ; 
if ( layout == null ) { 
if ( layout instanceof PatternLayout ) { 
String pattern = this . tagEncoder . getPattern ( ) ; 
if ( ! pattern . contains ( "%nopex" ) ) { 
this . tagEncoder . stop ( ) ; 
this . tagEncoder . setPattern ( pattern + "%nopex" ) ; 
this . tagEncoder . start ( ) ; 
PatternLayout tagLayout = ( PatternLayout ) layout ; 
tagLayout . setPostCompileProcessor ( null ) ; 
} public void append ( ILoggingEvent event ) { 
String tag = getTag ( event ) ; 
switch ( event . getLevel ( ) . levelInt ) { 
case Level . ALL_INT : 
if ( ! checkLoggable || Log . isLoggable ( tag , Log . VERBOSE ) ) { 
Log . v ( tag , this . encoder . getLayout ( ) . doLayout ( event ) ) ; 
if ( ! checkLoggable || Log . isLoggable ( tag , Log . DEBUG ) ) { 
Log . d ( tag , this . encoder . getLayout ( ) . doLayout ( event ) ) ; 
if ( ! checkLoggable || Log . isLoggable ( tag , Log . INFO ) ) { 
Log . i ( tag , this . encoder . getLayout ( ) . doLayout ( event ) ) ; 
if ( ! checkLoggable || Log . isLoggable ( tag , Log . WARN ) ) { 
Log . w ( tag , this . encoder . getLayout ( ) . doLayout ( event ) ) ; 
if ( ! checkLoggable || Log . isLoggable ( tag , Log . ERROR ) ) { 
Log . e ( tag , this . encoder . getLayout ( ) . doLayout ( event ) ) ; 
case Level . OFF_INT : 
} protected String getTag ( ILoggingEvent event ) { 
String tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; 
if ( checkLoggable && ( tag . length ( ) > MAX_TAG_LENGTH ) ) { 
tag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + "*" ; 
return tag ; 
} public void setLoggerContext ( LoggerContext lc ) { 
this . lc = lc ; 
this . logger = lc . getLogger ( getClass ( ) . getPackage ( ) . getName ( ) ) ; 
HardenedObjectInputStream ois = null ; 
ois = createObjectInputStream ( ) ; 
ILoggingEvent event = ( ILoggingEvent ) ois . readObject ( ) ; 
Logger remoteLogger = lc . getLogger ( event . getLoggerName ( ) ) ; 
if ( remoteLogger . isEnabledFor ( event . getLevel ( ) ) ) { 
remoteLogger . callAppenders ( event ) ; 
catch ( EOFException ex ) { 
catch ( ClassNotFoundException ex ) { 
if ( ois != null ) { 
CloseUtil . closeQuietly ( ois ) ; 
} public void begin ( InterpretationContext ec , String localName , 
Attributes attributes ) { 
if ( "substitutionProperty" . equals ( localName ) ) { 
String name = attributes . getValue ( NAME_ATTRIBUTE ) ; 
String value = attributes . getValue ( VALUE_ATTRIBUTE ) ; 
String scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; 
Scope scope = ActionUtil . stringToScope ( scopeStr ) ; 
if ( checkFileAttributeSanity ( attributes ) ) { 
String file = attributes . getValue ( FILE_ATTRIBUTE ) ; 
file = ec . subst ( file ) ; 
FileInputStream istream = new FileInputStream ( file ) ; 
loadAndSetProperties ( ec , istream , scope ) ; 
} else if ( checkResourceAttributeSanity ( attributes ) ) { 
String resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; 
resource = ec . subst ( resource ) ; 
URL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; 
if ( resourceURL == null ) { 
InputStream istream = resourceURL . openStream ( ) ; 
} else if ( checkValueNameAttributesSanity ( attributes ) ) { 
value = RegularEscapeUtil . basicEscape ( value ) ; 
value = ec . subst ( value ) ; 
ActionUtil . setProperty ( ec , name , value , scope ) ; 
addError ( INVALID_ATTRIBUTES ) ; 
} public static int getSeparatorIndexOf ( String name , int fromIndex ) { 
int dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; 
int dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; 
if ( dotIndex == - 1 && dollarIndex == - 1 ) return - 1 ; 
if ( dotIndex == - 1 ) return dollarIndex ; 
if ( dollarIndex == - 1 ) return dotIndex ; 
return dotIndex < dollarIndex ? dotIndex : dollarIndex ; 
Marker eventsMarker = event . getMarker ( ) ; 
if ( eventsMarker == null ) { 
for ( String markerStr : markerList ) { 
if ( eventsMarker . contains ( markerStr ) ) { 
} public TrustManagerFactory createTrustManagerFactory ( ) 
TrustManagerFactory . getInstance ( getAlgorithm ( ) , getProvider ( ) ) 
: TrustManagerFactory . getInstance ( getAlgorithm ( ) ) ; 
} protected String getClientThreadName ( Socket socket ) { 
} static public boolean areOnSameFileStore ( File a , File b ) throws RolloverFailure { 
if ( ! a . exists ( ) ) { 
if ( ! b . exists ( ) ) { 
Class < ? > pathClass = Class . forName ( PATH_CLASS_STR ) ; 
Class < ? > filesClass = Class . forName ( FILES_CLASS_STR ) ; 
Method toPath = File . class . getMethod ( "toPath" ) ; 
Method getFileStoreMethod = filesClass . getMethod ( "getFileStore" , pathClass ) ; 
Object pathA = toPath . invoke ( a ) ; 
Object pathB = toPath . invoke ( b ) ; 
Object fileStoreA = getFileStoreMethod . invoke ( null , pathA ) ; 
Object fileStoreB = getFileStoreMethod . invoke ( null , pathB ) ; 
return fileStoreA . equals ( fileStoreB ) ; 
if ( cbTracker == null ) { 
cbTracker = new CyclicBufferTracker < E > ( ) ; 
session = buildSessionFromProperties ( ) ; 
if ( session == null ) { 
subjectLayout = makeSubjectLayout ( subjectStr ) ; 
started = true ; 
} protected void append ( E eventObject ) { 
if ( ! checkEntryConditions ( ) ) { 
String key = discriminator . getDiscriminatingValue ( eventObject ) ; 
final CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; 
subAppend ( cb , eventObject ) ; 
if ( eventEvaluator . evaluate ( eventObject ) ) { 
CyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; 
cb . clear ( ) ; 
if ( asynchronousSending ) { 
SenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; 
context . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; 
sendBuffer ( cbClone , eventObject ) ; 
} catch ( EvaluationException ex ) { 
if ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { 
if ( eventMarksEndOfLife ( eventObject ) ) { 
cbTracker . endOfLife ( key ) ; 
cbTracker . removeStaleComponents ( now ) ; 
if ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { 
lastTrackerStatusPrint = now ; 
if ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { 
delayBetweenStatusMessages *= 4 ; 
} public boolean checkEntryConditions ( ) { 
+ this . getName ( ) ) ; 
if ( this . eventEvaluator == null ) { 
if ( this . layout == null ) { 
} protected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { 
MimeBodyPart part = new MimeBodyPart ( ) ; 
StringBuffer sbuf = new StringBuffer ( ) ; 
String header = layout . getFileHeader ( ) ; 
sbuf . append ( header ) ; 
String presentationHeader = layout . getPresentationHeader ( ) ; 
if ( presentationHeader != null ) { 
sbuf . append ( presentationHeader ) ; 
fillBuffer ( cb , sbuf ) ; 
String presentationFooter = layout . getPresentationFooter ( ) ; 
if ( presentationFooter != null ) { 
sbuf . append ( presentationFooter ) ; 
String footer = layout . getFileFooter ( ) ; 
if ( footer != null ) { 
sbuf . append ( footer ) ; 
if ( subjectLayout != null ) { 
subjectStr = subjectLayout . doLayout ( lastEventObject ) ; 
int newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\n' ) : - 1 ; 
if ( newLinePos > - 1 ) { 
subjectStr = subjectStr . substring ( 0 , newLinePos ) ; 
MimeMessage mimeMsg = new MimeMessage ( session ) ; 
mimeMsg . setFrom ( getAddress ( from ) ) ; 
mimeMsg . setFrom ( ) ; 
mimeMsg . setSubject ( subjectStr , charsetEncoding ) ; 
List < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; 
if ( destinationAddresses . isEmpty ( ) ) { 
InternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; 
mimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; 
String contentType = layout . getContentType ( ) ; 
if ( ContentTypeUtil . isTextual ( contentType ) ) { 
part . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil 
. getSubType ( contentType ) ) ; 
part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; 
Multipart mp = new MimeMultipart ( ) ; 
mp . addBodyPart ( part ) ; 
mimeMsg . setContent ( mp ) ; 
updateMimeMsg ( mimeMsg , cb , lastEventObject ) ; 
mimeMsg . setSentDate ( new Date ( ) ) ; 
Transport . send ( mimeMsg ) ; 
hardenedLoggingEventInputStream = new HardenedLoggingEventInputStream ( new BufferedInputStream ( socket . getInputStream ( ) ) ) ; 
ILoggingEvent event ; 
Logger remoteLogger ; 
while ( ! closed ) { 
event = ( ILoggingEvent ) hardenedLoggingEventInputStream . readObject ( ) ; 
remoteLogger = context . getLogger ( event . getLoggerName ( ) ) ; 
} catch ( java . io . EOFException e ) { 
socketServer . socketNodeClosing ( this ) ; 
} public void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { 
if ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) { 
valueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair 
. getLevel ( ) ) ; 
public FilterReply decide ( Marker marker , Logger logger , Level level , 
String s , Object [ ] objects , Throwable throwable ) { 
String mdcValue = MDC . get ( this . key ) ; 
Level levelAssociatedWithMDCValue = null ; 
if ( mdcValue != null ) { 
levelAssociatedWithMDCValue = valueLevelMap . get ( mdcValue ) ; 
if ( levelAssociatedWithMDCValue == null ) { 
levelAssociatedWithMDCValue = defaultThreshold ; 
if ( level . isGreaterOrEqual ( levelAssociatedWithMDCValue ) ) { 
return onHigherOrEqual ; 
return onLower ; 
DynamicConverter < E > createConverter ( SimpleKeywordNode kn ) { 
String keyword = ( String ) kn . getValue ( ) ; 
String converterClassStr = ( String ) converterMap . get ( keyword ) ; 
if ( converterClassStr != null ) { 
return ( DynamicConverter < E > ) OptionHelper . instantiateByClassName ( 
converterClassStr , DynamicConverter . class , context ) ; 
+ keyword + "]" ) ; 
CompositeConverter < E > createCompositeConverter ( CompositeNode cn ) { 
String keyword = ( String ) cn . getValue ( ) ; 
return ( CompositeConverter < E > ) OptionHelper . instantiateByClassName ( 
converterClassStr , CompositeConverter . class , context ) ; 
} protected void determineCompressionMode ( ) { 
if ( fileNamePatternStr . endsWith ( ".gz" ) ) { 
compressionMode = CompressionMode . GZ ; 
} else if ( fileNamePatternStr . endsWith ( ".zip" ) ) { 
compressionMode = CompressionMode . ZIP ; 
compressionMode = CompressionMode . NONE ; 
} public final void doConfigure ( URL url ) throws JoranException { 
InputStream in = null ; 
informContextOfURLUsedForConfiguration ( getContext ( ) , url ) ; 
URLConnection urlConnection = url . openConnection ( ) ; 
urlConnection . setUseCaches ( false ) ; 
in = urlConnection . getInputStream ( ) ; 
doConfigure ( in , url . toExternalForm ( ) ) ; 
addError ( errMsg , ioe ) ; 
throw new JoranException ( errMsg , ioe ) ; 
CloseUtil . closeQuietly ( in ) ; 
} public final void doConfigure ( File file ) throws JoranException { 
FileInputStream fis = null ; 
URL url = file . toURI ( ) . toURL ( ) ; 
fis = new FileInputStream ( file ) ; 
doConfigure ( fis , url . toExternalForm ( ) ) ; 
CloseUtil . closeQuietly ( fis ) ; 
} public final void doConfigure ( InputStream inputStream ) throws JoranException { 
doConfigure ( new InputSource ( inputStream ) ) ; 
} protected void buildInterpreter ( ) { 
RuleStore rs = new SimpleRuleStore ( context ) ; 
addInstanceRules ( rs ) ; 
this . interpreter = new Interpreter ( context , rs , initialElementPath ( ) ) ; 
InterpretationContext interpretationContext = interpreter . getInterpretationContext ( ) ; 
interpretationContext . setContext ( context ) ; 
addImplicitRules ( interpreter ) ; 
addDefaultNestedComponentRegistryRules ( interpretationContext . getDefaultNestedComponentRegistry ( ) ) ; 
} private final void doConfigure ( final InputSource inputSource ) 
throws JoranException { 
long threshold = System . currentTimeMillis ( ) ; 
SaxEventRecorder recorder = new SaxEventRecorder ( context ) ; 
recorder . recordEvents ( inputSource ) ; 
doConfigure ( recorder . getSaxEventList ( ) ) ; 
if ( statusUtil . noXMLParsingErrorsOccurred ( threshold ) ) { 
registerSafeConfiguration ( recorder . getSaxEventList ( ) ) ; 
} public void doConfigure ( final List < SaxEvent > eventList ) 
buildInterpreter ( ) ; 
synchronized ( context . getConfigurationLock ( ) ) { 
interpreter . getEventPlayer ( ) . play ( eventList ) ; 
if ( CONTEXT_NAME_KEY . equals ( key ) ) 
return getName ( ) ; 
return ( String ) this . propertyMap . get ( key ) ; 
} public void setName ( String name ) throws IllegalStateException { 
if ( name != null && name . equals ( this . name ) ) { 
if ( this . name == null 
|| CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) { 
this . name = name ; 
} static public boolean contextHasStatusListener ( Context context ) { 
if ( sm == null ) 
List < StatusListener > listeners = sm . getCopyOfStatusListenerList ( ) ; 
if ( listeners == null || listeners . size ( ) == 0 ) 
} public long timeOfLastReset ( ) { 
List < Status > statusList = sm . getCopyOfStatusList ( ) ; 
if ( statusList == null ) 
int len = statusList . size ( ) ; 
for ( int i = len - 1 ; i >= 0 ; i -- ) { 
Status s = statusList . get ( i ) ; 
if ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { 
return s . getDate ( ) ; 
} public void add ( E event ) { 
ea [ last ] = event ; 
if ( ++ last == maxSize ) 
if ( numElems < maxSize ) 
numElems ++ ; 
else if ( ++ first == maxSize ) 
first = 0 ; 
} public E get ( int i ) { 
if ( i < 0 || i >= numElems ) 
return ea [ ( first + i ) % maxSize ] ; 
} public E get ( ) { 
E r = null ; 
if ( numElems > 0 ) { 
numElems -- ; 
r = ea [ first ] ; 
ea [ first ] = null ; 
if ( ++ first == maxSize ) 
public void resize ( int newSize ) { 
if ( newSize < 0 ) { 
if ( newSize == numElems ) 
E [ ] temp = ( E [ ] ) new Object [ newSize ] ; 
int loopLen = newSize < numElems ? newSize : numElems ; 
for ( int i = 0 ; i < loopLen ; i ++ ) { 
temp [ i ] = ea [ first ] ; 
if ( ++ first == numElems ) 
ea = temp ; 
numElems = loopLen ; 
maxSize = newSize ; 
if ( loopLen == newSize ) { 
last = loopLen ; 
protected RemoteReceiverClient createClient ( String id , Socket socket ) 
return new RemoteReceiverStreamClient ( id , socket ) ; 
public Socket createSocket ( InetAddress address , int port , 
InetAddress localAddress , int localPort ) throws IOException { 
SSLSocket socket = ( SSLSocket ) delegate . createSocket ( address , port , 
localAddress , localPort ) ; 
parameters . configure ( new SSLConfigurableSocket ( socket ) ) ; 
public Socket createSocket ( InetAddress host , int port ) throws IOException { 
SSLSocket socket = ( SSLSocket ) delegate . createSocket ( host , port ) ; 
} public static ConfigurationWatchList getConfigurationWatchList ( Context context ) { 
if ( context == null ) return null ; 
return ( ConfigurationWatchList ) context . getObject ( CoreConstants . CONFIGURATION_WATCH_LIST ) ; 
Parser < E > p = new Parser < E > ( pattern ) ; 
p . setContext ( getContext ( ) ) ; 
Node t = p . parse ( ) ; 
this . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; 
ConverterUtil . startConverters ( this . head ) ; 
} catch ( ScanException ex ) { 
super . started = true ; 
} public Map < String , String > getEffectiveConverterMap ( ) { 
Map < String , String > effectiveMap = new HashMap < String , String > ( ) ; 
Map < String , String > defaultMap = getDefaultConverterMap ( ) ; 
if ( defaultMap != null ) { 
effectiveMap . putAll ( defaultMap ) ; 
Context context = getContext ( ) ; 
if ( context != null ) { 
Map < String , String > contextMap = ( Map < String , String > ) context 
. getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; 
if ( contextMap != null ) { 
effectiveMap . putAll ( contextMap ) ; 
return effectiveMap ; 
public String getFileHeader ( ) { 
StringBuilder sbuf = new StringBuilder ( ) ; 
sbuf . append ( LINE_SEPARATOR ) ; 
sbuf . append ( "<html>" ) ; 
sbuf . append ( title ) ; 
sbuf . append ( "</title>" ) ; 
cssBuilder . addCss ( sbuf ) ; 
sbuf . append ( "<body>" ) ; 
return sbuf . toString ( ) ; 
public String getFileFooter ( ) { 
sbuf . append ( "</body></html>" ) ; 
public void begin ( InterpretationContext ec , String localName , 
Attributes attributes ) throws ActionException { 
appender = null ; 
warnDeprecated ( className ) ; 
appender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , 
ch . qos . logback . core . Appender . class , context ) ; 
appender . setContext ( context ) ; 
String appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; 
if ( OptionHelper . isEmpty ( appenderName ) ) { 
+ "]." ) ; 
appender . setName ( appenderName ) ; 
HashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( 
ActionConst . APPENDER_BAG ) ; 
appenderBag . put ( appenderName , appender ) ; 
ec . pushObject ( appender ) ; 
oops ) ; 
throw new ActionException ( oops ) ; 
if ( appender instanceof LifeCycle ) { 
( ( LifeCycle ) appender ) . start ( ) ; 
if ( o != appender ) { 
final public boolean isTooSoon ( long currentTime ) { 
boolean maskMatch = ( ( invocationCounter ++ ) & mask ) == mask ; 
if ( maskMatch ) { 
if ( currentTime < this . lowerLimitForMaskMatch ) { 
increaseMask ( ) ; 
updateLimits ( currentTime ) ; 
if ( currentTime > this . upperLimitForNoMaskMatch ) { 
decreaseMask ( ) ; 
return ! maskMatch ; 
} public void stop ( ) throws IOException { 
listener . close ( ) ; 
accept ( new ClientVisitor < T > ( ) { 
public void visit ( T client ) { 
client . close ( ) ; 
} public void accept ( ClientVisitor < T > visitor ) { 
Collection < T > clients = copyClients ( ) ; 
for ( T client : clients ) { 
visitor . visit ( client ) ; 
} private Collection < T > copyClients ( ) { 
clientsLock . lock ( ) ; 
Collection < T > copy = new ArrayList < T > ( clients ) ; 
clientsLock . unlock ( ) ; 
setRunning ( true ) ; 
T client = listener . acceptClient ( ) ; 
if ( ! configureClient ( client ) ) { 
executor . execute ( new ClientWrapper ( client ) ) ; 
catch ( RejectedExecutionException ex ) { 
setRunning ( false ) ; 
} private void addClient ( T client ) { 
clients . add ( client ) ; 
} private void removeClient ( T client ) { 
clients . remove ( client ) ; 
} public void put ( String key , String val ) throws IllegalArgumentException { 
Map < String , String > oldMap = copyOnThreadLocal . get ( ) ; 
Integer lastOp = getAndSetLastOperation ( WRITE_OPERATION ) ; 
if ( wasLastOpReadOrNull ( lastOp ) || oldMap == null ) { 
Map < String , String > newMap = duplicateAndInsertNewMap ( oldMap ) ; 
newMap . put ( key , val ) ; 
oldMap . put ( key , val ) ; 
} public void remove ( String key ) { 
if ( oldMap == null ) return ; 
if ( wasLastOpReadOrNull ( lastOp ) ) { 
newMap . remove ( key ) ; 
oldMap . remove ( key ) ; 
} public String get ( String key ) { 
final Map < String , String > map = copyOnThreadLocal . get ( ) ; 
if ( ( map != null ) && ( key != null ) ) { 
return map . get ( key ) ; 
} public Set < String > getKeys ( ) { 
Map < String , String > map = getPropertyMap ( ) ; 
if ( map != null ) { 
return map . keySet ( ) ; 
} public Map < String , String > getCopyOfContextMap ( ) { 
Map < String , String > hashMap = copyOnThreadLocal . get ( ) ; 
if ( hashMap == null ) { 
return new HashMap < String , String > ( hashMap ) ; 
public static Object convertArg ( ContextAware ca , String val , Class < ? > type ) { 
String v = val . trim ( ) ; 
if ( String . class . isAssignableFrom ( type ) ) { 
} else if ( Integer . TYPE . isAssignableFrom ( type ) ) { 
return Integer . valueOf ( v ) ; 
} else if ( Long . TYPE . isAssignableFrom ( type ) ) { 
return Long . valueOf ( v ) ; 
} else if ( Float . TYPE . isAssignableFrom ( type ) ) { 
return Float . valueOf ( v ) ; 
} else if ( Double . TYPE . isAssignableFrom ( type ) ) { 
return Double . valueOf ( v ) ; 
} else if ( Boolean . TYPE . isAssignableFrom ( type ) ) { 
if ( "true" . equalsIgnoreCase ( v ) ) { 
} else if ( "false" . equalsIgnoreCase ( v ) ) { 
return Boolean . FALSE ; 
} else if ( type . isEnum ( ) ) { 
return convertToEnum ( ca , v , ( Class < ? extends Enum < ? > > ) type ) ; 
} else if ( StringToObjectConverter . followsTheValueOfConvention ( type ) ) { 
return convertByValueOfMethod ( ca , type , v ) ; 
} else if ( isOfTypeCharset ( type ) ) { 
return convertToCharset ( ca , val ) ; 
} public static Method getValueOfMethod ( Class < ? > type ) { 
return type . getMethod ( CoreConstants . VALUE_OF , STING_CLASS_PARAMETER ) ; 
} public FilterReply getTurboFilterChainDecision ( final Marker marker , 
final Logger logger , final Level level , final String format , 
final int size = size ( ) ; 
if ( size == 1 ) { 
TurboFilter tf = get ( 0 ) ; 
return tf . decide ( marker , logger , level , format , params , t ) ; 
} catch ( IndexOutOfBoundsException iobe ) { 
Object [ ] tfa = toArray ( ) ; 
final int len = tfa . length ; 
final TurboFilter tf = ( TurboFilter ) tfa [ i ] ; 
final FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; 
protected RemoteAppenderClient createClient ( String id , Socket socket ) 
return new RemoteAppenderStreamClient ( id , socket ) ; 
} public void addRule ( ElementSelector elementSelector , Action action ) { 
action . setContext ( context ) ; 
List < Action > a4p = rules . get ( elementSelector ) ; 
if ( a4p == null ) { 
a4p = new ArrayList < Action > ( ) ; 
rules . put ( elementSelector , a4p ) ; 
a4p . add ( action ) ; 
} public List < Action > matchActions ( ElementPath elementPath ) { 
List < Action > actionList ; 
if ( ( actionList = fullPathMatch ( elementPath ) ) != null ) { 
} else if ( ( actionList = suffixMatch ( elementPath ) ) != null ) { 
} else if ( ( actionList = prefixMatch ( elementPath ) ) != null ) { 
} else if ( ( actionList = middleMatch ( elementPath ) ) != null ) { 
} List < Action > suffixMatch ( ElementPath elementPath ) { 
ElementSelector longestMatchingElementSelector = null ; 
for ( ElementSelector selector : rules . keySet ( ) ) { 
if ( isSuffixPattern ( selector ) ) { 
int r = selector . getTailMatchLength ( elementPath ) ; 
if ( r > max ) { 
max = r ; 
longestMatchingElementSelector = selector ; 
if ( longestMatchingElementSelector != null ) { 
return rules . get ( longestMatchingElementSelector ) ; 
} static public boolean isAndroidOS ( ) { 
String osname = OptionHelper . getSystemProperty ( "os.name" ) ; 
String root = OptionHelper . getEnv ( "ANDROID_ROOT" ) ; 
String data = OptionHelper . getEnv ( "ANDROID_DATA" ) ; 
return osname != null && osname . contains ( "Linux" ) && 
root != null && root . contains ( "/system" ) && 
data != null && data . contains ( "/data" ) ; 
} void init ( ) { 
new ContextInitializer ( defaultLoggerContext ) . autoConfig ( ) ; 
} catch ( JoranException je ) { 
if ( ! StatusUtil . contextHasStatusListener ( defaultLoggerContext ) ) { 
StatusPrinter . printInCaseOfErrorsOrWarnings ( defaultLoggerContext ) ; 
contextSelectorBinder . init ( defaultLoggerContext , KEY ) ; 
+ "]" , t ) ; 
} public static File [ ] filesInFolderMatchingStemRegex ( File file , 
final String stemRegex ) { 
return new File [ 0 ] ; 
if ( ! file . exists ( ) || ! file . isDirectory ( ) ) { 
return file . listFiles ( new FilenameFilter ( ) { 
return name . matches ( stemRegex ) ; 
} public final void start ( ) { 
if ( getContext ( ) == null ) { 
if ( shouldStart ( ) ) { 
getContext ( ) . getScheduledExecutorService ( ) . execute ( getRunnableTask ( ) ) ; 
} public final void stop ( ) { 
onStop ( ) ; 
started = false ; 
socketFactory = new ConfigurableSSLServerSocketFactory ( parameters , 
sslContext . getServerSocketFactory ( ) ) ; 
addError ( ex . getMessage ( ) , ex ) ; 
} private void retrospectivePrint ( ) { 
if ( context == null ) 
for ( Status status : statusList ) { 
long timestampOfStatusMesage = status . getDate ( ) ; 
if ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) { 
print ( status ) ; 
} static public int facilityStringToint ( String facilityStr ) { 
if ( "KERN" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_KERN ; 
} else if ( "USER" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_USER ; 
} else if ( "MAIL" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_MAIL ; 
} else if ( "DAEMON" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_DAEMON ; 
} else if ( "AUTH" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_AUTH ; 
} else if ( "SYSLOG" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_SYSLOG ; 
} else if ( "LPR" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LPR ; 
} else if ( "NEWS" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_NEWS ; 
} else if ( "UUCP" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_UUCP ; 
} else if ( "CRON" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_CRON ; 
} else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_AUTHPRIV ; 
} else if ( "FTP" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_FTP ; 
} else if ( "NTP" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_NTP ; 
} else if ( "AUDIT" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_AUDIT ; 
} else if ( "ALERT" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_ALERT ; 
} else if ( "CLOCK" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_CLOCK ; 
} else if ( "LOCAL0" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL0 ; 
} else if ( "LOCAL1" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL1 ; 
} else if ( "LOCAL2" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL2 ; 
} else if ( "LOCAL3" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL3 ; 
} else if ( "LOCAL4" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL4 ; 
} else if ( "LOCAL5" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL5 ; 
} else if ( "LOCAL6" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL6 ; 
} else if ( "LOCAL7" . equalsIgnoreCase ( facilityStr ) ) { 
return SyslogConstants . LOG_LOCAL7 ; 
throw new IllegalArgumentException ( facilityStr 
} public void setFacility ( String facilityStr ) { 
if ( facilityStr != null ) { 
facilityStr = facilityStr . trim ( ) ; 
this . facilityStr = facilityStr ; 
} private boolean haveVisitedNodeAlready ( Node node , Stack < Node > cycleDetectionStack ) { 
for ( Node cycleNode : cycleDetectionStack ) { 
if ( equalNodes ( node , cycleNode ) ) { 
} public File getDatabaseFile ( String filename ) { 
File dbFile = null ; 
if ( filename != null && filename . trim ( ) . length ( ) > 0 ) { 
dbFile = new File ( filename ) ; 
if ( dbFile == null || dbFile . isDirectory ( ) ) { 
dbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( "logback.db" ) ) ; 
return dbFile ; 
File dbfile = getDatabaseFile ( this . filename ) ; 
if ( dbfile == null ) { 
boolean dbOpened = false ; 
dbfile . getParentFile ( ) . mkdirs ( ) ; 
this . db = SQLiteDatabase . openOrCreateDatabase ( dbfile . getPath ( ) , null ) ; 
dbOpened = true ; 
} catch ( SQLiteException e ) { 
if ( dbOpened ) { 
if ( dbNameResolver == null ) { 
dbNameResolver = new DefaultDBNameResolver ( ) ; 
insertExceptionSQL = SQLBuilder . buildInsertExceptionSQL ( dbNameResolver ) ; 
insertPropertiesSQL = SQLBuilder . buildInsertPropertiesSQL ( dbNameResolver ) ; 
insertSQL = SQLBuilder . buildInsertSQL ( dbNameResolver ) ; 
this . db . execSQL ( SQLBuilder . buildCreateLoggingEventTableSQL ( dbNameResolver ) ) ; 
this . db . execSQL ( SQLBuilder . buildCreatePropertyTableSQL ( dbNameResolver ) ) ; 
this . db . execSQL ( SQLBuilder . buildCreateExceptionTableSQL ( dbNameResolver ) ) ; 
clearExpiredLogs ( this . db ) ; 
this . started = true ; 
} private void clearExpiredLogs ( SQLiteDatabase db ) { 
if ( lastCheckExpired ( this . maxHistory , this . lastCleanupTime ) ) { 
this . lastCleanupTime = this . clock . currentTimeMillis ( ) ; 
this . getLogCleaner ( ) . performLogCleanup ( db , this . maxHistory ) ; 
} private boolean lastCheckExpired ( Duration expiry , long lastCleanupTime ) { 
boolean isExpired = false ; 
if ( expiry != null && expiry . getMilliseconds ( ) > 0 ) { 
final long now = this . clock . currentTimeMillis ( ) ; 
final long timeDiff = now - lastCleanupTime ; 
isExpired = ( lastCleanupTime <= 0 ) || ( timeDiff >= expiry . getMilliseconds ( ) ) ; 
return isExpired ; 
} public SQLiteLogCleaner getLogCleaner ( ) { 
if ( this . logCleaner == null ) { 
final Clock thisClock = this . clock ; 
this . logCleaner = new SQLiteLogCleaner ( ) { 
public void performLogCleanup ( SQLiteDatabase db , Duration expiry ) { 
final long expiryMs = thisClock . currentTimeMillis ( ) - expiry . getMilliseconds ( ) ; 
final String deleteExpiredLogsSQL = SQLBuilder . buildDeleteExpiredLogsSQL ( dbNameResolver , expiryMs ) ; 
db . execSQL ( deleteExpiredLogsSQL ) ; 
return this . logCleaner ; 
public void append ( ILoggingEvent eventObject ) { 
if ( isStarted ( ) ) { 
clearExpiredLogs ( db ) ; 
SQLiteStatement stmt = db . compileStatement ( insertSQL ) ; 
db . beginTransaction ( ) ; 
long eventId = subAppend ( eventObject , stmt ) ; 
if ( eventId != - 1 ) { 
secondarySubAppend ( eventObject , eventId ) ; 
db . setTransactionSuccessful ( ) ; 
if ( db . inTransaction ( ) ) { 
db . endTransaction ( ) ; 
stmt . close ( ) ; 
} private long subAppend ( ILoggingEvent event , SQLiteStatement insertStatement ) throws SQLException { 
bindLoggingEvent ( insertStatement , event ) ; 
bindLoggingEventArguments ( insertStatement , event . getArgumentArray ( ) ) ; 
bindCallerData ( insertStatement , event . getCallerData ( ) ) ; 
long insertId = - 1 ; 
insertId = insertStatement . executeInsert ( ) ; 
return insertId ; 
} private void secondarySubAppend ( ILoggingEvent event , long eventId ) throws SQLException { 
Map < String , String > mergedMap = mergePropertyMaps ( event ) ; 
insertProperties ( mergedMap , eventId ) ; 
if ( event . getThrowableProxy ( ) != null ) { 
insertThrowable ( event . getThrowableProxy ( ) , eventId ) ; 
} private void bindLoggingEvent ( SQLiteStatement stmt , ILoggingEvent event ) throws SQLException { 
stmt . bindLong ( TIMESTMP_INDEX , event . getTimeStamp ( ) ) ; 
stmt . bindString ( FORMATTED_MESSAGE_INDEX , event . getFormattedMessage ( ) ) ; 
stmt . bindString ( LOGGER_NAME_INDEX , event . getLoggerName ( ) ) ; 
stmt . bindString ( LEVEL_STRING_INDEX , event . getLevel ( ) . toString ( ) ) ; 
stmt . bindString ( THREAD_NAME_INDEX , event . getThreadName ( ) ) ; 
stmt . bindLong ( REFERENCE_FLAG_INDEX , computeReferenceMask ( event ) ) ; 
} private void bindLoggingEventArguments ( SQLiteStatement stmt , Object [ ] argArray ) throws SQLException { 
int arrayLen = argArray != null ? argArray . length : 0 ; 
for ( int i = 0 ; i < arrayLen && i < 4 ; i ++ ) { 
stmt . bindString ( ARG0_INDEX + i , asStringTruncatedTo254 ( argArray [ i ] ) ) ; 
} private String asStringTruncatedTo254 ( Object o ) { 
s = o . toString ( ) ; 
if ( s != null && s . length ( ) > 254 ) { 
s = s . substring ( 0 , 254 ) ; 
return s == null ? "" : s ; 
} private static short computeReferenceMask ( ILoggingEvent event ) { 
short mask = 0 ; 
int mdcPropSize = 0 ; 
if ( event . getMDCPropertyMap ( ) != null ) { 
mdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; 
int contextPropSize = 0 ; 
if ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { 
contextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; 
if ( mdcPropSize > 0 || contextPropSize > 0 ) { 
mask = PROPERTIES_EXIST ; 
mask |= EXCEPTION_EXISTS ; 
return mask ; 
} private Map < String , String > mergePropertyMaps ( ILoggingEvent event ) { 
Map < String , String > mergedMap = new HashMap < String , String > ( ) ; 
Map < String , String > loggerContextMap = event . getLoggerContextVO ( ) . getPropertyMap ( ) ; 
if ( loggerContextMap != null ) { 
mergedMap . putAll ( loggerContextMap ) ; 
if ( mdcMap != null ) { 
mergedMap . putAll ( mdcMap ) ; 
return mergedMap ; 
} private void insertProperties ( Map < String , String > mergedMap , long eventId ) throws SQLException { 
if ( mergedMap . size ( ) > 0 ) { 
SQLiteStatement stmt = db . compileStatement ( insertPropertiesSQL ) ; 
for ( Entry < String , String > entry : mergedMap . entrySet ( ) ) { 
stmt . bindLong ( 1 , eventId ) ; 
stmt . bindString ( 2 , entry . getKey ( ) ) ; 
stmt . bindString ( 3 , entry . getValue ( ) ) ; 
stmt . executeInsert ( ) ; 
} private void bindCallerData ( SQLiteStatement stmt , StackTraceElement [ ] callerDataArray ) throws SQLException { 
StackTraceElement callerData = callerDataArray [ 0 ] ; 
if ( callerData != null ) { 
bindString ( stmt , CALLER_FILENAME_INDEX , callerData . getFileName ( ) ) ; 
bindString ( stmt , CALLER_CLASS_INDEX , callerData . getClassName ( ) ) ; 
bindString ( stmt , CALLER_METHOD_INDEX , callerData . getMethodName ( ) ) ; 
bindString ( stmt , CALLER_LINE_INDEX , Integer . toString ( callerData . getLineNumber ( ) ) ) ; 
} private void insertException ( SQLiteStatement stmt , String txt , short i , long eventId ) throws SQLException { 
stmt . bindLong ( 2 , i ) ; 
stmt . bindString ( 3 , txt ) ; 
} public int getPrefixMatchLength ( ElementPath p ) { 
if ( p == null ) { 
int lSize = this . partList . size ( ) ; 
int rSize = p . partList . size ( ) ; 
if ( ( lSize == 0 ) || ( rSize == 0 ) ) { 
int minLen = ( lSize <= rSize ) ? lSize : rSize ; 
int match = 0 ; 
for ( int i = 0 ; i < minLen ; i ++ ) { 
String l = this . partList . get ( i ) ; 
String r = p . partList . get ( i ) ; 
if ( equalityCheck ( l , r ) ) { 
match ++ ; 
return match ; 
} public synchronized int getEffectiveLevel ( ) { 
int result = level ; 
int effLevel ; 
Iterator it = iterator ( ) ; 
Status s ; 
s = ( Status ) it . next ( ) ; 
effLevel = s . getEffectiveLevel ( ) ; 
if ( effLevel > result ) { 
result = effLevel ; 
} protected void introspect ( ) { 
propertyDescriptors = Introspector . getPropertyDescriptors ( this . objClass ) ; 
methodDescriptors = Introspector . getMethodDescriptors ( this . objClass ) ; 
} catch ( IntrospectionException ex ) { 
propertyDescriptors = new PropertyDescriptor [ 0 ] ; 
methodDescriptors = new MethodDescriptor [ 0 ] ; 
name = Introspector . decapitalize ( name ) ; 
PropertyDescriptor prop = getPropertyDescriptor ( name ) ; 
if ( prop == null ) { 
setProperty ( prop , name , value ) ; 
} catch ( PropertySetterException ex ) { 
} public void setProperty ( PropertyDescriptor prop , String name , String value ) 
throws PropertySetterException { 
Method setter = prop . getWriteMethod ( ) ; 
if ( setter == null ) { 
Class < ? > [ ] paramTypes = setter . getParameterTypes ( ) ; 
if ( paramTypes . length != 1 ) { 
Object arg ; 
arg = StringToObjectConverter . convertArg ( this , value , paramTypes [ 0 ] ) ; 
if ( arg == null ) { 
setter . invoke ( obj , arg ) ; 
throw new PropertySetterException ( ex ) ; 
} private boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { 
if ( clazz . isInterface ( ) ) { 
Object o ; 
o = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; 
if ( OptionHelper . isEmpty ( resourceStr ) ) { 
URL resourceURL = Loader . getResourceBySelfClassLoader ( resourceStr ) ; 
return booleanAsStr ( resourceURL != null ) ; 
protected HashMap < String , String > childValue ( 
HashMap < String , String > parentValue ) { 
if ( parentValue == null ) { 
return new HashMap < String , String > ( parentValue ) ; 
} private Node Eopt ( ) throws ScanException { 
Token next = peekAtCurentToken ( ) ; 
} private Node T ( ) throws ScanException { 
Token t = peekAtCurentToken ( ) ; 
switch ( t . type ) { 
case LITERAL : 
return makeNewLiteralNode ( t . payload ) ; 
case CURLY_LEFT : 
Node innerNode = C ( ) ; 
Token right = peekAtCurentToken ( ) ; 
expectCurlyRight ( right ) ; 
Node curlyLeft = makeNewLiteralNode ( CoreConstants . LEFT_ACCOLADE ) ; 
curlyLeft . append ( innerNode ) ; 
curlyLeft . append ( makeNewLiteralNode ( CoreConstants . RIGHT_ACCOLADE ) ) ; 
return curlyLeft ; 
case START : 
Node v = V ( ) ; 
Token w = peekAtCurentToken ( ) ; 
expectCurlyRight ( w ) ; 
} private Node V ( ) throws ScanException { 
Node e = E ( ) ; 
Node variable = new Node ( Node . Type . VARIABLE , e ) ; 
if ( isDefaultToken ( t ) ) { 
Node def = E ( ) ; 
variable . defaultPart = def ; 
return variable ; 
} private Node C ( ) throws ScanException { 
Node e0 = E ( ) ; 
Node literal = makeNewLiteralNode ( CoreConstants . DEFAULT_VALUE_SEPARATOR ) ; 
e0 . append ( literal ) ; 
Node e1 = E ( ) ; 
e0 . append ( e1 ) ; 
return e0 ; 
protected void processInclude ( InterpretationContext ic , URL url ) throws JoranException { 
InputStream in = openURL ( url ) ; 
if ( in != null ) { 
ConfigurationWatchListUtil . addToWatchList ( getContext ( ) , url ) ; 
SaxEventRecorder recorder = createRecorder ( in , url ) ; 
recorder . setContext ( getContext ( ) ) ; 
recorder . recordEvents ( in ) ; 
trimHeadAndTail ( recorder ) ; 
ic . getJoranInterpreter ( ) . getEventPlayer ( ) . addEventsDynamically ( recorder . getSaxEventList ( ) , this . eventOffset ) ; 
} catch ( JoranException e ) { 
close ( in ) ; 
} private InputStream openURL ( URL url ) { 
return url . openStream ( ) ; 
} private void trimHeadAndTail ( SaxEventRecorder recorder ) { 
List < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; 
if ( saxEventList . size ( ) == 0 ) { 
boolean includedTagFound = false ; 
boolean configTagFound = false ; 
SaxEvent first = saxEventList . get ( 0 ) ; 
if ( first != null ) { 
String elemName = getEventName ( first ) ; 
includedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; 
configTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; 
if ( includedTagFound || configTagFound ) { 
saxEventList . remove ( 0 ) ; 
final int listSize = saxEventList . size ( ) ; 
if ( listSize == 0 ) { 
final int lastIndex = listSize - 1 ; 
SaxEvent last = saxEventList . get ( lastIndex ) ; 
if ( last != null ) { 
String elemName = getEventName ( last ) ; 
if ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || 
( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { 
saxEventList . remove ( lastIndex ) ; 
} private String getEventName ( SaxEvent event ) { 
return event . qName . length ( ) > 0 ? event . qName : event . localName ; 
ServerSocket serverSocket = null ; 
serverSocket = getServerSocketFactory ( ) . createServerSocket ( 
getPort ( ) , getBacklog ( ) , getInetAddress ( ) ) ; 
ServerListener < RemoteAppenderClient > listener = 
createServerListener ( serverSocket ) ; 
runner = createServerRunner ( listener , getContext ( ) . getScheduledExecutorService ( ) ) ; 
runner . setContext ( getContext ( ) ) ; 
CloseUtil . closeQuietly ( serverSocket ) ; 
} protected void onStop ( ) { 
if ( runner == null ) return ; 
runner . stop ( ) ; 
} void prepareKeyStore ( ) { 
Key key = keyStore . getKey ( keyAlias , null ) ; 
Certificate certificate = keyStore . getCertificate ( keyAlias ) ; 
if ( key != null && certificate != null ) { 
createCipher ( ) . init ( Cipher . DECRYPT_MODE , key ) ; 
} catch ( KeyPermanentlyInvalidatedException e ) { 
storage . clear ( ) ; 
keyGenerator . initialize ( new KeyGenParameterSpec . Builder ( keyAlias , 
KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) 
. setBlockModes ( KeyProperties . BLOCK_MODE_ECB ) 
. setUserAuthenticationRequired ( true ) 
. setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_RSA_PKCS1 ) 
. build ( ) ) ; 
keyGenerator . generateKeyPair ( ) ; 
} catch ( GeneralSecurityException e ) { 
} protected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { 
byte ch = reader . read ( ) ; 
if ( ch != b [ 0 ] ) { 
} private static byte hexVal ( byte ch ) throws IOException { 
if ( ( ch >= '0' ) && ( ch <= '9' ) ) { 
return ( byte ) ( ( char ) ch - '0' ) ; 
} else if ( ( ch >= 'a' ) && ( ch <= 'f' ) ) { 
return ( byte ) ( ( char ) ch - 'a' + 10 ) ; 
} private void writeJsonString ( byte [ ] b ) throws IOException { 
context . write ( ) ; 
transport . write ( QUOTE ) ; 
int len = b . length ; 
if ( ( b [ i ] & 0x00FF ) >= 0x30 ) { 
if ( b [ i ] == BACKSLASH [ 0 ] ) { 
transport . write ( BACKSLASH ) ; 
transport . write ( b , i , 1 ) ; 
tmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; 
if ( tmpbuf [ 0 ] == 1 ) { 
} else if ( tmpbuf [ 0 ] > 1 ) { 
transport . write ( tmpbuf , 0 , 1 ) ; 
transport . write ( ESCSEQ ) ; 
tmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] > > 4 ) ) ; 
tmpbuf [ 1 ] = hexChar ( b [ i ] ) ; 
transport . write ( tmpbuf , 0 , 2 ) ; 
} private void writeJsonInteger ( long num ) throws IOException { 
String str = Long . toString ( num ) ; 
boolean escapeNum = context . escapeNum ( ) ; 
if ( escapeNum ) { 
byte [ ] buf = str . getBytes ( "UTF-8" ) ; 
transport . write ( buf ) ; 
throw new AssertionError ( e ) ; 
} private void writeJsonDouble ( double num ) throws IOException { 
String str = Double . toString ( num ) ; 
boolean special = false ; 
switch ( str . charAt ( 0 ) ) { 
case 'I' : 
special = true ; 
case '-' : 
if ( str . charAt ( 1 ) == 'I' ) { 
boolean escapeNum = special || context . escapeNum ( ) ; 
byte [ ] b = str . getBytes ( "UTF-8" ) ; 
transport . write ( b , 0 , b . length ) ; 
} private ByteString readJsonString ( boolean skipContext ) 
Buffer buffer = new Buffer ( ) ; 
ArrayList < Character > codeunits = new ArrayList < > ( ) ; 
if ( ! skipContext ) { 
context . read ( ) ; 
readJsonSyntaxChar ( QUOTE ) ; 
if ( ch == QUOTE [ 0 ] ) { 
if ( ch == ESCSEQ [ 0 ] ) { 
ch = reader . read ( ) ; 
if ( ch == ESCSEQ [ 1 ] ) { 
transport . read ( tmpbuf , 0 , 4 ) ; 
short cu = ( short ) ( 
( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) 
+ ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) 
+ ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) 
+ ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; 
if ( Character . isHighSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) > 0 ) { 
codeunits . add ( ( char ) cu ) ; 
} else if ( Character . isLowSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) == 0 ) { 
buffer . write ( new String ( new int [ ] { codeunits . get ( 0 ) , codeunits . get ( 1 ) } , 0 , 2 ) 
. getBytes ( "UTF-8" ) ) ; 
codeunits . clear ( ) ; 
buffer . write ( new String ( new int [ ] { cu } , 0 , 1 ) . getBytes ( "UTF-8" ) ) ; 
int off = ESCAPE_CHARS . indexOf ( ch ) ; 
if ( off == - 1 ) { 
ch = ESCAPE_CHAR_VALS [ off ] ; 
buffer . write ( new byte [ ] { ch } ) ; 
return buffer . readByteString ( ) ; 
} private String readJsonNumericChars ( ) throws IOException { 
StringBuilder strbld = new StringBuilder ( ) ; 
byte ch = reader . peek ( ) ; 
if ( ! isJsonNumeric ( ch ) ) { 
strbld . append ( ( char ) reader . read ( ) ) ; 
return strbld . toString ( ) ; 
} private long readJsonInteger ( ) throws IOException { 
if ( context . escapeNum ( ) ) { 
String str = readJsonNumericChars ( ) ; 
return Long . valueOf ( str ) ; 
} catch ( NumberFormatException ex ) { 
} private double readJsonDouble ( ) throws IOException { 
if ( reader . peek ( ) == QUOTE [ 0 ] ) { 
ByteString str = readJsonString ( true ) ; 
double dub = Double . valueOf ( str . utf8 ( ) ) ; 
if ( ! context . escapeNum ( ) && ! Double . isNaN ( dub ) 
&& ! Double . isInfinite ( dub ) ) { 
return dub ; 
return Double . valueOf ( readJsonNumericChars ( ) ) ; 
} private ByteString readJsonBase64 ( ) throws IOException { 
ByteString str = readJsonString ( false ) ; 
return ByteString . decodeBase64 ( str . utf8 ( ) ) ; 
} protected final Object execute ( MethodCall < ? > methodCall ) throws Exception { 
if ( ! running . get ( ) ) { 
return invokeRequest ( methodCall ) ; 
} catch ( ServerException e ) { 
throw e . thriftException ; 
} final Object invokeRequest ( MethodCall < ? > call ) throws Exception { 
boolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; 
int sid = seqId . incrementAndGet ( ) ; 
protocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; 
call . send ( protocol ) ; 
protocol . writeMessageEnd ( ) ; 
protocol . flush ( ) ; 
if ( isOneWay ) { 
MessageMetadata metadata = protocol . readMessageBegin ( ) ; 
if ( metadata . seqId != sid ) { 
throw new ThriftException ( 
ThriftException . Kind . BAD_SEQUENCE_ID , 
if ( metadata . type == TMessageType . EXCEPTION ) { 
ThriftException e = ThriftException . read ( protocol ) ; 
protocol . readMessageEnd ( ) ; 
throw new ServerException ( e ) ; 
} else if ( metadata . type != TMessageType . REPLY ) { 
ThriftException . Kind . INVALID_MESSAGE_TYPE , 
if ( metadata . seqId != seqId . get ( ) ) { 
if ( ! metadata . name . equals ( call . name ) ) { 
ThriftException . Kind . WRONG_METHOD_NAME , 
Object result = call . receive ( protocol , metadata ) ; 
if ( e instanceof Struct ) { 
public MessageMetadata readMessageBegin ( ) throws IOException { 
int size = readI32 ( ) ; 
if ( size < 0 ) { 
int version = size & VERSION_MASK ; 
if ( version != VERSION_1 ) { 
return new MessageMetadata ( readString ( ) , ( byte ) ( size & 0xff ) , readI32 ( ) ) ; 
if ( strictRead ) { 
return new MessageMetadata ( readStringWithSize ( size ) , readByte ( ) , readI32 ( ) ) ; 
} protected void enqueue ( MethodCall < ? > methodCall ) { 
if ( ! pendingCalls . offer ( methodCall ) ) { 
} public static IFile getResourceFromFSPath ( String location ) { 
return Activator . getDefault ( ) . getWorkspace ( ) . 
getRoot ( ) . getFileForLocation ( new Path ( location ) ) ; 
} public static void updateDecoration ( ) { 
final IWorkbench workbench = Activator . getDefault ( ) . getWorkbench ( ) ; 
workbench . getDisplay ( ) . syncExec ( new Runnable ( ) { 
IDecoratorManager manager = workbench . getDecoratorManager ( ) ; 
manager . update ( GuvnorDecorator . DECORATOR_ID ) ; 
} public static void refreshRepositoryView ( ) { 
IWorkbenchWindow activeWindow = Activator . getDefault ( ) . 
getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
if ( activeWindow == null ) { 
IWorkbenchPage page = activeWindow . getActivePage ( ) ; 
if ( page == null ) { 
RepositoryView view = ( RepositoryView ) page . findView ( IGuvnorConstants . REPVIEW_ID ) ; 
if ( view != null ) { 
view . refresh ( ) ; 
} public static ResourceHistoryView getResourceHistoryView ( ) throws Exception { 
return ( ResourceHistoryView ) page . showView ( IGuvnorConstants . RESHISTORYVIEW_ID ) ; 
} public static void openEditor ( String contents , String name ) { 
IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
IStorage storage = new StringStorage ( contents , name ) ; 
IStorageEditorInput input = new StringInput ( storage ) ; 
IWorkbenchPage page = window . getActivePage ( ) ; 
IEditorDescriptor desc = PlatformUI . getWorkbench ( ) . 
getEditorRegistry ( ) . getDefaultEditor ( name ) ; 
String editorId = desc != null ? desc . getId ( ) : "org.eclipse.ui.DefaultTextEditor" ; 
if ( page != null ) { 
page . openEditor ( input , editorId ) ; 
Activator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; 
} public static void reportAuthenticationFailure ( ) { 
Display display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; 
display . asyncExec ( new Runnable ( ) { 
Display display = Display . getCurrent ( ) ; 
Shell shell = display . getActiveShell ( ) ; 
MessageDialog . openError ( shell , Messages . getString ( "login.failure.dialog.caption" ) , 
Messages . getString ( "login.failure.dialog.message" ) ) ; 
} public AuthPromptResults promptForAuthentication ( final String server ) { 
AuthPromptRunnable op = new AuthPromptRunnable ( server ) ; 
display . syncExec ( op ) ; 
return op . getResults ( ) ; 
} public synchronized byte [ ] getBuffer ( ) { 
if ( pool . isEmpty ( ) ) 
return new byte [ BUFFER_SIZE ] ; 
byte [ ] buffer = ( byte [ ] ) pool . lastElement ( ) ; 
pool . removeElementAt ( pool . size ( ) - 1 ) ; 
} public synchronized void putBuffer ( byte [ ] buffer ) { 
Assert . isNotNull ( buffer ) ; 
Assert . isTrue ( buffer . length == BUFFER_SIZE ) ; 
if ( pool . size ( ) < MAX_BUFFERS ) 
pool . addElement ( buffer ) ; 
} private Control createDefaultPage ( FormToolkit kit ) { 
Form form = kit . createForm ( book ) ; 
Composite body = form . getBody ( ) ; 
GridLayout layout = new GridLayout ( 2 , false ) ; 
body . setLayout ( layout ) ; 
Link hlink = new Link ( body , SWT . NONE ) ; 
hlink . setBackground ( book . getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; 
GridData gd = new GridData ( SWT . LEFT , SWT . FILL , true , false ) ; 
hlink . setLayoutData ( gd ) ; 
hlink . addSelectionListener ( new SelectionAdapter ( ) { 
public void widgetSelected ( SelectionEvent e ) { 
ViewUtils . showServersView ( ) ; 
final CommonViewer commonViewer = this . getCommonViewer ( ) ; 
if ( commonViewer != null ) { 
ICommonViewerSite commonViewerSite = CommonViewerSiteFactory . createCommonViewerSite ( this . getViewSite ( ) ) ; 
if ( commonViewerSite != null ) { 
final NavigatorActionService actionService = new NavigatorActionService ( commonViewerSite , commonViewer , 
commonViewer . getNavigatorContentService ( ) ) ; 
MenuManager menuManager = new MenuManager ( "#PopupMenu" ) ; 
menuManager . addMenuListener ( new IMenuListener ( ) { 
public void menuAboutToShow ( IMenuManager mgr ) { 
ISelection selection = commonViewer . getSelection ( ) ; 
actionService . setContext ( new ActionContext ( selection ) ) ; 
actionService . fillContextMenu ( mgr ) ; 
Menu menu = menuManager . createContextMenu ( body ) ; 
body . setMenu ( menu ) ; 
hlink . setMenu ( menu ) ; 
} void toggleDefaultPage ( ) { 
if ( treeViewer . getTree ( ) . getItemCount ( ) < 1 ) { 
book . showPage ( noServersPage ) ; 
book . showPage ( mainPage ) ; 
} protected void startThread ( ) { 
if ( animationActive ) 
stopAnimation = false ; 
final Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; 
final int SLEEP = 200 ; 
final Runnable [ ] animator = new Runnable [ 1 ] ; 
animator [ 0 ] = new Runnable ( ) { 
if ( ! stopAnimation ) { 
String [ ] servers ; 
synchronized ( starting ) { 
size = starting . size ( ) ; 
servers = new String [ size ] ; 
starting . toArray ( servers ) ; 
IServer server = ServerCore . findServer ( servers [ i ] ) ; 
if ( server != null ) { 
treeViewer . update ( server , new String [ ] { "ICON" } ) ; 
display . timerExec ( SLEEP , animator [ 0 ] ) ; 
Display . getDefault ( ) . asyncExec ( new Runnable ( ) { 
} public void addProperty ( String propertyHref ) { 
Assert . isNotNull ( propertyHref ) ; 
Assert . isTrue ( getFirstChild ( root , "omit" ) == null ) ; 
Element keepalive = getFirstChild ( root , "keepalive" ) ; 
if ( keepalive == null ) 
keepalive = addChild ( root , "keepalive" , fgNamesKeepAlive , true ) ; 
Assert . isTrue ( ! "*" . equals ( getFirstText ( keepalive ) ) ) ; 
addChild ( keepalive , "href" , 
encodeHref ( propertyHref ) , new String [ ] { "href" } , 
false ) ; 
} public Enumeration getProperties ( ) throws MalformedElementException { 
ensureNotNull ( Policy . bind ( "ensure.missingKeealiveElmt" ) , keepalive ) ; 
ensure ( ! "*" . equals ( getFirstText ( keepalive ) ) , 
Policy . bind ( "ensure.wrongForm" ) ) ; 
final Element firstHref = getFirstChild ( keepalive , "href" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingHrefElmt" ) , firstHref ) ; 
Enumeration e = new Enumeration ( ) { 
Element currentHref = firstHref ; 
public boolean hasMoreElements ( ) { 
return currentHref != null ; 
public Object nextElement ( ) { 
if ( ! hasMoreElements ( ) ) 
String href = getFirstText ( currentHref ) ; 
currentHref = getTwin ( currentHref , true ) ; 
return decodeHref ( href ) ; 
} public boolean isKeepAllAlive ( ) throws MalformedElementException { 
Element child = getFirstChild ( root , childNames ) ; 
ensureNotNull ( Policy . bind ( "ensure.expectingOmitOrKeepaliveElmt" ) , child ) ; 
boolean isKeepAllAlive = false ; 
if ( isDAVElement ( child , "keepalive" ) ) { 
isKeepAllAlive = "*" . equals ( getFirstText ( child ) ) ; 
ensureNull ( Policy . bind ( "ensure.conflictingHrefElmt" ) , getFirstChild ( child , "href" ) ) ; 
child = getNextSibling ( child , childNames ) ; 
ensureNull ( Policy . bind ( "ensure.conflictingOmitOrKeepaliveElmt" ) , child ) ; 
return isKeepAllAlive ; 
} public void setIsKeepAllAlive ( boolean isKeepAllAlive ) { 
boolean isAlreadyKeepAllAlive = false ; 
if ( isDAVElement ( child , "keepalive" ) ) 
isAlreadyKeepAllAlive = "*" . equals ( getFirstText ( child ) ) ; 
if ( isKeepAllAlive ) { 
if ( ! isAlreadyKeepAllAlive ) { 
if ( child != null ) 
root . removeChild ( child ) ; 
appendChild ( root , "keepalive" , "*" ) ; 
} else if ( isAlreadyKeepAllAlive ) 
} public void setIsOmit ( boolean isOmit ) { 
boolean isAlreadyOmit = isDAVElement ( child , "omit" ) ; 
if ( isOmit ) { 
if ( ! isAlreadyOmit ) { 
appendChild ( root , "omit" ) ; 
} else if ( isAlreadyOmit ) 
} public void addLockTokenHref ( String href ) { 
Assert . isNotNull ( href ) ; 
Element locktoken = getLastChild ( root , "locktoken" ) ; 
if ( locktoken == null ) 
locktoken = setChild ( root , "locktoken" , childNames , false ) ; 
appendChild ( locktoken , "href" , encodeHref ( href ) ) ; 
} public String getDepth ( ) throws MalformedElementException { 
String depth = getChildText ( root , "depth" , false ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingDepthElmt" ) , depth ) ; 
ensure ( depth . equals ( IContext . DEPTH_ZERO ) || depth . equals ( IContext . DEPTH_ONE ) || depth . equals ( IContext . DEPTH_INFINITY ) , Policy . bind ( "ensure.invalidDepth" , depth ) ) ; 
return depth ; 
} public Enumeration getLockTokenHrefs ( ) throws MalformedElementException { 
Element firstHref = null ; 
if ( locktoken != null ) { 
firstHref = getFirstChild ( locktoken , "href" ) ; 
final Node node = firstHref ; 
Node currentHref = node ; 
if ( ! hasMoreElements ( ) ) { 
String href = getFirstText ( ( Element ) currentHref ) ; 
currentHref = getTwin ( ( Element ) currentHref , true ) ; 
} public Owner getOwner ( ) throws MalformedElementException { 
Element owner = getLastChild ( root , "owner" ) ; 
if ( owner == null ) 
return new Owner ( owner ) ; 
} public void setDepth ( String depth ) { 
Assert . isNotNull ( depth ) ; 
Assert . isTrue ( depth . equals ( IContext . DEPTH_ZERO ) || depth . equals ( IContext . DEPTH_ONE ) || depth . equals ( IContext . DEPTH_INFINITY ) ) ; 
setChild ( root , "depth" , depth , childNames , false ) ; 
} public void setIsShared ( boolean isShared ) { 
Element lockscope = setChild ( root , "lockscope" , childNames , true ) ; 
if ( isShared ) 
appendChild ( lockscope , "shared" ) ; 
appendChild ( lockscope , "exclusive" ) ; 
} public Owner setOwner ( ) { 
Element owner = setChild ( root , "owner" , childNames , false ) ; 
Owner result = null ; 
result = new Owner ( owner ) ; 
} catch ( MalformedElementException e ) { 
Assert . isTrue ( false , Policy . bind ( "assert.internalError" ) ) ; 
} public void setTimeout ( String timeout ) { 
if ( timeout == null ) { 
Element child = getLastChild ( root , "timeout" ) ; 
setChild ( root , "timeout" , timeout , childNames , false ) ; 
public String getPreferenceName ( String name ) { 
String canonicalName = getCanonicalName ( getRoot ( ) . getName ( ) ) ; 
return canonicalName ; 
return canonicalName + IKieConstants . PREF_PATH_SEPARATOR + getCanonicalName ( name ) ; 
} public static LockInfo create ( Document document ) { 
Assert . isNotNull ( document ) ; 
Assert . isTrue ( document . getOwnerDocument ( ) == null ) ; 
Element element = create ( document , "lockinfo" ) ; 
Element locktype = appendChild ( element , "locktype" ) ; 
appendChild ( locktype , "write" ) ; 
LockInfo result = null ; 
result = new LockInfo ( element ) ; 
} public boolean isShared ( ) throws MalformedElementException { 
Element lockscope = getFirstChild ( root , "lockscope" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingLockscopeElmt" ) , lockscope ) ; 
String [ ] names = new String [ ] { "shared" , "exclusive" } ; 
Element sharedOrExclusive = getFirstChild ( lockscope , names ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingSharedOrExclusiveElmt" ) , sharedOrExclusive ) ; 
boolean isShared = isDAVElement ( sharedOrExclusive , "shared" ) ; 
ensure ( getNextSibling ( sharedOrExclusive , names ) == null , Policy . bind ( "ensure.conflictingSharedOrExclusiveElmt" ) ) ; 
return isShared ; 
} public void addConditionFactor ( ConditionFactor factor ) throws WebDAVException { 
if ( conditionFactors . contains ( factor ) ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseDuplicateEntry" ) ) ; 
conditionFactors . addElement ( factor ) ; 
} public static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { 
ConditionTerm term = new ConditionTerm ( ) ; 
int token = tokenizer . ttype ; 
if ( token == '(' ) 
token = tokenizer . nextToken ( ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "(" ) ) ; 
while ( token == StreamTokenizer . TT_WORD || token == '<' || token == '[' ) { 
term . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; 
token = tokenizer . ttype ; 
if ( token == ')' ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , ")" ) ) ; 
} catch ( IOException exc ) { 
if ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingStateOrEntity" ) ) ; 
return term ; 
} public boolean matches ( ConditionTerm conditionTerm ) { 
int numberOfItemsToMatch = 0 ; 
Enumeration factors = getConditionFactors ( ) ; 
while ( match && factors . hasMoreElements ( ) ) { 
ConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; 
if ( factor . not ( ) ) { 
match = ! conditionTerm . contains ( factor ) ; 
match = conditionTerm . contains ( factor ) ; 
numberOfItemsToMatch ++ ; 
match = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; 
} public IContentAssistant getContentAssistant ( ISourceViewer sourceViewer ) { 
ContentAssistant assistant = new ContentAssistant ( ) ; 
assistant . setContentAssistProcessor ( 
new DefaultCompletionProcessor ( getEditor ( ) ) , IDocument . DEFAULT_CONTENT_TYPE ) ; 
new DSLRuleCompletionProcessor ( getEditor ( ) ) , DRLPartionScanner . RULE_PART_CONTENT ) ; 
assistant . setProposalPopupOrientation ( IContentAssistant . PROPOSAL_OVERLAY ) ; 
assistant . setAutoActivationDelay ( 0 ) ; 
return assistant ; 
} public void propertyChange ( PropertyChangeEvent evt ) { 
String prop = evt . getPropertyName ( ) ; 
if ( GraphicalVertex . SIZE_PROP . equals ( prop ) || GraphicalVertex . LOCATION_PROP . equals ( prop ) ) { 
refreshVisuals ( ) ; 
} else if ( GraphicalVertex . SOURCE_CONNECTIONS_PROP . equals ( prop ) ) { 
refreshSourceConnections ( ) ; 
} else if ( GraphicalVertex . TARGET_CONNECTIONS_PROP . equals ( prop ) ) { 
refreshTargetConnections ( ) ; 
} protected void refreshVisuals ( ) { 
Rectangle bounds = new Rectangle ( getCastedModel ( ) . getLocation ( ) , 
getCastedModel ( ) . getSize ( ) ) ; 
( ( GraphicalEditPart ) getParent ( ) ) . setLayoutConstraint ( this , 
getFigure ( ) , 
bounds ) ; 
} public Object getAdapter ( @ SuppressWarnings ( "rawtypes" ) Class key ) { 
if ( key == IPropertySource . class ) { 
return propertySource ; 
return super . getAdapter ( key ) ; 
public void initializeRuntimes ( List < RuntimeDefinition > serverDefinitions ) { 
IRuntime [ ] existingRuntimes = DroolsRuntimeManager . getDefault ( ) . getConfiguredRuntimes ( ) ; 
List < DroolsRuntime > droolsRuntimes = new ArrayList < DroolsRuntime > ( ) ; 
if ( existingRuntimes != null ) { 
for ( IRuntime runtime : existingRuntimes ) { 
if ( runtime instanceof DroolsRuntime ) 
droolsRuntimes . add ( ( DroolsRuntime ) runtime ) ; 
initializeInternal ( serverDefinitions , droolsRuntimes ) ; 
if ( droolsRuntimes . size ( ) > 0 ) { 
DroolsRuntime [ ] dra = droolsRuntimes . toArray ( new DroolsRuntime [ 0 ] ) ; 
DroolsRuntimeManager . getDefault ( ) . setRuntimes ( dra ) ; 
} private IJavaProject getCurrentJavaProject ( ) { 
IEditorInput input = getEditor ( ) . getEditorInput ( ) ; 
if ( ! ( input instanceof IFileEditorInput ) ) { 
IProject project = ( ( IFileEditorInput ) input ) . getFile ( ) . getProject ( ) ; 
IJavaProject javaProject = JavaCore . create ( project ) ; 
return javaProject ; 
} protected static boolean doesNotContainFieldCompletion ( String completion , List < ICompletionProposal > completions ) { 
if ( completion == null || completion . length ( ) == 0 || completions == null ) { 
for ( Iterator < ICompletionProposal > iter = completions . iterator ( ) ; iter . hasNext ( ) ; ) { 
if ( o instanceof AbstractJavaCompletionProposal ) { 
AbstractJavaCompletionProposal prop = ( AbstractJavaCompletionProposal ) o ; 
String content = prop . getReplacementString ( ) ; 
if ( completion . equals ( content ) ) { 
IJavaElement javaElement = prop . getJavaElement ( ) ; 
if ( javaElement instanceof ILocalVariable || javaElement instanceof IField ) { 
} public static Reader getDSLContent ( String ruleSource , IResource input ) throws CoreException { 
String dslFileName = findDSLConfigName ( ruleSource , input ) ; 
if ( dslFileName == null ) { 
IResource res = findDSLResource ( input , dslFileName ) ; 
if ( res instanceof IFile ) { 
IFile dslConf = ( IFile ) res ; 
if ( dslConf . exists ( ) ) { 
return new InputStreamReader ( dslConf . getContents ( ) ) ; 
} private void loadConfig ( IFile input ) { 
IResource res = findDSLResource ( input , dslConfigName ) ; 
InputStream stream = null ; 
stream = dslConf . getContents ( ) ; 
readConfig ( stream ) ; 
valid = true ; 
closeStream ( stream ) ; 
} void readConfig ( InputStream stream ) throws IOException , CoreException { 
DSLTokenizedMappingFile file = new DSLTokenizedMappingFile ( ) ; 
file . parseAndLoad ( new InputStreamReader ( stream ) ) ; 
DSLMapping grammar = file . getMapping ( ) ; 
List < DSLMappingEntry > conditions = grammar . getEntries ( DSLMappingEntry . CONDITION ) ; 
List < DSLMappingEntry > consequences = grammar . getEntries ( DSLMappingEntry . CONSEQUENCE ) ; 
conditionProposals = buildProposals ( conditions ) ; 
consequenceProposals = buildProposals ( consequences ) ; 
dslTree . buildTree ( grammar ) ; 
} static String findDSLConfigName ( String content ) { 
Matcher matches = EXPANDER_PATTERN . matcher ( content ) ; 
if ( matches . find ( ) ) { 
name = matches . group ( 1 ) + ".dsl" ; 
} public static URL appendTrailingSlash ( URL url ) { 
String file = url . getFile ( ) ; 
if ( file . endsWith ( "/" ) ) { 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , file + "/" ) ; 
} public static URL getChild ( String parent , String member ) throws MalformedURLException { 
return getChild ( new URL ( parent ) , member ) ; 
} public static URL getChild ( URL parent , String member ) { 
String file = parent . getFile ( ) ; 
if ( ! file . endsWith ( "/" ) ) 
file = file + "/" ; 
return new URL ( parent . getProtocol ( ) , parent . getHost ( ) , parent . getPort ( ) , file + member ) ; 
} public static Vector getElements ( URL url ) { 
Vector result = new Vector ( 5 ) ; 
String lastElement = null ; 
while ( ( lastElement = getLastElement ( url ) ) != null ) { 
result . insertElementAt ( lastElement , 0 ) ; 
url = getParent ( url ) ; 
} public static String getLastElement ( URL url ) { 
int len = file . length ( ) ; 
if ( len == 0 || len == 1 && file . charAt ( 0 ) == '/' ) { 
int lastSlashIndex = - 1 ; 
for ( int i = len - 2 ; lastSlashIndex == - 1 && i >= 0 ; -- i ) { 
if ( file . charAt ( i ) == '/' ) { 
lastSlashIndex = i ; 
boolean isDirectory = file . charAt ( len - 1 ) == '/' ; 
if ( lastSlashIndex == - 1 ) { 
if ( isDirectory ) 
return file . substring ( 0 , len - 1 ) ; 
return file . substring ( lastSlashIndex + 1 , len - 1 ) ; 
return file . substring ( lastSlashIndex + 1 , len ) ; 
} public static URL getParent ( URL url ) { 
if ( len == 0 || len == 1 && file . charAt ( 0 ) == '/' ) 
if ( file . charAt ( i ) == '/' ) 
if ( lastSlashIndex == - 1 ) 
file = "" ; 
file = file . substring ( 0 , lastSlashIndex + 1 ) ; 
url = new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , file ) ; 
Assert . isTrue ( false , e . getMessage ( ) ) ; 
} public static URL getRoot ( URL url ) { 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , "/" ) ; 
} public static URL removeTrailingSlash ( URL url ) { 
file = file . substring ( 0 , file . length ( ) - 1 ) ; 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , file ) ; 
} public static boolean urlsOverlap ( String url1 , String url2 ) throws MalformedURLException { 
return urlsOverlap ( new URL ( url1 ) , new URL ( url2 ) ) ; 
} public static boolean urlsOverlap ( URL url1 , URL url2 ) { 
if ( ! getRoot ( url1 ) . equals ( getRoot ( url2 ) ) ) { 
Vector elements1 = URLTool . getElements ( url1 ) ; 
Vector elements2 = URLTool . getElements ( url2 ) ; 
for ( int i = 0 ; i < elements1 . size ( ) && i < elements2 . size ( ) ; ++ i ) { 
String element1 = ( String ) elements1 . elementAt ( i ) ; 
String element2 = ( String ) elements2 . elementAt ( i ) ; 
if ( ! element1 . equals ( element2 ) ) { 
} public Menu getMenu ( Control parent ) { 
setMenu ( new Menu ( parent ) ) ; 
final Shell shell = parent . getShell ( ) ; 
addProjectWizard ( menu , 
shell ) ; 
addRuleWizard ( menu , 
addDSLWizard ( menu , 
addDTWizard ( menu , 
return menu ; 
} public long getContentLength ( ) { 
long contentLength = context . getContentLength ( ) ; 
if ( contentLength != - 1 ) 
return contentLength ; 
int statusCode = getStatusCode ( ) ; 
if ( statusCode == IResponse . SC_NO_CONTENT || statusCode == IResponse . SC_NOT_MODIFIED || statusCode >= 100 && statusCode < 200 ) 
} public ContentType getContentType ( ) { 
String contentTypeString = context . getContentType ( ) ; 
if ( contentTypeString == null ) 
ContentType contentType = null ; 
contentType = new ContentType ( contentTypeString ) ; 
return contentType ; 
} public Document getDocumentBody ( ) throws IOException { 
Assert . isTrue ( hasDocumentBody ) ; 
Assert . isTrue ( ! hasInputStream ) ; 
if ( document == null ) { 
String characterEncoding = null ; 
ContentType contentType = getContentType ( ) ; 
if ( contentType != null ) { 
characterEncoding = contentType . getValue ( "charset" ) ; 
if ( characterEncoding == null ) { 
characterEncoding = "ASCII" ; 
IDocumentMarshaler marshaler = new DocumentMarshaler ( ) ; 
document = marshaler . parse ( new InputStreamReader ( is , characterEncoding ) ) ; 
} public String getHtml ( ) { 
} public ResponseBody addResponse ( ) { 
Element response = addChild ( root , "response" , childNames , true ) ; 
return new ResponseBody ( response ) ; 
} public static MultiStatus create ( Document document ) { 
Element element = create ( document , "multistatus" ) ; 
return new MultiStatus ( element ) ; 
} public Enumeration getResponses ( ) throws MalformedElementException { 
final Element firstResponse = getFirstChild ( root , "response" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingResponseElmt" ) , firstResponse ) ; 
Element currentResponse = firstResponse ; 
return currentResponse != null ; 
ResponseBody responseBody = null ; 
responseBody = new ResponseBody ( currentResponse ) ; 
} catch ( MalformedElementException ex ) { 
currentResponse = getTwin ( currentResponse , true ) ; 
return responseBody ; 
} private boolean isGuvnorResource ( Object element ) { 
if ( element instanceof IResource ) { 
return GuvnorMetadataUtils . findGuvnorMetadata ( ( IResource ) element ) != null ; 
} public void addHref ( String href ) { 
String encodedHref = encodeHref ( href ) ; 
if ( isDuplicate ( encodedHref ) ) 
appendChild ( root , "href" , encodedHref ) ; 
} public static HrefSet create ( Document document , QualifiedName name ) { 
Assert . isNotNull ( name ) ; 
Assert . isTrue ( DAV_NS . equals ( name . getQualifier ( ) ) ) ; 
Element element = create ( document , name . getLocalName ( ) ) ; 
return new HrefSet ( element , name ) ; 
} public Enumeration getHrefs ( ) { 
final Element firstHref = getFirstChild ( root , "href" ) ; 
currentHref = getNextSibling ( currentHref , "href" ) ; 
} public void insertHrefBefore ( String newHref , String refHref ) { 
String refHrefEncoded = encodeHref ( refHref ) ; 
String newHrefEncoded = encodeHref ( newHref ) ; 
if ( isDuplicate ( newHrefEncoded ) ) 
Element child = getFirstChild ( root , "href" ) ; 
while ( child != null ) { 
if ( refHrefEncoded . equals ( getFirstText ( child ) ) ) { 
insertBefore ( child , "href" , newHrefEncoded ) ; 
child = getNextSibling ( child , "href" ) ; 
Assert . isTrue ( false , Policy . bind ( "assert.noHrefRef" ) ) ; 
} public void removeHref ( String href ) { 
if ( encodedHref . equals ( getFirstText ( child ) ) ) { 
} public PropStat accumulatePropStat ( QualifiedName propertyName , String status , String responseDescription ) { 
Assert . isNotNull ( propertyName ) ; 
Assert . isNotNull ( status ) ; 
Element child = getFirstChild ( root , new String [ ] { "href" , "status" } ) ; 
Assert . isTrue ( child == null || isDAVElement ( child , "href" ) 
&& getNextSibling ( child , new String [ ] { "href" , "status" } ) == null ) ; 
String nsName = propertyName . getQualifier ( ) ; 
Assert . isTrue ( ! "" . equals ( nsName ) ) ; 
String localName = propertyName . getLocalName ( ) ; 
Assert . isNotNull ( localName ) ; 
Assert . isTrue ( ! localName . equals ( "" ) ) ; 
Document document = root . getOwnerDocument ( ) ; 
Element element = document . createElement ( localName ) ; 
declareNS ( element , null , nsName ) ; 
return accumulatePropStat ( element , status , responseDescription ) ; 
} public PropStat accumulatePropStat ( Element element , String status , String responseDescription ) throws MalformedElementException { 
Assert . isNotNull ( element ) ; 
Element propstat = getFirstChild ( root , "propstat" ) ; 
while ( ! found && propstat != null ) { 
String text = getChildText ( propstat , "status" , false ) ; 
if ( text != null && text . equals ( status ) ) 
propstat = getTwin ( propstat , true ) ; 
Element prop = null ; 
if ( propstat == null ) { 
propstat = addChild ( root , "propstat" , fgNamesPropStat , false ) ; 
prop = setChild ( propstat , "prop" , PropStat . childNames , true ) ; 
setChild ( propstat , "status" , status , PropStat . childNames , false ) ; 
prop = getFirstChild ( propstat , "prop" ) ; 
if ( prop == null ) 
if ( responseDescription == null ) { 
Element responsedescription = getLastChild ( propstat , "responsedescription" ) ; 
if ( responsedescription != null ) 
propstat . removeChild ( responsedescription ) ; 
setChild ( propstat , "responsedescription" , 
responseDescription , PropStat . childNames , false ) ; 
extractNode ( prop , element ) ; 
return new PropStat ( propstat ) ; 
Assert . isTrue ( getLastChild ( root , "propstat" ) == null ) ; 
addChild ( root , "href" , encodeHref ( href ) , fgNamesStatus , false ) ; 
} public PropStat addPropStat ( ) { 
Element firstHref = getFirstChild ( root , "href" ) ; 
Assert . isTrue ( firstHref == null || getNextSibling ( firstHref , new String [ ] { "href" , "status" } ) == null ) ; 
Element element = addChild ( root , "propstat" , fgNamesPropStat , false ) ; 
return new PropStat ( element ) ; 
} public void changePropStatStatus ( String oldStatus , String newStatus , String responseDescription ) { 
Assert . isNotNull ( oldStatus ) ; 
Assert . isNotNull ( newStatus ) ; 
while ( propstat != null ) { 
String status = getChildText ( propstat , "status" , true ) ; 
if ( oldStatus . equals ( status ) ) { 
setChild ( propstat , "status" , newStatus , PropStat . childNames , true ) ; 
} public String getHref ( ) throws MalformedElementException { 
String href = getChildText ( root , "href" , true ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingHrefElmt" ) , href ) ; 
} public Enumeration getHrefs ( ) throws MalformedElementException { 
final Node firstHref = getFirstChild ( root , "href" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingStatusElmt" ) , 
getNextSibling ( ( Element ) firstHref , "status" ) ) ; 
Node currentHref = getTwin ( ( Element ) firstHref , true ) ; 
} public Enumeration getPropStats ( ) throws MalformedElementException { 
final Element firstPropStat = getFirstChild ( root , "propstat" ) ; 
ensureNotNull ( "ensure.missingPropstatElmt" , firstPropStat ) ; 
Element currentPropStat = firstPropStat ; 
return currentPropStat != null ; 
PropStat result = null ; 
result = new PropStat ( currentPropStat ) ; 
currentPropStat = getTwin ( currentPropStat , true ) ; 
} public String getStatus ( ) throws MalformedElementException { 
Element status = getFirstChild ( root , "status" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingStatusElmt" ) , status ) ; 
return getFirstText ( status ) ; 
} public boolean isPropStat ( ) throws MalformedElementException { 
Element child = getFirstChild ( root , new String [ ] { "status" , "propstat" } ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingStatusOrPropstatElmt" ) , child ) ; 
boolean isPropStat = isDAVElement ( child , "propstat" ) ; 
if ( isPropStat ) 
child = getNextSibling ( child , "status" ) ; 
child = getNextSibling ( child , "propstat" ) ; 
ensureNull ( Policy . bind ( "ensure.conflictingStatusOrPropstatElmt" ) , child ) ; 
return isPropStat ; 
} public void setResponseDescription ( Element value ) { 
Element child = getLastChild ( root , "responsedescription" ) ; 
child = setChild ( root , "responsedescription" , childNames , false ) ; 
child . appendChild ( value ) ; 
} public void setStatus ( String status ) { 
setChild ( root , "status" , status , fgNamesStatus , true ) ; 
} public JsonObject add ( String name , String value ) { 
add ( name , valueOf ( value ) ) ; 
} public JsonObject set ( String name , String value ) { 
set ( name , valueOf ( value ) ) ; 
} private String credentials ( String username , String password ) { 
Assert . isNotNull ( username ) ; 
Assert . isNotNull ( password ) ; 
String userpass = username + ":" + password ; 
byte [ ] data = null ; 
data = userpass . getBytes ( "UTF8" ) ; 
data = userpass . getBytes ( ) ; 
} protected void firePropertyChange ( String property , 
Object oldValue , 
Object newValue ) { 
if ( pcsDelegate . hasListeners ( property ) ) { 
pcsDelegate . firePropertyChange ( property , 
oldValue , 
newValue ) ; 
} public static IJavaStackFrame getStackFrame ( IValue value ) 
throws CoreException { 
IStatusHandler handler = getStackFrameProvider ( ) ; 
IJavaStackFrame stackFrame = ( IJavaStackFrame ) handler 
. handleStatus ( fgNeedStackFrame , value ) ; 
if ( stackFrame != null ) { 
return stackFrame ; 
IDebugTarget target = value . getDebugTarget ( ) ; 
IJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target 
. getAdapter ( IJavaDebugTarget . class ) ; 
if ( javaTarget != null ) { 
IThread [ ] threads = javaTarget . getThreads ( ) ; 
for ( int i = 0 ; i < threads . length ; i ++ ) { 
IThread thread = threads [ i ] ; 
if ( thread . isSuspended ( ) ) { 
return ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; 
} private boolean isSubtypeOf ( String class1 , 
String class2 ) { 
if ( class1 == null || class2 == null ) { 
class1 = convertToNonPrimitiveClass ( class1 ) ; 
class2 = convertToNonPrimitiveClass ( class2 ) ; 
ClassTypeResolver resolver = new ClassTypeResolver ( getUniqueImports ( ) , 
ProjectClassLoader . getProjectClassLoader ( getEditor ( ) ) ) ; 
Class < ? > clazz1 = resolver . resolveType ( class1 ) ; 
Class < ? > clazz2 = resolver . resolveType ( class2 ) ; 
if ( clazz1 == null || clazz2 == null ) { 
return clazz2 . isAssignableFrom ( clazz1 ) ; 
} catch ( ClassNotFoundException exc ) { 
} private Collection < ICompletionProposal > getMvelInstanceCompletionsFromJDT ( final int documentOffset , 
final String prefix , 
Map < String , String > params , 
Class < ? > lastType , 
boolean settersOnly ) { 
if ( lastType == null ) { 
lastType = Object . class ; 
final String syntheticVarName = "mvdrlofc" ; 
final List < ICompletionProposal > list1 = new ArrayList < ICompletionProposal > ( ) ; 
requestJavaCompletionProposals ( javaText , prefix , documentOffset , params , list1 ) ; 
final List < ICompletionProposal > list = list1 ; 
Collection < ICompletionProposal > mvelList = RuleCompletionProcessor . mvelifyProposals ( list , settersOnly ) ; 
return mvelList ; 
} private Collection < ICompletionProposal > getMvelClassCompletionsFromJDT ( final int documentOffset , 
Class < ? > lastType ) { 
String javaText = "\n" + CompletionUtil . getSimpleClassName ( lastType ) + "." ; 
Collection < ICompletionProposal > mvelList = RuleCompletionProcessor . mvelifyProposals ( list , false ) ; 
} public static boolean containsProposal ( final Collection < ICompletionProposal > proposals , String newProposal ) { 
for ( ICompletionProposal prop : proposals ) { 
String displayString = prop . getDisplayString ( ) ; 
if ( existings . length == 0 ) { 
if ( newProposals . length == 0 ) { 
if ( existings [ 0 ] . equals ( newProposals [ 0 ] ) ) { 
} public static Collection < ICompletionProposal > mvelifyProposals ( List < ICompletionProposal > list , boolean settersOnly ) { 
final Collection < ICompletionProposal > set = new HashSet < ICompletionProposal > ( ) ; 
for ( ICompletionProposal o : list ) { 
if ( o instanceof JavaMethodCompletionProposal ) { 
processJavaMethodCompletionProposal ( list , settersOnly , set , o ) ; 
} else if ( o instanceof JavaCompletionProposal ) { 
processesJavaCompletionProposal ( settersOnly , set , o ) ; 
} else if ( ! settersOnly ) { 
set . add ( o ) ; 
return set ; 
} public static Element appendChild ( Element parent , String name ) { 
Assert . isTrue ( isDAVElement ( parent ) ) ; 
String nsPrefix = getNSPrefix ( parent ) ; 
String tagName = nsPrefix == null ? name : nsPrefix + ":" + name ; 
Element child = parent . getOwnerDocument ( ) . createElement ( tagName ) ; 
parent . appendChild ( child ) ; 
} public static Element appendChild ( Element parent , String name , String data ) { 
Assert . isNotNull ( data ) ; 
Element child = appendChild ( parent , name ) ; 
child . appendChild ( child . getOwnerDocument ( ) . createTextNode ( data ) ) ; 
} public static Node cloneNode ( Document document , Node node ) { 
Node nodeClone = null ; 
nodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; 
NamedNodeMap namedNodeMap = node . getAttributes ( ) ; 
for ( int i = 0 ; i < namedNodeMap . getLength ( ) ; ++ i ) { 
Attr attr = ( Attr ) namedNodeMap . item ( i ) ; 
Attr attrClone = document . createAttribute ( attr . getName ( ) ) ; 
attrClone . setValue ( attr . getValue ( ) ) ; 
( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; 
nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; 
nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; 
nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; 
nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; 
nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; 
nodeClone = document . createDocumentFragment ( ) ; 
Assert . isTrue ( false , Policy . bind ( "assert.notSupported" ) ) ; 
Assert . isTrue ( false , Policy . bind ( "assert.unknownNodeType" ) ) ; 
return nodeClone ; 
} public static Element create ( Document document , String name ) { 
Assert . isTrue ( document . getDocumentElement ( ) == null ) ; 
Element element = document . createElement ( name ) ; 
declareNS ( element , null , DAV_NS ) ; 
document . appendChild ( element ) ; 
return element ; 
} public static void declareNS ( Element element , String prefix , String namespaceUrl ) { 
Assert . isTrue ( namespaceUrl != null || prefix == null && namespaceUrl == null ) ; 
String name = XML_PREFIX + ( prefix == null ? "" : ":" + prefix ) ; 
String value = namespaceUrl == null ? "" : namespaceUrl ; 
element . setAttribute ( name , value ) ; 
} protected static Element ensureDAVElement ( String message , Node node , String name ) throws MalformedElementException { 
if ( node == null || node . getNodeType ( ) != Node . ELEMENT_NODE ) 
throw new MalformedElementException ( message ) ; 
Element element = ( Element ) node ; 
if ( ! name . equals ( getNSLocalName ( element ) ) || ! DAV_NS . equals ( getNSName ( element ) ) ) 
} protected static void ensureNotNull ( String message , Object object ) throws MalformedElementException { 
if ( object == null ) 
} protected static void ensureNull ( String message , Object object ) throws MalformedElementException { 
if ( object != null ) 
} protected static Text ensureText ( String message , Node node ) throws MalformedElementException { 
if ( node == null || node . getNodeType ( ) != Node . TEXT_NODE ) 
return ( Text ) node ; 
} public static Element extractElement ( Document document , Element element ) throws MalformedElementException { 
return ( Element ) extractNode ( document , element ) ; 
} public static Node extractNode ( Node parent , Node node ) throws MalformedElementException { 
Document document ; 
if ( parent . getNodeType ( ) == Node . DOCUMENT_NODE ) 
document = ( Document ) parent ; 
document = parent . getOwnerDocument ( ) ; 
Node nodeClone = cloneNode ( document , node ) ; 
parent . appendChild ( nodeClone ) ; 
if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { 
String nsPrefix = getNSPrefix ( ( Element ) node ) ; 
String nsName = getNSName ( ( Element ) node ) ; 
String nsNameClone = resolve ( nsPrefix , ( Element ) nodeClone ) ; 
if ( nsName != nsNameClone && ( nsName == null || ! nsName . equals ( nsNameClone ) ) ) 
declareNS ( ( Element ) nodeClone , nsPrefix , nsName ) ; 
NamedNodeMap nodeMap = nodeClone . getAttributes ( ) ; 
for ( int i = 0 ; i < nodeMap . getLength ( ) ; ++ i ) { 
Attr attr = ( Attr ) nodeMap . item ( i ) ; 
nsPrefix = getNSPrefix ( attr . getName ( ) ) ; 
if ( nsPrefix != null && ! nsPrefix . equals ( XML_PREFIX ) ) { 
nsName = resolve ( nsPrefix , ( Element ) node ) ; 
nsNameClone = resolve ( nsPrefix , ( Element ) nodeClone ) ; 
Node child = node . getFirstChild ( ) ; 
extractNode ( nodeClone , child ) ; 
child = child . getNextSibling ( ) ; 
} private static Element getChild ( Element parent , String [ ] names , boolean firstToLast ) { 
Assert . isNotNull ( names ) ; 
Node child = null ; 
if ( firstToLast ) 
child = parent . getFirstChild ( ) ; 
child = parent . getLastChild ( ) ; 
for ( int i = 0 ; i < names . length ; ++ i ) 
if ( isDAVElement ( child , names [ i ] ) ) 
return ( Element ) child ; 
child = child . getPreviousSibling ( ) ; 
} public static Element getChild ( Element parent , String name , String [ ] names , boolean firstToLast ) { 
Assert . isNotNull ( parent ) ; 
for ( int i = 0 ; ! found && i < names . length ; ++ i ) { 
found = names [ i ] . equals ( name ) ; 
Assert . isTrue ( found ) ; 
if ( firstToLast ) { 
i = names . length - 1 ; 
while ( child != null && ! names [ i ] . equals ( name ) ) { 
int mark = i ; 
while ( ! isDAVElement ( child , names [ i ] ) && ! names [ i ] . equals ( name ) ) { 
++ i ; 
-- i ; 
if ( ! names [ i ] . equals ( name ) ) { 
} else if ( ! isDAVElement ( child , names [ i ] ) ) { 
int pos = i ; 
while ( ! found && ( pos >= 0 && pos < names . length ) ) { 
found = isDAVElement ( child , names [ pos ] ) ; 
++ pos ; 
i = mark ; 
} public static Element getChildElement ( Element parent , boolean firstToLast ) { 
while ( child != null && ! isElement ( child ) ) { 
} public static String getChildText ( Element parent , String name , boolean firstToLast ) { 
Element child ; 
child = getFirstChild ( parent , name ) ; 
child = getLastChild ( parent , name ) ; 
return getText ( child , firstToLast ) ; 
} public static Element getDAVChild ( Element parent ) { 
Node child = parent . getFirstChild ( ) ; 
while ( child != null && ! isDAVElement ( child ) ) 
} public static Element getFirstChild ( Element parent , String [ ] names ) { 
return getChild ( parent , names , true ) ; 
} public static Element getFirstChild ( Element parent , String name ) { 
return getChild ( parent , new String [ ] { name } , true ) ; 
} public static String getFirstText ( Element parent ) { 
while ( child != null && ! isText ( child ) ) 
if ( child == null ) 
return ( ( Text ) child ) . getData ( ) ; 
} public static Element getLastChild ( Element parent , String name ) { 
return getChild ( parent , new String [ ] { name } , false ) ; 
} public static Namespaces getNamespaces ( Element element ) { 
Node parent = element . getParentNode ( ) ; 
while ( parent != null && ! isElement ( parent ) ) 
parent = parent . getParentNode ( ) ; 
Namespaces namespaces = null ; 
namespaces = getNamespaces ( ( Element ) parent ) ; 
return getNamespaces ( element , namespaces , false ) ; 
} protected static Namespaces getNamespaces ( Element element , Namespaces namespaces , boolean removeDuplicateNSDeclarations ) { 
Namespaces newNamespaces = null ; 
if ( namespaces == null ) 
newNamespaces = new Namespaces ( ) ; 
newNamespaces = new Namespaces ( namespaces ) ; 
Vector oldAttributes = new Vector ( ) ; 
NamedNodeMap nodeMap = element . getAttributes ( ) ; 
String name = attr . getName ( ) ; 
if ( name . startsWith ( XML_PREFIX ) ) { 
String nsName = attr . getValue ( ) ; 
if ( name . length ( ) == XML_PREFIX . length ( ) ) { 
if ( nsName . equals ( "" ) ) 
newNamespaces . setDefaultNSName ( null ) ; 
newNamespaces . setDefaultNSName ( nsName ) ; 
} else if ( name . charAt ( XML_PREFIX . length ( ) ) == ':' ) { 
String nsPrefix = name . substring ( XML_PREFIX . length ( ) + 1 ) ; 
if ( nsPrefix . length ( ) > 0 && nsName . length ( ) > 0 ) { 
newNamespaces . putNSName ( nsPrefix , nsName ) ; 
boolean prefixExists = newNamespaces . getNSPrefix ( nsName ) != null ; 
if ( ! prefixExists ) 
newNamespaces . putNSPrefix ( nsName , nsPrefix ) ; 
if ( removeDuplicateNSDeclarations && ( prefixExists || nsName . equals ( newNamespaces . getDefaultNSName ( ) ) ) ) 
oldAttributes . addElement ( attr ) ; 
Enumeration e = oldAttributes . elements ( ) ; 
while ( e . hasMoreElements ( ) ) 
element . removeAttributeNode ( ( Attr ) e . nextElement ( ) ) ; 
return newNamespaces ; 
} public static Element getNextSibling ( Element element ) { 
Node sibling = element ; 
sibling = sibling . getNextSibling ( ) ; 
} while ( sibling != null && ! isElement ( sibling ) ) ; 
return ( Element ) sibling ; 
} public static Element getNextSibling ( Element element , String [ ] names ) { 
Assert . isTrue ( isDAVElement ( element ) ) ; 
Node sibling = element . getNextSibling ( ) ; 
while ( sibling != null ) { 
if ( isDAVElement ( sibling , names [ i ] ) ) 
} public static Element getNextSibling ( Element element , String name ) { 
return getNextSibling ( element , new String [ ] { name } ) ; 
} public static String getNSLocalName ( String name ) { 
int p = name . lastIndexOf ( ':' ) ; 
if ( p == - 1 ) 
if ( p == name . length ( ) - 1 ) 
return name . substring ( p + 1 ) ; 
} public static String getNSLocalName ( Element element ) { 
return getNSLocalName ( element . getTagName ( ) ) ; 
} public static String getNSName ( Element element ) throws MalformedElementException { 
String nsPrefix = getNSPrefix ( element ) ; 
String nsName = resolve ( nsPrefix , element ) ; 
if ( nsPrefix != null && nsName == null ) 
throw new MalformedElementException ( Policy . bind ( "exception.namespacePrefixNotResolved" , nsPrefix ) ) ; 
return nsName ; 
} public static String getNSPrefix ( String name ) { 
if ( p <= 0 ) 
return name . substring ( 0 , p ) ; 
} public static String getNSPrefix ( Element element ) { 
return getNSPrefix ( element . getTagName ( ) ) ; 
} public static QualifiedName getQualifiedName ( Element element ) throws MalformedElementException { 
String nsName = getNSName ( element ) ; 
String nsLocalName = getNSLocalName ( element ) ; 
if ( nsLocalName == null ) 
throw new MalformedElementException ( Policy . bind ( "exception.noLocalNameForElmt" ) ) ; 
return new QualifiedNameImpl ( nsName , nsLocalName ) ; 
} public static Element getSibling ( Element element , String name , boolean firstToLast ) { 
sibling = sibling . getPreviousSibling ( ) ; 
} while ( sibling != null && ! isDAVElement ( sibling , name ) ) ; 
} public static String getText ( Element parent , boolean firstToLast ) { 
while ( child != null && ! isText ( child ) ) { 
} public static Element getTwin ( Element element , boolean firstToLast ) { 
String name = getNSLocalName ( element ) ; 
return getSibling ( element , name , firstToLast ) ; 
} public static Element insertBefore ( Element sibling , String name ) { 
Assert . isTrue ( isDAVElement ( sibling ) ) ; 
String nsPrefix = getNSPrefix ( sibling ) ; 
Element newSibling = sibling . getOwnerDocument ( ) . createElement ( tagName ) ; 
sibling . getParentNode ( ) . insertBefore ( newSibling , sibling ) ; 
return newSibling ; 
} public static boolean isDAVElement ( Node node ) { 
if ( ! DAV_NS . equals ( getNSName ( ( Element ) node ) ) ) 
} public static boolean isDAVElement ( Node node , String name ) { 
if ( ! name . equals ( getNSLocalName ( element ) ) || ! DAV_NS . equals ( getNSName ( element ) ) ) { 
} public static Node reduceNS ( Node node , Namespaces parentNamespaces ) throws MalformedElementException { 
Namespaces namespaces = parentNamespaces ; 
namespaces = getNamespaces ( element , parentNamespaces , false ) ; 
if ( nsPrefix != null ) { 
String nsName = namespaces . getNSName ( nsPrefix ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingNamespaceForPrefix" , nsPrefix ) , nsName ) ; 
String tagName = null ; 
if ( nsName . equals ( namespaces . getDefaultNSName ( ) ) ) { 
tagName = nsLocalName ; 
tagName = namespaces . getNSPrefix ( nsName ) + ":" + nsLocalName ; 
if ( ! tagName . equals ( element . getTagName ( ) ) ) { 
Document document = element . getOwnerDocument ( ) ; 
Element newElement = document . createElement ( tagName ) ; 
newElement . setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; 
Node child = element . getFirstChild ( ) ; 
element . removeChild ( child ) ; 
newElement . appendChild ( child ) ; 
child = element . getFirstChild ( ) ; 
element . getParentNode ( ) . replaceChild ( newElement , element ) ; 
element = newElement ; 
Vector newAttributes = new Vector ( ) ; 
String value = attr . getValue ( ) ; 
String newName = name ; 
nsPrefix = getNSPrefix ( name ) ; 
nsLocalName = getNSLocalName ( name ) ; 
String newNSPrefix = namespaces . getNSPrefix ( nsName ) ; 
if ( ! newNSPrefix . equals ( nsPrefix ) ) { 
newName = newNSPrefix + ":" + nsLocalName ; 
boolean newAttribute = true ; 
if ( parentNamespaces != null ) { 
if ( nsPrefix == null && XML_PREFIX . equals ( nsLocalName ) ) { 
if ( value . equals ( parentNamespaces . getDefaultNSName ( ) ) ) { 
newAttribute = false ; 
if ( nsPrefix != null && XML_PREFIX . equals ( nsPrefix ) ) { 
if ( parentNamespaces . getNSPrefix ( value ) != null ) { 
if ( newAttribute ) { 
newAttributes . addElement ( new String [ ] { newName , value } ) ; 
Enumeration oldAttrs = oldAttributes . elements ( ) ; 
while ( oldAttrs . hasMoreElements ( ) ) { 
element . removeAttributeNode ( ( Attr ) oldAttrs . nextElement ( ) ) ; 
Enumeration newAttrs = newAttributes . elements ( ) ; 
while ( newAttrs . hasMoreElements ( ) ) { 
String [ ] newAttr = ( String [ ] ) newAttrs . nextElement ( ) ; 
element . setAttribute ( newAttr [ 0 ] , newAttr [ 1 ] ) ; 
node = element ; 
child = reduceNS ( child , namespaces ) ; 
} public static String resolve ( String prefix , Element element ) { 
if ( XML_NS_PREFIX . equals ( prefix ) ) { 
return XML_NS_NAME ; 
Node current = element ; 
NamedNodeMap attrs = current . getAttributes ( ) ; 
int n = attrs . getLength ( ) ; 
Attr attr = ( Attr ) attrs . item ( i ) ; 
if ( prefix == null ) { 
if ( nsName . equals ( "" ) ) { 
if ( prefix != null && name . equals ( XML_PREFIX + ":" + prefix ) ) { 
return attr . getValue ( ) ; 
current = current . getParentNode ( ) ; 
} while ( current != null && current . getNodeType ( ) != Node . ELEMENT_NODE ) ; 
} while ( current != null ) ; 
} public static Element setChild ( Element parent , String name , String [ ] names , boolean firstToLast ) { 
setChild ( parent , child , names , firstToLast ) ; 
} public static void setChild ( Element parent , Element child , String [ ] names , boolean firstToLast ) { 
Assert . isNotNull ( child ) ; 
Assert . isTrue ( DAV_NS . equals ( resolve ( getNSPrefix ( child ) , parent ) ) ) ; 
String name = getNSLocalName ( child ) ; 
Node sibling = getChild ( parent , name , names , firstToLast ) ; 
if ( isDAVElement ( sibling , name ) ) { 
parent . replaceChild ( child , sibling ) ; 
} else if ( firstToLast ) { 
if ( sibling == null ) { 
parent . insertBefore ( child , sibling ) ; 
Node refChild = null ; 
refChild = parent . getFirstChild ( ) ; 
refChild = sibling . getNextSibling ( ) ; 
if ( refChild == null ) { 
parent . insertBefore ( child , refChild ) ; 
} public void reset ( ) throws IOException { 
( ( ByteArrayInputStream ) is ) . reset ( ) ; 
if ( fos != null ) { 
while ( skip ( 4096 ) > 0 ) ; 
fos = null ; 
if ( length == - 1 ) { 
length = totalBytesRead ; 
is = new FileInputStream ( file ) ; 
totalBytesRead = 0 ; 
} protected void createActions ( ) { 
super . createActions ( ) ; 
IAction a = new TextOperationAction ( RuleEditorMessages 
. getResourceBundle ( ) , "ContentAssistProposal." , this , 
ISourceViewer . CONTENTASSIST_PROPOSALS ) ; 
a 
. setActionDefinitionId ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ) ; 
setAction ( "ContentAssistProposal" , a ) ; 
a = new TextOperationAction ( 
RuleEditorMessages . getResourceBundle ( ) , 
"ContentAssistTip." , this , ISourceViewer . CONTENTASSIST_CONTEXT_INFORMATION ) ; 
. setActionDefinitionId ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_CONTEXT_INFORMATION ) ; 
setAction ( "ContentAssistTip" , a ) ; 
a = new ToggleBreakpointAction ( getSite ( ) . getPart ( ) , null , getVerticalRuler ( ) ) ; 
setAction ( ITextEditorActionConstants . RULER_DOUBLE_CLICK , a ) ; 
} public void addConnection ( Connection conn ) { 
if ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) { 
if ( conn . getSource ( ) == this ) { 
sourceConnections . add ( conn ) ; 
firePropertyChange ( SOURCE_CONNECTIONS_PROP , 
conn ) ; 
} else if ( conn . getTarget ( ) == this ) { 
targetConnections . add ( conn ) ; 
firePropertyChange ( TARGET_CONNECTIONS_PROP , 
} public Object getPropertyValue ( Object propertyId ) { 
if ( XPOS_PROP . equals ( propertyId ) ) { 
return Integer . toString ( location . x ) ; 
if ( YPOS_PROP . equals ( propertyId ) ) { 
return Integer . toString ( location . y ) ; 
if ( HEIGHT_PROP . equals ( propertyId ) ) { 
return Integer . toString ( size . height ) ; 
if ( WIDTH_PROP . equals ( propertyId ) ) { 
return Integer . toString ( size . width ) ; 
} public void removeConnection ( Connection conn ) { 
if ( conn == null ) { 
sourceConnections . remove ( conn ) ; 
targetConnections . remove ( conn ) ; 
} public void setLocation ( Point newLocation ) { 
if ( newLocation == null ) { 
location . setLocation ( newLocation ) ; 
firePropertyChange ( LOCATION_PROP , 
location ) ; 
} public void setPropertyValue ( Object propertyId , 
Object value ) { 
int x = Integer . parseInt ( ( String ) value ) ; 
setLocation ( new Point ( x , 
location . y ) ) ; 
} else if ( YPOS_PROP . equals ( propertyId ) ) { 
int y = Integer . parseInt ( ( String ) value ) ; 
setLocation ( new Point ( location . x , 
y ) ) ; 
} else if ( HEIGHT_PROP . equals ( propertyId ) ) { 
int height = Integer . parseInt ( ( String ) value ) ; 
setSize ( new Dimension ( size . width , 
height ) ) ; 
} else if ( WIDTH_PROP . equals ( propertyId ) ) { 
int width = Integer . parseInt ( ( String ) value ) ; 
setSize ( new Dimension ( width , 
size . height ) ) ; 
} public void setSize ( Dimension newSize ) { 
if ( newSize != null ) { 
size . setSize ( newSize ) ; 
firePropertyChange ( SIZE_PROP , 
size ) ; 
} public static String dumpConstraints ( final Constraint [ ] constraints ) { 
if ( constraints == null ) { 
final StringBuffer buffer = new StringBuffer ( ) ; 
for ( int i = 0 , length = constraints . length ; i < length ; i ++ ) { 
buffer . append ( constraints [ i ] . toString ( ) + "<br>" ) ; 
} public void setZoomManager ( ZoomManager newManager ) { 
if ( zoomManager != null ) { 
zoomManager . removeZoomListener ( this ) ; 
zoomManager = newManager ; 
zoomManager . addZoomListener ( this ) ; 
} public static Map < String , ResourceProperties > parseListing ( String base , InputStream is ) throws Exception { 
Map < String , ResourceProperties > res = new HashMap < String , ResourceProperties > ( ) ; 
DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; 
factory . setNamespaceAware ( true ) ; 
DocumentBuilder parser = factory . newDocumentBuilder ( ) ; 
Document doc = parser . parse ( is ) ; 
NodeList nl = doc . getElementsByTagNameNS ( DAV_NS , "response" ) ; 
for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { 
Element oneElem = ( Element ) nl . item ( i ) ; 
NodeList resName = oneElem . getElementsByTagNameNS ( DAV_NS , "href" ) ; 
assert ( resName . getLength ( ) == 1 ) ; 
String bareName = extractOverlap ( base , URLDecoder . decode ( resName . item ( 0 ) . getTextContent ( ) , "UTF-8" ) ) ; 
if ( bareName . trim ( ) . length ( ) > 0 ) { 
ResourceProperties props = new ResourceProperties ( ) ; 
NodeList propList = oneElem . getElementsByTagNameNS ( DAV_NS , "resourcetype" ) ; 
assert ( propList . getLength ( ) == 1 ) ; 
NodeList resTypeList = ( ( Element ) propList . item ( 0 ) ) . getElementsByTagNameNS ( DAV_NS , "collection" ) ; 
assert ( resTypeList . getLength ( ) < 2 ) ; 
if ( resTypeList . getLength ( ) == 1 ) { 
props . setDirectory ( true ) ; 
propList = oneElem . getElementsByTagNameNS ( DAV_NS , "creationdate" ) ; 
if ( propList . getLength ( ) > 0 ) { 
props . setCreationDate ( propList . item ( 0 ) . getTextContent ( ) ) ; 
propList = oneElem . getElementsByTagNameNS ( DAV_NS , "getlastmodified" ) ; 
props . setLastModifiedDate ( propList . item ( 0 ) . getTextContent ( ) ) ; 
String normBase = base . trim ( ) . endsWith ( "/" ) ? base . trim ( ) : base . trim ( ) + "/" ; 
props . setBase ( normBase ) ; 
res . put ( bareName , props ) ; 
} public int compare ( Viewer viewer , Object o1 , Object o2 ) { 
DSLMappingEntry item1 = ( DSLMappingEntry ) o1 ; 
DSLMappingEntry item2 = ( DSLMappingEntry ) o2 ; 
switch ( criteria ) { 
case OBJECT : 
return compareObject ( item1 , item2 ) ; 
case EXPRESSION : 
return compareExpressions ( item1 , item2 ) ; 
case MAPPING : 
return compareMappings ( item1 , item2 ) ; 
case SCOPE : 
return compareScope ( item1 , item2 ) ; 
} public LockEntry addLockEntry ( ) { 
Element lockentry = addChild ( root , "lockentry" , childNames , false ) ; 
Element locktype = appendChild ( lockentry , "locktype" ) ; 
LockEntry result = null ; 
result = new LockEntry ( lockentry ) ; 
} public Enumeration getLockEntries ( ) throws MalformedElementException { 
final Node firstLockEntry = getFirstChild ( root , "lockentry" ) ; 
Node currentLockEntry = firstLockEntry ; 
return currentLockEntry != null ; 
result = new LockEntry ( ( Element ) currentLockEntry ) ; 
currentLockEntry = getTwin ( ( Element ) currentLockEntry , true ) ; 
} public void createPartControl ( Composite parent ) { 
viewer = new TreeViewer ( parent , SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL ) ; 
drillDownAdapter = new DrillDownAdapter ( viewer ) ; 
viewer . setContentProvider ( new RepositoryContentProvider ( ) ) ; 
viewer . setLabelProvider ( new RepositoryLabelProvider ( ) ) ; 
viewer . setSorter ( new NameSorter ( ) ) ; 
viewer . setInput ( viewer ) ; 
makeActions ( ) ; 
hookContextMenu ( ) ; 
hookDoubleClickAction ( ) ; 
contributeToActionBars ( ) ; 
Activator . getLocationManager ( ) . addRepositorySetListener ( new IRepositorySetListener ( ) { 
public void repositorySetChanged ( int type , List < GuvnorRepository > repList ) { 
super . getSite ( ) . setSelectionProvider ( viewer ) ; 
addDragDropSupport ( ) ; 
} public boolean addChild ( BaseVertex vertex ) { 
if ( vertex != null && vertices . add ( vertex ) ) { 
firePropertyChange ( PROP_CHILD_ADDED , 
vertex ) ; 
} public boolean removeChild ( BaseVertex vertex ) { 
if ( vertex != null && vertices . remove ( vertex ) ) { 
firePropertyChange ( PROP_CHILD_REMOVED , 
} public void start ( BundleContext context ) throws Exception { 
super . start ( context ) ; 
IPreferenceStore preferenceStore = getPreferenceStore ( ) ; 
useCachePreference = preferenceStore . getBoolean ( IDroolsConstants . CACHE_PARSED_RULES ) ; 
preferenceStore . addPropertyChangeListener ( new IPropertyChangeListener ( ) { 
public void propertyChange ( PropertyChangeEvent event ) { 
if ( IDroolsConstants . CACHE_PARSED_RULES . equals ( event . getProperty ( ) ) ) { 
useCachePreference = ( ( Boolean ) event . getNewValue ( ) ) . booleanValue ( ) ; 
if ( ! useCachePreference ) { 
clearCache ( ) ; 
} public void stop ( BundleContext context ) throws Exception { 
super . stop ( context ) ; 
plugin = null ; 
resourceBundle = null ; 
parsedRules = null ; 
compiledRules = null ; 
processInfos = null ; 
processInfosById = null ; 
for ( Color color : colors . values ( ) ) { 
color . dispose ( ) ; 
} public static String getResourceString ( String key ) { 
ResourceBundle bundle = DroolsEclipsePlugin . getDefault ( ) . getResourceBundle ( ) ; 
return ( bundle != null ) ? bundle . getString ( key ) : key ; 
} catch ( MissingResourceException e ) { 
} public ResourceBundle getResourceBundle ( ) { 
if ( resourceBundle == null ) resourceBundle = ResourceBundle . getBundle ( "droolsIDE.DroolsIDEPluginResources" ) ; 
} catch ( MissingResourceException x ) { 
return resourceBundle ; 
} public FormColors getRuleBuilderFormColors ( Display display ) { 
if ( ruleBuilderFormColors == null ) { 
ruleBuilderFormColors = new FormColors ( display ) ; 
ruleBuilderFormColors . markShared ( ) ; 
return ruleBuilderFormColors ; 
} public void setDateTime ( String date ) { 
String [ ] patterns = { RFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } ; 
for ( int i = 0 ; i < patterns . length ; i ++ ) { 
if ( setDateTime ( date , patterns [ i ] ) ) 
} protected boolean setDateTime ( String date , String pattern ) { 
boolean dateChanged = true ; 
dateFormat . applyPattern ( pattern ) ; 
setDateTime ( dateFormat . parse ( date ) ) ; 
dateChanged = false ; 
return dateChanged ; 
} public static String getDefaultRepositoryDir ( ) { 
String key = core_defaultRepositoryDir ; 
String dir = getDeprecatedRepoRootPreference ( ) ; 
IEclipsePreferences p = InstanceScope . INSTANCE . getNode ( egitPluginId ) ; 
dir = p . get ( key , getDefaultDefaultRepositoryDir ( ) ) ; 
IStringVariableManager manager = VariablesPlugin . getDefault ( ) . getStringVariableManager ( ) ; 
String result ; 
result = manager . performStringSubstitution ( dir ) ; 
} catch ( CoreException e ) { 
result = "" ; 
if ( result == null || result . isEmpty ( ) ) { 
result = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getRawLocation ( ) . toOSString ( ) ; 
} public void stop ( BundleContext bundleContext ) throws Exception { 
context = null ; 
instance = null ; 
super . stop ( bundleContext ) ; 
} public static IStatus error ( final String message , final Throwable thr ) { 
return new Status ( IStatus . ERROR , PLUGIN_ID , 0 , message , thr ) ; 
} public static void logError ( final String message , final Throwable thr ) { 
getDefault ( ) . getLog ( ) . log ( error ( message , thr ) ) ; 
} protected void addField ( FieldEditor editor ) { 
if ( fields == null ) { 
fields = new ArrayList < FieldEditor > ( ) ; 
String name = editor . getPreferenceName ( ) ; 
editor . setPreferenceName ( getPreferenceName ( name ) ) ; 
fields . add ( editor ) ; 
} protected void adjustGridLayout ( ) { 
int numColumns = calcNumberOfColumns ( ) ; 
( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; 
FieldEditor fieldEditor = fields . get ( i ) ; 
fieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; 
} protected void applyFont ( ) { 
Iterator < FieldEditor > e = fields . iterator ( ) ; 
while ( e . hasNext ( ) ) { 
FieldEditor pe = e . next ( ) ; 
} private int calcNumberOfColumns ( ) { 
result = Math . max ( result , pe . getNumberOfControls ( ) ) ; 
} protected void checkState ( ) { 
invalidFieldEditor = null ; 
int size = fields . size ( ) ; 
FieldEditor editor = fields . get ( i ) ; 
valid = valid && editor . isValid ( ) ; 
invalidFieldEditor = editor ; 
setValid ( valid ) ; 
protected Control createContents ( Composite parent ) { 
fieldEditorParent = new Composite ( parent , SWT . NULL ) ; 
GridLayout layout = new GridLayout ( ) ; 
layout . numColumns = 1 ; 
layout . marginHeight = 0 ; 
layout . marginWidth = 0 ; 
fieldEditorParent . setLayout ( layout ) ; 
fieldEditorParent . setFont ( parent . getFont ( ) ) ; 
createFieldEditors ( ) ; 
if ( style == GRID ) { 
adjustGridLayout ( ) ; 
return fieldEditorParent ; 
public void dispose ( ) { 
super . dispose ( ) ; 
pe . setPage ( null ) ; 
pe . setPropertyChangeListener ( null ) ; 
pe . setPreferenceStore ( null ) ; 
} protected Composite getFieldEditorParent ( ) { 
if ( style == FLAT ) { 
Composite parent = new Composite ( fieldEditorParent , SWT . NULL ) ; 
parent . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; 
} protected void initialize ( ) { 
pe . setPage ( this ) ; 
pe . setPropertyChangeListener ( this ) ; 
pe . setPreferenceStore ( getPreferenceStore ( ) ) ; 
pe . load ( ) ; 
protected void performDefaults ( ) { 
pe . loadDefault ( ) ; 
super . performDefaults ( ) ; 
public boolean performOk ( ) { 
pe . store ( ) ; 
if ( event . getProperty ( ) . equals ( FieldEditor . IS_VALID ) ) { 
boolean newValue = ( ( Boolean ) event . getNewValue ( ) ) . booleanValue ( ) ; 
invalidFieldEditor = ( FieldEditor ) event . getSource ( ) ; 
setValid ( newValue ) ; 
public void setVisible ( boolean visible ) { 
super . setVisible ( visible ) ; 
if ( visible && invalidFieldEditor != null ) { 
invalidFieldEditor . setFocus ( ) ; 
} public boolean contains ( String name ) { 
JsonValue value = object . get ( name ) ; 
return value != null ; 
} public void firePropertyChangeEvent ( String name , Object oldValue , Object newValue ) { 
firePropertyChangeEvent ( this , name , oldValue , newValue ) ; 
} public void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { 
PropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; 
Object [ ] listeners = fListeners . getListeners ( ) ; 
for ( int i = 0 ; i < listeners . length ; i ++ ) 
( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; 
} public void putValue ( String name , String value ) { 
object . set ( name , value ) ; 
dirty = true ; 
} public void setValue ( String name , String value ) { 
String oldValue = this . getString ( name ) ; 
putValue ( name , value ) ; 
firePropertyChangeEvent ( name , oldValue , value ) ; 
} public void run ( IAction action ) { 
if ( selectedFile == null 
|| props == null 
|| targetPart == null ) { 
VersionChooserDialog dialog = 
new VersionChooserDialog ( targetPart . getSite ( ) . getShell ( ) , 
selectedFile . getName ( ) , 
getVersionEntries ( ) ) ; 
if ( dialog . open ( ) == VersionChooserDialog . OK ) { 
compareWithSelectedVersion ( dialog . getSelectedEntry ( ) ) ; 
} public void init ( IActionBars bars , 
IWorkbenchPage page ) { 
contributor . init ( bars ) ; 
super . init ( bars , 
page ) ; 
} public void setActivePage ( IEditorPart activeEditor ) { 
IActionBars bars = getActionBars ( ) ; 
if ( activeEditor instanceof ITextEditor ) { 
if ( bars != null ) { 
contributor . setActiveEditor ( activeEditor ) ; 
} public void setActiveEditor ( IEditorPart part ) { 
super . setActiveEditor ( part ) ; 
if ( part instanceof DRLRuleEditor2 ) { 
DRLRuleEditor2 p = ( DRLRuleEditor2 ) part ; 
p . setZoomComboContributionItem ( zitem ) ; 
p . setZoomInAction ( zoomIn ) ; 
p . setZoomOutAction ( zoomOut ) ; 
} public void contributeToToolBar ( IToolBarManager toolBarManager ) { 
super . contributeToToolBar ( toolBarManager ) ; 
toolBarManager . add ( new Separator ( ) ) ; 
String [ ] zoomStrings = new String [ ] { ZoomManager . FIT_ALL , ZoomManager . FIT_HEIGHT , ZoomManager . FIT_WIDTH } ; 
zitem = new ZoomComboContributionItem ( getPage ( ) , 
zoomStrings ) ; 
zitem . setZoomManager ( null ) ; 
zitem . setVisible ( false ) ; 
zoomIn = new ZoomInAction2 ( ) ; 
zoomIn . setEnabled ( false ) ; 
zoomOut = new ZoomOutAction2 ( ) ; 
zoomOut . setEnabled ( false ) ; 
toolBarManager . add ( zitem ) ; 
toolBarManager . add ( zoomIn ) ; 
toolBarManager . add ( zoomOut ) ; 
} private void determineDialect ( String backText ) { 
dialect = null ; 
boolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; 
boolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; 
if ( mvel ) { 
dialect = MVEL_DIALECT ; 
} else if ( java ) { 
dialect = JAVA_DIALECT ; 
} public Map < String , String [ ] > getRuleParameters ( ) { 
Map < String , String [ ] > result = new HashMap < String , String [ ] > ( ) ; 
int lastLocation = - 1 ; 
for ( Object o : parserList ) { 
if ( o instanceof DroolsToken ) { 
DroolsToken token = ( DroolsToken ) o ; 
if ( DroolsEditorType . IDENTIFIER_VARIABLE . equals ( token . getEditorType ( ) ) || DroolsEditorType . IDENTIFIER_PATTERN . equals ( token . getEditorType ( ) ) ) { 
String variableName = token . getText ( ) ; 
if ( lastLocation == Location . LOCATION_LHS_BEGIN_OF_CONDITION ) { 
int j = i + 2 ; 
String className = "" ; 
while ( j < parserList . size ( ) ) { 
Object obj = parserList . get ( j ++ ) ; 
if ( obj instanceof DroolsToken ) { 
String s = ( ( DroolsToken ) obj ) . getText ( ) ; 
if ( "(" . equals ( s ) ) { 
result . put ( variableName , new String [ ] { className , null } ) ; 
className += s ; 
} else if ( lastLocation == Location . LOCATION_LHS_INSIDE_CONDITION_START ) { 
int index = findTokenBack ( Location . LOCATION_LHS_BEGIN_OF_CONDITION , i ) ; 
int j = index + 3 ; 
while ( j < i ) { 
j = i + 2 ; 
String propertyName = "" ; 
if ( "," . equals ( s ) || ")" . equals ( s ) ) { 
result . put ( variableName , new String [ ] { className , propertyName } ) ; 
propertyName += s ; 
} else if ( o instanceof Integer ) { 
lastLocation = ( Integer ) o ; 
} public static String decode ( String url ) { 
return decode ( new URL ( url ) ) . toString ( ) ; 
String ref = null ; 
int lastSlashIndex = url . lastIndexOf ( '/' ) ; 
int lastHashIndex = url . lastIndexOf ( '#' ) ; 
if ( ( lastHashIndex - lastSlashIndex > 1 ) && lastHashIndex < url . length ( ) - 1 ) { 
file = url . substring ( 0 , lastHashIndex ) ; 
ref = url . substring ( lastHashIndex + 1 , url . length ( ) ) ; 
file = url ; 
return decode ( file , ref ) ; 
} public static String decode ( String file , String ref ) { 
StringTokenizer tokenizer = new StringTokenizer ( file , "/" , true ) ; 
while ( tokenizer . hasMoreTokens ( ) ) { 
String token = tokenizer . nextToken ( ) ; 
if ( token . equals ( "/" ) ) { 
buf . append ( token ) ; 
buf . append ( decodeSegment ( token ) ) ; 
if ( ref != null ) { 
buf . append ( decodeSegment ( ref ) ) ; 
} public static String encode ( byte [ ] data ) { 
byte b = 0 ; 
int bits = 2 ; 
for ( int i = 0 ; i < data . length ; ++ i ) { 
b = ( byte ) ( ( b | ( data [ i ] > > bits ) ) & 0x003f ) ; 
buf . append ( encode ( b ) ) ; 
b = ( byte ) ( ( data [ i ] << 6 - bits ) & 0x003f ) ; 
bits += 2 ; 
if ( bits == 8 ) { 
buf . append ( encode ( ( byte ) ( b & 0x003f ) ) ) ; 
b = 0 ; 
bits = 2 ; 
if ( bits == 4 ) { 
buf . append ( "==" ) ; 
} else if ( bits == 6 ) { 
buf . append ( '=' ) ; 
} protected IContext newContext ( IContext userContext , ILocator locator ) throws MalformedURLException { 
Assert . isNotNull ( userContext ) ; 
Assert . isNotNull ( locator ) ; 
IContext context = davFactory . newContext ( userContext ) ; 
if ( locator . getLabel ( ) != null ) 
context . setLabel ( locator . getLabel ( ) ) ; 
return context ; 
} public void doSave ( IProgressMonitor monitor ) { 
FileEditorInput input = ( FileEditorInput ) getEditorInput ( ) ; 
File outputFile = input . getFile ( ) . getLocation ( ) . toFile ( ) ; 
saveFile ( monitor , 
outputFile , 
input ) ; 
} private void createTableListeners ( ) { 
table . addSelectionListener ( new SelectionListener ( ) { 
populate ( ) ; 
public void widgetDefaultSelected ( SelectionEvent e ) { 
private void populate ( ) { 
DSLMappingEntry selected = getCurrentSelected ( ) ; 
exprText . setText ( selected . getMappingKey ( ) ) ; 
mappingText . setText ( selected . getMappingValue ( ) ) ; 
objText . setText ( selected . getMetaData ( ) . getMetaData ( ) == null ? "" : selected . getMetaData ( ) . getMetaData ( ) ) ; 
table . addMouseListener ( new MouseListener ( ) { 
public void mouseDoubleClick ( MouseEvent e ) { 
showEditPopup ( ) ; 
public void mouseDown ( MouseEvent e ) { 
public void mouseUp ( MouseEvent e ) { 
} private void createTable ( Composite parent ) { 
int style = SWT . MULTI | SWT . BORDER | SWT . H_SCROLL | SWT . V_SCROLL | SWT . FULL_SELECTION | SWT . HIDE_SELECTION ; 
table = new Table ( parent , 
style ) ; 
GridData gridData = new GridData ( GridData . FILL_BOTH ) ; 
gridData . grabExcessVerticalSpace = true ; 
gridData . horizontalSpan = 3 ; 
table . setLayoutData ( gridData ) ; 
table . setLinesVisible ( true ) ; 
table . setHeaderVisible ( true ) ; 
TableColumn column ; 
column = new TableColumn ( table , 
SWT . LEFT , 
0 ) ; 
column . setWidth ( 350 ) ; 
column . addSelectionListener ( new SelectionAdapter ( ) { 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . EXPRESSION ) ) ; 
1 ) ; 
column . setWidth ( 200 ) ; 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . MAPPING ) ) ; 
2 ) ; 
column . setText ( "Object" ) ; 
column . setWidth ( 80 ) ; 
3 ) ; 
column . setText ( "Scope" ) ; 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . SCOPE ) ) ; 
} public Object get ( String url ) throws MalformedURLException { 
Assert . isNotNull ( url ) ; 
return get ( new URL ( url ) ) ; 
} public Object get ( URL url ) { 
return get ( new URLKey ( url ) ) ; 
} private Object get ( URLKey url ) { 
return table . get ( url ) ; 
} public Enumeration keys ( ) { 
final Enumeration keys = table . keys ( ) ; 
return keys . hasMoreElements ( ) ; 
return ( ( URLKey ) keys . nextElement ( ) ) . getURL ( ) ; 
} public void put ( String url , Object value ) throws MalformedURLException { 
Assert . isNotNull ( value ) ; 
put ( new URL ( url ) , value ) ; 
} public void put ( URL url , Object value ) { 
put ( new URLKey ( url ) , value ) ; 
} private void put ( URLKey url , Object value ) { 
if ( table . get ( url ) != null ) 
table . remove ( url ) ; 
table . put ( url , value ) ; 
} public Node addToken ( String token ) { 
Node newnode = new Node ( token ) ; 
newnode . setDepth ( depth + 1 ) ; 
newnode = addChild ( newnode ) ; 
return newnode ; 
} public Node addChild ( Node n ) { 
if ( ! this . children . containsKey ( n . getToken ( ) ) ) { 
this . children . put ( n . getToken ( ) , n ) ; 
n . setParent ( this ) ; 
return ( Node ) this . children . get ( n . getToken ( ) ) ; 
} void setFile ( IFile file , int offset , int length ) { 
} public boolean canExecute ( ) { 
Object type = request . getType ( ) ; 
return ( RequestConstants . REQ_MOVE . equals ( type ) || RequestConstants . REQ_MOVE_CHILDREN . equals ( type ) ) ; 
} public void addCondition ( Condition condition ) throws WebDAVException { 
Enumeration conditions = getConditions ( ) ; 
if ( condition . getResourceURI ( ) != null ) { 
while ( conditions . hasMoreElements ( ) ) { 
Condition existingCondition = ( Condition ) conditions . nextElement ( ) ; 
if ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMultipleSpecification" , condition . getResourceURI ( ) ) ) ; 
this . conditions . addElement ( condition ) ; 
} public void addStateTokenCondition ( String resourceURI , String stateToken ) throws WebDAVException { 
Condition condition = new Condition ( resourceURI ) ; 
term . addConditionFactor ( new StateToken ( stateToken ) ) ; 
condition . addConditionTerm ( term ) ; 
addCondition ( condition ) ; 
} public boolean matches ( Condition condition ) { 
boolean match = false ; 
while ( ! match && conditions . hasMoreElements ( ) ) { 
match = existingCondition . matches ( condition ) ; 
} static public void isNotNull ( Object o , String message ) { 
throw new AssertionFailedException ( Policy . bind ( "assert.null" , message ) ) ; 
} static public boolean isTrue ( boolean expression , String message ) { 
if ( ! expression ) 
throw new AssertionFailedException ( Policy . bind ( "assert.fail" , message ) ) ; 
return expression ; 
} public Prop getProp ( ) throws MalformedElementException { 
Element prop = getFirstChild ( root , "prop" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingPropElmt" ) , prop ) ; 
return new Prop ( prop ) ; 
String status = getChildText ( root , "status" , false ) ; 
} public Prop setProp ( ) { 
Element prop = setChild ( root , "prop" , childNames , true ) ; 
setChild ( root , "status" , status , childNames , true ) ; 
} public String getLastLine ( String backText ) { 
BufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; 
String last = "" ; 
String line = null ; 
while ( ( line = breader . readLine ( ) ) != null ) { 
if ( line . length ( ) > 0 ) { 
last = line ; 
DroolsEclipsePlugin . log ( e ) ; 
if ( last . indexOf ( "(" ) > - 1 ) { 
last = last . substring ( last . lastIndexOf ( "(" ) + 1 ) ; 
if ( last . indexOf ( "," ) > - 1 ) { 
last = last . substring ( last . lastIndexOf ( "," ) + 1 ) ; 
if ( last . endsWith ( ")" ) ) { 
last = "" ; 
return last ; 
} public String getLastNonDashLine ( String backText ) { 
if ( line . length ( ) > 0 && ! line . startsWith ( "-" ) ) { 
if ( last . indexOf ( "(" ) > - 1 && ! last . endsWith ( ")" ) ) { 
last = last . substring ( 0 , last . indexOf ( "(" ) ) ; 
} else if ( last . indexOf ( "(" ) > - 1 && last . endsWith ( ")" ) ) { 
} protected List < String > getProposals ( DSLAdapter adapter , String obj , String last , boolean firstLine ) { 
if ( last . length ( ) == 0 ) { 
return adapter . getDSLTree ( ) . getChildrenList ( obj , last , true , firstLine ) ; 
} public static String bind ( String id , String binding ) { 
return bind ( id , new String [ ] { binding } ) ; 
} public static String bind ( String id , String binding1 , String binding2 ) { 
return bind ( id , new String [ ] { binding1 , binding2 } ) ; 
} public static String bind ( String id , String [ ] bindings ) { 
if ( id == null ) 
String message = null ; 
message = bundle . getString ( id ) ; 
if ( bindings == null ) 
return MessageFormat . format ( message , bindings ) ; 
} public static String encode ( String file , String ref ) { 
buf . append ( encodeSegment ( token ) ) ; 
buf . append ( encodeSegment ( ref ) ) ; 
} public static URL encode ( URL url ) { 
String ref = url . getRef ( ) ; 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , encode ( file , ref ) ) ; 
} protected IFigure createFigure ( ) { 
PolylineConnection connection = new ConnectionFigure ( ) ; 
PolylineDecoration decoration = new PolylineDecoration ( ) ; 
connection . setTargetDecoration ( decoration ) ; 
} private void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) 
throws CoreException , IOException { 
String fileName = "org/jbpm/eclipse/wizard/project/" + exampleType + ".bpmn.template" ; 
IFolder folder = null ; 
folder = project . getProject ( ) . getFolder ( "src/main/resources/com/sample" ) ; 
FileUtils . createFolder ( folder , monitor ) ; 
IFile file = folder . getFile ( "sample.bpmn" ) ; 
InputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; 
file . create ( inputstream , true , monitor ) ; 
file . setContents ( inputstream , true , false , monitor ) ; 
fileName = "org/jbpm/eclipse/wizard/project/ProcessMain-" + exampleType + ".java" ; 
IRuntime runtime = startPage . getRuntime ( ) ; 
if ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { 
fileName += ".v5.template" ; 
fileName += ".template" ; 
folder = project . getProject ( ) . getFolder ( "src/main/java" ) ; 
IPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; 
IPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( "com.sample" , true , monitor ) ; 
inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; 
packageFragment . createCompilationUnit ( "ProcessMain.java" , new String ( FileUtils . readStream ( inputstream ) ) , true , 
monitor ) ; 
if ( "advanced" . equals ( exampleType ) ) { 
folder = project . getProject ( ) . getFolder ( "src/main/resources/META-INF" ) ; 
inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( 
"org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template" ) ; 
file = folder . getFile ( "persistence.xml" ) ; 
} private void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) 
throws JavaModelException , IOException { 
String s = "org/jbpm/eclipse/wizard/project/ProcessJUnit-" + exampleType + ".java" ; 
s += ".v5.template" ; 
s += ".template" ; 
IFolder folder = project . getProject ( ) . getFolder ( "src/main/java" ) ; 
IPackageFragmentRoot packageFragmentRoot = project 
. getPackageFragmentRoot ( folder ) ; 
IPackageFragment packageFragment = packageFragmentRoot 
. createPackageFragment ( "com.sample" , true , monitor ) ; 
InputStream inputstream = getClass ( ) . getClassLoader ( ) 
. getResourceAsStream ( s ) ; 
packageFragment . createCompilationUnit ( "ProcessTest.java" , new String ( 
FileUtils . readStream ( inputstream ) ) , true , monitor ) ; 
protected IKieProjectWizardPage createOnlineExampleProjectPage ( String pageId ) { 
return new AbstractKieOnlineExampleProjectWizardPage ( ONLINE_EXAMPLE_PROJECT_PAGE ) { 
public String getTitle ( ) { 
public String getDescription ( ) { 
public IRuntimeManager getRuntimeManager ( ) { 
return JBPMRuntimeManager . getDefault ( ) ; 
public String getProductId ( ) { 
return "jbpm" ; 
public String getRuntimeId ( ) { 
IPreferenceStore store = org . kie . eclipse . Activator . getDefault ( ) . getPreferenceStore ( ) ; 
String value = store . getString ( getKieVersionPreferenceKey ( ) ) ; 
public List < IKieRepositoryHandler > getRepositories ( IKieSpaceHandler space ) throws IOException { 
return getDelegate ( ) . getRepositories ( space ) ; 
public List < IKieProjectHandler > getProjects ( IKieRepositoryHandler repository ) throws IOException { 
return getDelegate ( ) . getProjects ( repository ) ; 
} public static int indexOf ( Object [ ] array , 
Object objectToFind , 
int startIndex ) { 
if ( array == null ) { 
return INDEX_NOT_FOUND ; 
if ( startIndex < 0 ) { 
startIndex = 0 ; 
if ( objectToFind == null ) { 
for ( int i = startIndex ; i < array . length ; i ++ ) { 
if ( array [ i ] == null ) { 
if ( objectToFind . equals ( array [ i ] ) ) { 
String repositoryLoc = null ; 
String fullPath = null ; 
if ( selectedNode != null ) { 
repositoryLoc = selectedNode . getGuvnorRepository ( ) . getLocation ( ) ; 
fullPath = selectedNode . getFullPath ( ) ; 
|| props == null ) { 
repositoryLoc = props . getRepository ( ) ; 
fullPath = props . getFullpath ( ) ; 
IResponse response = null ; 
IWebDavClient client = WebDavServerCache . getWebDavClient ( repositoryLoc ) ; 
if ( client == null ) { 
client = WebDavClientFactory . createClient ( new URL ( repositoryLoc ) ) ; 
WebDavServerCache . cacheWebDavClient ( repositoryLoc , client ) ; 
InputStream ins = null ; 
response = client . getResourceVersions ( fullPath ) ; 
ins = response . getInputStream ( ) ; 
} catch ( WebDavException wde ) { 
if ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) { 
throw wde ; 
boolean retry = PlatformUtils . getInstance ( ) . 
authenticateForServer ( repositoryLoc , client ) ; 
if ( retry ) { 
if ( ins != null ) { 
Properties verProps = new Properties ( ) ; 
verProps . load ( ins ) ; 
ResourceHistoryView view = PlatformUtils . getResourceHistoryView ( ) ; 
view . setEntries ( repositoryLoc , fullPath , verProps ) ; 
if ( response != null ) { 
response . close ( ) ; 
Activator . getDefault ( ) . writeLog ( IStatus . ERROR , ioe . getMessage ( ) , ioe ) ; 
} public void selectionChanged ( IAction action , ISelection selection ) { 
selectedFile = null ; 
selectedNode = null ; 
props = null ; 
action . setEnabled ( false ) ; 
if ( ! ( selection instanceof IStructuredSelection ) ) { 
IStructuredSelection sel = ( IStructuredSelection ) selection ; 
if ( sel . size ( ) != 1 ) { 
if ( sel . getFirstElement ( ) instanceof IFile ) { 
props = GuvnorMetadataUtils . getGuvnorMetadata ( ( IFile ) sel . getFirstElement ( ) ) ; 
if ( props != null ) { 
selectedFile = ( IFile ) sel . getFirstElement ( ) ; 
action . setEnabled ( true ) ; 
Activator . getDefault ( ) . writeLog ( IStatus . ERROR , e . getMessage ( ) , e ) ; 
if ( sel . getFirstElement ( ) instanceof TreeObject ) { 
if ( ( ( TreeObject ) sel . getFirstElement ( ) ) . getNodeType ( ) == TreeObject . Type . RESOURCE ) { 
selectedNode = ( TreeObject ) sel . getFirstElement ( ) ; 
} public void visitRete ( final Rete rete ) { 
this . rootVertex = ( ReteVertex ) this . visitedNodes . get ( dotId ( rete ) ) ; 
if ( this . rootVertex == null ) { 
this . rootVertex = new ReteVertex ( rete ) ; 
this . visitedNodes . put ( dotId ( rete ) , 
this . rootVertex ) ; 
this . graph . addChild ( this . rootVertex ) ; 
this . parentVertex = this . rootVertex ; 
for ( EntryPointNode node : rete . getEntryPointNodes ( ) . values ( ) ) { 
visit ( node ) ; 
} private void visitNode ( final Object node ) { 
Object realNode = node ; 
if ( node instanceof ObjectHashMap . ObjectEntry ) { 
ObjectHashMap . ObjectEntry entry = ( ObjectHashMap . ObjectEntry ) node ; 
realNode = entry . getValue ( ) ; 
visit ( realNode ) ; 
} private static String dotId ( final Object object ) { 
return Integer . toHexString ( System . identityHashCode ( object ) ) . toUpperCase ( ) ; 
} public Prop addRemove ( ) { 
Element remove = appendChild ( root , "remove" ) ; 
Element prop = appendChild ( remove , "prop" ) ; 
Prop result = null ; 
result = new Prop ( prop ) ; 
} public Prop addSet ( ) { 
Element set = appendChild ( root , "set" ) ; 
Element prop = appendChild ( set , "prop" ) ; 
} public Enumeration getSetsAndRemoves ( ) throws MalformedElementException { 
Node setOrRemove = getFirstChild ( root , new String [ ] { "remove" , "set" } ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingRemoveOrSetElmt" ) , setOrRemove ) ; 
Node property = null ; 
while ( setOrRemove != null && property == null ) { 
Node prop = getFirstChild ( ( Element ) setOrRemove , "prop" ) ; 
property = getChildElement ( ( Element ) prop , true ) ; 
if ( property == null ) 
setOrRemove = getNextSibling ( ( Element ) setOrRemove , new String [ ] { "remove" , "set" } ) ; 
final Node a = setOrRemove ; 
final Node c = property ; 
Node currentSetOrRemove = a ; 
Node currentProperty = c ; 
return currentProperty != null ; 
Directive result = null ; 
result = new Directive ( ( Element ) currentProperty ) ; 
currentProperty = getNextSibling ( ( Element ) currentProperty ) ; 
while ( currentSetOrRemove != null && currentProperty == null ) { 
currentSetOrRemove = getNextSibling ( ( Element ) currentSetOrRemove , new String [ ] { "remove" , "set" } ) ; 
if ( currentSetOrRemove != null ) { 
Node prop = getFirstChild ( ( Element ) currentSetOrRemove , "prop" ) ; 
currentProperty = getChildElement ( ( Element ) prop , true ) ; 
Control contents = super . createContents ( parent ) ; 
setTitle ( title ) ; 
validate ( ) ; 
return contents ; 
protected Control createDialogArea ( Composite parent ) { 
Composite parentComposite = ( Composite ) super . createDialogArea ( parent ) ; 
Composite composite = new Composite ( parentComposite , SWT . NONE ) ; 
composite . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; 
composite . setLayout ( new GridLayout ( 3 , false ) ) ; 
composite . setFont ( parent . getFont ( ) ) ; 
createFields ( composite ) ; 
return parentComposite ; 
protected Control createHelpControl ( Composite parent ) { 
( ( GridLayout ) parent . getLayout ( ) ) . numColumns ++ ; 
errorComposite = new Composite ( parent , SWT . NONE ) ; 
GridData gd = new GridData ( SWT . FILL , SWT . FILL , true , true ) ; 
errorComposite . setLayoutData ( gd ) ; 
errorComposite . setLayout ( new GridLayout ( 2 , false ) ) ; 
Label errorImage = new Label ( errorComposite , SWT . NONE ) ; 
errorImage . setLayoutData ( new GridData ( SWT . BEGINNING , SWT . CENTER , false , false ) ) ; 
errorImage . setImage ( JFaceResources . getImage ( DLG_IMG_TITLE_ERROR ) ) ; 
errorText = new Label ( errorComposite , SWT . NONE ) ; 
gd = new GridData ( SWT . FILL , SWT . CENTER , true , false ) ; 
errorText . setLayoutData ( gd ) ; 
errorText . setText ( "" ) ; 
return errorComposite ; 
public void setErrorMessage ( String newErrorMessage ) { 
if ( errorComposite != null && ! errorComposite . isDisposed ( ) ) { 
if ( newErrorMessage == null || newErrorMessage . isEmpty ( ) ) { 
errorComposite . setVisible ( false ) ; 
( ( GridData ) errorComposite . getLayoutData ( ) ) . exclude = true ; 
errorComposite . setVisible ( true ) ; 
( ( GridData ) errorComposite . getLayoutData ( ) ) . exclude = false ; 
errorText . setText ( newErrorMessage ) ; 
errorText . getParent ( ) . getParent ( ) . layout ( ) ; 
protected Button createButton ( Composite parent , int id , String label , boolean defaultButton ) { 
Button button = super . createButton ( parent , id , label , defaultButton ) ; 
if ( id == IDialogConstants . OK_ID ) 
okButton = button ; 
return button ; 
} public ILocator newLocator ( String resourceURL , String label ) { 
return locatorFactory . newLocator ( resourceURL , label ) ; 
} public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { 
PresentationReconciler reconciler = new PresentationReconciler ( ) ; 
DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( getScanner ( ) ) ; 
reconciler . setDamager ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; 
reconciler . setRepairer ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; 
dr = new DefaultDamagerRepairer ( getScanner ( ) ) ; 
reconciler . setDamager ( dr , DRLPartionScanner . RULE_PART_CONTENT ) ; 
reconciler . setRepairer ( dr , DRLPartionScanner . RULE_PART_CONTENT ) ; 
dr = new DefaultDamagerRepairer ( new SingleTokenScanner ( 
new TextAttribute ( ColorManager . getInstance ( ) . getColor ( 
ColorManager . SINGLE_LINE_COMMENT ) ) ) ) ; 
reconciler . setDamager ( dr , DRLPartionScanner . RULE_COMMENT ) ; 
reconciler . setRepairer ( dr , DRLPartionScanner . RULE_COMMENT ) ; 
return reconciler ; 
new DefaultCompletionProcessor ( editor ) , IDocument . DEFAULT_CONTENT_TYPE ) ; 
new RuleCompletionProcessor ( editor ) , DRLPartionScanner . RULE_PART_CONTENT ) ; 
} public boolean sameAs ( Object obj ) { 
if ( obj == null || ! ( obj instanceof Status ) ) 
Status other = ( Status ) obj ; 
if ( other . code != code || ! other . message . equals ( message ) ) 
return other . extendedStatus . equals ( extendedStatus ) ; 
} public boolean contains ( ConditionTerm term ) { 
Enumeration terms = getConditionTerms ( ) ; 
while ( ! match && terms . hasMoreElements ( ) ) { 
ConditionTerm t = ( ConditionTerm ) terms . nextElement ( ) ; 
match = term . matches ( t ) ; 
} public static Condition create ( StreamTokenizer tokenizer ) throws WebDAVException { 
Condition condition = new Condition ( ) ; 
if ( token == '<' ) { 
if ( token == StreamTokenizer . TT_WORD ) { 
condition . setResourceURI ( tokenizer . sval ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingResource" ) ) ; 
if ( token == '>' ) { 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , ">" ) ) ; 
if ( token == '(' ) { 
while ( token == '(' ) { 
condition . addConditionTerm ( ConditionTerm . create ( tokenizer ) ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingStart" , String . valueOf ( token ) ) ) ; 
return condition ; 
} public static Condition create ( String ifHeader ) throws WebDAVException { 
StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( ifHeader ) ) ; 
tokenizer . wordChars ( '!' , '/' ) ; 
tokenizer . wordChars ( ':' , '@' ) ; 
tokenizer . ordinaryChar ( '(' ) ; 
tokenizer . ordinaryChar ( ')' ) ; 
tokenizer . ordinaryChar ( '<' ) ; 
tokenizer . ordinaryChar ( '>' ) ; 
tokenizer . ordinaryChar ( '[' ) ; 
tokenizer . ordinaryChar ( ']' ) ; 
tokenizer . quoteChar ( '"' ) ; 
Condition condition = null ; 
int token = tokenizer . nextToken ( ) ; 
condition = Condition . create ( tokenizer ) ; 
if ( token != StreamTokenizer . TT_EOF ) { 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "EOF" ) ) ; 
} public void addProperty ( Element element ) throws MalformedElementException { 
extractNode ( root , element ) ; 
} public void addPropertyName ( QualifiedName name ) { 
String nsName = name . getQualifier ( ) ; 
String localName = name . getLocalName ( ) ; 
root . appendChild ( element ) ; 
Node firstChild = getChildElement ( root , true ) ; 
final Node firstElement = firstChild ; 
Node currentElement = firstElement ; 
return currentElement != null ; 
Node nextElement = currentElement ; 
currentElement = getNextSibling ( ( Element ) currentElement ) ; 
return nextElement ; 
} public Enumeration getPropertyNames ( ) throws MalformedElementException { 
String nsName = null ; 
nsName = getNSName ( ( Element ) currentElement ) ; 
String localName = getNSLocalName ( ( Element ) currentElement ) ; 
QualifiedNameImpl name = new QualifiedNameImpl ( nsName , localName ) ; 
} public static ConditionFactor create ( StreamTokenizer tokenizer ) throws WebDAVException { 
StateToken stateToken = new StateToken ( ) ; 
if ( token == '<' ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "<" ) ) ; 
stateToken . setURI ( tokenizer . sval ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingURI" , String . valueOf ( token ) ) ) ; 
if ( token == '>' ) 
return stateToken ; 
} protected void addPages ( ) { 
textEditor = new DRLRuleEditor ( ) { 
public void close ( boolean save ) { 
super . close ( save ) ; 
DRLRuleEditor2 . this . close ( save ) ; 
protected void setPartName ( String partName ) { 
super . setPartName ( partName ) ; 
DRLRuleEditor2 . this . setPartName ( partName ) ; 
reteViewer = new ReteViewer ( textEditor ) ; 
int text = addPage ( textEditor , 
getEditorInput ( ) ) ; 
int rete = addPage ( reteViewer , 
setPageText ( text , 
setPageText ( rete , 
textEditor . getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) . addDocumentListener ( new IDocumentListener ( ) { 
public void documentAboutToBeChanged ( DocumentEvent event ) { 
public void documentChanged ( DocumentEvent event ) { 
reteViewer . fireDocumentChanged ( ) ; 
} catch ( PartInitException e ) { 
} public Object getAdapter ( @ SuppressWarnings ( "rawtypes" ) Class adapter ) { 
if ( adapter == ZoomManager . class ) { 
if ( getActiveEditor ( ) instanceof ReteViewer ) { 
return reteViewer . getAdapter ( adapter ) ; 
} else if ( getActiveEditor ( ) instanceof DRLRuleEditor ) { 
} else if ( adapter == ZoomInAction2 . class ) { 
return zoomIn ; 
} else if ( adapter == ZoomOutAction2 . class ) { 
return zoomOut ; 
} else if ( adapter == ZoomComboContributionItem . class ) { 
return zitem ; 
return textEditor . getAdapter ( adapter ) ; 
} protected String httpDelete ( String request ) throws IOException { 
String host = getKieRESTUrl ( ) ; 
URL url = new URL ( host + "/" + request ) ; 
HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; 
conn . setRequestMethod ( "DELETE" ) ; 
conn . setRequestProperty ( "Content" , "application/json" ) ; 
setHttpCredentials ( conn ) ; 
String response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; 
if ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { 
JsonObject jo = JsonObject . readFrom ( response ) ; 
String status = jo . get ( "status" ) . asString ( ) ; 
if ( status != null && ! status . isEmpty ( ) ) { 
if ( ! "APPROVED" . equals ( status ) ) 
String jobId = jo . get ( "jobId" ) . asString ( ) ; 
if ( jobId != null && ! jobId . isEmpty ( ) ) 
return jobId ; 
} protected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { 
conn . setDoOutput ( body != null ) ; 
conn . setRequestMethod ( "POST" ) ; 
conn . setRequestProperty ( "Content-Type" , "application/json" ) ; 
java . io . OutputStream os = conn . getOutputStream ( ) ; 
Writer writer = new OutputStreamWriter ( os , "UTF-8" ) ; 
body . writeTo ( writer ) ; 
} public String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { 
final AtomicReference < String > ar = new AtomicReference < String > ( ) ; 
IWorkbench wb = PlatformUI . getWorkbench ( ) ; 
IProgressService ps = wb . getProgressService ( ) ; 
ps . busyCursorWhile ( new IRunnableWithProgress ( ) { 
public void run ( IProgressMonitor pm ) throws InterruptedException { 
pm . subTask ( title ) ; 
long stopTime = startTime ; 
Thread . sleep ( STATUS_REQUEST_DELAY ) ; 
String response = httpGet ( "jobs/" + jobId ) ; 
String result = jo . get ( "result" ) . asString ( ) ; 
if ( "null" . equals ( result ) ) { 
if ( ! "SUCCESS" . equals ( status ) ) 
if ( status != null && result != null ) 
ar . set ( status + ":" + result ) ; 
stopTime = System . currentTimeMillis ( ) ; 
pm . worked ( STATUS_REQUEST_DELAY ) ; 
Activator . println ( "status=" + status ) ; 
Activator . println ( "result=" + result ) ; 
if ( pm . isCanceled ( ) ) 
while ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; 
pm . done ( ) ; 
Activator . println ( 
"\n----------------------------------\n" + 
"\n----------------------------------\n" ) ; 
catch ( InvocationTargetException e ) { 
return ar . get ( ) ; 
} protected void doubleClicked ( ) { 
super . doubleClicked ( ) ; 
WorkDefinition workDefinition = getWorkDefinition ( ) ; 
if ( workDefinition instanceof WorkDefinitionExtension ) { 
String editor = ( ( WorkDefinitionExtension ) workDefinition ) . getCustomEditor ( ) ; 
if ( editor != null ) { 
Work work = openEditor ( editor , workDefinition ) ; 
if ( work != null ) { 
SetWorkCommand setCommand = new SetWorkCommand ( ) ; 
setCommand . setPropertyValue ( work ) ; 
CommandStack stack = getViewer ( ) . getEditDomain ( ) . getCommandStack ( ) ; 
stack . execute ( setCommand ) ; 
EditRepLocationWizard editWizard = new EditRepLocationWizard ( rep ) ; 
editWizard . init ( Activator . getDefault ( ) . getWorkbench ( ) , null ) ; 
WizardDialog dialog = 
new WizardDialog ( Display . getCurrent ( ) . getActiveShell ( ) , editWizard ) ; 
dialog . create ( ) ; 
dialog . open ( ) ; 
} public void setZoomManager ( ZoomManager manager ) { 
zoomManager = manager ; 
} public static Update createLabel ( Document document , String label ) { 
Assert . isNotNull ( label ) ; 
Element element = create ( document , "update" ) ; 
Update editor = new Update ( element ) ; 
editor . setLabelName ( label ) ; 
return editor ; 
} public static Update createVersion ( Document document , String href ) { 
editor . setVersion ( href ) ; 
} public String getVersion ( ) throws MalformedElementException { 
Element version = getFirstChild ( root , "version" ) ; 
ensureNotNull ( Policy . bind ( "ensure.missingVersionElmt" ) , version ) ; 
String href = getChildText ( version , "href" , true ) ; 
} public void setLabelName ( String label ) throws MalformedElementException { 
if ( isDAVElement ( child , "version" ) ) 
setChild ( child , "label-name" , label , new String [ ] { "label-name" } , true ) ; 
} public void setVersion ( String href ) throws MalformedElementException { 
if ( isDAVElement ( child , "label-name" ) ) 
Element newChild = setChild ( root , "version" , new String [ ] { "version" } , true ) ; 
setChild ( newChild , "href" , encodeHref ( href ) , new String [ ] { "href" } , true ) ; 
} @ SuppressWarnings ( "restriction" ) 
public void execute ( IProgressMonitor monitor ) { 
pullOperation . execute ( monitor ) ; 
results . putAll ( pullOperation . getResults ( ) ) ; 
catch ( CoreException e ) { 
if ( e . getStatus ( ) . getSeverity ( ) == IStatus . CANCEL ) 
repoNode . handleException ( ( Throwable ) e ) ; 
} private void handlePullResults ( final Map < Repository , Object > resultsMap ) { 
if ( tasksToWaitFor . decrementAndGet ( ) == 0 && ! results . isEmpty ( ) ) 
showResults ( ) ; 
} public JsonArray set ( int index , String value ) { 
values . set ( index , valueOf ( value ) ) ; 
} public ActiveLock addActiveLock ( ) { 
Element activelock = addChild ( root , "activelock" , childNames , false ) ; 
Element locktype = appendChild ( activelock , "locktype" ) ; 
ActiveLock result = null ; 
result = new ActiveLock ( activelock ) ; 
} public Enumeration getActiveLocks ( ) throws MalformedElementException { 
final Node firstActiveLock = getFirstChild ( root , "activelock" ) ; 
Node currentActiveLock = firstActiveLock ; 
return currentActiveLock != null ; 
result = new ActiveLock ( ( Element ) currentActiveLock ) ; 
currentActiveLock = getTwin ( ( Element ) currentActiveLock , true ) ; 
} protected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { 
if ( prefix != null && prefix . trim ( ) . length ( ) > 0 ) { 
Iterator < ICompletionProposal > iterator = props . iterator ( ) ; 
String prefixLc = prefix . toLowerCase ( ) ; 
ICompletionProposal item = iterator . next ( ) ; 
String content = item . getDisplayString ( ) . toLowerCase ( ) ; 
if ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) { 
} protected String readBackwards ( int documentOffset , IDocument doc ) throws BadLocationException { 
int startPart = doc . getPartition ( documentOffset ) . getOffset ( ) ; 
String prefix = doc . get ( startPart , documentOffset - startPart ) ; 
} public static RowList calculateReteRows ( BaseVertex root ) { 
RowList rowList = new RowList ( ) ; 
rowList . add ( 0 , 
root ) ; 
int curRow = 0 ; 
final Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; 
seenVertices . add ( root ) ; 
while ( curRow < rowList . getDepth ( ) ) { 
final List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; 
for ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; rowNodeIter . hasNext ( ) ; ) { 
final BaseVertex rowNode = rowNodeIter . next ( ) ; 
final List < Connection > edges = rowNode . getSourceConnections ( ) ; 
for ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; edgeIter . hasNext ( ) ; ) { 
final Connection edge = edgeIter . next ( ) ; 
final BaseVertex destNode = edge . getOpposite ( rowNode ) ; 
if ( ! seenVertices . contains ( destNode ) ) { 
rowList . add ( curRow + 1 , 
destNode ) ; 
seenVertices . add ( destNode ) ; 
seenVertices . add ( rowNode ) ; 
++ curRow ; 
rowList . optimize ( ) ; 
return rowList ; 
} public void paint ( Graphics g ) { 
g . setAntialias ( SWT . ON ) ; 
Rectangle r = getBounds ( ) . getCopy ( ) ; 
g . translate ( r . getLocation ( ) ) ; 
g . setBackgroundColor ( backgroundColor ) ; 
g . setForegroundColor ( borderColor ) ; 
g . fillArc ( 0 , 
0 , 
15 , 
360 ) ; 
g . drawArc ( 0 , 
14 , 
super . paint ( g ) ; 
} public EditPart createEditPart ( EditPart context , 
Object modelElement ) { 
EditPart part = getPartForElement ( modelElement ) ; 
part . setModel ( modelElement ) ; 
} private EditPart getPartForElement ( Object modelElement ) { 
if ( modelElement instanceof ReteGraph ) { 
return new DiagramEditPart ( ) ; 
if ( modelElement instanceof BaseVertex ) { 
return new VertexEditPart ( ) ; 
if ( modelElement instanceof Connection ) { 
return new ConnectionEditPart ( ) ; 
} public static ImageDescriptor getImageDescriptor ( String path ) { 
JBPMEclipsePlugin plugin = getDefault ( ) ; 
ImageRegistry reg = plugin . getImageRegistry ( ) ; 
ImageDescriptor des = reg . getDescriptor ( path ) ; 
if ( des == null ) { 
des = AbstractUIPlugin . imageDescriptorFromPlugin ( "org.jbpm.eclipse" , path ) ; 
reg . put ( path , des ) ; 
return des ; 
} public final static void declareRegistryImage ( String key , String path ) { 
ImageDescriptor desc = ImageDescriptor . getMissingImageDescriptor ( ) ; 
desc = ImageDescriptor . createFromURL ( makeIconFileURL ( path ) ) ; 
imageRegistry . put ( key , desc ) ; 
} private String credentials ( Request request , String realm , String username , String password , String algorithm , String messageQop , String nonce , String nonceCount , String opaque , String cnonce , String method , String digestUri ) throws Exception { 
Assert . isNotNull ( request ) ; 
Assert . isNotNull ( realm ) ; 
Assert . isNotNull ( nonce ) ; 
Assert . isNotNull ( method ) ; 
Assert . isNotNull ( digestUri ) ; 
buf . append ( username ) ; 
buf . append ( "\"" ) ; 
buf . append ( realm ) ; 
if ( messageQop != null ) { 
buf . append ( messageQop ) ; 
if ( algorithm != null ) { 
buf . append ( algorithm ) ; 
buf . append ( digestUri ) ; 
buf . append ( nonce ) ; 
if ( nonceCount != null ) { 
buf . append ( nonceCount ) ; 
if ( cnonce != null ) { 
buf . append ( cnonce ) ; 
if ( opaque != null ) { 
buf . append ( opaque ) ; 
String response = response ( request , realm , username , password , algorithm , messageQop , nonce , nonceCount , cnonce , method , digestUri ) ; 
buf . append ( response ) ; 
} public void add ( final int depth , 
final BaseVertex vertex ) { 
if ( this . rows . size ( ) < ( depth + 1 ) ) { 
final int addRows = depth - this . rows . size ( ) + 1 ; 
for ( int i = 0 ; i < addRows ; ++ i ) { 
this . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; 
( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; 
} public int getRow ( final BaseVertex vertex ) { 
final int numRows = this . rows . size ( ) ; 
for ( int i = 0 ; i < numRows ; ++ i ) { 
if ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { 
} public int getWidth ( ) { 
int width = 0 ; 
for ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; rowIter . hasNext ( ) ; ) { 
final Row row = rowIter . next ( ) ; 
final int rowWidth = row . getWidth ( ) ; 
if ( rowWidth > width ) { 
width = rowWidth ; 
return width ; 
} public void dump ( ) { 
} public void optimize ( ) { 
get ( i ) . optimize ( ) ; 
} private IFile getSourceFieldIFile ( ) { 
Field fReferences ; 
fReferences = processor . getClass ( ) . getDeclaredField ( "fReferences" ) ; 
fReferences . setAccessible ( true ) ; 
SearchResultGroup object [ ] = ( SearchResultGroup [ ] ) fReferences . get ( processor ) ; 
for ( SearchResultGroup searchResultGroup : object ) { 
if ( searchResultGroup . getResource ( ) instanceof IFile ) 
return ( IFile ) searchResultGroup . getResource ( ) ; 
} protected void configureGraphicalViewer ( ) { 
super . configureGraphicalViewer ( ) ; 
GraphicalViewer viewer = getGraphicalViewer ( ) ; 
viewer . getControl ( ) . setBackground ( ColorConstants . white ) ; 
viewer . setEditPartFactory ( new VertexEditPartFactory ( ) ) ; 
viewer . setRootEditPart ( rootEditPart ) ; 
viewer . setKeyHandler ( new GraphicalViewerKeyHandler ( viewer ) ) ; 
} public Object getAdapter ( @ SuppressWarnings ( "rawtypes" ) Class type ) { 
if ( type == ZoomManager . class ) return ( ( ScalableFreeformRootEditPart ) getGraphicalViewer ( ) . getRootEditPart ( ) ) . getZoomManager ( ) ; 
if ( type == GraphicalViewer . class ) return getGraphicalViewer ( ) ; 
if ( type == EditPart . class && getGraphicalViewer ( ) != null ) return getGraphicalViewer ( ) . getRootEditPart ( ) ; 
if ( type == IFigure . class && getGraphicalViewer ( ) != null ) return ( ( GraphicalEditPart ) getGraphicalViewer ( ) . getRootEditPart ( ) ) . getFigure ( ) ; 
return super . getAdapter ( type ) ; 
} public ReteGraph loadReteModel ( IProgressMonitor monitor , 
String contents ) throws Throwable { 
if ( relayoutRequired == false ) { 
return diagram ; 
ReteGraph newDiagram = new ReteGraph ( ) ; 
100 ) ; 
InternalKnowledgeBase ruleBase = null ; 
IResource resource = drlEditor . getResource ( ) ; 
ClassLoader newLoader = DroolsBuilder . class . getClassLoader ( ) ; 
if ( resource . getProject ( ) . getNature ( "org.eclipse.jdt.core.javanature" ) != null ) { 
IJavaProject project = JavaCore . create ( resource . getProject ( ) ) ; 
newLoader = ProjectClassLoader . getProjectClassLoader ( project ) ; 
DRLInfo drlInfo = DroolsEclipsePlugin . getDefault ( ) . parseResource ( drlEditor , true , true ) ; 
if ( drlInfo == null ) { 
if ( drlInfo . getBuilderErrors ( ) . length > 0 ) { 
if ( drlInfo . getParserErrors ( ) . size ( ) > 0 ) { 
InternalKnowledgePackage pkg = drlInfo . getPackage ( ) ; 
RuleBaseConfiguration config = new RuleBaseConfiguration ( ) ; 
config . setClassLoader ( newLoader ) ; 
ruleBase = KnowledgeBaseFactory . newKnowledgeBase ( config ) ; 
if ( pkg != null ) { 
ruleBase . addPackage ( pkg ) ; 
DroolsEclipsePlugin . log ( t ) ; 
monitor . worked ( 50 ) ; 
if ( monitor . isCanceled ( ) ) { 
throw new InterruptedException ( ) ; 
final ReteooVisitor visitor = new ReteooVisitor ( newDiagram ) ; 
visitor . visitInternalKnowledgeBase ( ruleBase ) ; 
monitor . worked ( 30 ) ; 
BaseVertex rootVertex = visitor . getRootVertex ( ) ; 
RowList rowList = ReteooLayoutFactory . calculateReteRows ( rootVertex ) ; 
ReteooLayoutFactory . layoutRowList ( newDiagram , 
rowList ) ; 
zeroBaseDiagram ( newDiagram ) ; 
monitor . worked ( 20 ) ; 
monitor . done ( ) ; 
if ( ! ( t instanceof InterruptedException ) ) { 
relayoutRequired = false ; 
return newDiagram ; 
} protected void initializeGraphicalViewer ( ) { 
ZoomManager zoomManager = rootEditPart . getZoomManager ( ) ; 
List < String > zoomLevels = new ArrayList < String > ( 3 ) ; 
zoomLevels . add ( ZoomManager . FIT_ALL ) ; 
zoomLevels . add ( ZoomManager . FIT_HEIGHT ) ; 
zoomLevels . add ( ZoomManager . FIT_WIDTH ) ; 
zoomManager . setZoomLevelContributions ( zoomLevels ) ; 
getGraphicalViewer ( ) . setProperty ( MouseWheelHandler . KeyGenerator . getKey ( SWT . MOD1 ) , 
MouseWheelZoomHandler . SINGLETON ) ; 
} private void zeroBaseDiagram ( ReteGraph graph ) { 
Dimension dim = rootEditPart . getContentPane ( ) . getSize ( ) ; 
int minx = 0 , miny = 0 , maxx = 0 , x = dim . width ; 
final Iterator < BaseVertex > nodeIter = graph . getChildren ( ) . iterator ( ) ; 
while ( nodeIter . hasNext ( ) ) { 
Point loc = nodeIter . next ( ) . getLocation ( ) ; 
minx = Math . min ( loc . x , 
minx ) ; 
maxx = Math . max ( loc . x , 
maxx ) ; 
miny = Math . min ( loc . y , 
miny ) ; 
int delta = ( x - ( maxx - minx + 20 ) ) / 2 ; 
minx = minx - ( delta ) ; 
final Iterator < BaseVertex > nodeIter2 = graph . getChildren ( ) . iterator ( ) ; 
while ( nodeIter2 . hasNext ( ) ) { 
final BaseVertex vertex = nodeIter2 . next ( ) ; 
Point loc = vertex . getLocation ( ) ; 
vertex . setLocation ( new Point ( loc . x - minx , 
loc . y - miny ) ) ; 
} public void drawGraph ( ReteGraph newGraph ) { 
LayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; 
ConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; 
if ( getGraphicalViewer ( ) . getContents ( ) == null ) { 
getGraphicalViewer ( ) . setContents ( getModel ( ) ) ; 
final boolean isNewDiagram = newGraph != null && newGraph != diagram ; 
if ( isNewDiagram ) { 
diagram . removeAll ( ) ; 
ConnectionRouter router ; 
if ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) { 
router = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; 
router = ConnectionRouter . NULL ; 
connLayer . setConnectionRouter ( router ) ; 
if ( newGraph != null && newGraph != diagram ) { 
diagram . addAll ( newGraph . getChildren ( ) ) ; 
} public DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { 
if ( source == null ) { 
Iterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; 
IJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; 
if ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( "mvel" ) ) { 
DroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; 
int matchLine = l . getLineNumber ( ) ; 
String matchSource = l . getRuleName ( ) ; 
if ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) { 
return l ; 
logError ( e ) ; 
if ( selectedNode == null ) { 
IWorkbenchBrowserSupport browserSupport = 
Activator . getDefault ( ) . getWorkbench ( ) . getBrowserSupport ( ) ; 
URL consoleURL = new URL ( 
extractGuvnorConsoleUrl ( selectedNode . getGuvnorRepository ( ) . getLocation ( ) ) ) ; 
if ( browserSupport . isInternalWebBrowserAvailable ( ) ) { 
browserSupport . createBrowser ( null ) . openURL ( consoleURL ) ; 
browserSupport . getExternalBrowser ( ) . openURL ( consoleURL ) ; 
if ( ( ( TreeObject ) sel . getFirstElement ( ) ) . getNodeType ( ) == TreeObject . Type . REPOSITORY ) { 
} public void setNLMappingItem ( DSLMappingEntry item ) { 
model = item ; 
setSection ( model . getSection ( ) ) ; 
exprText . setText ( model . getMappingKey ( ) == null ? "" : model . getMappingKey ( ) ) ; 
mappingText . setText ( model . getMappingValue ( ) == null ? "" : model . getMappingValue ( ) ) ; 
objText . setText ( model . getMetaData ( ) . getMetaData ( ) == null ? "" : model . getMetaData ( ) . getMetaData ( ) ) ; 
} public void setHref ( String href ) { 
setChild ( root , "href" , encodeHref ( href ) , childNames , true ) ; 
} public boolean canTalkDAV ( ) throws DAVException { 
response = davClient . options ( locator , newContext ( ) ) ; 
examineResponse ( response ) ; 
String davHeader = response . getContext ( ) . getDAV ( ) ; 
return ! ( ( davHeader == null ) || ( davHeader . indexOf ( "1" ) == - 1 ) ) ; 
} catch ( IOException exception ) { 
throw new SystemException ( exception ) ; 
closeResponse ( response ) ; 
} protected void closeResponse ( IResponse response ) throws SystemException { 
if ( response == null ) 
throw new SystemException ( e ) ; 
} public void copy ( ILocator destination ) throws DAVException { 
copy ( destination , IContext . DEPTH_INFINITY , false , null ) ; 
} public void copy ( ILocator destination , String depth , boolean overwrite , Collection propertyNames ) throws DAVException { 
IContext context = newContext ( ) ; 
context . setDepth ( depth ) ; 
context . setOverwrite ( overwrite ) ; 
Document document = newDocument ( ) ; 
PropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; 
if ( propertyNames == null ) 
propertyBehavior . setIsKeepAllAlive ( true ) ; 
Iterator namesItr = propertyNames . iterator ( ) ; 
while ( namesItr . hasNext ( ) ) { 
QualifiedName name = ( QualifiedName ) namesItr . next ( ) ; 
String nameURI = name . getQualifier ( ) + "/" + name . getLocalName ( ) ; 
propertyBehavior . addProperty ( nameURI ) ; 
response = davClient . copy ( locator , destination , context , document ) ; 
examineMultiStatusResponse ( response ) ; 
} protected void examineMultiStatusResponse ( IResponse response ) throws DAVException { 
if ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) 
if ( ! response . hasDocumentBody ( ) ) 
throw new DAVException ( Policy . bind ( "exception.responseMustHaveDocBody" ) ) ; 
Element documentElement ; 
documentElement = response . getDocumentBody ( ) . getDocumentElement ( ) ; 
if ( documentElement == null ) 
throw new DAVException ( Policy . bind ( "exception.invalidDoc" ) ) ; 
MultiStatus multistatus = new MultiStatus ( documentElement ) ; 
Enumeration responseEnum = multistatus . getResponses ( ) ; 
while ( responseEnum . hasMoreElements ( ) ) { 
ResponseBody responseBody = ( ResponseBody ) responseEnum . nextElement ( ) ; 
Enumeration propstatEnum = responseBody . getPropStats ( ) ; 
while ( propstatEnum . hasMoreElements ( ) ) { 
PropStat propstat = ( PropStat ) propstatEnum . nextElement ( ) ; 
examineStatusCode ( propstat . getStatusCode ( ) , propstat . getResponseDescription ( ) ) ; 
} protected URLTable extractPropStats ( MultiStatus multiStatus ) throws IOException , MalformedElementException { 
URLTable reply = new URLTable ( ) ; 
Enumeration responses = multiStatus . getResponses ( ) ; 
while ( responses . hasMoreElements ( ) ) { 
ResponseBody responseBody = ( ResponseBody ) responses . nextElement ( ) ; 
String href = responseBody . getHref ( ) ; 
URL resourceURL = new URL ( new URL ( locator . getResourceURL ( ) ) , href ) ; 
Hashtable properties = new Hashtable ( ) ; 
reply . put ( resourceURL , properties ) ; 
Enumeration propstats = responseBody . getPropStats ( ) ; 
while ( propstats . hasMoreElements ( ) ) { 
PropStat propstat = ( PropStat ) propstats . nextElement ( ) ; 
org . eclipse . webdav . dom . Status status = new org . eclipse . webdav . dom . Status ( propstat . getStatus ( ) ) ; 
Enumeration elements = propstat . getProp ( ) . getProperties ( ) ; 
while ( elements . hasMoreElements ( ) ) { 
Element element = ( Element ) elements . nextElement ( ) ; 
QualifiedName name = ElementEditor . getQualifiedName ( element ) ; 
PropertyStatus propertyStatus = new PropertyStatus ( element , status . getStatusCode ( ) , status . getStatusMessage ( ) ) ; 
properties . put ( name , propertyStatus ) ; 
return reply ; 
} public ResponseInputStream getContent ( ) throws DAVException { 
response = davClient . get ( locator , newContext ( ) ) ; 
return new ResponseInputStream ( response ) ; 
} public Enumeration getLocks ( ) throws DAVException { 
LockDiscovery lockdiscovery = null ; 
Element element = getProperty ( DAV_LOCK_DISCOVERY ) . getProperty ( ) ; 
lockdiscovery = new LockDiscovery ( element ) ; 
return lockdiscovery . getActiveLocks ( ) ; 
} catch ( WebDAVException exception ) { 
if ( exception . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) 
return new EmptyEnumeration ( ) ; 
throw exception ; 
} catch ( MalformedElementException elemException ) { 
throw new SystemException ( elemException ) ; 
} public CollectionHandle getParent ( ) throws DAVException { 
Assert . isTrue ( locator . getLabel ( ) == null ) ; 
Assert . isTrue ( ! locator . isStable ( ) ) ; 
URL url = URLTool . getParent ( locator . getResourceURL ( ) ) ; 
String parentName = url . toString ( ) ; 
ILocator parentLocator = davClient . getDAVFactory ( ) . newLocator ( parentName ) ; 
return new CollectionHandle ( davClient , parentLocator ) ; 
} public URLTable getProperties ( Collection propertyNames , String depth ) throws DAVException { 
PropFind propfind = PropFind . create ( document ) ; 
propfind . setIsAllProp ( true ) ; 
Prop prop = propfind . setProp ( ) ; 
while ( namesItr . hasNext ( ) ) 
prop . addPropertyName ( ( QualifiedName ) namesItr . next ( ) ) ; 
response = davClient . propfind ( locator , context , document ) ; 
throw new DAVException ( Policy . bind ( "exception.respMustShareXMLDoc" ) ) ; 
Element documentElement = response . getDocumentBody ( ) . getDocumentElement ( ) ; 
throw new DAVException ( Policy . bind ( "exception.respHasInvalidDoc" ) ) ; 
MultiStatus multiStatus = new MultiStatus ( documentElement ) ; 
return extractPropStats ( multiStatus ) ; 
} public PropertyStatus getProperty ( QualifiedName propertyName ) throws DAVException { 
Collection names = new HashSet ( ) ; 
names . add ( propertyName ) ; 
URLTable result = getProperties ( names , IContext . DEPTH_ZERO ) ; 
url = new URL ( locator . getResourceURL ( ) ) ; 
Hashtable propTable = ( Hashtable ) result . get ( url ) ; 
if ( propTable == null ) 
throw new DAVException ( Policy . bind ( "exception.lookup" , url . toExternalForm ( ) ) ) ; 
return ( PropertyStatus ) propTable . get ( propertyName ) ; 
} public URLTable getPropertyNames ( String depth ) throws DAVException { 
propfind . setIsPropName ( true ) ; 
if ( ! response . hasDocumentBody ( ) ) { 
throw new DAVException ( Policy . bind ( "exception.respMustHaveElmtBody" ) ) ; 
if ( documentElement == null ) { 
throw new DAVException ( Policy . bind ( "exception.bodyMustHaveElmt" ) ) ; 
URLTable reply = new URLTable ( 10 ) ; 
Enumeration responses = multistatus . getResponses ( ) ; 
URL resourceUrl = new URL ( new URL ( locator . getResourceURL ( ) ) , href ) ; 
Vector vector = new Vector ( ) ; 
Prop prop = propstat . getProp ( ) ; 
Enumeration names = prop . getPropertyNames ( ) ; 
QualifiedName dname = ( QualifiedName ) names . nextElement ( ) ; 
vector . addElement ( dname ) ; 
reply . put ( resourceUrl , vector . elements ( ) ) ; 
} public URLTable getVersionTree ( ) throws DAVException { 
Element root = ElementEditor . create ( document , "version-tree" ) ; 
Element propElement = ElementEditor . appendChild ( root , "prop" ) ; 
ElementEditor . appendChild ( propElement , "predecessor-set" ) ; 
response = davClient . report ( locator , newContext ( ) , document ) ; 
URLTable predecessorTable = new URLTable ( ) ; 
Vector predecessors = new Vector ( ) ; 
predecessorTable . put ( resourceURL , predecessors ) ; 
if ( propstat . getStatusCode ( ) != IResponse . SC_OK ) 
throw new DAVException ( Policy . bind ( "exception.errorRetrievingProp" ) ) ; 
Enumeration elements = prop . getProperties ( ) ; 
if ( name . equals ( DAV_PREDECESSOR_SET ) ) { 
Enumeration e = new HrefSet ( element , DAV_PREDECESSOR_SET ) . getHrefs ( ) ; 
URL predURL = new URL ( ( String ) e . nextElement ( ) ) ; 
predecessors . add ( predURL ) ; 
return predecessorTable ; 
} public IContext head ( ) throws DAVException { 
response = davClient . head ( locator , newContext ( ) ) ; 
return response . getContext ( ) ; 
} public LockToken lock ( boolean isShared , String depth , int timeout , String owner ) throws DAVException { 
context . setTimeout ( timeout ) ; 
LockInfo lockinfo = LockInfo . create ( document ) ; 
lockinfo . setIsShared ( isShared ) ; 
if ( owner != null ) { 
Owner ownerEditor = lockinfo . setOwner ( ) ; 
ownerEditor . getElement ( ) . appendChild ( document . createTextNode ( owner ) ) ; 
response = davClient . lock ( locator , context , document ) ; 
LockToken token = new LockToken ( response . getContext ( ) . getLockToken ( ) ) ; 
} public void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { 
if ( names == null ) { 
Object obj = names . nextElement ( ) ; 
Assert . isTrue ( obj instanceof QualifiedName , Policy . bind ( "assert.propNameMustBeEnumOverQual" ) ) ; 
propertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; 
response = davClient . move ( locator , destination , context , document ) ; 
} protected ILocator protectedCheckIn ( ) throws DAVException { 
response = davClient . checkin ( locator , newContext ( ) , null ) ; 
String versionUrl = response . getContext ( ) . getLocation ( ) ; 
return davClient . getDAVFactory ( ) . newStableLocator ( versionUrl ) ; 
} protected ILocator protectedCheckOut ( ) throws DAVException { 
response = davClient . checkout ( locator , newContext ( ) , null ) ; 
String resourceUrl = response . getContext ( ) . getLocation ( ) ; 
return davClient . getDAVFactory ( ) . newStableLocator ( resourceUrl ) ; 
} public void refreshLock ( LockToken lockToken , int timeout ) throws DAVException { 
context . setLockToken ( lockToken . getToken ( ) ) ; 
response = davClient . lock ( locator , context , null ) ; 
} public void removeProperties ( Collection propertyNames ) throws DAVException { 
Assert . isNotNull ( propertyNames ) ; 
if ( propertyNames . isEmpty ( ) ) 
PropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; 
Prop prop = propertyUpdate . addRemove ( ) ; 
response = davClient . proppatch ( locator , newContext ( ) , document ) ; 
} public void removeProperty ( QualifiedName propertyName ) throws DAVException { 
Collection propertyNames = new Vector ( 1 ) ; 
propertyNames . add ( propertyName ) ; 
removeProperties ( propertyNames ) ; 
} public void setContent ( String contentType , InputStream input ) throws DAVException { 
context . setContentType ( contentType ) ; 
response = davClient . put ( locator , context , input ) ; 
} public void setProperties ( Collection properties ) throws DAVException { 
Assert . isNotNull ( properties ) ; 
if ( properties . isEmpty ( ) ) 
Prop prop = propertyUpdate . addSet ( ) ; 
Iterator propertiesItr = properties . iterator ( ) ; 
while ( propertiesItr . hasNext ( ) ) { 
Element element = ( Element ) propertiesItr . next ( ) ; 
prop . addProperty ( element ) ; 
} catch ( MalformedElementException exception ) { 
} public void setProperty ( Element property ) throws DAVException { 
Collection properties = new Vector ( 1 ) ; 
properties . add ( property ) ; 
setProperties ( properties ) ; 
} public void unlock ( LockToken token ) throws DAVException { 
context . setLockToken ( "<" + token . getToken ( ) + ">" ) ; 
response = davClient . unlock ( locator , context ) ; 
} public void update ( ILocator version ) throws DAVException { 
Update . createVersion ( document , version . getResourceURL ( ) ) ; 
response = davClient . update ( locator , newContext ( ) , document ) ; 
} public void versionControl ( ) throws DAVException { 
response = davClient . versionControl ( locator , newContext ( ) , null ) ; 
} public void delete ( boolean mustExist ) throws DAVException { 
response = davClient . delete ( locator , newContext ( ) ) ; 
if ( ! mustExist && ( response . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) ) 
} protected void examineStatusCode ( int code , String message ) throws WebDAVException { 
if ( code >= 300 && code <= 399 ) 
throw new RedirectionException ( code , message ) ; 
if ( code >= 400 && code <= 499 ) 
throw new ClientException ( code , message ) ; 
if ( code >= 500 && code <= 599 ) 
throw new ServerException ( code , message ) ; 
} public boolean exists ( ) throws DAVException { 
if ( response . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) 
} public boolean isWorkingResource ( ) throws DAVException { 
PropertyStatus propertyStat = getProperty ( DAV_SUPPORTED_LIVE_PROPERTY_SET ) ; 
if ( propertyStat . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) 
examineStatusCode ( propertyStat . getStatusCode ( ) , propertyStat . getStatusMessage ( ) ) ; 
Element propertySet = propertyStat . getProperty ( ) ; 
return ( ( ElementEditor . hasChild ( propertySet , DAV_CHECKED_OUT ) ) && ! ( ElementEditor . hasChild ( propertySet , DAV_AUTO_CHECKOUT ) ) ) ; 
} protected boolean propertyHasChild ( QualifiedName propertyName , QualifiedName childName ) throws DAVException { 
PropertyStatus propertyStat = getProperty ( propertyName ) ; 
return ElementEditor . hasChild ( propertyStat . getProperty ( ) , childName ) ; 
} public void addBinding ( String href , String segment ) { 
Assert . isNotNull ( segment ) ; 
appendChild ( root , "href" , encodeHref ( href ) ) ; 
appendChild ( root , "segment" , segment ) ; 
} public Enumeration getBindings ( ) throws MalformedElementException { 
Node segment = null ; 
if ( firstHref != null ) 
segment = getNextSibling ( ( Element ) firstHref , "segment" ) ; 
final Node firstSegment = segment ; 
Node fCurrentHref = firstHref ; 
Node fCurrentSegment = firstSegment ; 
return fCurrentHref != null && fCurrentSegment != null ; 
String nextHref = getFirstText ( ( Element ) fCurrentHref ) ; 
String nextSegment = getFirstText ( ( Element ) fCurrentSegment ) ; 
Binding nextBinding = new Binding ( decodeHref ( nextHref ) , nextSegment ) ; 
fCurrentHref = getNextSibling ( ( Element ) fCurrentSegment , "href" ) ; 
fCurrentSegment = null ; 
if ( fCurrentHref != null ) 
fCurrentSegment = getNextSibling ( ( Element ) fCurrentHref , "segment" ) ; 
return nextBinding ; 
} public Element newDAVElementSet ( QualifiedName setName , QualifiedName memberName , Enumeration memberEnum ) { 
Element setElement = newDAVElement ( setName ) ; 
while ( memberEnum . hasMoreElements ( ) ) { 
String member = ( String ) memberEnum . nextElement ( ) ; 
Element memberElement = newDAVTextElement ( memberName , member ) ; 
setElement . appendChild ( memberElement ) ; 
return setElement ; 
Figure f = new FreeformLayer ( ) ; 
f . setBorder ( new MarginBorder ( 3 ) ) ; 
f . setLayoutManager ( new FreeformLayout ( ) ) ; 
if ( ReteGraph . PROP_CHILD_ADDED . equals ( prop ) || ReteGraph . PROP_CHILD_REMOVED . equals ( prop ) ) { 
refreshChildren ( ) ; 
long contentLength = super . getContentLength ( ) ; 
if ( requestBodyWriter == null ) 
return ( ( RequestInputStream ) is ) . length ( ) ; 
} public void write ( OutputStream os ) throws IOException { 
if ( requestBodyWriter == null ) { 
if ( inputRead ) { 
is . reset ( ) ; 
inputRead = false ; 
super . write ( os ) ; 
requestBodyWriter . writeRequestBody ( os ) ; 
} public static String toHex ( byte [ ] arr ) { 
for ( int i = 0 ; i < arr . length ; ++ i ) { 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 4 ) & 0x0f ) ) ; 
buf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; 
} public static String toHex ( int [ ] arr ) { 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 28 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 24 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 20 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 16 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 12 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 8 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] > > 4 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; 
} public void inputChanged ( Viewer v , Object oldInput , Object newInput ) { 
if ( v instanceof AbstractTreeViewer ) { 
viewer = ( AbstractTreeViewer ) v ; 
manager = new DeferredTreeContentManager ( this , viewer ) ; 
} public Object [ ] getElements ( Object parent ) { 
if ( parent . equals ( viewer ) ) { 
if ( invisibleRoot == null ) initialize ( ) ; 
return getChildren ( invisibleRoot ) ; 
return getChildren ( parent ) ; 
} public Object getParent ( Object child ) { 
if ( child instanceof TreeObject ) { 
return ( ( TreeObject ) child ) . getParent ( ) ; 
} public Object [ ] getChildren ( Object parent ) { 
if ( parent == invisibleRoot ) { 
return ( ( TreeParent ) invisibleRoot ) . getChildren ( ) ; 
} else if ( parent instanceof TreeParent ) { 
return manager . getChildren ( parent ) ; 
} public static PropFind create ( Document document ) { 
Element element = create ( document , "propfind" ) ; 
return new PropFind ( element ) ; 
} public boolean isAllProp ( ) throws MalformedElementException { 
ensureNotNull ( Policy . bind ( "ensure.missingAllpropOrPropnameOrPropElmt" ) , child ) ; 
boolean isAllProp = isDAVElement ( child , "allprop" ) ; 
ensureNull ( Policy . bind ( "ensure.conflictingAllpropOrPropnameOrPropElmt" ) , child ) ; 
return isAllProp ; 
} public void setIsAllProp ( boolean isAllProp ) { 
boolean isAlreadyAllProp = isDAVElement ( child , "allprop" ) ; 
if ( isAllProp ) { 
if ( ! isAlreadyAllProp ) { 
appendChild ( root , "allprop" ) ; 
} else if ( isAlreadyAllProp ) 
} public void setIsPropName ( boolean isPropName ) { 
boolean isAlreadyPropName = isDAVElement ( child , "propname" ) ; 
if ( isPropName ) { 
if ( ! isAlreadyPropName ) { 
appendChild ( root , "propname" ) ; 
} else if ( isAlreadyPropName ) 
Assert . isTrue ( getFirstChild ( root , new String [ ] { "allprop" , "propname" } ) == null ) ; 
Element prop = setChild ( root , "prop" , new String [ ] { "prop" } , true ) ; 
} public static String stripLastWord ( String prefix ) { 
if ( "" . equals ( prefix ) ) { 
char [ ] c = prefix . toCharArray ( ) ; 
for ( int i = c . length - 1 ; i >= 0 ; i -- ) { 
if ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { 
start = i + 1 ; 
prefix = prefix . substring ( start , 
prefix . length ( ) ) ; 
} public static String getCompilableText ( String backText ) { 
String trimed = backText . trim ( ) ; 
if ( trimed . endsWith ( ";" ) ) { 
return backText . substring ( 0 , 
backText . length ( ) - 1 ) ; 
} else if ( trimed . endsWith ( "." ) || trimed . endsWith ( "," ) ) { 
} else if ( CompletionUtil . COMPLETED_MVEL_EXPRESSION . matcher ( backText ) . matches ( ) ) { 
return backText + ";" ; 
return backText ; 
} public static boolean isGetter ( String methodName , 
int argCount , 
String returnedType ) { 
return isAccessor ( methodName , 
argCount , 
"get" , 
returnedType , 
Signature . SIG_VOID , 
} public static String getPropertyName ( String methodName , 
int parameterCount , 
String returnType ) { 
if ( methodName == null ) { 
String simpleName = methodName . replaceAll ( "\\(\\)" , 
"" ) ; 
int prefixLength = 0 ; 
if ( isIsGetter ( simpleName , 
parameterCount , 
returnType ) ) { 
prefixLength = 2 ; 
} else if ( isGetter ( simpleName , 
returnType ) 
|| isSetter ( simpleName , 
prefixLength = 3 ; 
return methodName ; 
char firstChar = Character . toLowerCase ( simpleName . charAt ( prefixLength ) ) ; 
String propertyName = firstChar + simpleName . substring ( prefixLength + 1 ) ; 
return propertyName ; 
} public static String getWritablePropertyName ( String methodName , 
if ( ! isSetter ( simpleName , 
int prefixLength = 3 ; 
} private static boolean isAccessor ( String methodName , 
int actualParameterCount , 
int requiredParameterCount , 
String prefix , 
String returnType , 
String requiredReturnType , 
boolean includeType ) { 
if ( methodName . length ( ) < prefix . length ( ) + 1 ) { 
if ( ! methodName . startsWith ( prefix ) ) { 
if ( actualParameterCount != requiredParameterCount ) { 
if ( includeType ) { 
if ( ! requiredReturnType . equals ( returnType ) ) { 
if ( requiredReturnType . equals ( returnType ) ) { 
} public static String getSimpleClassName ( Class < ? > cls ) { 
int lastIndex = cls . getName ( ) . lastIndexOf ( '$' ) ; 
if ( lastIndex < 0 ) { 
lastIndex = cls . getName ( ) . lastIndexOf ( '.' ) ; 
if ( cls . isArray ( ) ) { 
return cls . getName ( ) . substring ( lastIndex + 1 ) + "[]" ; 
return cls . getName ( ) . substring ( lastIndex + 1 ) ; 
} public void update ( ) { 
TreeViewer viewer = getTreeViewer ( ) ; 
if ( viewer != null ) { 
Control control = viewer . getControl ( ) ; 
if ( control != null && ! control . isDisposed ( ) ) { 
initRules ( ) ; 
populatePackageTreeNode ( ) ; 
viewer . refresh ( ) ; 
control . setRedraw ( false ) ; 
viewer . expandToLevel ( 2 ) ; 
control . setRedraw ( true ) ; 
if ( is instanceof ByteArrayInputStream ) 
return ( ( ByteArrayInputStream ) is ) . available ( ) ; 
Assert . isTrue ( ! inputRead ) ; 
int totalBytesRead = 0 ; 
byte [ ] buffer = bufferPool . getBuffer ( ) ; 
long contentLength = getContentLength ( ) ; 
while ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { 
if ( contentLength == - 1 ) { 
bytesRead = is . read ( buffer ) ; 
bytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; 
if ( bytesRead == - 1 ) { 
if ( contentLength >= 0 ) { 
throw new IOException ( Policy . bind ( "exception.unexpectedEndStream" ) ) ; 
bufferPool . putBuffer ( buffer ) ; 
inputRead = true ; 
} public synchronized void stepOver ( ) throws DebugException { 
if ( ! ( getTopStackFrame ( ) instanceof MVELStackFrame ) ) { 
super . stepOver ( ) ; 
MVELStackFrame mvelStack = ( MVELStackFrame ) getTopStackFrame ( ) ; 
if ( ! canStepOver ( ) || ! mvelStack . canStepOver ( ) ) { 
if ( ! setRemoteOnBreakReturn ( Debugger . STEP ) ) { 
preserveStackFrames ( ) ; 
fireEvent ( new DebugEvent ( this , 
DebugEvent . RESUME , 
DebugEvent . STEP_OVER ) ) ; 
getUnderlyingThread ( ) . resume ( ) ; 
targetRequestFailed ( MessageFormat . format ( JDIDebugModelMessages . JDIThread_exception_stepping , e . toString ( ) ) , e ) ; 
} protected void markParseErrors ( List < DroolsBuildMarker > markers , 
List < BaseKnowledgeBuilderResultImpl > parserErrors ) { 
for ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; iter . hasNext ( ) ; ) { 
Object error = iter . next ( ) ; 
if ( error instanceof ParserError ) { 
ParserError err = ( ParserError ) error ; 
markers . add ( new DroolsBuildMarker ( err . getMessage ( ) , 
err . getRow ( ) ) ) ; 
} else if ( error instanceof KnowledgeBuilderResult ) { 
KnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; 
int [ ] errorLines = res . getLines ( ) ; 
markers . add ( new DroolsBuildMarker ( res . getMessage ( ) , 
errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; 
} else if ( error instanceof ExpanderException ) { 
ExpanderException exc = ( ExpanderException ) error ; 
markers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , 
- 1 ) ) ; 
markers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; 
} private void markOtherErrors ( List < DroolsBuildMarker > markers , 
DroolsError [ ] buildErrors ) { 
for ( int i = 0 ; i < buildErrors . length ; i ++ ) { 
DroolsError error = buildErrors [ i ] ; 
if ( error instanceof GlobalError ) { 
GlobalError globalError = ( GlobalError ) error ; 
} else if ( error instanceof RuleBuildError ) { 
RuleBuildError ruleError = ( RuleBuildError ) error ; 
if ( ruleError . getObject ( ) instanceof CompilationProblem [ ] ) { 
CompilationProblem [ ] problems = ( CompilationProblem [ ] ) ruleError . getObject ( ) ; 
for ( int j = 0 ; j < problems . length ; j ++ ) { 
markers . add ( new DroolsBuildMarker ( problems [ j ] . getMessage ( ) , 
ruleError . getLine ( ) ) ) ; 
markers . add ( new DroolsBuildMarker ( ruleError . getRule ( ) . getName ( ) + ":" + ruleError . getMessage ( ) , 
} else if ( error instanceof ParserError ) { 
ParserError parserError = ( ParserError ) error ; 
markers . add ( new DroolsBuildMarker ( parserError . getMessage ( ) , 
parserError . getRow ( ) ) ) ; 
} else if ( error instanceof FunctionError ) { 
FunctionError functionError = ( FunctionError ) error ; 
if ( functionError . getObject ( ) instanceof CompilationProblem [ ] ) { 
CompilationProblem [ ] problems = ( CompilationProblem [ ] ) functionError . getObject ( ) ; 
functionError . getLines ( ) [ j ] ) ) ; 
markers . add ( new DroolsBuildMarker ( functionError . getFunctionDescr ( ) . getName ( ) + ":" + functionError . getMessage ( ) , 
} else if ( error instanceof FieldTemplateError ) { 
markers . add ( new DroolsBuildMarker ( error . getMessage ( ) , 
( ( FieldTemplateError ) error ) . getLine ( ) ) ) ; 
} else if ( error instanceof FactTemplateError ) { 
( ( FactTemplateError ) error ) . getLine ( ) ) ) ; 
} else if ( error instanceof ImportError ) { 
} else if ( error instanceof DescrBuildError ) { 
( ( DescrBuildError ) error ) . getLine ( ) ) ) ; 
} public void match ( char c ) throws ParserException { 
checkPosition ( ) ; 
if ( s . charAt ( pos ) != c ) 
throw new ParserException ( ) ; 
} public String nextQuotedString ( ) throws ParserException { 
int start = pos ; 
match ( '"' ) ; 
while ( s . charAt ( pos ) != '"' ) { 
return s . substring ( start , pos ) ; 
} public String nextToken ( ) throws ParserException { 
while ( ! done && pos < s . length ( ) ) { 
int c = s . charAt ( pos ) ; 
if ( c <= 31 
|| c == 127 
|| c == '(' 
|| c == ')' 
|| c == '<' 
|| c == '>' 
|| c == '@' 
|| c == ',' 
|| c == ';' 
|| c == ':' 
|| c == '\\' 
|| c == '"' 
|| c == '/' 
|| c == '[' 
|| c == ']' 
|| c == '?' 
|| c == '=' 
|| c == '{' 
|| c == '}' 
|| Character . isWhitespace ( ( char ) c ) ) { 
if ( start == pos ) { 
} public void skipWhiteSpace ( ) { 
while ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) 
} public static IFile findGuvnorMetadata ( IResource resource ) { 
IFile res = null ; 
IPath dir = resource . getFullPath ( ) . removeLastSegments ( 1 ) ; 
IPath mdpath = dir . append ( ".guvnorinfo" ) . append ( "." + resource . getName ( ) ) ; 
IResource mdResource = resource . getWorkspace ( ) . getRoot ( ) . findMember ( mdpath ) ; 
if ( mdResource != null 
&& mdResource . exists ( ) 
&& mdResource instanceof IFile ) { 
res = ( IFile ) mdResource ; 
} public static boolean addResourceToGuvnor ( String repLoc , 
String targetLoc , 
IFile selectedFile ) { 
boolean res = false ; 
String fullPath = targetLoc + selectedFile . getName ( ) ; 
IWebDavClient client = WebDavServerCache . getWebDavClient ( repLoc ) ; 
client = WebDavClientFactory . createClient ( new URL ( repLoc ) ) ; 
WebDavServerCache . cacheWebDavClient ( repLoc , client ) ; 
res = client . createResource ( fullPath , new ByteArrayInputStream ( new byte [ 0 ] ) , false ) ; 
client . putResource ( fullPath , selectedFile . getContents ( ) ) ; 
authenticateForServer ( repLoc , client ) ; 
GuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; 
ResourceProperties resProps = client . queryProperties ( fullPath ) ; 
GuvnorMetadataProps mdProps = 
new GuvnorMetadataProps ( selectedFile . getName ( ) , 
repLoc , 
fullPath , resProps . getLastModifiedDate ( ) , 
resProps . getRevision ( ) ) ; 
GuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; 
} public static void commitFileChanges ( IFile selectedFile ) { 
GuvnorMetadataProps props = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; 
IWebDavClient client = WebDavServerCache . getWebDavClient ( props . getRepository ( ) ) ; 
client = WebDavClientFactory . createClient ( new URL ( props . getRepository ( ) ) ) ; 
WebDavServerCache . cacheWebDavClient ( props . getRepository ( ) , client ) ; 
ResourceProperties remoteProps = null ; 
remoteProps = client . queryProperties ( props . getFullpath ( ) ) ; 
authenticateForServer ( props . getRepository ( ) , client ) ; 
if ( remoteProps == null ) { 
boolean proceed = true ; 
if ( ! props . getRevision ( ) . equals ( remoteProps . getRevision ( ) ) ) { 
String msg = MessageFormat . format ( Messages . getString ( "overwrite.confirmation" ) , 
new Object [ ] { selectedFile . getName ( ) , 
remoteProps . getRevision ( ) , 
props . getRevision ( ) } ) ; 
proceed = MessageDialog . openQuestion ( display . getActiveShell ( ) , 
Messages . getString ( "overwrite.confirmation.caption" ) , msg ) ; 
if ( proceed ) { 
client . putResource ( props . getFullpath ( ) , selectedFile . getContents ( ) ) ; 
ResourceProperties resProps = client . queryProperties ( props . getFullpath ( ) ) ; 
GuvnorMetadataProps mdProps = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; 
mdProps . setVersion ( resProps . getLastModifiedDate ( ) ) ; 
mdProps . setRevision ( resProps . getRevision ( ) ) ; 
} public static IFile findGuvnorMetadata ( IPath resource ) { 
IPath dir = resource . removeLastSegments ( 1 ) ; 
IPath mdpath = dir . append ( ".guvnorinfo" ) . append ( "." + resource . lastSegment ( ) ) ; 
IResource mdResource = Activator . getDefault ( ) . getWorkspace ( ) . 
getRoot ( ) . findMember ( mdpath ) ; 
} public void collapse ( ) { 
if ( defaults != null ) { 
Enumeration keysEnum = defaults . keys ( ) ; 
while ( keysEnum . hasMoreElements ( ) ) { 
String key = ( String ) keysEnum . nextElement ( ) ; 
put ( key , get ( key ) ) ; 
defaults = null ; 
String value = ( String ) properties . get ( new ContextKey ( key ) ) ; 
if ( value == null && defaults != null ) 
} public int getAge ( ) { 
String ageString = get ( AGE ) ; 
return ( ageString == null ) ? - 1 : Integer . parseInt ( ageString ) ; 
String lengthString = get ( CONTENT_LENGTH ) ; 
return ( lengthString == null ) ? - 1 : Long . parseLong ( lengthString ) ; 
} public int getMaxForwards ( ) { 
String s = get ( MAX_FORWARDS ) ; 
return s == null ? - 1 : Integer . parseInt ( s ) ; 
} public boolean getOverwrite ( ) { 
String overwriteString = get ( OVERWRITE ) ; 
return overwriteString == null ? false : overwriteString . equalsIgnoreCase ( "T" ) ; 
} public boolean getPassthrough ( ) { 
String s = get ( PASSTHROUGH ) ; 
return s == null ? false : s . equalsIgnoreCase ( "T" ) ; 
} public int getTimeout ( ) { 
String timeoutString = get ( TIMEOUT ) ; 
if ( timeoutString == null ) 
if ( timeoutString . equalsIgnoreCase ( DEPTH_INFINITY ) ) 
return - 2 ; 
if ( timeoutString . regionMatches ( true , 1 , "Second-" , 1 , 7 ) ) 
return Integer . parseInt ( timeoutString . substring ( 7 ) ) ; 
if ( defaults == null ) 
return new ContextKeyToStringEnum ( properties . keys ( ) ) ; 
Enumeration allKeys = new MergedEnumeration ( new ContextKeyToStringEnum ( properties . keys ( ) ) , defaults . keys ( ) ) ; 
Hashtable keysSet = new Hashtable ( ) ; 
while ( allKeys . hasMoreElements ( ) ) 
keysSet . put ( allKeys . nextElement ( ) , "ignored" ) ; 
return keysSet . keys ( ) ; 
} public void put ( String key , String value ) { 
ContextKey ckey = new ContextKey ( key ) ; 
if ( ( value == null ) || ( value . length ( ) == 0 ) ) 
properties . remove ( ckey ) ; 
properties . put ( ckey , value ) ; 
} public void setTimeout ( int value ) { 
if ( value == - 1 ) 
put ( TIMEOUT , "" ) ; 
put ( TIMEOUT , ( value == - 2 ) ? DEPTH_INFINITY : "Second-" + Integer . toString ( value ) ) ; 
} protected BufferedReader openDSLFile ( String filename ) { 
FileReader reader = new FileReader ( filename ) ; 
BufferedReader breader = new BufferedReader ( reader ) ; 
return breader ; 
} protected void parseFile ( BufferedReader reader ) { 
while ( ( line = reader . readLine ( ) ) != null ) { 
Section section = getSection ( line ) ; 
String nl = stripHeadingAndCode ( line ) ; 
String objname = this . getObjMetadata ( nl ) ; 
nl = this . stripObjMetadata ( nl ) ; 
addEntry ( section , nl , objname ) ; 
} protected String stripHeadingAndCode ( String text ) { 
if ( text . startsWith ( DSLMappingEntry . CONDITION . getSymbol ( ) ) ) { 
return text . substring ( DSLMappingEntry . CONDITION . getSymbol ( ) . length ( ) + 2 , text . indexOf ( "=" ) ) ; 
} else if ( text . startsWith ( DSLMappingEntry . CONSEQUENCE . getSymbol ( ) ) ) { 
return text . substring ( DSLMappingEntry . CONSEQUENCE . getSymbol ( ) . length ( ) + 2 , text . indexOf ( "=" ) ) ; 
} else if ( text . startsWith ( DSLMappingEntry . ANY . getSymbol ( ) ) ) { 
return text . substring ( DSLMappingEntry . ANY . getSymbol ( ) . length ( ) + 2 , text . indexOf ( "=" ) ) ; 
} else if ( text . startsWith ( "#" ) ) { 
} protected String getObjMetadata ( String text ) { 
if ( text . startsWith ( "[" ) ) { 
return text . substring ( 1 , text . lastIndexOf ( "]" ) ) ; 
} protected String stripObjMetadata ( String text ) { 
return text . substring ( text . lastIndexOf ( "]" ) + 1 ) ; 
} public void addTokens ( String metadata , StringTokenizer tokens ) { 
Node mnode = this . rootCond . addToken ( metadata ) ; 
Node thenode = mnode ; 
while ( tokens . hasMoreTokens ( ) ) { 
Node newnode = thenode . addToken ( tokens . nextToken ( ) ) ; 
thenode = newnode ; 
} public void addTokens ( String [ ] tokens , Node rootNode ) { 
Node thenode = rootNode ; 
for ( int i = 0 ; i < tokens . length ; i ++ ) { 
Node newnode = thenode . addToken ( tokens [ i ] ) ; 
} public Node [ ] getConditionChildren ( String text ) { 
Node thenode = this . rootCond ; 
if ( text . length ( ) > 0 ) { 
StringTokenizer tokenz = new StringTokenizer ( text ) ; 
this . last = this . current ; 
while ( tokenz . hasMoreTokens ( ) ) { 
String strtk = tokenz . nextToken ( ) ; 
Node ch = thenode . getChild ( strtk ) ; 
if ( ch != null ) { 
thenode = ch ; 
if ( thenode != this . rootCond ) { 
this . current = thenode ; 
Collection < Node > children = thenode . getChildren ( ) ; 
Node [ ] nchild = new Node [ children . size ( ) ] ; 
return children . toArray ( nchild ) ; 
} public Node [ ] getChildren ( String obj , String text ) { 
Node thenode = this . rootCond . getChild ( obj ) ; 
if ( thenode == null ) { 
for ( Node child : this . rootCond . getChildren ( ) ) { 
String tokenText = child . getToken ( ) ; 
if ( tokenText != null ) { 
int index = tokenText . indexOf ( "{" ) ; 
String substring = tokenText . substring ( 0 , index ) ; 
if ( obj != null && obj . startsWith ( substring ) ) { 
thenode = child ; 
if ( thenode != null && text . length ( ) > 0 ) { 
} public ArrayList < String > getConditionChildrenList ( String text , boolean addChildren ) { 
Node [ ] c = getConditionChildren ( text ) ; 
this . suggestions . clear ( ) ; 
for ( int idx = 0 ; idx < c . length ; idx ++ ) { 
this . suggestions . add ( c [ idx ] . getToken ( ) ) ; 
if ( addChildren ) { 
this . addChildToList ( c [ idx ] , c [ idx ] . getToken ( ) , this . suggestions ) ; 
return this . suggestions ; 
} public ArrayList < String > getConsequenceChildrenList ( String text , boolean addChildren ) { 
Node [ ] c = getConsequenceChildren ( text ) ; 
} public void addChildToList ( Node n , String prefix , ArrayList < String > list ) { 
if ( n . getChildren ( ) . size ( ) > 0 ) { 
for ( Node child : n . getChildren ( ) ) { 
if ( prefix != null && "-" . equals ( child . getToken ( ) ) ) { 
if ( ! list . contains ( prefix ) ) { 
list . add ( prefix ) ; 
addChildToList ( child , text , list ) ; 
} public void printTree ( ) { 
System . out . println ( "ROOT" ) ; 
for ( Node n : rootCond . getChildren ( ) ) { 
printNode ( n ) ; 
} protected void printNode ( Node n ) { 
printTabs ( n . getDepth ( ) ) ; 
for ( Node c : n . getChildren ( ) ) { 
printNode ( c ) ; 
} protected void printTabs ( int count ) { 
for ( int idx = 0 ; idx < count ; idx ++ ) { 
System . out . print ( tab ) ; 
} public static JsonValue readFrom ( String text ) { 
return new JsonParser ( text ) . parse ( ) ; 
throw new RuntimeException ( exception ) ; 
} public static JsonValue valueOf ( float value ) { 
if ( Float . isInfinite ( value ) || Float . isNaN ( value ) ) { 
return new JsonNumber ( cutOffPointZero ( Float . toString ( value ) ) ) ; 
} public void fetchDeferredChildren ( Object object , 
IElementCollector collector , 
IProgressMonitor monitor ) { 
if ( ! ( object instanceof TreeParent ) ) { 
TreeParent node = ( TreeParent ) object ; 
if ( node . getNodeType ( ) == Type . NONE ) { 
List < GuvnorRepository > reps = Activator . getLocationManager ( ) . getRepositories ( ) ; 
monitor . beginTask ( Messages . getString ( "pending" ) , reps . size ( ) ) ; 
for ( int i = 0 ; i < reps . size ( ) ; i ++ ) { 
TreeParent p = new TreeParent ( reps . get ( i ) . getLocation ( ) , Type . REPOSITORY ) ; 
p . setParent ( node ) ; 
p . setGuvnorRepository ( reps . get ( i ) ) ; 
props . setBase ( "" ) ; 
p . setResourceProps ( props ) ; 
collector . add ( p , monitor ) ; 
monitor . worked ( 1 ) ; 
if ( EnumSet . of ( Type . REPOSITORY , Type . GLOBALS , Type . PACKAGES , Type . SNAPSHOTS , Type . PACKAGE , 
Type . SNAPSHOT_PACKAGE ) . contains ( node . getNodeType ( ) ) ) { 
listDirectory ( node , collector , monitor ) ; 
} public void listDirectory ( TreeParent node , 
monitor . beginTask ( Messages . getString ( "pending" ) , 1 ) ; 
GuvnorRepository rep = node . getGuvnorRepository ( ) ; 
IWebDavClient webdav = WebDavServerCache . getWebDavClient ( rep . getLocation ( ) ) ; 
if ( webdav == null ) { 
webdav = WebDavClientFactory . createClient ( new URL ( rep . getLocation ( ) ) ) ; 
WebDavServerCache . cacheWebDavClient ( rep . getLocation ( ) , webdav ) ; 
Map < String , ResourceProperties > listing = null ; 
listing = webdav . listDirectory ( node . getFullPath ( ) ) ; 
boolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( 
node . getGuvnorRepository ( ) . getLocation ( ) , webdav ) ; 
if ( listing != null ) { 
for ( String s : listing . keySet ( ) ) { 
ResourceProperties resProps = listing . get ( s ) ; 
TreeObject o = null ; 
if ( resProps . isDirectory ( ) ) { 
Type childType ; 
switch ( getNodeType ( ) ) { 
case REPOSITORY : 
if ( s . startsWith ( "snapshot" ) ) { 
childType = Type . SNAPSHOTS ; 
} else if ( s . startsWith ( "packages" ) ) { 
childType = Type . PACKAGES ; 
} else if ( s . startsWith ( "globalarea" ) ) { 
childType = Type . GLOBALS ; 
childType = Type . PACKAGE ; 
case SNAPSHOTS : 
childType = Type . SNAPSHOT_PACKAGE ; 
case SNAPSHOT_PACKAGE : 
childType = Type . SNAPSHOT ; 
o = new TreeParent ( s , childType ) ; 
o = new TreeObject ( s , Type . RESOURCE ) ; 
o . setGuvnorRepository ( rep ) ; 
o . setResourceProps ( resProps ) ; 
node . addChild ( o ) ; 
collector . add ( o , monitor ) ; 
} catch ( WebDavException e ) { 
if ( e . getErrorCode ( ) == IResponse . SC_UNAUTHORIZED ) { 
PlatformUtils . reportAuthenticationFailure ( ) ; 
if ( e . getErrorCode ( ) == IResponse . SC_NOT_IMPLEMENTED ) { 
Activator . getDefault ( ) . displayMessage ( IStatus . ERROR , 
Messages . getString ( "rep.connect.fail" ) ) ; 
} catch ( ConnectException ce ) { 
Activator . getDefault ( ) . 
displayMessage ( IStatus . ERROR , 
} public Object getParent ( Object o ) { 
if ( o instanceof TreeObject ) { 
return ( ( TreeObject ) o ) . getParent ( ) ; 
plugin = this ; 
getWorkspace ( ) . addResourceChangeListener ( rcListner ) ; 
getWorkspace ( ) . removeResourceChangeListener ( rcListner ) ; 
} public static ImageDescriptor getImageDescriptor ( String id ) { 
ImageDescriptor retVal = getDefault ( ) . getImageRegistry ( ) . getDescriptor ( id ) ; 
if ( retVal == null ) { 
retVal = loadImageDescriptor ( id ) ; 
getDefault ( ) . getImageRegistry ( ) . put ( id , retVal ) ; 
} public void addProxyServerException ( String pattern ) { 
Assert . isNotNull ( pattern ) ; 
proxyServerExceptions . put ( pattern , pattern ) ; 
} public IContext getContext ( URL originServerUrl ) { 
Assert . isNotNull ( originServerUrl ) ; 
return ( IContext ) contexts . get ( originServerUrl ) ; 
} public Enumeration getOriginServerUrls ( ) { 
final Enumeration enum1 = contexts . keys ( ) ; 
final Enumeration enum2 = proxyServerUrls . keys ( ) ; 
return enum1 . hasMoreElements ( ) || enum2 . hasMoreElements ( ) ; 
if ( enum1 . hasMoreElements ( ) ) 
return enum1 . nextElement ( ) ; 
return enum2 . nextElement ( ) ; 
} public URL getProxyServerUrl ( URL originServerUrl ) { 
return ( URL ) proxyServerUrls . get ( originServerUrl ) ; 
} public Response invoke ( Request request ) throws IOException { 
URL resourceUrl = request . getResourceUrl ( ) ; 
URL originServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , "/" ) ; 
URL proxyServerUrl = getProxyServerUrl ( originServerUrl ) ; 
if ( proxyServerUrl == null && ! matchesProxyServerException ( originServerUrl ) ) { 
proxyServerUrl = getDefaultProxyServerUrl ( ) ; 
IContext context = webDAVFactory . newContext ( request . getContext ( ) ) ; 
IContext defaultContext = getContext ( originServerUrl ) ; 
if ( defaultContext == null ) { 
defaultContext = getDefaultContext ( ) ; 
if ( defaultContext != null ) { 
Enumeration e = defaultContext . keys ( ) ; 
String key = ( String ) e . nextElement ( ) ; 
context . put ( key , defaultContext . get ( key ) ) ; 
if ( authority != null ) { 
authority . authorize ( request , null , context , proxyServerUrl , true ) ; 
authority . authorize ( request , null , context , proxyServerUrl , false ) ; 
return invoke1 ( request , context , proxyServerUrl , originServerUrl , 0 , 0 ) ; 
request . close ( ) ; 
} public void setContext ( URL originServerUrl , IContext context ) { 
contexts . remove ( originServerUrl ) ; 
contexts . put ( originServerUrl , context ) ; 
} public void setProxyServerUrl ( URL originServerUrl , URL proxyServerUrl ) { 
if ( proxyServerUrl == null ) 
proxyServerUrls . remove ( originServerUrl ) ; 
proxyServerUrls . put ( originServerUrl , proxyServerUrl ) ; 
} public InputStream getInputStream ( ) throws IOException { 
sendRequest ( ) ; 
String transferEncoding = responseHeader . getFieldValue ( "Transfer-Encoding" ) ; 
String contentLength = responseHeader . getFieldValue ( "Content-Length" ) ; 
if ( "chunked" . equalsIgnoreCase ( transferEncoding ) ) { 
is = new ChunkedInputStream ( ) ; 
} else if ( method . equals ( "HEAD" ) && statusCode == HTTP_OK ) { 
is = new LimitedInputStream ( 0 ) ; 
} else if ( contentLength != null ) { 
is = new LimitedInputStream ( Integer . parseInt ( contentLength ) ) ; 
} else if ( ( statusCode >= 100 && statusCode < 200 ) || statusCode == HTTP_NO_CONTENT || statusCode == HTTP_NOT_MODIFIED ) { 
closeConnection = true ; 
is = socketIn ; 
} public OutputStream getOutputStream ( ) throws IOException { 
if ( os != null ) 
return os ; 
String contentLength = requestHeader . getFieldValue ( "Content-Length" ) ; 
if ( sendChunked && httpVersion > 1.0 ) { 
os = new ChunkedOutputStream ( ) ; 
os = new LimitedOutputStream ( Integer . parseInt ( contentLength ) ) ; 
throw new IOException ( Policy . bind ( "exception.malformedContentLength" ) ) ; 
os = new CachedOutputStream ( ) ; 
} public String getRequestHeaderFieldValue ( String fieldName ) { 
Assert . isNotNull ( fieldName ) ; 
return requestHeader . getFieldValue ( fieldName ) ; 
} public String getResponseHeaderFieldName ( int position ) throws IOException { 
Assert . isTrue ( position >= 0 ) ; 
return responseHeader . getFieldName ( position ) ; 
} public String getResponseHeaderFieldValue ( int position ) throws IOException { 
return responseHeader . getFieldValue ( position ) ; 
} public String getResponseHeaderFieldValue ( String fieldName ) throws IOException { 
return responseHeader . getFieldValue ( fieldName ) ; 
} public void setProxyServerUrl ( URL proxyServerUrl ) { 
endRequest ( ) ; 
if ( proxyServerUrl == null && this . proxyServerUrl == null ) 
boolean closeConnection = true ; 
if ( proxyServerUrl != null && this . proxyServerUrl != null ) { 
URL oldProxyServerUrl = null ; 
URL newProxyServerUrl = null ; 
oldProxyServerUrl = new URL ( this . proxyServerUrl . getProtocol ( ) , this . proxyServerUrl . getHost ( ) , this . proxyServerUrl . getPort ( ) , "/" ) ; 
newProxyServerUrl = new URL ( proxyServerUrl . getProtocol ( ) , proxyServerUrl . getHost ( ) , proxyServerUrl . getPort ( ) , "/" ) ; 
if ( oldProxyServerUrl . equals ( newProxyServerUrl ) ) { 
closeConnection = false ; 
if ( closeConnection ) { 
this . proxyServerUrl = proxyServerUrl ; 
} public void setRequestHeaderField ( String fieldName , String fieldValue ) { 
Assert . isNotNull ( fieldValue ) ; 
requestHeader . addField ( fieldName , fieldValue ) ; 
} public void setResourceUrl ( URL resourceUrl ) { 
Assert . isNotNull ( resourceUrl ) ; 
URL oldOriginServerUrl = null ; 
URL newOriginServerUrl = null ; 
oldOriginServerUrl = new URL ( this . resourceUrl . getProtocol ( ) , this . resourceUrl . getHost ( ) , this . resourceUrl . getPort ( ) , "/" ) ; 
newOriginServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , "/" ) ; 
if ( ! oldOriginServerUrl . equals ( newOriginServerUrl ) ) { 
this . resourceUrl = resourceUrl ; 
} public void setSocketFactory ( ISocketFactory socketFactory ) { 
if ( socketFactory == this . socketFactory ) 
this . socketFactory = socketFactory ; 
} private void createRuleSampleLauncher ( IJavaProject project ) 
Version version = startPage . getRuntime ( ) . getVersion ( ) ; 
if ( version . getMajor ( ) == 4 ) { 
createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template" , "DroolsTest.java" ) ; 
} else if ( version . getMajor ( ) == 5 ) { 
createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template" , "DroolsTest.java" ) ; 
} else if ( version . getMajor ( ) >= 6 ) { 
createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template" , "DroolsTest.java" ) ; 
} private void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { 
if ( startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) >= 6 ) { 
FileUtils . createFolder ( project , "src/main/resources/com/sample/rules" , monitor ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/Sample.drl.template" , "src/main/resources/com/sample/rules" , "Sample.drl" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/Sample.drl.template" , "src/main/rules" , "Sample.drl" ) ; 
} private void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.rf.template" , "src/main/rules" , "ruleflow.rf" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.rfm.template" , "src/main/rules" , "ruleflow.rfm" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.drl.template" , "src/main/rules" , "ruleflow.drl" ) ; 
} else if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) { 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow.rf.template" , "src/main/rules" , "ruleflow.rf" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/sample.bpmn.template" , "src/main/rules" , "sample.bpmn" ) ; 
FileUtils . createFolder ( project , "src/main/resources/com/sample/process" , monitor ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/sample.bpmn.template" , "src/main/resources/com/sample/process" , "sample.bpmn" ) ; 
} private void createRuleFlowSampleLauncher ( IJavaProject project ) 
s = "org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template" ; 
s = "org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template" ; 
s = "org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template" ; 
s = "org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template" ; 
createProjectJavaFile ( project , s , "ProcessTest.java" ) ; 
protected IKieProjectWizardPage createStartPage ( String pageId ) { 
return new AbstractKieProjectStartWizardPage ( pageId ) { 
} public List < IInstallableUnit > getSelectedIUs ( ) { 
List < IInstallableUnit > result = new ArrayList < IInstallableUnit > ( ) ; 
for ( Object o : getCheckedElements ( ) ) { 
if ( o instanceof IUTreeItem ) { 
IUTreeItem item = ( IUTreeItem ) o ; 
if ( item . parent != null ) 
result . add ( item . iu ) ; 
assert ( targetPart != null && selectedItems != null ) ; 
AddResourceWizard wiz = new AddResourceWizard ( ) ; 
wiz . init ( Activator . getDefault ( ) . getWorkbench ( ) , selectedItems ) ; 
WizardDialog dialog = new WizardDialog ( targetPart . getSite ( ) . getShell ( ) , wiz ) ; 
if ( dialog . open ( ) == WizardDialog . OK ) { 
PlatformUtils . refreshRepositoryView ( ) ; 
} public void createImage ( OutputStream stream , int format ) { 
SWTGraphics g = null ; 
GC gc = null ; 
LayerManager layerManager = ( LayerManager ) 
getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; 
IFigure figure = layerManager . getLayer ( LayerConstants . PRINTABLE_LAYERS ) ; 
Rectangle r = figure . getBounds ( ) ; 
image = new Image ( Display . getDefault ( ) , r . width , r . height ) ; 
gc = new GC ( image ) ; 
g = new SWTGraphics ( gc ) ; 
g . translate ( r . x * - 1 , r . y * - 1 ) ; 
figure . paint ( g ) ; 
ImageLoader imageLoader = new ImageLoader ( ) ; 
imageLoader . data = new ImageData [ ] { image . getImageData ( ) } ; 
imageLoader . save ( stream , format ) ; 
gc . dispose ( ) ; 
if ( image != null ) { 
image . dispose ( ) ; 
Object key = keysEnum . nextElement ( ) ; 
localValues . put ( key , defaults . get ( key ) ) ; 
} public Object get ( Object key ) { 
Object value = localValues . get ( key ) ; 
return localValues . keys ( ) ; 
return new MergedEnumeration ( localValues . keys ( ) , defaults . keys ( ) ) ; 
public void run ( IAction action ) { 
assert ( selectedItems != null ) ; 
for ( Iterator it = selectedItems . iterator ( ) ; it . hasNext ( ) ; ) { 
Object oneItem = it . next ( ) ; 
if ( oneItem instanceof IFile ) { 
processUpdate ( ( IFile ) oneItem ) ; 
PlatformUtils . updateDecoration ( ) ; 
public Object loadAdapter ( Class adapter , IProgressMonitor monitor ) { 
return server . loadAdapter ( adapter , monitor ) ; 
public IStatus canModifyModules ( IModule [ ] add , IModule [ ] remove , IProgressMonitor monitor ) { 
return server . canModifyModules ( add , remove , monitor ) ; 
public String getAttribute ( String attributeName , String defaultValue ) { 
return server . getAttribute ( attributeName , defaultValue ) ; 
public Map getAttribute ( String attributeName , Map defaultValue ) { 
public IModule [ ] getChildModules ( IModule [ ] module , IProgressMonitor monitor ) { 
return server . getChildModules ( module , monitor ) ; 
public IModule [ ] getRootModules ( IModule module , IProgressMonitor monitor ) throws CoreException { 
return server . getRootModules ( module , monitor ) ; 
public IStatus publish ( int kind , IProgressMonitor monitor ) { 
return server . publish ( kind , monitor ) ; 
public void publish ( int kind , List < IModule [ ] > modules , IAdaptable info , IOperationListener listener ) { 
server . publish ( kind , modules , info , listener ) ; 
public void start ( String launchMode , IProgressMonitor monitor ) throws CoreException { 
server . start ( launchMode , monitor ) ; 
public void start ( String launchMode , IOperationListener listener ) { 
server . start ( launchMode , listener ) ; 
public void restart ( String launchMode , IProgressMonitor monitor ) { 
server . restart ( launchMode , monitor ) ; 
public void restart ( String launchMode , IOperationListener listener ) { 
server . restart ( launchMode , listener ) ; 
public IStatus canControlModule ( IModule [ ] module , IProgressMonitor monitor ) { 
return server . canControlModule ( module , monitor ) ; 
public IStatus canRestartModule ( IModule [ ] module , IProgressMonitor monitor ) { 
return server . canRestartModule ( module , monitor ) ; 
public IStatus canPublishModule ( IModule [ ] module , IProgressMonitor monitor ) { 
return server . canPublishModule ( module , monitor ) ; 
public void startModule ( IModule [ ] module , IOperationListener listener ) { 
server . startModule ( module , listener ) ; 
public void stopModule ( IModule [ ] module , IOperationListener listener ) { 
server . stopModule ( module , listener ) ; 
public void restartModule ( IModule [ ] module , IOperationListener listener ) { 
server . restartModule ( module , listener ) ; 
public ILaunchConfiguration getLaunchConfiguration ( boolean create , IProgressMonitor monitor ) throws CoreException { 
return server . getLaunchConfiguration ( create , monitor ) ; 
public void synchronousStart ( String launchMode , IProgressMonitor monitor ) throws CoreException { 
server . synchronousStart ( launchMode , monitor ) ; 
AlphaNodeFieldConstraint constraint = this . node . getConstraint ( ) ; 
if ( constraint instanceof MvelConstraint ) { 
MvelConstraint mvelConstraint = ( MvelConstraint ) constraint ; 
return NODE_NAME + "<BR/>" ; 
} public String getFieldName ( ) { 
InternalReadAccessor accessor = mvelConstraint . getFieldExtractor ( ) ; 
if ( accessor instanceof ClassFieldReader ) { 
return ( ( ClassFieldReader ) accessor ) . getFieldName ( ) ; 
} public String getEvaluator ( ) { 
return mvelConstraint . toString ( ) ; 
} public String getValue ( ) { 
FieldValue field = mvelConstraint . getField ( ) ; 
return field != null ? field . toString ( ) : null ; 
Object oneSelection = it . next ( ) ; 
if ( oneSelection instanceof IFile ) { 
GuvnorMetadataUtils . commitFileChanges ( ( IFile ) oneSelection ) ; 
boolean validResourceSet = ActionUtils . checkResourceSet ( selection , true ) 
&& ActionUtils . areFilesDirty ( selection ) ; 
if ( validResourceSet ) { 
selectedItems = ( IStructuredSelection ) selection ; 
selectedItems = null ; 
} public void setSessionAuthenticator ( IAuthenticator sessionAuthen ) { 
if ( sessionAuthen != null ) { 
client . getHttpClient ( ) . setAuthenticator ( sessionAuthen ) ; 
client . getHttpClient ( ) . setAuthenticator ( platformAuthenticator ) ; 
} public IContext createContext ( ) { 
IContext context = WebDAVFactory . contextFactory . newContext ( ) ; 
context . put ( "USER-AGENT" , "guvnor" ) ; 
} public Map < String , ResourceProperties > listDirectory ( String path ) throws Exception { 
IContext context = createContext ( ) ; 
context . put ( "Depth" , "1" ) ; 
ILocator locator = WebDAVFactory . locatorFactory . newLocator ( path ) ; 
response = client . propfind ( locator , context , null ) ; 
if ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) { 
throw new WebDavException ( response ) ; 
Map < String , ResourceProperties > res = 
StreamProcessingUtils . parseListing ( path , response . getInputStream ( ) ) ; 
addGuvnorResourceProperties ( res , path ) ; 
} public ResourceProperties queryProperties ( String resource ) throws Exception { 
ILocator locator = WebDAVFactory . locatorFactory . newLocator ( resource ) ; 
if ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS 
&& response . getStatusCode ( ) != IResponse . SC_OK ) { 
Map < String , ResourceProperties > props = 
StreamProcessingUtils . parseListing ( "" , response . getInputStream ( ) ) ; 
if ( props . keySet ( ) . size ( ) != 1 ) { 
String fullpath = props . keySet ( ) . iterator ( ) . next ( ) ; 
ResourceProperties res = props . get ( fullpath ) ; 
String filename = new Path ( fullpath ) . lastSegment ( ) ; 
addGuvnorResourceProperties ( res , filename , resource ) ; 
} private void addGuvnorResourceProperties ( ResourceProperties props , 
String filename , String resource ) throws Exception { 
if ( props == null ) { 
String path = resource . substring ( 0 , resource . lastIndexOf ( '/' ) ) ; 
String apiVer = changeToAPICall ( path ) ; 
Properties guvProps = new Properties ( ) ; 
response = getResourceInputStream ( apiVer ) ; 
guvProps . load ( response . getInputStream ( ) ) ; 
String val = guvProps . getProperty ( filename ) ; 
if ( val != null ) { 
StringTokenizer tokens = new StringTokenizer ( val , "," ) ; 
if ( tokens . hasMoreElements ( ) ) { 
props . setLastModifiedDate ( tokens . nextToken ( ) ) ; 
props . setRevision ( tokens . nextToken ( ) ) ; 
Activator . getDefault ( ) . writeLog ( IStatus . WARNING , nfe . getMessage ( ) , nfe ) ; 
} public String getResourceContents ( String resource ) throws Exception { 
response = getResourceInputStream ( resource ) ; 
return StreamProcessingUtils . getStreamContents ( response . getInputStream ( ) ) ; 
} public String getResourceVersionContents ( String resource , String version ) throws Exception { 
String apiVer = changeToAPICall ( resource ) + "?version=" + version ; 
return getResourceContents ( apiVer ) ; 
} public IResponse getResourceInputStream ( String resource ) throws Exception { 
IResponse response = client . get ( locator , createContext ( ) ) ; 
if ( response . getStatusCode ( ) != IResponse . SC_OK ) { 
} public IResponse getResourceVersionInputStream ( String resource , String version ) throws Exception { 
return getResourceInputStream ( apiVer ) ; 
} public boolean createResource ( String resource , InputStream is ) throws Exception { 
return createResource ( resource , is , true ) ; 
} public boolean createResource ( String resource , InputStream is , boolean overwrite ) throws Exception { 
boolean res = true ; 
if ( ! overwrite ) { 
if ( queryProperties ( resource ) != null ) { 
res = false ; 
if ( e . getErrorCode ( ) != IResponse . SC_NOT_FOUND ) { 
response = client . put ( locator , createContext ( ) , is ) ; 
if ( response . getStatusCode ( ) != IResponse . SC_OK 
&& response . getStatusCode ( ) != IResponse . SC_CREATED ) { 
} public void putResource ( String resource , InputStream is ) throws Exception { 
&& response . getStatusCode ( ) != IResponse . SC_NO_CONTENT 
} public IResponse getResourceVersions ( String resource ) throws Exception { 
String apiVer = changeToAPICall ( resource ) + "?version=all" ; 
} public void deleteResource ( String resource ) throws Exception { 
response = client . delete ( locator , createContext ( ) ) ; 
if ( response . getStatusCode ( ) != IResponse . SC_NO_CONTENT 
if ( selectedItems == null ) { 
String msg = null ; 
if ( selectedItems . size ( ) == 1 ) { 
msg = MessageFormat . format ( Messages . getString ( "delete.singlefile.confirmation" ) , 
new Object [ ] { ( ( IFile ) selectedItems . getFirstElement ( ) ) . getName ( ) } ) ; 
msg = MessageFormat . format ( Messages . getString ( "delete.multifile.confirmation" ) , 
new Object [ ] { String . valueOf ( selectedItems . size ( ) ) } ) ; 
if ( ! MessageDialog . openConfirm ( targetPart . getSite ( ) . getShell ( ) , 
Messages . getString ( "delete.confirmation.dialog.caption" ) , msg ) ) { 
processDelete ( ( IFile ) oneItem ) ; 
DisconnectAction dsAction = new DisconnectAction ( ) ; 
dsAction . disconnect ( selectedItems ) ; 
} public void baselineControl ( ILocator baseline ) throws DAVException { 
Assert . isNotNull ( baseline ) ; 
Element root = ElementEditor . create ( document , "baseline-control" ) ; 
ElementEditor . addChild ( root , "baseline" , 
baseline . getResourceURL ( ) , new String [ ] { "baseline" } , 
response = davClient . baselineControl ( locator , newContext ( ) , document ) ; 
} public void bind ( String member , ILocator source ) throws DAVException { 
bind ( member , source , false ) ; 
} public void bind ( String member , ILocator source , boolean overwrite ) throws DAVException { 
ILocator destination = getMember ( member ) ; 
response = davClient . bind ( source , destination , context ) ; 
} public ILocator getMember ( String memberName ) { 
String parentName = locator . getResourceURL ( ) ; 
String childName ; 
if ( parentName . endsWith ( "/" ) ) 
childName = parentName + memberName ; 
childName = parentName + "/" + memberName ; 
return davClient . getDAVFactory ( ) . newLocator ( childName ) ; 
} public Set getMembers ( ) throws DAVException { 
Collection querySet = new Vector ( ) ; 
querySet . add ( DAV_RESOURCE_TYPE ) ; 
URLTable resourceTable = getProperties ( querySet , IContext . DEPTH_ONE ) ; 
Set reply = new HashSet ( ) ; 
resourceTable . remove ( locator . getResourceURL ( ) ) ; 
} catch ( MalformedURLException exception ) { 
throw new DAVException ( Policy . bind ( "exception.malformedLocator" ) ) ; 
Enumeration resourceNameEnum = resourceTable . keys ( ) ; 
while ( resourceNameEnum . hasMoreElements ( ) ) { 
URL url = ( URL ) resourceNameEnum . nextElement ( ) ; 
Hashtable propertyTable = ( Hashtable ) resourceTable . get ( url ) ; 
Assert . isNotNull ( propertyTable ) ; 
PropertyStatus propertyStatus = ( PropertyStatus ) propertyTable . get ( DAV_RESOURCE_TYPE ) ; 
Assert . isNotNull ( propertyStatus ) ; 
ILocator newLocator = davClient . getDAVFactory ( ) . newLocator ( url . toString ( ) ) ; 
Element property = propertyStatus . getProperty ( ) ; 
if ( ElementEditor . hasChild ( property , DAV_COLLECTION_RESOURCE_TYPE ) ) 
reply . add ( new CollectionHandle ( davClient , newLocator ) ) ; 
reply . add ( new ResourceHandle ( davClient , newLocator ) ) ; 
final List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; 
Collections . sort ( sorted , new Comparator < BaseVertex > ( ) { 
public int compare ( final BaseVertex v1 , final BaseVertex v2 ) { 
int v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; 
int v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; 
if ( v1OutDegree < v2OutDegree ) { 
if ( v1OutDegree > v2OutDegree ) { 
final LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; 
boolean front = false ; 
for ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; vertexIter . hasNext ( ) ; ) { 
final BaseVertex vertex = vertexIter . next ( ) ; 
if ( front ) { 
optimized . addFirst ( vertex ) ; 
optimized . addLast ( vertex ) ; 
front = ! front ; 
this . vertices = optimized ; 
} public boolean authorize ( Request request , IResponse response , IContext context , URL proxyServerUrl , boolean isProxyAuthorization ) { 
Assert . isNotNull ( context ) ; 
URL serverUrl = null ; 
URL protectionSpaceUrl = null ; 
if ( isProxyAuthorization ) { 
if ( proxyServerUrl == null ) { 
serverUrl = proxyServerUrl ; 
protectionSpaceUrl = proxyServerUrl ; 
serverUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , "/" ) ; 
protectionSpaceUrl = resourceUrl ; 
String challengeString = null ; 
challengeString = response . getContext ( ) . getProxyAuthenticate ( ) ; 
challengeString = response . getContext ( ) . getWWWAuthenticate ( ) ; 
if ( challengeString == null ) { 
AuthenticateChallenge challenge = null ; 
challenge = new AuthenticateChallenge ( challengeString ) ; 
} catch ( ParserException e ) { 
String authScheme = challenge . getAuthScheme ( ) ; 
String realm = challenge . getRealm ( ) ; 
AuthorizationAuthority authority = getAuthorizationAuthority ( authScheme ) ; 
if ( authority == null ) { 
Map oldInfo = authenticatorStore . getAuthenticationInfo ( serverUrl , realm , authScheme ) ; 
Map info = authority . getAuthenticationInfo ( challenge , oldInfo , serverUrl , protectionSpaceUrl ) ; 
if ( info == null ) { 
authenticatorStore . addAuthenticationInfo ( serverUrl , realm , authScheme , info ) ; 
authenticatorStore . addProtectionSpace ( protectionSpaceUrl , realm ) ; 
String realm = authenticatorStore . getProtectionSpace ( protectionSpaceUrl ) ; 
if ( realm == null ) { 
Map info = null ; 
String authScheme = null ; 
for ( int i = 0 ; i < authenticationSchemes . length ; ++ i ) { 
authScheme = authenticationSchemes [ i ] ; 
info = authenticatorStore . getAuthenticationInfo ( serverUrl , realm , authScheme ) ; 
if ( info != null ) { 
String authorization = authority . getAuthorization ( request , info , serverUrl , protectionSpaceUrl , proxyServerUrl ) ; 
if ( authorization == null ) { 
if ( authorization . equals ( context . getProxyAuthorization ( ) ) ) 
context . setProxyAuthorization ( authorization ) ; 
if ( authorization . equals ( context . getAuthorization ( ) ) ) 
context . setAuthorization ( authorization ) ; 
} public boolean confirm ( Request request , IResponse response , URL proxyServerUrl ) { 
Assert . isNotNull ( response ) ; 
String realm = authenticatorStore . getProtectionSpace ( resourceUrl ) ; 
return authority . confirmResponse ( request , response , proxyServerUrl ) ; 
} protected boolean confirmResponse ( Request request , IResponse response , URL proxyServerUrl ) { 
} protected Map getAuthenticationInfo ( AuthenticateChallenge challenge , Map oldInfo , URL serverUrl , URL protectionSpaceUrl ) { 
Assert . isNotNull ( challenge ) ; 
Assert . isNotNull ( serverUrl ) ; 
Assert . isNotNull ( protectionSpaceUrl ) ; 
} protected String getAuthorization ( Request request , Map info , URL serverUrl , URL protectionSpaceUrl , URL proxyServerUrl ) { 
Assert . isNotNull ( info ) ; 
} private AuthorizationAuthority getAuthorizationAuthority ( String scheme ) { 
scheme = Character . toUpperCase ( scheme . charAt ( 0 ) ) + scheme . substring ( 1 ) . toLowerCase ( ) ; 
String packageName = "org.eclipse.webdav.internal.authentication" ; 
String className = scheme + "Authority" ; 
Class clazz = Class . forName ( packageName + "." + className ) ; 
Constructor constructor = clazz . getConstructor ( new Class [ ] { IAuthenticator . class } ) ; 
return ( AuthorizationAuthority ) constructor . newInstance ( new Object [ ] { authenticatorStore } ) ; 
} protected String md5 ( String s ) throws NoSuchAlgorithmException , UnsupportedEncodingException { 
MessageDigest md5 = MessageDigest . getInstance ( "MD5" ) ; 
byte [ ] hash = md5 . digest ( s . getBytes ( "UTF8" ) ) ; 
return HexConverter . toHex ( hash ) ; 
} protected String md5 ( Request request ) throws NoSuchAlgorithmException , IOException { 
DigestOutputStream dos = new DigestOutputStream ( "MD5" ) ; 
request . write ( dos ) ; 
String result = HexConverter . toHex ( dos . digest ( ) ) ; 
dos . close ( ) ; 
} protected String unquote ( String s ) { 
if ( s . charAt ( 0 ) == '"' && s . charAt ( s . length ( ) - 1 ) == '"' ) 
boolean not = false ; 
ConditionFactor factor = null ; 
if ( tokenizer . sval . equalsIgnoreCase ( "Not" ) ) { 
not = true ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingNot" ) ) ; 
switch ( token ) { 
factor = StateToken . create ( tokenizer ) ; 
case '[' : 
factor = EntityTag . create ( tokenizer ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingOpen" , String . valueOf ( token ) ) ) ; 
factor . setNot ( not ) ; 
return factor ; 
public void createRepository ( final IKieRepositoryHandler repository ) throws IOException { 
public String execute ( ) throws IOException { 
return httpPost ( "spaces/" + repository . getParent ( ) . getName ( ) + "/projects/" , repository . getProperties ( ) ) ; 
} private void initializeControls ( ) { 
if ( originalFile != null ) { 
resourceGroup . setContainerFullPath ( originalFile . getParent ( ) 
. getFullPath ( ) ) ; 
String fileName = originalFile . getName ( ) ; 
int index = fileName . lastIndexOf ( "." ) ; 
fileName = fileName . substring ( 0 , index ) ; 
fileName += "-image.png" ; 
resourceGroup . setResource ( fileName ) ; 
} else if ( originalName != null ) { 
resourceGroup . setResource ( originalName ) ; 
setDialogComplete ( validatePage ( ) ) ; 
} protected void okPressed ( ) { 
IPath path = resourceGroup . getContainerFullPath ( ) . append ( 
resourceGroup . getResource ( ) ) ; 
if ( path . getFileExtension ( ) == null ) { 
if ( originalFile != null && originalFile . getFileExtension ( ) != null ) { 
path = path . addFileExtension ( originalFile . getFileExtension ( ) ) ; 
int pos = originalName . lastIndexOf ( '.' ) ; 
if ( ++ pos > 0 && pos < originalName . length ( ) ) { 
path = path . addFileExtension ( originalName . substring ( pos ) ) ; 
IFile file = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFile ( path ) ; 
if ( file . exists ( ) ) { 
String [ ] buttons = new String [ ] { IDialogConstants . YES_LABEL , 
IDialogConstants . NO_LABEL , IDialogConstants . CANCEL_LABEL } ; 
String question = NLS . bind ( 
IDEWorkbenchMessages . SaveAsDialog_overwriteQuestion , path 
. toString ( ) ) ; 
MessageDialog d = new MessageDialog ( getShell ( ) , 
IDEWorkbenchMessages . Question , 
null , question , MessageDialog . QUESTION , buttons , 0 ) ; 
int overwrite = d . open ( ) ; 
switch ( overwrite ) { 
cancelPressed ( ) ; 
result = path ; 
} private boolean validatePage ( ) { 
if ( ! resourceGroup . areAllValuesValid ( ) ) { 
if ( ! resourceGroup . getResource ( ) . equals ( "" ) ) { 
setErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; 
setErrorMessage ( null ) ; 
String resourceName = resourceGroup . getResource ( ) ; 
IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; 
IPath fullPath = resourceGroup . getContainerFullPath ( ) ; 
if ( fullPath != null ) { 
String projectName = fullPath . segment ( 0 ) ; 
IStatus isValidProjectName = workspace . validateName ( projectName , IResource . PROJECT ) ; 
if ( isValidProjectName . isOK ( ) ) { 
IProject project = workspace . getRoot ( ) . getProject ( projectName ) ; 
if ( ! project . isOpen ( ) ) { 
setErrorMessage ( IDEWorkbenchMessages . SaveAsDialog_closedProjectMessage ) ; 
IStatus result = workspace . validateName ( resourceName , IResource . FILE ) ; 
if ( ! result . isOK ( ) ) { 
setErrorMessage ( result . getMessage ( ) ) ; 
} protected IDialogSettings getDialogBoundsSettings ( ) { 
IDialogSettings settings = IDEWorkbenchPlugin . getDefault ( ) . getDialogSettings ( ) ; 
IDialogSettings section = settings . getSection ( DIALOG_SETTINGS_SECTION ) ; 
section = settings . addNewSection ( DIALOG_SETTINGS_SECTION ) ; 
return section ; 
EntityTag entityTag = new EntityTag ( ) ; 
if ( token == '[' ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "[" ) ) ; 
if ( token == '"' ) { 
entityTag . setETag ( tokenizer . sval ) ; 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingQuotedString" , String . valueOf ( token ) ) ) ; 
if ( token == ']' ) 
throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "]" ) ) ; 
return entityTag ; 
} public static EntityTag generateEntityTag ( ) { 
String xx = basetime + ":" + Integer . toHexString ( Thread . currentThread ( ) . hashCode ( ) ) ; 
bcnt ++ ; 
xx += ":" + bcnt ; 
return new EntityTag ( xx ) ; 
} public void create ( ) throws DAVException { 
Mkworkspace . create ( document ) ; 
response = davClient . mkworkspace ( locator , newContext ( ) , document ) ; 
} public BaseVertex getOpposite ( BaseVertex vertex ) { 
if ( vertex == null || ( ! vertex . equals ( getSource ( ) ) && ! vertex . equals ( getTarget ( ) ) ) ) { 
if ( vertex . equals ( getSource ( ) ) ) { 
return getTarget ( ) ; 
return getSource ( ) ; 
} public static AsymmetricCipherKeyPair generateKeyPairParameter ( ECDomainParameters domainParameters , 
SecureRandom random ) { 
ECKeyGenerationParameters keyGenerationParams = new ECKeyGenerationParameters ( domainParameters , 
random ) ; 
ECKeyPairGenerator keyGen = new ECKeyPairGenerator ( ) ; 
keyGen . init ( keyGenerationParams ) ; 
return keyGen . generateKeyPair ( ) ; 
} public static byte [ ] convertECPrivateKeyToPKCS8 ( ECPrivateKeyParameters priKey , 
ECPublicKeyParameters pubKey ) { 
ECDomainParameters domainParams = priKey . getParameters ( ) ; 
ECParameterSpec spec = new ECParameterSpec ( domainParams . getCurve ( ) , domainParams . getG ( ) , 
domainParams . getN ( ) , domainParams . getH ( ) ) ; 
BCECPublicKey publicKey = null ; 
if ( pubKey != null ) { 
publicKey = new BCECPublicKey ( ALGO_NAME_EC , pubKey , spec , 
BouncyCastleProvider . CONFIGURATION ) ; 
BCECPrivateKey privateKey = new BCECPrivateKey ( ALGO_NAME_EC , priKey , publicKey , 
spec , BouncyCastleProvider . CONFIGURATION ) ; 
return privateKey . getEncoded ( ) ; 
} public static BCECPrivateKey convertPKCS8ToECPrivateKey ( byte [ ] pkcs8Key ) 
throws NoSuchAlgorithmException , NoSuchProviderException , InvalidKeySpecException { 
PKCS8EncodedKeySpec peks = new PKCS8EncodedKeySpec ( pkcs8Key ) ; 
KeyFactory kf = KeyFactory . getInstance ( ALGO_NAME_EC , BouncyCastleProvider . PROVIDER_NAME ) ; 
return ( BCECPrivateKey ) kf . generatePrivate ( peks ) ; 
} public static byte [ ] convertECPrivateKeyToSEC1 ( ECPrivateKeyParameters priKey , 
ECPublicKeyParameters pubKey ) throws IOException { 
byte [ ] pkcs8Bytes = convertECPrivateKeyToPKCS8 ( priKey , pubKey ) ; 
PrivateKeyInfo pki = PrivateKeyInfo . getInstance ( pkcs8Bytes ) ; 
ASN1Encodable encodable = pki . parsePrivateKey ( ) ; 
ASN1Primitive primitive = encodable . toASN1Primitive ( ) ; 
byte [ ] sec1Bytes = primitive . getEncoded ( ) ; 
return sec1Bytes ; 
} public static byte [ ] convertECPrivateKeySEC1ToPKCS8 ( byte [ ] sec1Key ) throws IOException { 
X962Parameters params = getDomainParametersFromName ( SM2Util . JDK_EC_SPEC , false ) ; 
ASN1OctetString privKey = new DEROctetString ( sec1Key ) ; 
ASN1EncodableVector v = new ASN1EncodableVector ( ) ; 
v . add ( new ASN1Integer ( 0 ) ) ; 
v . add ( new AlgorithmIdentifier ( X9ObjectIdentifiers . id_ecPublicKey , params ) ) ; 
v . add ( privKey ) ; 
DERSequence ds = new DERSequence ( v ) ; 
return ds . getEncoded ( ASN1Encoding . DER ) ; 
} public static BCECPrivateKey convertSEC1ToBCECPrivateKey ( byte [ ] sec1Key ) 
throws NoSuchAlgorithmException , NoSuchProviderException , InvalidKeySpecException , IOException { 
PKCS8EncodedKeySpec peks = new PKCS8EncodedKeySpec ( convertECPrivateKeySEC1ToPKCS8 ( sec1Key ) ) ; 
} public static ECPrivateKeyParameters convertSEC1ToECPrivateKey ( byte [ ] sec1Key ) 
BCECPrivateKey privateKey = convertSEC1ToBCECPrivateKey ( sec1Key ) ; 
return convertPrivateKeyToParameters ( privateKey ) ; 
} public static byte [ ] convertECPublicKeyToX509 ( ECPublicKeyParameters pubKey ) { 
ECDomainParameters domainParams = pubKey . getParameters ( ) ; 
BCECPublicKey publicKey = new BCECPublicKey ( ALGO_NAME_EC , pubKey , spec , 
return publicKey . getEncoded ( ) ; 
} public static BCECPublicKey convertX509ToECPublicKey ( byte [ ] x509Bytes ) throws NoSuchProviderException , 
NoSuchAlgorithmException , InvalidKeySpecException { 
X509EncodedKeySpec eks = new X509EncodedKeySpec ( x509Bytes ) ; 
KeyFactory kf = KeyFactory . getInstance ( "EC" , BouncyCastleProvider . PROVIDER_NAME ) ; 
return ( BCECPublicKey ) kf . generatePublic ( eks ) ; 
} public static X9ECParameters getDomainParametersFromName ( String curveName ) { 
X9ECParameters domainParameters ; 
if ( curveName . charAt ( 0 ) >= '0' && curveName . charAt ( 0 ) <= '2' ) { 
ASN1ObjectIdentifier oidID = new ASN1ObjectIdentifier ( curveName ) ; 
domainParameters = ECUtil . getNamedCurveByOid ( oidID ) ; 
domainParameters = ECUtil . getNamedCurveByName ( curveName ) ; 
return domainParameters ; 
} public static X962Parameters getDomainParametersFromName ( java . security . spec . ECParameterSpec ecSpec , 
boolean withCompression ) { 
X962Parameters params ; 
if ( ecSpec instanceof ECNamedCurveSpec ) { 
ASN1ObjectIdentifier curveOid = ECUtil . getNamedCurveOid ( ( ( ECNamedCurveSpec ) ecSpec ) . getName ( ) ) ; 
if ( curveOid == null ) { 
curveOid = new ASN1ObjectIdentifier ( ( ( ECNamedCurveSpec ) ecSpec ) . getName ( ) ) ; 
params = new X962Parameters ( curveOid ) ; 
} else if ( ecSpec == null ) { 
params = new X962Parameters ( DERNull . INSTANCE ) ; 
ECCurve curve = EC5Util . convertCurve ( ecSpec . getCurve ( ) ) ; 
X9ECParameters ecP = new X9ECParameters ( 
curve , 
EC5Util . convertPoint ( curve , ecSpec . getGenerator ( ) , withCompression ) , 
ecSpec . getOrder ( ) , 
BigInteger . valueOf ( ecSpec . getCofactor ( ) ) , 
ecSpec . getCurve ( ) . getSeed ( ) ) ; 
params = new X962Parameters ( ecP ) ; 
return params ; 
} public static byte [ ] encrypt ( String srcData , String publicKey ) throws Exception { 
if ( RUNNING_PUBLIC_KEY == null ) { 
LOCK . lock ( ) ; 
ECPoint ecPoint = CURVE . decodePoint ( Base64 . decode ( publicKey . toCharArray ( ) ) ) ; 
RUNNING_PUBLIC_KEY = new ECPublicKeyParameters ( ecPoint , DOMAIN_PARAMS ) ; 
LOCK . unlock ( ) ; 
return encrypt ( RUNNING_PUBLIC_KEY , srcData . getBytes ( ) ) ; 
} public static byte [ ] getRawPublicKey ( BCECPublicKey publicKey ) { 
byte [ ] src65 = publicKey . getQ ( ) . getEncoded ( false ) ; 
byte [ ] rawXY = new byte [ CURVE_LEN * 2 ] ; 
System . arraycopy ( src65 , 1 , rawXY , 0 , rawXY . length ) ; 
return rawXY ; 
} public static byte [ ] encrypt ( ECPublicKeyParameters pubKeyParameters , byte [ ] srcData ) 
throws InvalidCipherTextException { 
SM2Engine engine = new SM2Engine ( ) ; 
ParametersWithRandom pwr = new ParametersWithRandom ( pubKeyParameters , new SecureRandom ( ) ) ; 
engine . init ( true , pwr ) ; 
return engine . processBlock ( srcData , 0 , srcData . length ) ; 
} public static byte [ ] decrypt ( ECPrivateKeyParameters priKeyParameters , byte [ ] sm2Cipher ) 
engine . init ( false , priKeyParameters ) ; 
return engine . processBlock ( sm2Cipher , 0 , sm2Cipher . length ) ; 
} public static AmazonKinesis buildKinesisClient ( @ Nullable String accessKey , @ Nullable String secretKey , 
@ Nullable String endpoint , @ Nullable Integer port , @ Nullable String region ) { 
AmazonKinesisClientBuilder builder = AmazonKinesisClientBuilder . standard ( ) ; 
setAws ( builder , accessKey , secretKey , endpoint , port , region ) ; 
} public static void ensureStreamExists ( AmazonKinesis kinesisClient , String streamName ) { 
createStreamIfNotExists ( kinesisClient , streamName , 1 ) ; 
waitStreamActivation ( kinesisClient , streamName , MIN_3 ) ; 
} private static void createStreamIfNotExists ( AmazonKinesis kinesis , String streamName , int shardCount ) { 
performAmazonActionWithRetry ( "createStream" , ( ) -> { 
DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; 
kinesis . describeStream ( describeStreamRequest ) ; 
} catch ( ResourceNotFoundException e ) { 
kinesis . createStream ( streamName , shardCount ) ; 
} , DEFAULT_RETRY_COUNT , DEFAULT_RETRY_DURATION_IN_MILLIS ) ; 
} private static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { 
DescribeStreamResult describeStreamResult = null ; 
String streamStatus = null ; 
long endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; 
describeStreamResult = consumer . describeStream ( describeStreamRequest ) ; 
streamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; 
if ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) { 
} catch ( ResourceNotFoundException | LimitExceededException ignored ) { 
} while ( System . currentTimeMillis ( ) < endTime ) ; 
if ( describeStreamResult == null || streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) { 
args -> args . add ( "streamName" , streamName ) . add ( "streamCreationTimeoutMillis" , streamCreationTimeoutMillis ) ) ; 
public < T > TypeConverter < T > getTypeConverter ( Class < T > clazz ) { 
TypeConverter < T > converter = ( TypeConverter < T > ) TYPE_CONVERTERS . get ( clazz ) ; 
converter = value -> ( T ) value ; 
} public static < TAIL , HEAD > Collection < TAIL > reciprocalManyRelation ( Class < TAIL > tailEntityClass , Accessor < TAIL , HEAD > relationAccessor ) { 
return THREAD_LOCAL_DSL_HELPER . get ( ) . reciprocalManyRelation ( tailEntityClass , relationAccessor ) ; 
} private static void completeStoreSnapshotWithMissingInstanceSnapshots ( Path targetStoresPath ) { 
String transactionIdRegexAlone = "\"transactionId\"\\s*:\\s*\\d+\\s*," ; 
String transactionIdRegexReplace = "(.*\"transactionId\"\\s*:\\s*)\\d+(\\s*,.*)" ; 
Pattern transactionIdPattern = compile ( transactionIdRegexAlone ) ; 
Set < File > previousSnapshots = new HashSet < > ( ) ; 
Arrays . stream ( targetStoresPath . resolve ( SNAPSHOT_DIRECTORY_NAME ) . toFile ( ) . listFiles ( ) ) . 
sorted ( ) . 
forEach ( snapshot -> { 
Set < String > snapshotNames = Arrays . stream ( snapshot . listFiles ( ) ) . map ( File :: getName ) . collect ( toSet ( ) ) ; 
previousSnapshots . stream ( ) . 
filter ( previousSnapshot -> ! snapshotNames . contains ( previousSnapshot . getName ( ) ) ) . 
forEach ( previousSnapshot -> { 
Path targetPath = snapshot . toPath ( ) . resolve ( previousSnapshot . getName ( ) ) ; 
Path sourcePath = previousSnapshot . toPath ( ) ; 
long count = countTransactionId ( transactionIdPattern , sourcePath ) ; 
if ( count != 1L ) { 
BigInteger newTransactionId = new BigInteger ( snapshot . getName ( ) ) ; 
replaceTransactionIdValue ( transactionIdRegexReplace , sourcePath , targetPath , newTransactionId . toString ( ) ) ; 
throw new UncheckedIOException ( e ) ; 
previousSnapshots . clear ( ) ; 
previousSnapshots . addAll ( Arrays . stream ( snapshot . listFiles ( ) ) . collect ( toSet ( ) ) ) ; 
} private Shard getUniqueShard ( ) { 
DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( m_streamName ) . withLimit ( 1 ) ; 
( ) -> m_kinesis . describeStream ( describeStreamRequest ) , DEFAULT_RETRY_COUNT , 
DEFAULT_RETRY_DURATION_IN_MILLIS ) ; 
String streamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; 
if ( streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) { 
List < Shard > shards = describeStreamResult . getStreamDescription ( ) . getShards ( ) ; 
args -> args . add ( "streamName" , m_streamName ) . add ( "shardCount" , shards . size ( ) ) ) ; 
return shards . get ( 0 ) ; 
} private boolean waitTheMinimalDurationToExecuteTheNextProvisioningRequest ( ) { 
if ( m_lastGetShardIteratorRequestTime != null ) { 
long delay = m_durationBetweenRequests . get ( ) - ( System . currentTimeMillis ( ) - m_lastGetShardIteratorRequestTime ) ; 
if ( delay > 0 ) { 
Thread . sleep ( delay ) ; 
m_lastGetShardIteratorRequestTime = System . currentTimeMillis ( ) ; 
private List < Record > getRecords ( GetRecordsRequest getRecordsRequest ) { 
return tryAmazonAction ( "" , ( ) -> { 
GetRecordsResult getRecordsResult = m_kinesis . getRecords ( getRecordsRequest ) ; 
m_shardIterator = getRecordsResult . getNextShardIterator ( ) ; 
List < Record > records = getRecordsResult . getRecords ( ) ; 
. add ( "millisBehindLatest" , getRecordsResult . getMillisBehindLatest ( ) ) ) ; 
} , m_durationBetweenRequests ) . orElse ( List . of ( ) ) ; 
} public static < T > T performAmazonActionWithRetry ( String actionLabel , Supplier < T > action , int retryLimit , int durationInMillis ) { 
int retryCount = 0 ; 
return action . get ( ) ; 
} catch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { 
int remainingRetries = retryLimit - retryCount ; 
args -> args . add ( "exception" , e . getClass ( ) . getName ( ) ) . add ( "action" , actionLabel ) . add ( "remainingRetryCount" , remainingRetries ) ) ; 
sleepUntilInterrupted ( actionLabel , durationInMillis ) ; 
} while ( retryCount ++ < retryLimit ) ; 
} public static < T > Optional < T > tryAmazonAction ( String actionLabel , Supplier < T > action , AtomicLong durationBetweenRequests ) { 
return of ( action . get ( ) ) ; 
int durationRandomModifier = 1 + RANDOM . nextInt ( 64 ) ; 
long updatedDuration = durationBetweenRequests . updateAndGet ( duration -> duration * 2 
+ duration * 2 / durationRandomModifier ) ; 
} public static AmazonS3 buildS3Client ( @ Nullable String accessKey , @ Nullable String secretKey , 
AmazonS3ClientBuilder builder = AmazonS3ClientBuilder . standard ( ) ; 
} static String checkBucketIsAccessible ( AmazonS3 amazonS3 , String bucketName ) { 
HeadBucketRequest headBucketRequest = new HeadBucketRequest ( bucketName ) ; 
amazonS3 . headBucket ( headBucketRequest ) ; 
} catch ( AmazonServiceException e ) { 
return bucketName ; 
} public static < T > Method retrieveMethod ( Class < T > clazz , Accessor < T , ? > accessor ) { 
MethodCallRecorder methodCallRecorder = new MethodCallRecorder ( ) ; 
T accessorInstance = ProxyFactoryBuilder . < MethodCallRecorder > newProxyFactoryBuilder ( ) 
. defaultObjectMethods ( ) 
. unhandled ( ( context , proxy , method , args ) -> { 
context . setMethod ( method ) ; 
return DEFAULT_VALUES . get ( method . getReturnType ( ) ) ; 
. build ( clazz ) . createProxy ( methodCallRecorder ) ; 
accessor . get ( accessorInstance ) ; 
Method method = methodCallRecorder . getMethod ( ) ; 
if ( method == null ) { 
return method ; 
} Optional < BigInteger > loadStores ( Function < String , EntityStores > entityStoresByStoreName , 
BiFunction < SerializableSnapshot , String , SerializableSnapshot > snapshotPostProcessor ) { 
Optional < BigInteger > latestSnapshotTxId ; 
latestSnapshotTxId = m_snapshotStore . listSnapshots ( ) . stream ( ) . max ( BigInteger :: compareTo ) ; 
latestSnapshotTxId . ifPresent ( lastTx -> { 
var postProcess = new SnapshotPostProcessor ( snapshotPostProcessor ) ; 
Flowable . fromPublisher ( m_snapshotStore . createSnapshotReader ( lastTx ) ) 
. blockingForEach ( reader -> { 
String storeName = reader . storeName ( ) ; 
EntityStores entityStores = entityStoresByStoreName . apply ( storeName ) ; 
SerializableSnapshot serializableSnapshot ; 
try ( InputStream is = reader . inputStream ( ) ) { 
serializableSnapshot = m_snapshotSerializer . deserializeSnapshot ( storeName , is ) ; 
if ( serializableSnapshot . getSnapshotModelVersion ( ) != SNAPSHOT_MODEL_VERSION ) { 
args -> args . add ( "version" , serializableSnapshot . getSnapshotModelVersion ( ) ) 
. add ( "expectedVersion" , SNAPSHOT_MODEL_VERSION ) ) ; 
if ( ! lastTx . equals ( serializableSnapshot . getTransactionId ( ) ) ) { 
args -> args . add ( "snapshotTransactionId" , serializableSnapshot . getTransactionId ( ) ) 
. add ( "requestTransactionId" , lastTx ) ) ; 
SerializableSnapshot finalSnapshot = postProcess . apply ( storeName , serializableSnapshot ) ; 
finalSnapshot . getEntities ( ) . forEach ( serializableEntityInstances -> { 
String entityName = serializableEntityInstances . getEntityName ( ) ; 
EntityStore < ? > entityStore = entityStores . getEntityStore ( entityName ) ; 
entityStore . recover ( serializableEntityInstances ) ; 
m_applicationModelVersion = postProcess . getConsistentApplicationModelVersion ( ) ; 
if ( ! latestSnapshotTxId . isPresent ( ) ) { 
return latestSnapshotTxId ; 
} public InputStream locateStream ( final String uri , final File folder ) 
final Collection < File > files = findMatchedFiles ( new WildcardContext ( uri , folder ) ) ; 
final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
for ( final File file : files ) { 
if ( file . isFile ( ) ) { 
final InputStream is = new FileInputStream ( file ) ; 
IOUtils . copy ( is , out ) ; 
return new BufferedInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; 
} @ SuppressWarnings ( "serial" ) 
private IOFileFilter createWildcardCollectorFileFilter ( final WildcardContext wildcardContext , final Collection < File > allFiles ) { 
notNull ( wildcardContext ) ; 
notNull ( allFiles ) ; 
return new WildcardFileFilter ( wildcardContext . getWildcard ( ) ) { 
public boolean accept ( final File file ) { 
final boolean accept = super . accept ( file ) ; 
allFiles . add ( file ) ; 
return accept ; 
} private void validate ( final WildcardContext wildcardContext ) 
final String uri = wildcardContext . getUri ( ) ; 
final File folder = wildcardContext . getFolder ( ) ; 
if ( uri == null || folder == null || ! folder . isDirectory ( ) ) { 
if ( folder != null ) { 
throw new IOException ( message . toString ( ) ) ; 
if ( ! hasWildcard ( uri ) ) { 
} void triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) 
if ( allFiles . isEmpty ( ) ) { 
LOG . warn ( message ) ; 
throw new IOException ( message ) ; 
if ( wildcardExpanderHandler != null ) { 
wildcardExpanderHandler . apply ( allFiles ) ; 
} private static String replace ( final String inString , final String oldPattern , 
final String newPattern ) { 
if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { 
return inString ; 
final StringBuffer sbuf = new StringBuffer ( ) ; 
int index = inString . indexOf ( oldPattern ) ; 
final int patLen = oldPattern . length ( ) ; 
sbuf . append ( inString . substring ( pos , index ) ) ; 
sbuf . append ( newPattern ) ; 
pos = index + patLen ; 
index = inString . indexOf ( oldPattern , pos ) ; 
sbuf . append ( inString . substring ( pos ) ) ; 
} private static String collectionToDelimitedString ( final Collection < String > coll , 
final String delim ) { 
return collectionToDelimitedString ( coll , delim , EMPTY , EMPTY ) ; 
} private static String deleteAny ( final String inString , 
final String charsToDelete ) { 
if ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { 
final StringBuffer out = new StringBuffer ( ) ; 
for ( int i = 0 ; i < inString . length ( ) ; i ++ ) { 
final char c = inString . charAt ( i ) ; 
if ( charsToDelete . indexOf ( c ) == - 1 ) { 
out . append ( c ) ; 
public void process ( final Resource resource , final Reader reader , final Writer writer ) 
final String content = IOUtils . toString ( reader ) ; 
final TypeScriptCompiler compiler = enginePool . getObject ( ) ; 
writer . write ( compiler . compile ( content ) ) ; 
onException ( e , content ) ; 
enginePool . returnObject ( compiler ) ; 
protected String getArgument ( final Resource resource ) { 
final String name = resource == null ? "" : FilenameUtils . getBaseName ( resource . getUri ( ) ) ; 
return String . format ( "'%s'" , name ) ; 
} private RequestHandlerFactory newRequestHandlerFactory ( ) { 
final SimpleRequestHandlerFactory factory = new SimpleRequestHandlerFactory ( ) ; 
final List < RequestHandler > requestHandlers = getConfiguredStrategies ( ) ; 
for ( final RequestHandler requestHandler : requestHandlers ) { 
factory . addHandler ( requestHandler ) ; 
if ( requestHandlers . isEmpty ( ) ) { 
return new DefaultRequestHandlerFactory ( ) ; 
} public LintReport < T > addReport ( final ResourceLintReport < T > resourceLintReport ) { 
Validate . notNull ( resourceLintReport ) ; 
reports . add ( resourceLintReport ) ; 
} private RhinoScriptBuilder initScriptBuilder ( ) { 
builder = RhinoScriptBuilder . newChain ( ) . evaluateChain ( DEFINE_WINDOW , "window" ) . evaluateChain ( 
getScriptAsStream ( ) , "linter.js" ) ; 
} public void validate ( final String data ) 
throws LinterException { 
final StopWatch watch = new StopWatch ( ) ; 
watch . start ( "init" ) ; 
final RhinoScriptBuilder builder = initScriptBuilder ( ) ; 
watch . stop ( ) ; 
watch . start ( "lint" ) ; 
final String packIt = buildLinterScript ( WroUtil . toJSMultiLineString ( data ) , getOptions ( ) ) ; 
final boolean valid = Boolean . parseBoolean ( builder . evaluate ( packIt , "check" ) . toString ( ) ) ; 
final String json = builder . addJSON ( ) . evaluate ( 
final Type type = new TypeToken < List < LinterError > > ( ) { } . getType ( ) ; 
final List < LinterError > errors = new Gson ( ) . fromJson ( json , type ) ; 
throw new LinterException ( ) . setErrors ( errors ) ; 
LOG . debug ( watch . prettyPrint ( ) ) ; 
} private String buildLinterScript ( final String data , final String options ) { 
return String . format ( "%s(%s,%s);" , getLinterName ( ) , data , optionsBuilder . buildFromCsv ( options ) ) ; 
protected ProcessorsFactory newProcessorsFactory ( ) { 
return new ConfigurableProcessorsFactory ( ) { 
protected Properties newProperties ( ) { 
final Properties props = new Properties ( ) ; 
updatePropertiesWithConfiguration ( props , ConfigurableProcessorsFactory . PARAM_PRE_PROCESSORS ) ; 
updatePropertiesWithConfiguration ( props , ConfigurableProcessorsFactory . PARAM_POST_PROCESSORS ) ; 
protected Map < String , ResourcePostProcessor > getPostProcessorStrategies ( final ProcessorProvider provider ) { 
final Map < String , ResourcePostProcessor > map = super . getPostProcessorStrategies ( provider ) ; 
contributePostProcessors ( map ) ; 
protected Map < String , ResourcePreProcessor > getPreProcessorStrategies ( final ProcessorProvider provider ) { 
final Map < String , ResourcePreProcessor > map = super . getPreProcessorStrategies ( provider ) ; 
contributePreProcessors ( map ) ; 
} private void updatePropertiesWithConfiguration ( final Properties props , final String key ) { 
final FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; 
final String valuesAsString = filterConfig . getInitParameter ( key ) ; 
if ( valuesAsString != null ) { 
props . setProperty ( key , valuesAsString ) ; 
final String value = getConfigProperties ( ) . getProperty ( key ) ; 
props . setProperty ( key , value ) ; 
} private Properties getConfigProperties ( ) { 
if ( configProperties == null ) { 
configProperties = newConfigProperties ( ) ; 
if ( additionalConfigProperties != null ) { 
configProperties . putAll ( additionalConfigProperties ) ; 
return configProperties ; 
} protected Properties newConfigProperties ( ) { 
return new ServletContextPropertyWroConfigurationFactory ( Context . get ( ) . getServletContext ( ) ) . createProperties ( ) ; 
} private Map < String , ResourcePreProcessor > getPreProcessorsMap ( ) { 
if ( this . preProcessorsMap == null ) { 
this . preProcessorsMap = newPreProcessorsMap ( ) ; 
return this . preProcessorsMap ; 
} private Map < String , ResourcePostProcessor > getPostProcessorsMap ( ) { 
if ( this . postProcessorsMap == null ) { 
this . postProcessorsMap = newPostProcessorsMap ( ) ; 
return this . postProcessorsMap ; 
public synchronized WroModel create ( ) { 
stopWatch . start ( "createModel" ) ; 
final Type type = new TypeToken < WroModel > ( ) { } . getType ( ) ; 
final InputStream is = getModelResourceAsStream ( ) ; 
final WroModel model = new Gson ( ) . fromJson ( new InputStreamReader ( new AutoCloseInputStream ( is ) ) , type ) ; 
if ( model == null ) { 
return model ; 
stopWatch . stop ( ) ; 
LOG . debug ( stopWatch . prettyPrint ( ) ) ; 
} public static SmartWroModelFactory createFromStandaloneContext ( final StandaloneContext context ) { 
notNull ( context ) ; 
final boolean autoDetectWroFile = WroUtil . normalize ( context . getWroFile ( ) . getPath ( ) ) . contains ( 
WroUtil . normalize ( DEFAULT_WRO_FILE ) ) ; 
if ( ! autoDetectWroFile ) { 
return new SmartWroModelFactory ( ) . setWroFile ( context . getWroFile ( ) ) . setAutoDetectWroFile ( autoDetectWroFile ) ; 
} private InputStream createAutoDetectedStream ( final String defaultFileName ) 
if ( autoDetectWroFile ) { 
final File file = new File ( wroFile . getParentFile ( ) , defaultFileName ) ; 
return new FileInputStream ( file ) ; 
return new FileInputStream ( wroFile ) ; 
} catch ( final FileNotFoundException e ) { 
public WroModel create ( ) { 
if ( factoryList == null ) { 
factoryList = newWroModelFactoryFactoryList ( ) ; 
if ( factoryList != null ) { 
final StringBuffer logMessageBuffer = new StringBuffer ( ) ; 
for ( final WroModelFactory factory : factoryList ) { 
injector . inject ( factory ) ; 
final Class < ? extends WroModelFactory > factoryClass = factory . getClass ( ) . asSubclass ( WroModelFactory . class ) ; 
return factory . create ( ) ; 
} catch ( final WroRuntimeException e ) { 
if ( ! autoDetectWroFile && e . getCause ( ) instanceof IOException ) { 
LOG . error ( logMessageBuffer . toString ( ) ) ; 
} public final String removeImportStatements ( ) { 
final StringBuffer sb = new StringBuffer ( ) ; 
matcher . appendReplacement ( sb , StringUtils . EMPTY ) ; 
matcher . appendTail ( sb ) ; 
} public Map < String , ResourcePreProcessor > providePreProcessors ( ) { 
final Map < String , ResourcePreProcessor > map = new HashMap < String , ResourcePreProcessor > ( ) ; 
populateProcessorsMap ( map ) ; 
} private Map < String , ResourcePostProcessor > toPostProcessors ( 
final Map < String , ResourcePreProcessor > preProcessorsMap ) { 
final Map < String , ResourcePostProcessor > map = new HashMap < String , ResourcePostProcessor > ( ) ; 
for ( final Entry < String , ResourcePreProcessor > entry : preProcessorsMap . entrySet ( ) ) { 
map . put ( entry . getKey ( ) , new ProcessorDecorator ( entry . getValue ( ) ) ) ; 
} protected ExecutorService newExecutor ( ) { 
final ExecutorService executor = ( ExecutorService ) Class . forName ( "java.util.concurrent.ForkJoinPool" ) . newInstance ( ) ; 
return executor ; 
return Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
} public void submit ( final Collection < Callable < T > > callables ) 
Validate . notNull ( callables ) ; 
final AtomicLong totalTime = new AtomicLong ( ) ; 
if ( callables . size ( ) == 1 ) { 
final T result = callables . iterator ( ) . next ( ) . call ( ) ; 
onResultAvailable ( result ) ; 
for ( final Callable < T > callable : callables ) { 
getCompletionService ( ) . submit ( decorate ( callable , totalTime ) ) ; 
for ( int i = 0 ; i < callables . size ( ) ; i ++ ) { 
doConsumeResult ( ) ; 
destroy ( ) ; 
final long averageExecutionTime = callables . size ( ) != 0 ? totalTime . longValue ( ) / callables . size ( ) : 0 ; 
} public void process ( final Resource resource , final Reader reader , final Writer writer ) 
final StringBuffer result = new JawrCssMinifier ( ) . minifyCSS ( new StringBuffer ( content ) ) ; 
writer . write ( result . toString ( ) ) ; 
final String resourceUri = resource == null ? StringUtils . EMPTY : "[" + resource . getUri ( ) + "]" ; 
LOG . error ( message , e ) ; 
} public String compile ( final String content , final String optionalArgument ) { 
final String argStr = createArgStr ( optionalArgument ) + createArgStr ( getArguments ( ) ) ; 
final String compileScript = 
String . format ( "%s(%s%s);" , getCompileCommand ( ) , WroUtil . toJSMultiLineString ( content ) , argStr ) ; 
return ( String ) builder . evaluate ( compileScript , getCompileCommand ( ) ) ; 
public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { 
final AbstractJsTemplateCompiler jsCompiler = enginePool . getObject ( ) ; 
writer . write ( jsCompiler . compile ( content , getArgument ( resource ) ) ) ; 
enginePool . returnObject ( jsCompiler ) ; 
protected String replaceImageUrl ( final String cssUri , final String imageUrl ) { 
Validate . notNull ( uriLocatorFactory ) ; 
final String cleanImageUrl = cleanImageUrl ( imageUrl ) ; 
final String fileName = FilenameUtils . getName ( imageUrl ) ; 
String fullPath = cleanImageUrl ; 
if ( isImageUrlChangeRequired ( cleanImageUrl ) ) { 
fullPath = WroUtil . getFullPath ( cssUri ) + cleanImageUrl ; 
String result = imageUrl ; 
is = uriLocatorFactory . locate ( fullPath ) ; 
final String dataUri = getDataUriGenerator ( ) . generateDataURI ( is , fileName ) ; 
if ( isReplaceAccepted ( dataUri ) ) { 
result = dataUri ; 
IOUtils . closeQuietly ( is ) ; 
} protected boolean isReplaceAccepted ( final String dataUri ) { 
final byte [ ] bytes = dataUri . getBytes ( CharEncoding . UTF_8 ) ; 
final boolean exceedLimit = bytes . length >= SIZE_LIMIT ; 
return ! exceedLimit ; 
} catch ( final UnsupportedEncodingException e ) { 
final Matcher originalMatcher = PATTERN_COPYRIGHT . matcher ( content ) ; 
final StringBuffer copyrightBuffer = new StringBuffer ( ) ; 
while ( originalMatcher . find ( ) ) { 
copyrightBuffer . append ( originalMatcher . group ( ) ) ; 
final Writer processedWriter = new StringWriter ( ) ; 
getDecoratedObject ( ) . process ( resource , new StringReader ( content ) , processedWriter ) ; 
final Matcher processedMatcher = PATTERN_COPYRIGHT . matcher ( processedWriter . toString ( ) ) ; 
if ( ! processedMatcher . find ( ) ) { 
writer . write ( copyrightBuffer . toString ( ) ) ; 
writer . write ( processedWriter . toString ( ) ) ; 
protected ObjectFactory < WroConfiguration > newWroConfigurationFactory ( final FilterConfig filterConfig ) { 
properties = new Properties ( ) ; 
properties . setProperty ( ConfigConstants . debug . name ( ) , String . valueOf ( debug ) ) ; 
properties . setProperty ( ConfigConstants . gzipResources . name ( ) , String . valueOf ( gzipEnabled ) ) ; 
properties . setProperty ( ConfigConstants . jmxEnabled . name ( ) , String . valueOf ( jmxEnabled ) ) ; 
properties . setProperty ( ConfigConstants . cacheUpdatePeriod . name ( ) , String . valueOf ( cacheUpdatePeriod ) ) ; 
properties . setProperty ( ConfigConstants . modelUpdatePeriod . name ( ) , String . valueOf ( modelUpdatePeriod ) ) ; 
properties . setProperty ( ConfigConstants . disableCache . name ( ) , String . valueOf ( disableCache ) ) ; 
if ( encoding != null ) { 
properties . setProperty ( ConfigConstants . encoding . name ( ) , encoding ) ; 
if ( mbeanName != null ) { 
properties . setProperty ( ConfigConstants . mbeanName . name ( ) , mbeanName ) ; 
return new PropertyWroConfigurationFactory ( properties ) ; 
WroModel newModel = null ; 
newModel = super . create ( ) ; 
if ( newModel == null ) { 
if ( lastValidModel == null ) { 
return lastValidModel ; 
lastValidModel = newModel ; 
final String resourceContent = IOUtils . toString ( reader ) ; 
final Reader innerReader = new StringReader ( resourceContent ) ; 
final StringWriter innerWriter = new StringWriter ( ) ; 
super . process ( resource , innerReader , innerWriter ) ; 
writer . write ( innerWriter . toString ( ) ) ; 
final String processorName = toString ( ) ; 
if ( isIgnoreFailingProcessor ( ) ) { 
writer . write ( resourceContent ) ; 
final String resourceUri = resource != null ? resource . getUri ( ) : null ; 
throw WroRuntimeException . wrap ( e , 
} public String encodeGroupUrl ( final String groupName , final ResourceType resourceType , final boolean minimize ) { 
return decorated . encodeGroupUrl ( groupName , resourceType , minimize ) ; 
} private void reloadCacheWithNewValue ( final Long newValue ) { 
final long newValueAsPrimitive = newValue == null ? getCacheUpdatePeriod ( ) : newValue ; 
for ( final PropertyChangeListener listener : cacheUpdatePeriodListeners ) { 
final PropertyChangeEvent event = new PropertyChangeEvent ( this , "cache" , getCacheUpdatePeriod ( ) , 
newValueAsPrimitive ) ; 
listener . propertyChange ( event ) ; 
} private void reloadModelWithNewValue ( final Long newValue ) { 
final long newValueAsPrimitive = newValue == null ? getModelUpdatePeriod ( ) : newValue ; 
for ( final PropertyChangeListener listener : modelUpdatePeriodListeners ) { 
final PropertyChangeEvent event = new PropertyChangeEvent ( this , "model" , getModelUpdatePeriod ( ) , 
public Map < String , ResourcePostProcessor > providePostProcessors ( ) { 
final Map < String , ResourcePostProcessor > resultMap = new HashMap < String , ResourcePostProcessor > ( ) ; 
final Map < String , ResourcePreProcessor > preProcessorsMap = createMap ( ) ; 
resultMap . put ( entry . getKey ( ) , new ProcessorDecorator ( entry . getValue ( ) ) ) ; 
return resultMap ; 
} public static SchedulerHelper create ( final LazyInitializer < Runnable > runnableFactory , final String name ) { 
return new SchedulerHelper ( runnableFactory , name ) ; 
} public SchedulerHelper scheduleWithPeriod ( final long period , final TimeUnit timeUnit ) { 
notNull ( timeUnit ) ; 
if ( this . period != period ) { 
this . period = period ; 
if ( ! poolInitializer . get ( ) . isShutdown ( ) ) { 
startScheduler ( period , timeUnit ) ; 
} private synchronized void destroyScheduler ( ) { 
poolInitializer . get ( ) . shutdown ( ) ; 
future . cancel ( true ) ; 
while ( ! poolInitializer . get ( ) . awaitTermination ( 5 , TimeUnit . SECONDS ) ) { 
poolInitializer . get ( ) . shutdownNow ( ) ; 
} catch ( final InterruptedException e ) { 
} public InputStream getInputStream ( final HttpServletRequest request , final HttpServletResponse response , 
final String location ) 
if ( request == null || response == null || location == null ) { 
final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; 
boolean warnOnEmptyStream = false ; 
final RequestDispatcher dispatcher = request . getRequestDispatcher ( location ) ; 
if ( dispatcher != null ) { 
final ServletRequest servletRequest = getWrappedServletRequest ( request , location ) ; 
final ServletResponse servletResponse = new RedirectedStreamServletResponseWrapper ( os , response ) ; 
dispatcher . include ( servletRequest , servletResponse ) ; 
warnOnEmptyStream = true ; 
servletResponse . getWriter ( ) . flush ( ) ; 
return locateExternal ( request , location ) ; 
if ( os . size ( ) == 0 ) { 
if ( warnOnEmptyStream && os . size ( ) == 0 ) { 
return new ByteArrayInputStream ( os . toByteArray ( ) ) ; 
} private ServletRequest getWrappedServletRequest ( final HttpServletRequest request , final String location ) { 
final HttpServletRequest wrappedRequest = new HttpServletRequestWrapper ( request ) { 
public String getRequestURI ( ) { 
return getContextPath ( ) + location ; 
public String getPathInfo ( ) { 
return WroUtil . getPathInfoFromLocation ( this , location ) ; 
public String getServletPath ( ) { 
return WroUtil . getServletPathFromLocation ( this , location ) ; 
wrappedRequest . setAttribute ( ATTRIBUTE_INCLUDED_BY_DISPATCHER , Boolean . TRUE ) ; 
return wrappedRequest ; 
} public void setResourcePreProcessors ( final Collection < ResourcePreProcessor > processors ) { 
preProcessors . clear ( ) ; 
if ( processors != null ) { 
preProcessors . addAll ( processors ) ; 
} public void setResourcePostProcessors ( final Collection < ResourcePostProcessor > processors ) { 
postProcessors . clear ( ) ; 
postProcessors . addAll ( processors ) ; 
} public SimpleProcessorsFactory addPostProcessor ( final ResourcePostProcessor processor ) { 
if ( processor . getClass ( ) . isAnnotationPresent ( Minimize . class ) ) { 
postProcessors . add ( processor ) ; 
return RhinoScriptBuilder . newClientSideAwareChain ( ) . addJSON ( ) . evaluateChain ( 
getScriptAsStream ( ) , DEFAULT_JS ) ; 
} public static < T > ProviderFinder < T > of ( final Class < T > type ) { 
return new ProviderFinder < T > ( type ) ; 
private void collectConfigurableProviders ( final List < T > providers ) { 
if ( type . isAssignableFrom ( ConfigurableProvider . class ) && ( type != ConfigurableProvider . class ) ) { 
final Iterator < ConfigurableProvider > iterator = lookupProviders ( ConfigurableProvider . class ) ; 
for ( ; iterator . hasNext ( ) ; ) { 
final T provider = ( T ) iterator . next ( ) ; 
providers . add ( provider ) ; 
< P > Iterator < P > lookupProviders ( final Class < P > providerClass ) { 
final Class < ? > serviceLoader = getClass ( ) . getClassLoader ( ) . loadClass ( "java.util.ServiceLoader" ) ; 
return ( ( Iterable < P > ) serviceLoader . getMethod ( "load" , Class . class ) . invoke ( serviceLoader , providerClass ) ) . iterator ( ) ; 
return ServiceRegistry . lookupProviders ( providerClass ) ; 
protected void doInit ( final FilterConfig filterConfig ) 
throws ServletException { 
String targetBeanName = filterConfig 
. getInitParameter ( PARAM_TARGET_BEAN_NAME ) ; 
targetBeanName = StringUtils . isEmpty ( targetBeanName ) ? DEFAULT_TARGET_BEAN_NAME 
: targetBeanName ; 
final WebApplicationContext ctx = WebApplicationContextUtils 
. getWebApplicationContext ( filterConfig . getServletContext ( ) ) ; 
factory = ( WroManagerFactory ) ctx . getBean ( targetBeanName , 
WroManagerFactory . class ) ; 
if ( factory == null ) { 
+ WroManagerFactory . class . getName ( ) 
} public String resolve ( ) { 
final File cssTargetFolder = cssDestinationFolder == null ? destinationFolder : cssDestinationFolder ; 
File rootFolder = null ; 
if ( buildFinalName != null && cssTargetFolder . getPath ( ) . startsWith ( buildFinalName . getPath ( ) ) ) { 
rootFolder = buildFinalName ; 
} else if ( cssTargetFolder . getPath ( ) . startsWith ( buildDirectory . getPath ( ) ) ) { 
rootFolder = buildDirectory ; 
for ( final String contextFolder : getContextFolders ( ) ) { 
if ( cssTargetFolder . getPath ( ) . startsWith ( contextFolder ) ) { 
rootFolder = new File ( contextFolder ) ; 
if ( rootFolder != null ) { 
result = StringUtils . removeStart ( cssTargetFolder . getPath ( ) , rootFolder . getPath ( ) ) ; 
} private String [ ] getContextFolders ( ) { 
final StandaloneContext context = new StandaloneContext ( ) ; 
context . setContextFoldersAsCSV ( contextFoldersAsCSV ) ; 
return context . getContextFolders ( ) ; 
} public static Transformer < String > extensionTransformer ( final String newExtension ) { 
return new Transformer < String > ( ) { 
public String transform ( final String input ) { 
return FilenameUtils . getBaseName ( input ) + "." + newExtension ; 
} public static Transformer < String > baseNameSuffixTransformer ( final String suffix ) { 
final String baseName = FilenameUtils . getBaseName ( input ) ; 
final String extension = FilenameUtils . getExtension ( input ) ; 
return baseName + suffix + "." + extension ; 
} void action ( final int d ) throws IOException , 
UnterminatedRegExpLiteralException , UnterminatedCommentException , 
UnterminatedStringLiteralException { 
switch ( d ) { 
out . write ( theA ) ; 
if ( theA == theB && ( theA == '+' || theA == '-' ) && theY != theA ) { 
theA = theB ; 
if ( theA == '\'' || theA == '"' || theA == '`' ) { 
theA = get ( ) ; 
if ( theA == theB ) { 
if ( theA <= '\n' ) { 
throw new UnterminatedStringLiteralException ( ) ; 
if ( theA == '\\' ) { 
theB = next ( ) ; 
if ( theB == '/' 
&& ( theA == '(' || theA == ',' || theA == '=' || theA == ':' 
|| theA == '[' || theA == '!' || theA == '&' || theA == '|' 
|| theA == '?' || theA == '+' || theA == '-' || theA == '~' 
|| theA == '*' || theA == '/' || theA == '{' || theA == '\n' ) ) { 
if ( theA == '/' || theA == '*' ) { 
out . write ( theB ) ; 
if ( theA == '[' ) { 
if ( theA == ']' ) { 
throw new UnterminatedRegExpLiteralException ( ) ; 
} else if ( theA == '/' ) { 
switch ( peek ( ) ) { 
case '/' : 
case '*' : 
} else if ( theA == '\\' ) { 
} else if ( theA <= '\n' ) { 
} public static String get ( final String fileName ) { 
final String extension = FilenameUtils . getExtension ( WroUtil . removeQueryString ( fileName . toLowerCase ( ) ) ) ; 
if ( defaultContentTypeMap . containsKey ( extension ) ) { 
return defaultContentTypeMap . get ( extension ) ; 
final Class < ? > fileTypeMapClass = ClassLoader . getSystemClassLoader ( ) . loadClass ( "javax.activation.FileTypeMap" ) ; 
final Object fileTypeMap = fileTypeMapClass . getMethod ( "getDefaultFileTypeMap" ) . invoke ( fileTypeMapClass ) ; 
return ( String ) fileTypeMapClass . getMethod ( "getContentType" , String . class ) . invoke ( fileTypeMap , fileName ) ; 
return DEFAULT_CONTENT_TYPE ; 
} public static String get ( final String fileName , final String encoding ) { 
final String contentType = get ( fileName ) ; 
if ( requiresCharset . contains ( contentType ) ) { 
} public InputStream locate ( final String uri ) 
String location = StringUtils . cleanPath ( uri . replaceFirst ( PREFIX , "" ) ) . trim ( ) ; 
if ( getWildcardStreamLocator ( ) . hasWildcard ( location ) ) { 
return locateWildcardStream ( uri , location ) ; 
if ( location . contains ( "?" ) ) { 
location = DefaultWildcardStreamLocator . stripQueryPath ( location ) ; 
final InputStream is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( location ) ; 
public WildcardStreamLocator newWildcardStreamLocator ( ) { 
return new JarWildcardStreamLocator ( ) { 
public boolean hasWildcard ( final String uri ) { 
return isEnableWildcards ( ) && super . hasWildcard ( uri ) ; 
} public Map < String , NamingStrategy > provideNamingStrategies ( ) { 
final Map < String , NamingStrategy > map = new HashMap < String , NamingStrategy > ( ) ; 
map . put ( TimestampNamingStrategy . ALIAS , new TimestampNamingStrategy ( ) ) ; 
map . put ( NoOpNamingStrategy . ALIAS , new NoOpNamingStrategy ( ) ) ; 
map . put ( DefaultHashEncoderNamingStrategy . ALIAS , new DefaultHashEncoderNamingStrategy ( ) ) ; 
map . put ( FolderHashEncoderNamingStrategy . ALIAS , new FolderHashEncoderNamingStrategy ( ) ) ; 
} private void onError ( final int sc , final String msg ) { 
final OutputStream emptyStream = new ByteArrayOutputStream ( ) ; 
printWriter = new PrintWriter ( emptyStream ) ; 
servletOutputStream = new DelegatingServletOutputStream ( emptyStream ) ; 
public void sendRedirect ( final String location ) 
final InputStream is = externalResourceLocator . locate ( location ) ; 
IOUtils . copy ( is , servletOutputStream ) ; 
servletOutputStream . close ( ) ; 
} public synchronized WroModel transform ( final WroModel input ) { 
final WroModel model = input ; 
for ( final Group group : model . getGroups ( ) ) { 
final List < Resource > resources = group . getResources ( ) ; 
for ( final Resource resource : resources ) { 
processResource ( group , resource ) ; 
} private void processResource ( final Group group , final Resource resource ) { 
final UriLocator uriLocator = locatorFactory . getInstance ( resource . getUri ( ) ) ; 
if ( uriLocator instanceof WildcardUriLocatorSupport ) { 
final WildcardStreamLocator wildcardStreamLocator = ( ( WildcardUriLocatorSupport ) uriLocator ) . getWildcardStreamLocator ( ) ; 
if ( wildcardStreamLocator . hasWildcard ( resource . getUri ( ) ) 
&& wildcardStreamLocator instanceof WildcardExpanderHandlerAware ) { 
final WildcardExpanderHandlerAware expandedHandler = ( WildcardExpanderHandlerAware ) wildcardStreamLocator ; 
final String baseNameFolder = computeBaseNameFolder ( resource , uriLocator , expandedHandler ) ; 
expandedHandler . setWildcardExpanderHandler ( createExpanderHandler ( group , resource , baseNameFolder ) ) ; 
uriLocator . locate ( resource . getUri ( ) ) ; 
resource . getUri ( ) ) ; 
expandedHandler . setWildcardExpanderHandler ( null ) ; 
} private String computeBaseNameFolder ( final Resource resource , final UriLocator uriLocator , 
final WildcardExpanderHandlerAware expandedHandler ) { 
final String resourcePath = FilenameUtils . getFullPath ( resource . getUri ( ) ) 
+ DefaultWildcardStreamLocator . RECURSIVE_WILDCARD ; 
final ThreadLocal < String > baseNameFolderHolder = new ThreadLocal < String > ( ) ; 
expandedHandler . setWildcardExpanderHandler ( createBaseNameComputerFunction ( baseNameFolderHolder ) ) ; 
uriLocator . locate ( resourcePath ) ; 
resourcePath , e . getMessage ( ) ) ; 
if ( baseNameFolderHolder . get ( ) == null ) { 
return baseNameFolderHolder . get ( ) ; 
} public Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , 
final String baseNameFolder ) { 
return new Function < Collection < File > , Void > ( ) { 
public Void apply ( final Collection < File > files ) { 
if ( baseNameFolder == null ) { 
group . replace ( resource , new ArrayList < Resource > ( ) ) ; 
final List < Resource > expandedResources = new ArrayList < Resource > ( ) ; 
final String resourcePath = getFullPathNoEndSeparator ( resource ) ; 
final String computedResourceUri = resourcePath 
+ StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( '\\' , '/' ) ; 
final Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; 
expandedResources . add ( expandedResource ) ; 
group . replace ( resource , expandedResources ) ; 
private String getFullPathNoEndSeparator ( final Resource resource1 ) { 
final String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; 
if ( result != null && 1 == result . length ( ) && 0 == FilenameUtils . indexOfLastSeparator ( result ) ) { 
protected final String replaceImageUrl ( final String cssUri , final String imageUrl ) { 
if ( ! imageUrls . contains ( imageUrl ) ) { 
imageUrls . add ( imageUrl ) ; 
return super . replaceImageUrl ( cssUri , imageUrl ) ; 
return imageUrl ; 
} public final InputStream locate ( final String uri ) 
final UriLocator uriLocator = getInstance ( uri ) ; 
if ( uriLocator == null ) { 
return new AutoCloseInputStream ( uriLocator . locate ( uri ) ) ; 
RhinoScriptBuilder builder = null ; 
if ( scope == null ) { 
builder = RhinoScriptBuilder . newChain ( ) . evaluateChain ( getCoffeeScriptAsStream ( ) , DEFAULT_COFFE_SCRIPT ) ; 
scope = builder . getScope ( ) ; 
builder = RhinoScriptBuilder . newChain ( scope ) ; 
} public String compile ( final String data ) { 
buildOptions ( ) ) ; 
return ( String ) builder . evaluate ( compileScript , "CoffeeScript.compile" ) ; 
} private WroConfiguration createConfiguration ( ) { 
final WroConfiguration configAttribute = ServletContextAttributeHelper . create ( filterConfig ) . getWroConfiguration ( ) ; 
if ( configAttribute != null ) { 
setConfiguration ( configAttribute ) ; 
return getWroConfigurationFactory ( ) . create ( ) ; 
} private WroManagerFactory createWroManagerFactory ( ) { 
if ( wroManagerFactory == null ) { 
final WroManagerFactory managerFactoryAttribute = ServletContextAttributeHelper . create ( filterConfig ) 
. getManagerFactory ( ) ; 
wroManagerFactory = managerFactoryAttribute != null ? managerFactoryAttribute : newWroManagerFactory ( ) ; 
return wroManagerFactory ; 
} private void registerMBean ( ) { 
if ( wroConfiguration . isJmxEnabled ( ) ) { 
mbeanServer = getMBeanServer ( ) ; 
final ObjectName name = getMBeanObjectName ( ) ; 
if ( ! mbeanServer . isRegistered ( name ) ) { 
mbeanServer . registerMBean ( wroConfiguration , name ) ; 
} catch ( final JMException e ) { 
} private void registerChangeListeners ( ) { 
wroConfiguration . registerCacheUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { 
public void propertyChange ( final PropertyChangeEvent event ) { 
headersConfigurer = newResponseHeadersConfigurer ( ) ; 
wroManagerFactory . onCachePeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; 
wroConfiguration . registerModelUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { 
wroManagerFactory . onModelPeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; 
} private void processRequest ( final HttpServletRequest request , final HttpServletResponse response ) 
setResponseHeaders ( response ) ; 
wroManagerFactory . create ( ) . process ( ) ; 
} protected void onException ( final Exception e , final HttpServletResponse response , final FilterChain chain ) { 
chain . doFilter ( Context . get ( ) . getRequest ( ) , response ) ; 
} catch ( final Exception ex ) { 
} public final void setConfiguration ( final WroConfiguration config ) { 
notNull ( config ) ; 
wroConfigurationFactory = new ObjectFactory < WroConfiguration > ( ) { 
public WroConfiguration create ( ) { 
return config ; 
} public void destroy ( ) { 
unregisterMBean ( ) ; 
if ( wroManagerFactory != null ) { 
wroManagerFactory . destroy ( ) ; 
if ( wroConfiguration != null ) { 
wroConfiguration . destroy ( ) ; 
Context . destroy ( ) ; 
} private void identifyDuplicateGroupNames ( final Collection < Group > groups ) { 
LOG . debug ( "identifyDuplicateGroupNames" ) ; 
final List < String > groupNames = new ArrayList < String > ( ) ; 
for ( final Group group : groups ) { 
if ( groupNames . contains ( group . getName ( ) ) ) { 
groupNames . add ( group . getName ( ) ) ; 
} public void merge ( final WroModel importedModel ) { 
for ( final String groupName : new WroModelInspector ( importedModel ) . getGroupNames ( ) ) { 
if ( new WroModelInspector ( this ) . getGroupNames ( ) . contains ( groupName ) ) { 
final Group importedGroup = new WroModelInspector ( importedModel ) . getGroupByName ( groupName ) ; 
addGroup ( importedGroup ) ; 
final PackerJs packerJs = enginePool . getObject ( ) ; 
writer . write ( packerJs . pack ( content ) ) ; 
enginePool . returnObject ( packerJs ) ; 
final UriLocator locator = getInstance ( uri ) ; 
if ( locator == null ) { 
return getDecoratedObject ( ) . locate ( uri ) ; 
return locator . locate ( uri ) ; 
} public void process ( final Resource resource , final Reader reader , 
final Writer writer ) throws IOException { 
final InputStream is = new ProxyInputStream ( new ReaderInputStream ( reader , getEncoding ( ) ) ) { } ; 
final OutputStream os = new ProxyOutputStream ( new WriterOutputStream ( writer , getEncoding ( ) ) ) ; 
new JSMin ( is , os ) . jsmin ( ) ; 
throw WroRuntimeException . wrap ( e ) ; 
IOUtils . closeQuietly ( os ) ; 
} private String applyPostProcessors ( final CacheKey cacheKey , final String content ) 
final Collection < ResourcePostProcessor > processors = processorsFactory . getPostProcessors ( ) ; 
if ( processors . isEmpty ( ) ) { 
return content ; 
final Resource resource = Resource . create ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; 
Reader reader = new StringReader ( content . toString ( ) ) ; 
Writer writer = null ; 
for ( final ResourcePostProcessor processor : processors ) { 
final ResourcePreProcessor decoratedProcessor = decorateProcessor ( processor , cacheKey . isMinimize ( ) ) ; 
writer = new StringWriter ( ) ; 
decoratedProcessor . process ( resource , reader , writer ) ; 
reader = new StringReader ( writer . toString ( ) ) ; 
} private synchronized ProcessorDecorator decorateProcessor ( final ResourcePostProcessor processor , 
final boolean minimize ) { 
final ProcessorDecorator decorated = new DefaultProcessorDecorator ( processor , minimize ) { 
callbackRegistry . onBeforePostProcess ( ) ; 
super . process ( resource , reader , writer ) ; 
callbackRegistry . onAfterPostProcess ( ) ; 
injector . inject ( decorated ) ; 
return decorated ; 
} public final void doFilter ( final ServletRequest req , final ServletResponse res , final FilterChain chain ) 
final HttpServletRequest request = ( HttpServletRequest ) req ; 
final HttpServletResponse response = ( HttpServletResponse ) res ; 
final String originalCorrelationId = Context . isContextSet ( ) ? Context . getCorrelationId ( ) : null ; 
Context . set ( Context . webContext ( request , response , this . filterConfig ) , getWroConfiguration ( ) ) ; 
final String correlationId = Context . getCorrelationId ( ) ; 
Context . setCorrelationId ( correlationId ) ; 
Context . unset ( ) ; 
if ( originalCorrelationId != null ) { 
Context . setCorrelationId ( originalCorrelationId ) ; 
} public void doFilter ( final ServletRequest req , final ServletResponse res , final FilterChain chain ) 
Context . set ( Context . webContext ( request , response , filterConfig ) ) ; 
final HttpServletResponse wrappedResponse = new RedirectedStreamServletResponseWrapper ( os , response ) ; 
chain . doFilter ( request , wrappedResponse ) ; 
final Reader reader = new StringReader ( new String ( os . toByteArray ( ) , Context . get ( ) . getConfig ( ) . getEncoding ( ) ) ) ; 
final StringWriter writer = new StringWriter ( ) ; 
final String requestUri = request . getRequestURI ( ) . replaceFirst ( request . getContextPath ( ) , "" ) ; 
doProcess ( requestUri , reader , writer ) ; 
final int contentLength = writer . getBuffer ( ) . length ( ) ; 
response . setContentLength ( contentLength ) ; 
if ( contentLength > 0 ) { 
IOUtils . write ( writer . toString ( ) , response . getOutputStream ( ) ) ; 
onRuntimeException ( e , response , chain ) ; 
} private void doProcess ( final String requestUri , final Reader reader , final Writer writer ) 
Reader input = reader ; 
Writer output = null ; 
final StopWatch stopWatch = new StopWatch ( ) ; 
final Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; 
final List < ResourcePreProcessor > processors = getProcessorsList ( ) ; 
if ( processors == null || processors . isEmpty ( ) ) { 
IOUtils . copy ( reader , writer ) ; 
for ( final ResourcePreProcessor processor : processors ) { 
injector . inject ( processor ) ; 
output = new StringWriter ( ) ; 
processor . process ( createResource ( requestUri ) , input , output ) ; 
input = new StringReader ( output . toString ( ) ) ; 
if ( output != null ) { 
writer . write ( output . toString ( ) ) ; 
} protected void onRuntimeException ( final RuntimeException e , final HttpServletResponse response , 
final FilterChain chain ) { 
} public String [ ] splitOptions ( final String optionAsString ) { 
return optionAsString == null ? ArrayUtils . EMPTY_STRING_ARRAY : optionAsString . split ( "(?ims),(?![^\\[\\]]*\\])" ) ; 
builder = RhinoScriptBuilder . newClientSideAwareChain ( ) . addJSON ( ) . evaluateChain ( 
getScriptAsStream ( ) , "cjson.js" ) ; 
final InputStream initStream = LessCss . class . getResourceAsStream ( SCRIPT_INIT ) ; 
builder = RhinoScriptBuilder . newClientSideAwareChain ( ) . evaluateChain ( initStream , SCRIPT_INIT ) . evaluateChain ( 
getScriptAsStream ( ) , DEFAULT_LESS_JS ) ; 
} public Properties load ( final InputStream inputStream ) throws IOException { 
Validate . notNull ( inputStream ) ; 
final String rawContent = IOUtils . toString ( inputStream , CharEncoding . UTF_8 ) ; 
parseProperties ( rawContent . replaceAll ( REGEX_COMMENTS , "" ) ) ; 
return this . properties ; 
} private void parseProperties ( final String propertiesAsString ) { 
final String [ ] propertyEntries = propertiesAsString . split ( "\\r?\\n" ) ; 
for ( final String entry : propertyEntries ) { 
readPropertyEntry ( entry ) ; 
} private StandaloneContext createStandaloneContext ( ) { 
final StandaloneContext runContext = new StandaloneContext ( ) ; 
runContext . setContextFoldersAsCSV ( getContextFoldersAsCSV ( ) ) ; 
runContext . setMinimize ( isMinimize ( ) ) ; 
runContext . setWroFile ( getWroFile ( ) ) ; 
runContext . setIgnoreMissingResourcesAsString ( isIgnoreMissingResources ( ) ) ; 
return runContext ; 
} protected final WroManagerFactory getManagerFactory ( ) { 
if ( managerFactory == null ) { 
managerFactory = wroManagerFactory != null ? createCustomManagerFactory ( ) : newWroManagerFactory ( ) ; 
onAfterCreate ( managerFactory ) ; 
} catch ( final MojoExecutionException e ) { 
return managerFactory ; 
} private WroManagerFactory createCustomManagerFactory ( ) 
WroManagerFactory factory = null ; 
final Class < ? > wroManagerFactoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( 
wroManagerFactory . trim ( ) ) ; 
factory = ( WroManagerFactory ) wroManagerFactoryClass . newInstance ( ) ; 
} protected WroManagerFactory newWroManagerFactory ( ) 
factory = new ConfigurableWroManagerFactory ( ) ; 
} private void onAfterCreate ( final WroManagerFactory factory ) 
if ( factory instanceof ExtraConfigFileAware ) { 
if ( extraConfigFile == null ) { 
( ( ExtraConfigFileAware ) factory ) . setExtraConfigFile ( extraConfigFile ) ; 
if ( factory instanceof StandaloneContextAware ) { 
( ( StandaloneContextAware ) factory ) . initialize ( createStandaloneContext ( ) ) ; 
} private void persistResourceFingerprints ( final List < String > groupNames ) { 
final WroModelInspector modelInspector = new WroModelInspector ( getModel ( ) ) ; 
for ( final String groupName : groupNames ) { 
final Group group = modelInspector . getGroupByName ( groupName ) ; 
if ( group != null ) { 
for ( final Resource resource : group . getResources ( ) ) { 
getResourceChangeHandler ( ) . remember ( resource ) ; 
} private boolean isTargetGroup ( final Group group ) { 
notNull ( group ) ; 
final String targetGroups = getTargetGroups ( ) ; 
return targetGroups == null || targetGroups . contains ( group . getName ( ) ) ; 
} protected final void extendPluginClasspath ( ) 
final List < String > classpathElements = new ArrayList < String > ( ) ; 
classpathElements . addAll ( mavenProject . getRuntimeClasspathElements ( ) ) ; 
} catch ( final DependencyResolutionRequiredException e ) { 
final ClassLoader classLoader = createClassLoader ( classpathElements ) ; 
Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; 
protected boolean isEnabled ( final Resource resource ) { 
final boolean applyProcessor = ( resource != null && resource . isMinimize ( ) && minimize ) 
|| ( resource == null && minimize ) || ! isMinimize ( ) ; 
return super . isEnabled ( resource ) && applyProcessor ; 
} protected InputStream getModelResourceAsStream ( ) 
final ServletContext servletContext = context . getServletContext ( ) ; 
if ( servletContext == null ) { 
throw new WroRuntimeException ( 
final String resourceLocation = "/WEB-INF/" + getDefaultModelFilename ( ) ; 
final InputStream stream = servletContext . getResourceAsStream ( resourceLocation ) ; 
} public static Resource create ( final String uri ) { 
final String resourceExtension = FilenameUtils . getExtension ( uri ) ; 
final ResourceType type = ResourceType . get ( resourceExtension ) ; 
return new Resource ( uri , type ) ; 
} private static String cleanUri ( final String uri ) { 
String result = uri . trim ( ) ; 
if ( ! StringUtils . isEmpty ( uri ) ) { 
final int endIndex = result . length ( ) - 1 ; 
if ( result . lastIndexOf ( '/' ) == endIndex ) { 
result = result . substring ( 0 , endIndex ) ; 
if ( getWildcardStreamLocator ( ) . hasWildcard ( uri ) ) { 
final String fullPath = FilenameUtils . getFullPath ( uri ) ; 
final URL url = new URL ( fullPath ) ; 
return getWildcardStreamLocator ( ) . locateStream ( uri , new File ( URLDecoder . decode ( url . getFile ( ) , "UTF-8" ) ) ) ; 
final URL url = new URL ( uri ) ; 
final URLConnection connection = url . openConnection ( ) ; 
connection . setUseCaches ( false ) ; 
connection . setRequestProperty ( "User-Agent" , "java" ) ; 
connection . setConnectTimeout ( timeout ) ; 
connection . setReadTimeout ( timeout ) ; 
return new BufferedInputStream ( connection . getInputStream ( ) ) ; 
String result = ConsoleStripperProcessor . PATTERN . matcher ( content ) . replaceAll ( "" ) ; 
writer . write ( result ) ; 
} public static DefaultWroManagerFactory create ( final WroConfiguration configuration ) { 
return create ( new ObjectFactory < WroConfiguration > ( ) { 
return configuration ; 
} private WroManagerFactory initFactory ( final Properties properties ) { 
final String wroManagerClassName = properties . getProperty ( ConfigConstants . managerFactoryClassName . name ( ) ) ; 
if ( StringUtils . isEmpty ( wroManagerClassName ) ) { 
factory = newManagerFactory ( ) ; 
Class < ? > factoryClass = null ; 
factoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerClassName ) ; 
factory = ( WroManagerFactory ) factoryClass . newInstance ( ) ; 
if ( factory instanceof ConfigurableWroManagerFactory ) { 
( ( ConfigurableWroManagerFactory ) factory ) . addConfigProperties ( properties ) ; 
return RhinoScriptBuilder . newChain ( ) . evaluateChain ( getStreamForBase2 ( ) , "base2.min.js" ) . evaluateChain ( 
getStreamForPacker ( ) , "packer.min.js" ) ; 
} public ModelTransformerFactory setTransformers ( final List < Transformer < WroModel > > modelTransformers ) { 
Validate . notNull ( modelTransformers ) ; 
this . modelTransformers = modelTransformers ; 
WroModel model = super . create ( ) ; 
for ( final Transformer < WroModel > transformer : modelTransformers ) { 
injector . inject ( transformer ) ; 
model = transformer . transform ( model ) ; 
public String compile ( final String content , final String name ) { 
final String precompiledFunction = super . compile ( content , "" ) ; 
protected InputStream getCompilerAsStream ( ) throws IOException { 
final Vector < InputStream > inputStreams = new Vector < InputStream > ( ) ; 
inputStreams . add ( getWebjarLocator ( ) . locate ( WebjarUriLocator . createUri ( "jquery.js" ) ) ) ; 
inputStreams . add ( getWebjarLocator ( ) . locate ( WebjarUriLocator . createUri ( "handlebars.js" ) ) ) ; 
inputStreams . add ( getWebjarLocator ( ) . locate ( WebjarUriLocator . createUri ( "ember.js" ) ) ) ; 
inputStreams . add ( EmberJs . class . getResourceAsStream ( DEFAULT_HEADLESS_RHINO_JS ) ) ; 
return new SequenceInputStream ( inputStreams . elements ( ) ) ; 
} protected boolean isReplaceNeeded ( final String url ) { 
return ! ( UrlUriLocator . isValid ( url ) || DataUriGenerator . isDataUri ( url . trim ( ) ) ) ; 
} public String processAndMerge ( final List < Resource > resources , final boolean minimize ) 
return processAndMerge ( resources , ProcessingCriteria . create ( ProcessingType . ALL , minimize ) ) ; 
} public String processAndMerge ( final List < Resource > resources , final ProcessingCriteria criteria ) 
notNull ( criteria ) ; 
callbackRegistry . onBeforeMerge ( ) ; 
notNull ( resources ) ; 
final StringBuffer result = new StringBuffer ( ) ; 
if ( shouldRunInParallel ( resources ) ) { 
result . append ( runInParallel ( resources , criteria ) ) ; 
result . append ( applyPreProcessors ( resource , criteria ) ) ; 
callbackRegistry . onAfterMerge ( ) ; 
} private String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) 
final List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; 
callables . add ( new Callable < String > ( ) { 
public String call ( ) 
return applyPreProcessors ( resource , criteria ) ; 
final ExecutorService exec = getExecutorService ( ) ; 
final List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; 
for ( final Callable < String > callable : callables ) { 
final Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; 
futures . add ( exec . submit ( decoratedCallable ) ) ; 
for ( final Future < String > future : futures ) { 
result . append ( future . get ( ) ) ; 
final Throwable cause = e . getCause ( ) ; 
if ( cause instanceof WroRuntimeException ) { 
throw ( WroRuntimeException ) cause ; 
} else if ( cause instanceof IOException ) { 
throw ( IOException ) cause ; 
} private String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) 
final Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; 
String resourceContent = null ; 
resourceContent = getResourceContent ( resource ) ; 
if ( Context . get ( ) . getConfig ( ) . isIgnoreMissingResources ( ) ) { 
if ( ! processors . isEmpty ( ) ) { 
final ResourcePreProcessor decoratedProcessor = decoratePreProcessor ( processor , criteria ) ; 
final Reader reader = new StringReader ( resourceContent ) ; 
resourceContent = writer . toString ( ) ; 
return String . format ( "%s%n" , resourceContent ) ; 
} private synchronized ResourcePreProcessor decoratePreProcessor ( final ResourcePreProcessor processor , 
final ProcessingCriteria criteria ) { 
final ResourcePreProcessor decorated = new DefaultProcessorDecorator ( processor , criteria ) { 
callbackRegistry . onBeforePreProcess ( ) ; 
callbackRegistry . onAfterPreProcess ( ) ; 
} public void onBeforeModelCreated ( ) { 
forEachCallbackDo ( new Function < LifecycleCallback , Void > ( ) { 
public Void apply ( final LifecycleCallback input ) 
input . onBeforeModelCreated ( ) ; 
} public void persist ( ) { 
OutputStream os = null ; 
os = new FileOutputStream ( fallbackStorageFile ) ; 
fallbackStorage . store ( os , "Generated" ) ; 
} public < T > T inject ( final T object ) { 
notNull ( object ) ; 
if ( ! injectedObjects . containsKey ( computeKey ( object ) ) ) { 
injectedObjects . put ( computeKey ( object ) , true ) ; 
processInjectAnnotation ( object ) ; 
} private void processInjectAnnotation ( final Object object ) { 
final Collection < Field > fields = getAllFields ( object ) ; 
for ( final Field field : fields ) { 
if ( field . isAnnotationPresent ( Inject . class ) ) { 
if ( ! acceptAnnotatedField ( object , field ) ) { 
final String message = String . format ( 
field . getType ( ) , this ) ; 
throw new WroRuntimeException ( message ) ; 
if ( object instanceof ObjectDecorator ) { 
processInjectAnnotation ( ( ( ObjectDecorator < ? > ) object ) . getDecoratedObject ( ) ) ; 
} private Collection < Field > getAllFields ( final Object object ) { 
final Collection < Field > fields = new ArrayList < Field > ( ) ; 
fields . addAll ( Arrays . asList ( object . getClass ( ) . getDeclaredFields ( ) ) ) ; 
Class < ? > superClass = object . getClass ( ) . getSuperclass ( ) ; 
while ( superClass != null ) { 
fields . addAll ( Arrays . asList ( superClass . getDeclaredFields ( ) ) ) ; 
superClass = superClass . getSuperclass ( ) ; 
} private boolean acceptAnnotatedField ( final Object object , final Field field ) 
throws IllegalAccessException { 
for ( final Map . Entry < Class < ? > , Object > entry : map . entrySet ( ) ) { 
if ( entry . getKey ( ) . isAssignableFrom ( field . getType ( ) ) ) { 
if ( value instanceof InjectorObjectFactory ) { 
value = ( ( InjectorObjectFactory < ? > ) value ) . create ( ) ; 
inject ( value ) ; 
field . set ( object , value ) ; 
} public String rewrite ( final String cssUri , final String imageUrl ) { 
notNull ( cssUri ) ; 
notNull ( imageUrl ) ; 
if ( StringUtils . isEmpty ( imageUrl ) ) { 
if ( ServletContextUriLocator . isValid ( cssUri ) ) { 
if ( ServletContextUriLocator . isValid ( imageUrl ) ) { 
return prependContextPath ( imageUrl ) ; 
if ( ServletContextUriLocator . isProtectedResource ( cssUri ) ) { 
return context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; 
final String aggregatedPathPrefix = computeAggregationPathPrefix ( context . aggregatedFolderPath ) ; 
String newImageLocation = computeNewImageLocation ( aggregatedPathPrefix + cssUri , imageUrl ) ; 
if ( newImageLocation . startsWith ( ServletContextUriLocator . PREFIX ) ) { 
newImageLocation = prependContextPath ( newImageLocation ) ; 
return newImageLocation ; 
if ( ClasspathUriLocator . isValid ( cssUri ) ) { 
final String proxyUrl = context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; 
final String contextRelativeUrl = prependContextPath ( imageUrl ) ; 
return ( ServletContextUriLocator . isValid ( imageUrl ) ? contextRelativeUrl : proxyUrl ) ; 
if ( UrlUriLocator . isValid ( cssUri ) ) { 
final String computedCssUri = ServletContextUriLocator . isValid ( imageUrl ) ? computeCssUriForExternalServer ( cssUri ) 
: cssUri ; 
return computeNewImageLocation ( computedCssUri , imageUrl ) ; 
} private String computeCssUriForExternalServer ( final String cssUri ) { 
String exernalServerCssUri = cssUri ; 
final String serverHost = cssUri . replace ( new URL ( cssUri ) . getPath ( ) , StringUtils . EMPTY ) ; 
exernalServerCssUri = serverHost + ServletContextUriLocator . PREFIX ; 
} catch ( final MalformedURLException e ) { 
return exernalServerCssUri ; 
} private String computeNewImageLocation ( final String cssUri , final String imageUrl ) { 
int idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; 
if ( idxLastSeparator == - 1 ) { 
idxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; 
if ( idxLastSeparator >= 0 ) { 
idxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; 
if ( idxLastSeparator < 0 ) { 
final String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; 
final String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) 
: cleanImageUrl ; 
final String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; 
return computedImageLocation ; 
} public CacheKey addAttribute ( final String key , final String value ) { 
map . put ( key , value ) ; 
final YuiCssCompressor compressor = new YuiCssCompressor ( reader ) ; 
compressor . compress ( writer , linebreakpos ) ; 
} public void onCachePeriodChanged ( final long period ) { 
managerInitializer . get ( ) . onCachePeriodChanged ( period ) ; 
} public void onModelPeriodChanged ( final long period ) { 
managerInitializer . get ( ) . onModelPeriodChanged ( period ) ; 
} public BaseWroManagerFactory addModelTransformer ( final Transformer < WroModel > modelTransformer ) { 
if ( modelTransformers == null ) { 
modelTransformers = new ArrayList < Transformer < WroModel > > ( ) ; 
this . modelTransformers . add ( modelTransformer ) ; 
} public void serveProcessedBundle ( ) 
final WroConfiguration configuration = context . getConfig ( ) ; 
final HttpServletRequest request = context . getRequest ( ) ; 
final HttpServletResponse response = context . getResponse ( ) ; 
final CacheKey cacheKey = getSafeCacheKey ( request ) ; 
initAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; 
final CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; 
final String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; 
final String etagValue = String . format ( "\"%s\"" , cacheValue . getHash ( ) ) ; 
if ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { 
response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; 
response . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; 
os = response . getOutputStream ( ) ; 
if ( cacheValue . getRawContent ( ) != null ) { 
if ( isGzipAllowed ( ) ) { 
response . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; 
response . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , "gzip" ) ; 
response . setHeader ( "Vary" , "Accept-Encoding" ) ; 
IOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; 
response . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; 
IOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; 
if ( os != null ) { 
} private void initAggregatedFolderPath ( final HttpServletRequest request , final ResourceType type ) { 
if ( ResourceType . CSS == type && context . getAggregatedFolderPath ( ) == null ) { 
final String requestUri = request . getRequestURI ( ) ; 
final String cssFolder = StringUtils . removeEnd ( requestUri , FilenameUtils . getName ( requestUri ) ) ; 
final String aggregatedFolder = StringUtils . removeStart ( cssFolder , request . getContextPath ( ) ) ; 
Context . get ( ) . setAggregatedFolderPath ( aggregatedFolder ) ; 
} private Map < String , String > extractVariables ( final String variablesBody ) { 
final Map < String , String > map = new HashMap < String , String > ( ) ; 
final Matcher m = PATTERN_VARIABLES_BODY . matcher ( variablesBody ) ; 
while ( m . find ( ) ) { 
final String key = m . group ( 1 ) ; 
final String value = m . group ( 2 ) ; 
if ( map . containsKey ( key ) ) { 
final String css = IOUtils . toString ( reader ) ; 
final String result = parseCss ( css ) ; 
} private String parseCss ( final String css ) { 
final Matcher m = PATTERN_VARIABLES_DEFINITION . matcher ( css ) ; 
final String variablesBody = m . group ( 1 ) ; 
map . putAll ( extractVariables ( variablesBody ) ) ; 
m . appendReplacement ( sb , "" ) ; 
m . appendTail ( sb ) ; 
return replaceVariables ( sb . toString ( ) , map ) ; 
} private String replaceVariables ( final String css , final Map < String , String > variables ) { 
final Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; 
final String oldMatch = m . group ( ) ; 
final String variableName = m . group ( 1 ) ; 
final String variableValue = variables . get ( variableName ) ; 
if ( variableValue != null ) { 
final String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; 
m . appendReplacement ( sb , newReplacement . trim ( ) ) ; 
IOUtils . closeQuietly ( reader ) ; 
IOUtils . closeQuietly ( writer ) ; 
final boolean isApplicable = resource != null ? isEligible ( criteria . isMinimize ( ) , resource . getType ( ) ) : true ; 
return super . isEnabled ( resource ) && isApplicable ; 
} public String rename ( final String originalName , final InputStream inputStream ) { 
final String baseName = FilenameUtils . getBaseName ( originalName ) ; 
final String extension = FilenameUtils . getExtension ( originalName ) ; 
final long timestamp = getTimestamp ( ) ; 
final StringBuilder sb = new StringBuilder ( baseName ) . append ( "-" ) . append ( timestamp ) ; 
if ( ! StringUtils . isEmpty ( extension ) ) { 
sb . append ( "." ) . append ( extension ) ; 
protected Map < String , CacheStrategy < CacheKey , CacheValue > > getStrategies ( final CacheStrategyProvider provider ) { 
return provider . provideCacheStrategies ( ) ; 
} private static ResourcePreProcessor toPreProcessor ( final ResourcePostProcessor postProcessor ) { 
return new AbstractProcessorDecoratorSupport < ResourcePostProcessor > ( postProcessor ) { 
postProcessor . process ( reader , writer ) ; 
protected boolean isMinimizeInternal ( ) { 
return isMinimizeForProcessor ( postProcessor ) ; 
protected SupportedResourceType getSupportedResourceTypeInternal ( ) { 
return getSupportedResourceTypeForProcessor ( postProcessor ) ; 
return postProcessor . toString ( ) ; 
} public final boolean isEligible ( final boolean minimize , final ResourceType searchedType ) { 
Validate . notNull ( searchedType ) ; 
final SupportedResourceType supportedType = getSupportedResourceType ( ) ; 
final boolean isTypeSatisfied = supportedType == null 
|| ( supportedType != null && searchedType == supportedType . value ( ) ) ; 
final boolean isMinimizedSatisfied = minimize == true || ! isMinimize ( ) ; 
return isTypeSatisfied && isMinimizedSatisfied ; 
} protected void onLinterException ( final LinterException e , final Resource resource ) { 
} public final void contextInitialized ( final ServletContextEvent event ) { 
this . servletContext = event . getServletContext ( ) ; 
attributeHelper = new ServletContextAttributeHelper ( this . servletContext , getListenerName ( ) ) ; 
initListener ( event . getServletContext ( ) ) ; 
watch . start ( "pack" ) ; 
Context . enter ( ) ; 
final String script = IOUtils . toString ( reader ) ; 
final String stripConsole = null ; 
final String out = Compressor . compressScript ( script , 0 , 0 , stripConsole ) ; 
writer . write ( out ) ; 
Context . exit ( ) ; 
StopWatch stopWatch = null ; 
if ( isDebug ( ) ) { 
stopWatch = new StopWatch ( ) ; 
before ( stopWatch ) ; 
after ( stopWatch ) ; 
} private UriLocatorFactory newLocatorFactory ( ) { 
final SimpleUriLocatorFactory factory = new SimpleUriLocatorFactory ( ) ; 
final List < UriLocator > locators = getConfiguredStrategies ( ) ; 
for ( final UriLocator locator : locators ) { 
factory . addLocator ( locator ) ; 
if ( locators . isEmpty ( ) ) { 
return new DefaultUriLocatorFactory ( ) ; 
} public boolean accept ( final String url ) { 
if ( url == null ) return false ; 
final String extension = FilenameUtils . getExtension ( url ) ; 
if ( "" . equals ( extension ) || "scss" . equals ( extension ) ) { 
boolean result = getScssFile ( url ) != null ; 
} public InputStream locate ( final String uri ) throws IOException { 
return new FileInputStream ( getScssFile ( uri ) ) ; 
if ( isInitialized ( ) ) { 
if ( get ( ) instanceof Destroyable ) { 
( ( Destroyable ) get ( ) ) . destroy ( ) ; 
object = null ; 
protected String replaceDeclaration ( final String originalDeclaration , final String modifiedDeclaration ) { 
return originalDeclaration . equals ( modifiedDeclaration ) ? modifiedDeclaration : computeNewDeclaration ( 
originalDeclaration , modifiedDeclaration ) ; 
if ( isGzipAllowed ( request ) ) { 
doGzipResponse ( request , response , chain ) ; 
} private void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) 
final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
final CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( 
baos ) ) ) ; 
final HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , 
response ) ; 
chain . doFilter ( req , wrappedResponse ) ; 
countingStream . close ( ) ; 
response . setContentLength ( countingStream . getCount ( ) ) ; 
if ( countingStream . getCount ( ) > 0 ) { 
IOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; 
} public static PathPatternProcessorDecorator include ( final Object processor , final String ... patterns ) { 
return new PathPatternProcessorDecorator ( processor , true , patterns ) ; 
} public static PathPatternProcessorDecorator exclude ( final Object processor , final String ... patterns ) { 
return new PathPatternProcessorDecorator ( processor , false , patterns ) ; 
public void process ( final Resource resource , final Reader reader , 
final Writer writer ) 
final String uri = resource . getUri ( ) ; 
if ( includes ) { 
for ( String pattern : patterns ) { 
if ( matcher . match ( pattern , uri ) ) { 
uri , toString ( ) ) ; 
getDecoratedObject ( ) . process ( resource , reader , writer ) ; 
boolean process = true ; 
process = false ; 
if ( process ) { 
toString ( ) ) ; 
uri , getDecoratedObject ( ) , toString ( ) } ) ; 
WroUtil . safeCopy ( reader , writer ) ; 
} public static ResourceChangeHandler create ( final WroManagerFactory managerFactory , final Log log ) { 
return new ResourceChangeHandler ( ) . setManagerFactory ( managerFactory ) . setLog ( log ) ; 
} public void remember ( final Resource resource ) { 
final WroManager manager = getManagerFactory ( ) . create ( ) ; 
final HashStrategy hashStrategy = manager . getHashStrategy ( ) ; 
final UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; 
if ( rememberedSet . contains ( resource . getUri ( ) ) ) { 
final String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; 
getBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; 
rememberedSet . add ( resource . getUri ( ) ) ; 
if ( resource . getType ( ) == ResourceType . CSS ) { 
final Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; 
persistFingerprintsForCssImports ( resource , reader ) ; 
} private void forEachCssImportApply ( final Function < String , ChangeStatus > func , final Resource resource , final Reader reader ) 
final ResourcePreProcessor processor = createCssImportProcessor ( func ) ; 
InjectorBuilder . create ( getManagerFactory ( ) ) . build ( ) . inject ( processor ) ; 
processor . process ( resource , reader , new StringWriter ( ) ) ; 
} public void forget ( final Resource resource ) { 
getBuildContextHolder ( ) . setValue ( resource . getUri ( ) , null ) ; 
rememberedSet . remove ( resource . getUri ( ) ) ; 
} public String getHash ( final InputStream inputStream ) 
return getConfiguredStrategy ( ) . getHash ( inputStream ) ; 
IOUtils . closeQuietly ( inputStream ) ; 
} public static < T > ResourceLintReport < T > create ( final String resourcePath , final Collection < T > lints ) { 
return new ResourceLintReport < T > ( resourcePath , lints ) ; 
} private List < T > filter ( final Collection < T > collection ) { 
final List < T > nullFreeList = new ArrayList < T > ( ) ; 
if ( collection != null ) { 
for ( final T item : collection ) { 
nullFreeList . add ( item ) ; 
return nullFreeList ; 
} public String getGroupName ( final HttpServletRequest request ) { 
Validate . notNull ( request ) ; 
String uri = request . getRequestURI ( ) ; 
final String includeUriPath = ( String ) request . getAttribute ( ATTR_INCLUDE_PATH ) ; 
uri = includeUriPath != null ? includeUriPath : uri ; 
final String groupName = FilenameUtils . getBaseName ( stripSessionID ( uri ) ) ; 
return StringUtils . isEmpty ( groupName ) ? null : groupName ; 
} public ResourceType getResourceType ( final HttpServletRequest request ) { 
final String uri = request . getRequestURI ( ) ; 
Validate . notNull ( uri ) ; 
ResourceType type = null ; 
type = ResourceType . get ( FilenameUtils . getExtension ( stripSessionID ( uri ) ) ) ; 
} catch ( final IllegalArgumentException e ) { 
return String . format ( "%s.%s?" + PARAM_MINIMIZE + "=%s" , groupName , resourceType . name ( ) . toLowerCase ( ) , minimize ) ; 
} public boolean isMinimized ( final HttpServletRequest request ) { 
final String minimizeAsString = request . getParameter ( PARAM_MINIMIZE ) ; 
return ! ( Context . get ( ) . getConfig ( ) . isDebug ( ) && "false" . equalsIgnoreCase ( minimizeAsString ) ) ; 
writer . write ( script ) ; 
if ( isSemicolonNeeded ( script ) ) { 
writer . write ( ';' ) ; 
writer . write ( doProcess ( content ) ) ; 
} public final void process ( final Resource resource , final Reader reader , final Writer writer ) 
final String result = parseCss ( resource , IOUtils . toString ( reader ) ) ; 
clearProcessedImports ( ) ; 
} private List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) 
final List < Resource > imports = new ArrayList < Resource > ( ) ; 
final String css = cssContent ; 
final List < String > foundImports = findImports ( css ) ; 
for ( final String importUrl : foundImports ) { 
final Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; 
if ( imports . contains ( importedResource ) ) { 
imports . add ( importedResource ) ; 
onImportDetected ( importedResource . getUri ( ) ) ; 
return imports ; 
} private Resource createImportedResource ( final String resourceUri , final String importUrl ) { 
final String absoluteUrl = uriLocatorFactory . getInstance ( importUrl ) != null ? importUrl 
: computeAbsoluteUrl ( resourceUri , importUrl ) ; 
return Resource . create ( absoluteUrl , ResourceType . CSS ) ; 
} private String computeAbsoluteUrl ( final String relativeResourceUri , final String importUrl ) { 
final String folder = WroUtil . getFullPath ( relativeResourceUri ) ; 
return StringUtils . cleanPath ( folder + importUrl ) ; 
} protected boolean isResourceChanged ( final HttpServletRequest request ) { 
final long ifModifiedSince = request . getDateHeader ( HttpHeader . IF_MODIFIED_SINCE . toString ( ) ) ; 
return ifModifiedSince < getHeadersConfigurer ( ) . getLastModifiedTimestamp ( ) ; 
} public static String createProxyPath ( final String requestUri , final String resourceId ) { 
notNull ( requestUri ) ; 
notNull ( resourceId ) ; 
return requestUri + getRequestHandlerPath ( resourceId ) ; 
} public static String createItemsAsString ( final String ... items ) { 
for ( int i = 0 ; i < items . length ; i ++ ) { 
sb . append ( items [ i ] ) ; 
if ( i < items . length - 1 ) { 
sb . append ( TOKEN_DELIMITER ) ; 
} private List < String > getAliasList ( final String aliasCsv ) { 
final List < String > list = new ArrayList < String > ( ) ; 
if ( ! StringUtils . isEmpty ( aliasCsv ) ) { 
final String [ ] tokens = aliasCsv . split ( TOKEN_DELIMITER ) ; 
for ( final String token : tokens ) { 
list . add ( token . trim ( ) ) ; 
} private ScriptableObject createContext ( final ScriptableObject initialScope ) { 
final Context context = getContext ( ) ; 
context . setOptimizationLevel ( - 1 ) ; 
context . setErrorReporter ( new ToolErrorReporter ( false ) ) ; 
context . setLanguageVersion ( Context . VERSION_1_8 ) ; 
InputStream script = null ; 
final ScriptableObject scriptCommon = ( ScriptableObject ) context . initStandardObjects ( initialScope ) ; 
script = new AutoCloseInputStream ( getClass ( ) . getResourceAsStream ( "commons.js" ) ) ; 
context . evaluateReader ( scriptCommon , new InputStreamReader ( script ) , "commons.js" , 1 , null ) ; 
IOUtils . closeQuietly ( script ) ; 
return scriptCommon ; 
} public RhinoScriptBuilder addClientSideEnvironment ( ) { 
final InputStream scriptEnv = new WebjarUriLocator ( ) . locate ( "env.rhino.js" ) ; 
evaluateChain ( scriptEnv , SCRIPT_ENV ) ; 
} public RhinoScriptBuilder addJSON ( ) { 
final InputStream script = new AutoCloseInputStream ( 
new WebjarUriLocator ( ) . locate ( WebjarUriLocator . createUri ( "20110223/json2.js" ) ) ) ; 
final InputStream scriptCycle = getClass ( ) . getResourceAsStream ( SCRIPT_CYCLE ) ; 
evaluateChain ( script , SCRIPT_JSON ) ; 
evaluateChain ( scriptCycle , SCRIPT_CYCLE ) ; 
} public RhinoScriptBuilder evaluateChain ( final InputStream stream , final String sourceName ) 
notNull ( stream ) ; 
getContext ( ) . evaluateReader ( scope , new InputStreamReader ( stream ) , sourceName , 1 , null ) ; 
} catch ( final RhinoException e ) { 
if ( e instanceof RhinoException ) { 
} public RhinoScriptBuilder evaluateChain ( final String script , final String sourceName ) { 
notNull ( script ) ; 
getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; 
} public Object evaluate ( final Reader reader , final String sourceName ) 
notNull ( reader ) ; 
return evaluate ( IOUtils . toString ( reader ) , sourceName ) ; 
} public Object evaluate ( final String script , final String sourceName ) { 
return getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; 
final String message = RhinoUtils . createExceptionMessage ( e ) ; 
if ( Context . getCurrentContext ( ) != null ) { 
} public final void process ( ) 
final WroConfiguration config = Context . get ( ) . getConfig ( ) ; 
cacheSchedulerHelper . scheduleWithPeriod ( config . getCacheUpdatePeriod ( ) ) ; 
modelSchedulerHelper . scheduleWithPeriod ( config . getModelUpdatePeriod ( ) ) ; 
resourceBundleProcessor . serveProcessedBundle ( ) ; 
} public final String encodeVersionIntoGroupPath ( final String groupName , final ResourceType resourceType , 
final CacheKey key = new CacheKey ( groupName , resourceType , minimize ) ; 
final CacheValue cacheValue = cacheStrategy . get ( key ) ; 
final String groupUrl = groupExtractor . encodeGroupUrl ( groupName , resourceType , minimize ) ; 
return formatVersionedResource ( cacheValue . getHash ( ) , groupUrl ) ; 
} protected String formatVersionedResource ( final String hash , final String resourcePath ) { 
return String . format ( "%s/%s" , hash , resourcePath ) ; 
} public final void destroy ( ) { 
cacheSchedulerHelper . destroy ( ) ; 
modelSchedulerHelper . destroy ( ) ; 
cacheStrategy . destroy ( ) ; 
modelFactory . destroy ( ) ; 
resourceWatcher . destroy ( ) ; 
destroyProcessors ( ) ; 
} private void destroyProcessors ( ) throws Exception { 
for ( final ResourcePreProcessor processor : processorsFactory . getPreProcessors ( ) ) { 
if ( processor instanceof Destroyable ) { 
( ( Destroyable ) processor ) . destroy ( ) ; 
for ( final ResourcePostProcessor processor : processorsFactory . getPostProcessors ( ) ) { 
} public Map < String , CacheStrategy < CacheKey , CacheValue > > provideCacheStrategies ( ) { 
return new HashMap < String , CacheStrategy < CacheKey , CacheValue > > ( ) ; 
} private boolean isHandlerRequest ( final HttpServletRequest request ) { 
String apiHandlerValue = request . getParameter ( PATH_API ) ; 
return PATH_HANDLER . equals ( apiHandlerValue ) && retrieveCacheKey ( request ) != null ; 
} public static String createHandlerRequestPath ( final CacheKey cacheKey , final HttpServletRequest request ) { 
final String handlerQueryPath = getRequestHandlerPath ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; 
return request . getServletPath ( ) + handlerQueryPath ; 
} private String rename ( final String group , final InputStream input ) 
final String newName = getManagerFactory ( ) . create ( ) . getNamingStrategy ( ) . rename ( group , input ) ; 
groupNames . setProperty ( group , newName ) ; 
return newName ; 
} private File computeDestinationFolder ( final ResourceType resourceType ) 
File folder = destinationFolder ; 
if ( resourceType == ResourceType . JS ) { 
if ( jsDestinationFolder != null ) { 
folder = jsDestinationFolder ; 
if ( resourceType == ResourceType . CSS ) { 
if ( cssDestinationFolder != null ) { 
folder = cssDestinationFolder ; 
if ( folder == null ) { 
if ( ! folder . exists ( ) ) { 
folder . mkdirs ( ) ; 
return folder ; 
} private void processGroup ( final String group , final File parentFoder ) 
ByteArrayOutputStream resultOutputStream = null ; 
InputStream resultInputStream = null ; 
final HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; 
Mockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; 
Mockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; 
final HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; 
resultOutputStream = new ByteArrayOutputStream ( ) ; 
Mockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; 
config . setIgnoreEmptyGroup ( true ) ; 
Context . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; 
Context . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; 
getManagerFactory ( ) . create ( ) . process ( ) ; 
resultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; 
final File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; 
final File parentFolder = destinationFile . getParentFile ( ) ; 
if ( ! parentFolder . exists ( ) ) { 
parentFolder . mkdirs ( ) ; 
destinationFile . createNewFile ( ) ; 
resultInputStream . reset ( ) ; 
final OutputStream fos = new FileOutputStream ( destinationFile ) ; 
IOUtils . copy ( resultInputStream , fos ) ; 
if ( destinationFile . length ( ) == 0 ) { 
destinationFile . delete ( ) ; 
if ( getBuildContext ( ) != null ) { 
getBuildContext ( ) . refresh ( parentFoder ) ; 
if ( resultOutputStream != null ) { 
resultOutputStream . close ( ) ; 
if ( resultInputStream != null ) { 
resultInputStream . close ( ) ; 
} public static WroRuntimeException wrap ( final Exception e , final String message ) { 
if ( e instanceof WroRuntimeException ) { 
return ( WroRuntimeException ) e ; 
return new WroRuntimeException ( message , e ) ; 
final CompilerOptions compilerOptions = optionsPool . getObject ( ) ; 
final Compiler compiler = newCompiler ( compilerOptions ) ; 
final String fileName = resource == null ? "wro4j-processed-file.js" : resource . getUri ( ) ; 
final SourceFile [ ] input = new SourceFile [ ] { 
SourceFile . fromInputStream ( fileName , new ByteArrayInputStream ( content . getBytes ( getEncoding ( ) ) ) ) 
SourceFile [ ] externs = getExterns ( resource ) ; 
if ( externs == null ) { 
externs = new SourceFile [ ] { } ; 
Result result = null ; 
result = compiler . compile ( Arrays . asList ( externs ) , Arrays . asList ( input ) , compilerOptions ) ; 
if ( result . success ) { 
writer . write ( compiler . toSource ( ) ) ; 
optionsPool . returnObject ( compilerOptions ) ; 
} final SupportedResourceType getSupportedResourceTypeForProcessor ( final Object processor ) { 
SupportedResourceType supportedType = processor . getClass ( ) . getAnnotation ( SupportedResourceType . class ) ; 
if ( processor instanceof SupportedResourceTypeAware ) { 
supportedType = ( ( SupportedResourceTypeAware ) processor ) . getSupportedResourceType ( ) ; 
return supportedType ; 
} public boolean checkChangeForGroup ( final String uri , final String groupName ) throws IOException { 
notNull ( uri ) ; 
notNull ( groupName ) ; 
final ResourceChangeInfo resourceInfo = changeInfoMap . get ( uri ) ; 
if ( resourceInfo . isCheckRequiredForGroup ( groupName ) ) { 
final InputStream inputStream = locatorFactory . locate ( uri ) ; 
final String currentHash = hashStrategy . getHash ( inputStream ) ; 
resourceInfo . updateHashForGroup ( currentHash , groupName ) ; 
return resourceInfo . isChanged ( groupName ) ; 
protected RubySassEngine newEngine ( ) { 
final RubySassEngine engine = super . newEngine ( ) ; 
engine . addRequire ( BOURBON_GEM_REQUIRE ) ; 
builder = RhinoScriptBuilder . newChain ( ) . evaluateChain ( scriptInit , "initSass" ) . evaluateChain ( 
getScriptAsStream ( ) , DEFAULT_SASS_JS ) ; 
public InputStream locate ( final String uri ) 
Exception lastException = null ; 
final String [ ] contextFolders = standaloneContext . getContextFolders ( ) ; 
for ( final String contextFolder : contextFolders ) { 
return locateStreamWithContextFolder ( uri , contextFolder ) ; 
lastException = e ; 
Arrays . toString ( standaloneContext . getContextFolders ( ) ) ) ; 
throw new IOException ( exceptionMessage , lastException ) ; 
} private InputStream locateStreamWithContextFolder ( final String uri , final String contextFolder ) 
throws IOException , FileNotFoundException { 
final String fullPath = WroUtil . getFullPath ( uri ) ; 
final String realPath = contextFolder + fullPath ; 
return getWildcardStreamLocator ( ) . locateStream ( uri , new File ( realPath ) ) ; 
final String uriWithoutPrefix = uri . replaceFirst ( PREFIX , EMPTY ) ; 
final File file = new File ( contextFolder , uriWithoutPrefix ) ; 
builder = RhinoScriptBuilder . newChain ( ) . evaluateChain ( getScriptAsStream ( ) , DEFAULT_CSSLINT_JS ) ; 
throws CssLintException { 
watch . start ( "cssLint" ) ; 
final String script = buildCssLintScript ( WroUtil . toJSMultiLineString ( data ) ) ; 
builder . evaluate ( script , "CSSLint.verify" ) . toString ( ) ; 
final Type type = new TypeToken < List < CssLintError > > ( ) { } . getType ( ) ; 
final List < CssLintError > errors = new Gson ( ) . fromJson ( json , type ) ; 
throw new CssLintException ( ) . setErrors ( errors ) ; 
} private GenericObjectPool < T > createObjectPool ( final ObjectFactory < T > objectFactory ) { 
final GenericObjectPool < T > pool = newObjectPool ( objectFactory ) ; 
notNull ( pool ) ; 
} protected GenericObjectPool < T > newObjectPool ( final ObjectFactory < T > objectFactory ) { 
final int maxActive = Math . max ( 2 , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
final GenericObjectPool < T > pool = new GenericObjectPool < T > ( new BasePoolableObjectFactory < T > ( ) { 
public T makeObject ( ) 
return objectFactory . create ( ) ; 
pool . setMaxActive ( maxActive ) ; 
pool . setMaxIdle ( MAX_IDLE ) ; 
pool . setMaxWait ( MAX_WAIT ) ; 
pool . setWhenExhaustedAction ( GenericObjectPool . WHEN_EXHAUSTED_GROW ) ; 
pool . setSoftMinEvictableIdleTimeMillis ( EVICTABLE_IDLE_TIME ) ; 
pool . setTimeBetweenEvictionRunsMillis ( EVICTABLE_IDLE_TIME ) ; 
final Matcher matcher = PATTERN_PLACEHOLDER . matcher ( content ) ; 
Properties properties = null ; 
if ( propertiesFactory != null ) { 
properties = propertiesFactory . create ( ) ; 
properties = EMPTY_PROPERTIES ; 
final String variableName = matcher . group ( 1 ) ; 
matcher . appendReplacement ( sb , replaceVariable ( properties , variableName ) ) ; 
writer . write ( sb . toString ( ) ) ; 
getProcessorDecorator ( ) . process ( resource , reader , writer ) ; 
} public void process ( final Reader reader , final Writer writer ) 
getProcessorDecorator ( ) . process ( reader , writer ) ; 
public JsonElement serialize ( final Resource resource , final Type type , final JsonSerializationContext context ) { 
final JsonObject jsonObject = new JsonObject ( ) ; 
jsonObject . add ( "type" , new JsonPrimitive ( resource . getType ( ) . toString ( ) ) ) ; 
jsonObject . add ( "minimize" , new JsonPrimitive ( resource . isMinimize ( ) ) ) ; 
jsonObject . add ( "uri" , new JsonPrimitive ( uri ) ) ; 
jsonObject . add ( "proxyUri" , new JsonPrimitive ( getExternalUri ( uri ) ) ) ; 
return jsonObject ; 
public InputStream locateStream ( final String uri , final File folder ) 
notNull ( folder ) ; 
final File jarPath = getJarFile ( folder ) ; 
if ( isSupported ( jarPath ) ) { 
return locateStreamFromJar ( uri , jarPath ) ; 
return super . locateStream ( uri , folder ) ; 
} JarFile open ( final File jarFile ) throws IOException { 
return new JarFile ( jarFile ) ; 
} private InputStream locateStreamFromJar ( final String uri , final File jarPath ) 
JarFile jarFile = null ; 
final WildcardContext wildcardContext = new WildcardContext ( uri , jarPath ) ; 
String classPath = FilenameUtils . getPath ( uri ) ; 
if ( classPath . startsWith ( ClasspathUriLocator . PREFIX ) ) { 
classPath = substringAfter ( classPath , ClasspathUriLocator . PREFIX ) ; 
jarFile = open ( jarPath ) ; 
final List < JarEntry > jarEntryList = Collections . list ( jarFile . entries ( ) ) ; 
final List < JarEntry > filteredJarEntryList = new ArrayList < JarEntry > ( ) ; 
final List < File > allFiles = new ArrayList < File > ( ) ; 
for ( final JarEntry entry : jarEntryList ) { 
final String entryName = entry . getName ( ) ; 
final boolean isSupportedEntry = entryName . startsWith ( classPath ) && ! entryName . equals ( classPath ) 
&& accept ( entryName , wildcardContext . getWildcard ( ) ) ; 
if ( isSupportedEntry ) { 
allFiles . add ( new File ( entryName ) ) ; 
filteredJarEntryList . add ( entry ) ; 
triggerWildcardExpander ( allFiles , wildcardContext ) ; 
for ( final JarEntry entry : filteredJarEntryList ) { 
final InputStream is = jarFile . getInputStream ( entry ) ; 
IOUtils . closeQuietly ( jarFile ) ; 
} private String extractPath ( final String uri ) { 
return DefaultWildcardStreamLocator . stripQueryPath ( uri . replace ( PREFIX , StringUtils . EMPTY ) ) ; 
} public CacheKey create ( final HttpServletRequest request ) { 
notNull ( request ) ; 
CacheKey key = null ; 
final String groupName = groupExtractor . getGroupName ( request ) ; 
final ResourceType resourceType = groupExtractor . getResourceType ( request ) ; 
final boolean minimize = isMinimized ( request ) ; 
if ( groupName != null && resourceType != null ) { 
key = new CacheKey ( groupName , resourceType , minimize ) ; 
} private boolean isMinimized ( final HttpServletRequest request ) { 
return context . getConfig ( ) . isMinimizeEnabled ( ) ? groupExtractor . isMinimized ( request ) : false ; 
} private void writeReport ( final OutputStream outputStream ) { 
Transformer transformer ; 
transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; 
transformer . transform ( new DOMSource ( doc ) , new StreamResult ( outputStream ) ) ; 
final Script script ; 
stopWatch . start ( "parseStream" ) ; 
script = new GroovyShell ( ) . parse ( new InputStreamReader ( new AutoCloseInputStream ( getModelResourceAsStream ( ) ) ) ) ; 
stopWatch . start ( "parseScript" ) ; 
final WroModel model = GroovyModelParser . parse ( script ) ; 
} public final SimpleUriLocatorFactory addLocator ( final UriLocator ... locators ) { 
uriLocators . add ( locator ) ; 
} public static WroModelFactory decorate ( final WroModelFactory decorated , 
final List < Transformer < WroModel > > modelTransformers ) { 
return decorated instanceof DefaultWroModelFactoryDecorator ? decorated : new DefaultWroModelFactoryDecorator ( 
decorated , modelTransformers ) ; 
final String result = new Lessify ( ) . variablizeColors ( IOUtils . toString ( reader ) ) ; 
} public void addRequire ( final String require ) { 
if ( require != null && require . trim ( ) . length ( ) > 0 ) { 
requires . add ( require . trim ( ) ) ; 
} public String process ( final String content ) { 
if ( isEmpty ( content ) ) { 
return engineInitializer . get ( ) . eval ( buildUpdateScript ( content ) ) . toString ( ) ; 
} catch ( final ScriptException e ) { 
throw new WroRuntimeException ( e . getMessage ( ) , e ) ; 
} public String getHash ( final InputStream input ) 
if ( input == null ) { 
final Checksum checksum = new CRC32 ( ) ; 
final byte [ ] bytes = new byte [ 1024 ] ; 
while ( ( len = input . read ( bytes ) ) >= 0 ) { 
checksum . update ( bytes , 0 , len ) ; 
final String hash = new BigInteger ( Long . toString ( checksum . getValue ( ) ) ) . toString ( 16 ) ; 
return hash ; 
IOUtils . closeQuietly ( input ) ; 
} public void logSummary ( ) { 
log . info ( "----------------------------------------" ) ; 
log . info ( message ) ; 
log . info ( "----------------------------------------\n" ) ; 
} public synchronized void onProcessingResource ( final Resource resource ) { 
totalResources ++ ; 
if ( isLogRequired ( ) ) { 
updateLastInvocation ( ) ; 
final ResourcePreProcessor decoratedProcessor = getDecoratedObject ( ) ; 
if ( decoratedProcessor instanceof SupportAware ) { 
if ( ! ( ( SupportAware ) decoratedProcessor ) . isSupported ( ) ) { 
} private ReadWriteLock getLockForKey ( final K key ) { 
final ReadWriteLock lock = locks . putIfAbsent ( key , new ReentrantReadWriteLock ( ) ) ; 
return lock == null ? locks . get ( key ) : lock ; 
} protected void onCssLintException ( final CssLintException e , final Resource resource ) { 
final String uri = resource == null ? StringUtils . EMPTY : resource . getUri ( ) ; 
for ( final CssLintError x : e . getErrors ( ) ) { 
+ x . getMessage ( ) ) ; 
} private Process createProcess ( final File sourceFile ) 
notNull ( sourceFile ) ; 
final String [ ] commandLine = getCommandLine ( sourceFile . getPath ( ) ) ; 
return new ProcessBuilder ( commandLine ) . redirectErrorStream ( true ) . start ( ) ; 
public Map < String , WroModelFactory > provideModelFactories ( ) { 
final Map < String , WroModelFactory > map = new HashMap < String , WroModelFactory > ( ) ; 
map . put ( GroovyModelFactory . ALIAS , new GroovyModelFactory ( ) ) ; 
map . put ( JsonModelFactory . ALIAS , new JsonModelFactory ( ) ) ; 
map . put ( SmartWroModelFactory . ALIAS , new SmartWroModelFactory ( ) ) ; 
final String compilerPath = System . getProperty ( PARAM_COMPILER_PATH ) ; 
return StringUtils . isEmpty ( compilerPath ) ? getDefaultCompilerStream ( ) : new FileInputStream ( 
compilerPath ) ; 
public String compile ( final String content , final String optionalArgument ) { 
} public Map < String , WroModelFactory > provideModelFactories ( ) { 
map . put ( XmlModelFactory . ALIAS , new XmlModelFactory ( ) ) ; 
} private Property [ ] parseProperties ( final String contents ) { 
final String [ ] parts = contents . split ( ";" ) ; 
final List < Property > resultsAsList = new ArrayList < Property > ( ) ; 
if ( ! StringUtils . isEmpty ( part . trim ( ) ) ) { 
resultsAsList . add ( new Property ( part ) ) ; 
LOG . warn ( e . getMessage ( ) , e ) ; 
return resultsAsList . toArray ( new Property [ resultsAsList . size ( ) ] ) ; 
} public TaskInfo [ ] getTaskInfo ( ) { 
if ( ! this . keepTaskList ) { 
return ( TaskInfo [ ] ) this . taskList . toArray ( new TaskInfo [ this . taskList . size ( ) ] ) ; 
} public String prettyPrint ( ) { 
final StringBuffer sb = new StringBuffer ( shortSummary ( ) ) ; 
sb . append ( '\n' ) ; 
final TaskInfo [ ] tasks = getTaskInfo ( ) ; 
sb . append ( "-----------------------------------------\n" ) ; 
final NumberFormat nf = NumberFormat . getNumberInstance ( ) ; 
nf . setMinimumIntegerDigits ( 5 ) ; 
nf . setGroupingUsed ( false ) ; 
final NumberFormat pf = NumberFormat . getPercentInstance ( ) ; 
pf . setMinimumIntegerDigits ( 3 ) ; 
pf . setGroupingUsed ( false ) ; 
for ( final TaskInfo task : tasks ) { 
final double totalTimeSeconds = getTotalTimeSeconds ( ) ; 
final double percentage = totalTimeSeconds == 0 ? 0 : task . getTimeSeconds ( ) / totalTimeSeconds ; 
sb . append ( task . getTaskName ( ) + "\n" ) ; 
} private String getCompilationCommand ( final String input ) { 
ecmaScriptVersion ) ; 
} public static ResponseHeadersConfigurer noCache ( ) { 
return new ResponseHeadersConfigurer ( ) { 
public void configureDefaultHeaders ( final Map < String , String > map ) { 
addNoCacheHeaders ( map ) ; 
} public static ResponseHeadersConfigurer fromConfig ( final WroConfiguration config ) { 
return new ResponseHeadersConfigurer ( config . getHeader ( ) ) { 
if ( config . isDebug ( ) ) { 
final Calendar cal = Calendar . getInstance ( ) ; 
cal . roll ( Calendar . YEAR , 1 ) ; 
map . put ( HttpHeader . CACHE_CONTROL . toString ( ) , DEFAULT_CACHE_CONTROL_VALUE ) ; 
map . put ( HttpHeader . EXPIRES . toString ( ) , WroUtil . toDateAsString ( cal . getTimeInMillis ( ) ) ) ; 
map . put ( HttpHeader . LAST_MODIFIED . toString ( ) , WroUtil . toDateAsString ( getLastModifiedTimestamp ( ) ) ) ; 
} private void parseHeader ( final String header ) { 
final String headerName = header . substring ( 0 , header . indexOf ( ":" ) ) ; 
if ( ! headersMap . containsKey ( headerName ) ) { 
final String value = header . substring ( header . indexOf ( ":" ) + 1 ) ; 
headersMap . put ( headerName , StringUtils . trim ( value ) ) ; 
} private static void addNoCacheHeaders ( final Map < String , String > map ) { 
map . put ( HttpHeader . PRAGMA . toString ( ) , "no-cache" ) ; 
map . put ( HttpHeader . CACHE_CONTROL . toString ( ) , "no-cache" ) ; 
map . put ( HttpHeader . EXPIRES . toString ( ) , "0" ) ; 
} public void setHeaders ( final HttpServletResponse response ) { 
for ( final Map . Entry < String , String > entry : headersMap . entrySet ( ) ) { 
response . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; 
final CoffeeScript coffeeScript = enginePool . getObject ( ) ; 
writer . write ( coffeeScript . compile ( content ) ) ; 
enginePool . returnObject ( coffeeScript ) ; 
public Properties createProperties ( ) { 
final Properties merged = new Properties ( ) ; 
final Properties props = newDefaultProperties ( ) ; 
merged . putAll ( props ) ; 
final Properties props = createPropertiesFromFilterConfig ( ) ; 
return merged ; 
} public static String createExceptionMessage ( final RhinoException e ) { 
if ( e instanceof JavaScriptException ) { 
message . append ( toJson ( ( ( JavaScriptException ) e ) . getValue ( ) ) ) ; 
} else if ( e instanceof EcmaError ) { 
final EcmaError ecmaError = ( EcmaError ) e ; 
ecmaError . lineNumber ( ) , ecmaError . lineSource ( ) ) ) ; 
message . append ( e . getMessage ( ) ) ; 
return message . toString ( ) ; 
} public static String toJson ( final Object object , final boolean indent ) { 
final StringBuilder s = new StringBuilder ( ) ; 
encode ( s , object , indent , indent ? 0 : - 1 ) ; 
} public static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { 
if ( StringUtils . isEmpty ( location ) ) { 
final String contextPath = request . getContextPath ( ) ; 
if ( contextPath != null ) { 
if ( startsWithIgnoreCase ( location , contextPath ) ) { 
return location . substring ( contextPath . length ( ) ) ; 
final String noSlash = location . substring ( 1 ) ; 
final int nextSlash = noSlash . indexOf ( '/' ) ; 
if ( nextSlash == - 1 ) { 
return noSlash . substring ( nextSlash ) ; 
} public static String toPackageAsFolder ( final Class < ? > clazz ) { 
return clazz . getPackage ( ) . getName ( ) . replace ( '.' , '/' ) ; 
} private static boolean startsWith ( final String str , final String prefix , final boolean ignoreCase ) { 
if ( str == null || prefix == null ) { 
return ( str == null && prefix == null ) ; 
if ( prefix . length ( ) > str . length ( ) ) { 
return str . regionMatches ( ignoreCase , 0 , prefix , 0 , prefix . length ( ) ) ; 
} public static String getServletPathFromLocation ( final HttpServletRequest request , final String location ) { 
return location . replace ( getPathInfoFromLocation ( request , location ) , StringUtils . EMPTY ) ; 
public static boolean isGzipSupported ( final HttpServletRequest request ) { 
final Enumeration < String > headerNames = request . getHeaderNames ( ) ; 
if ( headerNames != null ) { 
while ( headerNames . hasMoreElements ( ) ) { 
final String headerName = headerNames . nextElement ( ) ; 
final Matcher m = PATTERN_ACCEPT_ENCODING . matcher ( headerName ) ; 
final String headerValue = request . getHeader ( headerName ) ; 
final Matcher mValue = PATTERN_GZIP . matcher ( headerValue ) ; 
return mValue . find ( ) ; 
} public static String toJSMultiLineString ( final String data ) { 
final StringBuffer result = new StringBuffer ( "[" ) ; 
final String [ ] lines = data . split ( "\n" ) ; 
if ( lines . length == 0 ) { 
result . append ( "\"\"" ) ; 
for ( int i = 0 ; i < lines . length ; i ++ ) { 
final String line = lines [ i ] ; 
result . append ( "\"" ) ; 
result . append ( line . replace ( SEPARATOR_WINDOWS , "\\\\" ) . replace ( "\"" , "\\\"" ) . replaceAll ( "\\r|\\n" , "" ) ) ; 
if ( lines . length == 1 ) { 
result . append ( "\\n" ) ; 
if ( i < lines . length - 1 ) { 
result . append ( "," ) ; 
result . append ( "].join(\"\\n\")" ) ; 
} public static boolean matchesUrl ( final HttpServletRequest request , final String path ) { 
final Pattern pattern = Pattern . compile ( ".*" + path + "[/]?" , Pattern . CASE_INSENSITIVE ) ; 
if ( request . getRequestURI ( ) != null ) { 
final Matcher m = pattern . matcher ( request . getRequestURI ( ) ) ; 
} public static ResourcePostProcessor newResourceProcessor ( final Resource resource , 
final ResourcePreProcessor preProcessor ) { 
return new ResourcePostProcessor ( ) { 
public void process ( final Reader reader , final Writer writer ) 
preProcessor . process ( resource , reader , writer ) ; 
} public static String loadRegexpWithKey ( final String key ) { 
stream = WroUtil . class . getResourceAsStream ( "regexp.properties" ) ; 
final Properties props = new RegexpProperties ( ) . load ( stream ) ; 
return props . getProperty ( key ) ; 
closeQuietly ( stream ) ; 
} public static void safeCopy ( final Reader reader , final Writer writer ) 
} public static File createTempFile ( final String extension ) { 
final String fileName = String . format ( "wro4j-%s.%s" , UUID . randomUUID ( ) . toString ( ) , extension ) ; 
final File file = new File ( createTempDirectory ( ) , fileName ) ; 
} public static String joinPath ( final String left , final String right ) { 
String leftHand = left ; 
if ( ! left . endsWith ( SEPARATOR_UNIX ) ) { 
leftHand += SEPARATOR_UNIX ; 
return leftHand + right . replaceFirst ( "^/(.*)" , "$1" ) ; 
} public static final String cleanImageUrl ( final String imageUrl ) { 
} public static final String getFullPath ( final String path ) { 
final String fullPath = FilenameUtils . getFullPath ( path ) ; 
return replaceWithServletContextSeparatorIfNedded ( fullPath ) ; 
} public static final String normalize ( final String path ) { 
final String normalized = FilenameUtils . normalize ( path ) ; 
return replaceWithServletContextSeparatorIfNedded ( normalized ) ; 
} public static ServletContextAttributeHelper create ( final FilterConfig filterConfig ) { 
Validate . notNull ( filterConfig ) ; 
final String nameFromParam = filterConfig . getInitParameter ( INIT_PARAM_NAME ) ; 
final String name = nameFromParam != null ? nameFromParam : DEFAULT_NAME ; 
return new ServletContextAttributeHelper ( filterConfig . getServletContext ( ) , name ) ; 
} final String getAttributeName ( final Attribute attribute ) { 
Validate . notNull ( attribute ) ; 
return WroServletContextListener . class . getName ( ) + "-" + attribute . name ( ) + "-" + this . name ; 
} final void setAttribute ( final Attribute attribute , final Object object ) { 
servletContext . setAttribute ( getAttributeName ( attribute ) , object ) ; 
for ( Attribute attribute : Attribute . values ( ) ) { 
servletContext . removeAttribute ( getAttributeName ( attribute ) ) ; 
} public String generateDataURI ( final InputStream inputStream , final String fileName ) 
final byte [ ] bytes = IOUtils . toByteArray ( inputStream ) ; 
final String mimeType = getMimeType ( fileName ) ; 
generateDataURI ( bytes , writer , mimeType ) ; 
} private void generateDataURI ( final byte [ ] bytes , final Writer out , final String mimeType ) 
buffer . append ( DATA_URI_PREFIX ) ; 
buffer . append ( mimeType ) ; 
buffer . append ( ";base64," ) ; 
buffer . append ( Base64 . encodeBytes ( bytes ) ) ; 
out . write ( buffer . toString ( ) ) ; 
} public static ReportXmlFormatter create ( final LintReport < LintItem > lintReport , final FormatterType formatterType ) { 
return new ReportXmlFormatter ( lintReport , formatterType ) ; 
} private static < F > ReportXmlFormatter createInternal ( final LintReport < F > lintReport , 
final FormatterType formatterType , final Function < F , LintItem > adapter ) { 
Validate . notNull ( lintReport ) ; 
final LintReport < LintItem > report = new LintReport < LintItem > ( ) ; 
for ( final ResourceLintReport < F > reportItem : lintReport . getReports ( ) ) { 
final Collection < LintItem > lintItems = new ArrayList < LintItem > ( ) ; 
for ( final F lint : reportItem . getLints ( ) ) { 
lintItems . add ( adapter . apply ( lint ) ) ; 
report . addReport ( ResourceLintReport . create ( reportItem . getResourcePath ( ) , lintItems ) ) ; 
return new ReportXmlFormatter ( report , formatterType ) ; 
protected void buildDocument ( ) { 
final Element rootElement = getDocument ( ) . createElement ( formatterType . rootElementName ) ; 
getDocument ( ) . appendChild ( rootElement ) ; 
for ( final ResourceLintReport < LintItem > resourceErrors : getLintReport ( ) . getReports ( ) ) { 
rootElement . appendChild ( createFileElement ( resourceErrors ) ) ; 
} private Node createFileElement ( final ResourceLintReport < LintItem > resourceErrors ) { 
final Element fileElement = getDocument ( ) . createElement ( ELEMENT_FILE ) ; 
fileElement . setAttribute ( ATTR_NAME , resourceErrors . getResourcePath ( ) ) ; 
for ( final LintItem error : resourceErrors . getLints ( ) ) { 
fileElement . appendChild ( createIssueElement ( error ) ) ; 
return fileElement ; 
} private Node createIssueElement ( final LintItem error ) { 
final Element issueElement = getDocument ( ) . createElement ( getIssueElementName ( ) ) ; 
final String column = String . valueOf ( error . getColumn ( ) ) ; 
if ( StringUtils . isNotBlank ( column ) ) { 
issueElement . setAttribute ( getColumnAttributeName ( ) , column ) ; 
final String evidence = error . getEvidence ( ) ; 
if ( StringUtils . isNotBlank ( evidence ) ) { 
issueElement . setAttribute ( ATTR_EVIDENCE , evidence ) ; 
final String line = String . valueOf ( error . getLine ( ) ) ; 
if ( StringUtils . isNotBlank ( line ) ) { 
issueElement . setAttribute ( ATTR_LINE , line ) ; 
final String reason = error . getReason ( ) ; 
if ( StringUtils . isNotBlank ( reason ) ) { 
issueElement . setAttribute ( getReasonAttributeName ( ) , reason ) ; 
final String severity = error . getSeverity ( ) ; 
if ( StringUtils . isNotBlank ( severity ) ) { 
issueElement . setAttribute ( ATTR_SEVERITY , severity ) ; 
return issueElement ; 
} public static Context webContext ( final HttpServletRequest request , final HttpServletResponse response , 
final FilterConfig filterConfig ) { 
return new Context ( request , response , filterConfig ) ; 
} public static void set ( final Context context , final WroConfiguration config ) { 
context . setConfig ( config ) ; 
final String correlationId = generateCorrelationId ( ) ; 
CORRELATION_ID . set ( correlationId ) ; 
CONTEXT_MAP . put ( correlationId , context ) ; 
} public static void unset ( ) { 
final String correlationId = CORRELATION_ID . get ( ) ; 
if ( correlationId != null ) { 
CONTEXT_MAP . remove ( correlationId ) ; 
CORRELATION_ID . remove ( ) ; 
} public static < T > Callable < T > decorate ( final Callable < T > callable ) { 
return new ContextPropagatingCallable < T > ( callable ) ; 
} public static CacheStrategy < CacheKey , CacheValue > decorate ( final CacheStrategy < CacheKey , CacheValue > decorated ) { 
return decorated instanceof DefaultSynchronizedCacheStrategyDecorator ? decorated 
: new DefaultSynchronizedCacheStrategyDecorator ( decorated ) ; 
} private CacheValue computeCacheValueByContent ( final String content ) { 
String hash = null ; 
if ( LOG . isDebugEnabled ( ) ) { 
hash = hashStrategy . getHash ( new ByteArrayInputStream ( content . getBytes ( ) ) ) ; 
final CacheValue entry = CacheValue . valueOf ( content , hash ) ; 
} public boolean tryAsyncCheck ( final CacheKey cacheKey ) { 
boolean checkInvoked = false ; 
if ( context . getConfig ( ) . isResourceWatcherAsync ( ) ) { 
if ( isAsyncCheckAllowed ( ) ) { 
final Callable < Void > callable = createAsyncCheckCallable ( cacheKey ) ; 
submit ( callable ) ; 
checkInvoked = true ; 
check ( cacheKey ) ; 
return checkInvoked ; 
} public void check ( final CacheKey cacheKey , final Callback callback ) { 
notNull ( cacheKey ) ; 
LOG . debug ( "started" ) ; 
final Group group = new WroModelInspector ( modelFactory . create ( ) ) . getGroupByName ( cacheKey . getGroupName ( ) ) ; 
if ( isGroupChanged ( group . collectResourcesOfType ( cacheKey . getType ( ) ) , callback ) ) { 
callback . onGroupChanged ( cacheKey ) ; 
cacheStrategy . put ( cacheKey , null ) ; 
resourceChangeDetector . reset ( ) ; 
} protected void onException ( final Exception e ) { 
} private void checkResourceChange ( final Resource resource , final Group group , final Callback callback , 
final AtomicBoolean isChanged ) 
if ( isChanged ( resource , group . getName ( ) ) ) { 
isChanged . compareAndSet ( false , true ) ; 
callback . onResourceChanged ( resource ) ; 
lifecycleCallback . onResourceChanged ( resource ) ; 
} private boolean isChanged ( final Resource resource , final String groupName ) { 
boolean changed = false ; 
final AtomicBoolean changeDetected = new AtomicBoolean ( resourceChangeDetector . checkChangeForGroup ( uri , groupName ) ) ; 
if ( ! changeDetected . get ( ) && resource . getType ( ) == ResourceType . CSS ) { 
final Reader reader = new InputStreamReader ( locatorFactory . locate ( uri ) ) ; 
createCssImportProcessor ( changeDetected , groupName ) . process ( resource , reader , new StringWriter ( ) ) ; 
changed = changeDetected . get ( ) ; 
} public void updateHashForGroup ( final String hash , final String groupName ) { 
this . currentHash = hash ; 
if ( isChangedHash ( ) ) { 
groups . clear ( ) ; 
} public final boolean hasResourcesOfType ( final ResourceType resourceType ) { 
if ( resourceType . equals ( resource . getType ( ) ) ) { 
} public void replace ( final Resource resource , final List < Resource > expandedResources ) { 
notNull ( resource ) ; 
notNull ( expandedResources ) ; 
final Set < Resource > result = new LinkedHashSet < Resource > ( ) ; 
for ( final Resource resourceItem : resources ) { 
if ( resourceItem . equals ( resource ) ) { 
for ( final Resource expandedResource : expandedResources ) { 
expandedResource . setMinimize ( resource . isMinimize ( ) ) ; 
result . add ( expandedResource ) ; 
result . add ( resourceItem ) ; 
setResources ( new ArrayList < Resource > ( result ) ) ; 
} public Group addResource ( final Resource resource ) { 
if ( ! hasResource ( resource ) ) { 
} public final void setResources ( final List < Resource > resources ) { 
this . resources . clear ( ) ; 
addResource ( resource ) ; 
} protected final void copyAll ( final Map < String , S > source , final Map < String , S > target ) { 
notNull ( source ) ; 
notNull ( target ) ; 
for ( final Map . Entry < String , S > entry : source . entrySet ( ) ) { 
target . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} private Process createProcess ( final File sourceFile , final File destFile ) 
final String [ ] commandLine = getCommandLine ( sourceFile . getPath ( ) , destFile . getPath ( ) ) ; 
final Process process = new ProcessBuilder ( commandLine ) . redirectErrorStream ( true ) . start ( ) ; 
final StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , "ERROR" ) ; 
final StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , "OUTPUT" ) ; 
errorGobbler . start ( ) ; 
outputGobbler . start ( ) ; 
return process ; 
} protected String [ ] getCommandLine ( final String filePath , final String outFilePath ) { 
return isWindows ? buildArgumentsForWindows ( filePath , outFilePath ) : buildArgumentsForUnix ( filePath , outFilePath ) ; 
builder = RhinoScriptBuilder . newChain ( ) . addJSON ( ) . evaluateChain ( UglifyJs . class . getResourceAsStream ( "init.js" ) , 
"initScript" ) . evaluateChain ( getScriptAsStream ( ) , DEFAULT_UGLIFY_JS ) ; 
} public static void encode ( final java . nio . ByteBuffer raw , final java . nio . CharBuffer encoded ) { 
final byte [ ] raw3 = new byte [ 3 ] ; 
final byte [ ] enc4 = new byte [ 4 ] ; 
while ( raw . hasRemaining ( ) ) { 
final int rem = Math . min ( 3 , raw . remaining ( ) ) ; 
raw . get ( raw3 , 0 , rem ) ; 
Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; 
encoded . put ( ( char ) ( enc4 [ i ] & 0xFF ) ) ; 
} public static String encodeObject ( final java . io . Serializable serializableObject ) 
return encodeObject ( serializableObject , NO_OPTIONS ) ; 
} private void processGroups ( final Document document ) { 
final NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; 
for ( int i = 0 ; i < groupNodeList . getLength ( ) ; i ++ ) { 
final Element groupElement = ( Element ) groupNodeList . item ( i ) ; 
final String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; 
allGroupElements . put ( name , groupElement ) ; 
} private Collection < Resource > parseGroup ( final Element element ) { 
final String name = element . getAttribute ( ATTR_GROUP_NAME ) ; 
final String isAbstractAsString = element . getAttribute ( ATTR_GROUP_ABSTRACT ) ; 
final boolean isAbstractGroup = StringUtils . isNotEmpty ( isAbstractAsString ) && Boolean . valueOf ( isAbstractAsString ) ; 
if ( groupsInProcess . contains ( name ) ) { 
groupsInProcess . add ( name ) ; 
final Group parsedGroup = new WroModelInspector ( model ) . getGroupByName ( name ) ; 
if ( parsedGroup != null ) { 
groupsInProcess . remove ( name ) ; 
return parsedGroup . getResources ( ) ; 
final Group group = createGroup ( element ) ; 
if ( ! isAbstractGroup ) { 
model . addGroup ( group ) ; 
return group . getResources ( ) ; 
} protected Group createGroup ( final Element element ) { 
final Group group = new Group ( name ) ; 
final List < Resource > resources = new ArrayList < Resource > ( ) ; 
final NodeList resourceNodeList = element . getChildNodes ( ) ; 
for ( int i = 0 ; i < resourceNodeList . getLength ( ) ; i ++ ) { 
final Node node = resourceNodeList . item ( i ) ; 
if ( node instanceof Element ) { 
final Element resourceElement = ( Element ) node ; 
parseResource ( resourceElement , resources ) ; 
group . setResources ( resources ) ; 
} private void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { 
final String tagName = resourceElement . getTagName ( ) ; 
final String uri = resourceElement . getTextContent ( ) ; 
if ( TAG_GROUP_REF . equals ( tagName ) ) { 
resources . addAll ( getResourcesForGroup ( uri ) ) ; 
if ( getResourceType ( resourceElement ) != null ) { 
final Resource resource = createResource ( resourceElement ) ; 
} protected Resource createResource ( final Element resourceElement ) { 
final String minimizeAsString = resourceElement . getAttribute ( ATTR_MINIMIZE ) ; 
final boolean minimize = StringUtils . isEmpty ( minimizeAsString ) || Boolean . valueOf ( minimizeAsString ) ; 
final Resource resource = Resource . create ( uri , getResourceType ( resourceElement ) ) ; 
resource . setMinimize ( minimize ) ; 
return resource ; 
} private Collection < Resource > getResourcesForGroup ( final String groupName ) { 
final WroModelInspector modelInspector = new WroModelInspector ( model ) ; 
final Group foundGroup = modelInspector . getGroupByName ( groupName ) ; 
if ( foundGroup == null ) { 
final Element groupElement = allGroupElements . get ( groupName ) ; 
if ( groupElement == null ) { 
return parseGroup ( groupElement ) ; 
return foundGroup . getResources ( ) ; 
} public Map < String , HashStrategy > provideHashStrategies ( ) { 
final Map < String , HashStrategy > map = new HashMap < String , HashStrategy > ( ) ; 
map . put ( CRC32HashStrategy . ALIAS , new CRC32HashStrategy ( ) ) ; 
map . put ( MD5HashStrategy . ALIAS , new MD5HashStrategy ( ) ) ; 
map . put ( SHA1HashStrategy . ALIAS , new SHA1HashStrategy ( ) ) ; 
protected ResourcePreProcessor createFallbackProcessor ( ) { 
return new LazyProcessorDecorator ( new LazyInitializer < ResourcePreProcessor > ( ) { 
protected ResourcePreProcessor initialize ( ) { 
return new RhinoCoffeeScriptProcessor ( ) ; 
final String contextPath = context . getRequest ( ) != null ? context . getRequest ( ) . getContextPath ( ) : null ; 
final RewriterContext rewriterContext = new RewriterContext ( ) . setAggregatedFolderPath ( 
context . getAggregatedFolderPath ( ) ) . setProxyPrefix ( getUrlPrefix ( ) ) . setContextPath ( contextPath ) ; 
return new ImageUrlRewriter ( rewriterContext ) . rewrite ( cssUri , imageUrl ) ; 
} public DeployableUnitDescriptorImpl parse ( InputStream inputStream ) throws DeploymentException { 
Object jaxbPojo = buildJAXBPojo ( inputStream ) ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . du . DeployableUnit ) { 
return new DeployableUnitDescriptorImpl ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . du . DeployableUnit ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . du . DeployableUnit ) { 
return new DeployableUnitDescriptorImpl ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . du . DeployableUnit ) jaxbPojo ) ; 
} private void suspendIfAssoaciatedWithThread ( ) throws SystemException { 
final SleeTransaction currentThreadTransaction = transactionManager 
. getSleeTransaction ( ) ; 
if ( currentThreadTransaction != null 
&& currentThreadTransaction . equals ( this ) ) { 
transactionManager . getRealTransactionManager ( ) . suspend ( ) ; 
} private void beforeAsyncOperation ( ) throws IllegalStateException , 
SecurityException { 
int status = transaction . getStatus ( ) ; 
if ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE 
&& status != Status . STATUS_MARKED_ROLLBACK ) ) { 
suspendIfAssoaciatedWithThread ( ) ; 
} catch ( SystemException e ) { 
} public void asyncCommit ( CommitListener commitListener ) 
throws IllegalStateException , SecurityException { 
beforeAsyncOperation ( ) ; 
transactionManager . getExecutorService ( ) . submit ( new AsyncTransactionCommitRunnable ( 
commitListener , transaction ) ) ; 
} public void asyncRollback ( RollbackListener rollbackListener ) 
transactionManager . getExecutorService ( ) . submit ( new AsyncTransactionRollbackRunnable ( 
rollbackListener , transaction ) ) ; 
} public boolean delistResource ( XAResource arg0 , int arg1 ) 
throws IllegalStateException , SystemException { 
return transaction . delistResource ( arg0 , arg1 ) ; 
} public boolean enlistResource ( XAResource arg0 ) 
throws IllegalStateException , RollbackException { 
return transaction . enlistResource ( arg0 ) ; 
} public void commit ( ) throws RollbackException , HeuristicMixedException , 
HeuristicRollbackException , SecurityException , 
IllegalStateException , SystemException { 
if ( asyncOperationInitiated . get ( ) ) { 
transaction . commit ( ) ; 
} public static ResourceAdaptorEntityState fromInt ( int state ) throws IllegalArgumentException { 
case ENTITY_INACTIVE : return INACTIVE ; 
case ENTITY_ACTIVE : return ACTIVE ; 
case ENTITY_STOPPING : return STOPPING ; 
} public List < ServiceComponentImpl > buildComponents ( String serviceDescriptorFileName , JarFile deployableUnitJar ) throws DeploymentException { 
JarEntry componentDescriptor = deployableUnitJar . getJarEntry ( serviceDescriptorFileName ) ; 
InputStream componentDescriptorInputStream = null ; 
List < ServiceComponentImpl > result = new ArrayList < ServiceComponentImpl > ( ) ; 
componentDescriptorInputStream = deployableUnitJar . getInputStream ( componentDescriptor ) ; 
ServiceDescriptorFactoryImpl descriptorFactory = componentManagement . getComponentDescriptorFactory ( ) . getServiceDescriptorFactory ( ) ; 
for ( ServiceDescriptorImpl descriptor : descriptorFactory . parse ( componentDescriptorInputStream ) ) { 
result . add ( new ServiceComponentImpl ( descriptor ) ) ; 
if ( componentDescriptorInputStream != null ) { 
componentDescriptorInputStream . close ( ) ; 
} static public List getJarsFileListing ( File aStartingDir ) 
throws FileNotFoundException { 
validateDirectory ( aStartingDir ) ; 
List result = new ArrayList ( ) ; 
File [ ] filesAndDirs = aStartingDir . listFiles ( new FileFilter ( ) { 
public boolean accept ( File pathname ) { 
if ( pathname . getName ( ) . endsWith ( ".jar" ) ) 
List filesDirs = Arrays . asList ( filesAndDirs ) ; 
Iterator filesIter = filesDirs . iterator ( ) ; 
File file = null ; 
while ( filesIter . hasNext ( ) ) { 
file = ( File ) filesIter . next ( ) ; 
result . add ( file ) ; 
List deeperList = getJarsFileListing ( file ) ; 
result . addAll ( deeperList ) ; 
} static private void validateDirectory ( File aDirectory ) 
if ( aDirectory == null ) { 
if ( ! aDirectory . exists ( ) ) { 
+ aDirectory ) ; 
if ( ! aDirectory . isDirectory ( ) ) { 
if ( ! aDirectory . canRead ( ) ) { 
} public static void createInterfaceLinks ( CtClass concreteClass , 
CtClass [ ] interfaces ) { 
if ( interfaces != null ) 
concreteClass . setInterfaces ( interfaces ) ; 
} public static void createInheritanceLink ( CtClass concreteClass , 
CtClass superClass ) { 
if ( superClass == null ) 
concreteClass . setSuperclass ( superClass ) ; 
} catch ( CannotCompileException cce ) { 
cce . printStackTrace ( ) ; 
} public static void addInterceptedMethod ( CtClass concreteClass , 
CtMethod method , String interceptorName , boolean callSuperMethod ) { 
boolean hasReturn = false ; 
CtClass returnType = null ; 
returnType = method . getReturnType ( ) ; 
hasReturn = true ; 
} catch ( NotFoundException nfe ) { 
methodToAdd = methodToAdd . concat ( method . getName ( ) + "(" ) ; 
CtClass [ ] parameterTypes = null ; 
parameterTypes = method . getParameterTypes ( ) ; 
+ parameterTypes . length + "];" ; 
+ "];" ; 
for ( int argNumber = 0 ; argNumber < parameterTypes . length ; argNumber ++ ) { 
methodToAdd = methodToAdd . concat ( parameterTypes [ argNumber ] 
. getName ( ) 
if ( ! parameterTypes [ argNumber ] . isPrimitive ( ) ) 
+ "]=arg_" + argNumber + ";" ; 
parametersInit = parametersInit 
+ argNumber 
+ "]=" 
+ ClassUtils 
. getObjectFromPrimitiveType ( 
parameterTypes [ argNumber ] . getName ( ) , 
"arg_" + argNumber ) + ";" ; 
String typeClass = parameterTypes [ argNumber ] . getName ( ) ; 
if ( ! parameterTypes [ argNumber ] . isPrimitive ( ) ) { 
if ( parameterTypes [ argNumber ] . isArray ( ) ) { 
String arrayClassRepresentation = toArray ( parameterTypes [ argNumber ] ) ; 
if ( arrayClassRepresentation != null ) 
argsInit = argsInit + "classes[" + argNumber + "]=" 
+ SleeContainerUtils . class . getName ( ) + ".getCurrentThreadClassLoader().loadClass(\"" 
+ arrayClassRepresentation + "\");" ; 
argsInit = argsInit + "classes[" + argNumber 
+ "]=" + SleeContainerUtils . class . getName ( ) + ".getCurrentThreadClassLoader().loadClass(\"" + typeClass + "\");" ; 
+ ClassUtils . getClassFromPrimitiveType ( typeClass ) + ".TYPE;" ; 
if ( argNumber + 1 < parameterTypes . length ) 
methodToAdd = methodToAdd + "," ; 
if ( method . getExceptionTypes ( ) . length > 0 ) 
CtClass [ ] exceptions = method . getExceptionTypes ( ) ; 
for ( int i = 0 ; i < exceptions . length - 1 ; i ++ ) { 
String exName = exceptions [ i ] . getName ( ) ; 
methodToAdd += exceptions [ exceptions . length - 1 ] . getName ( ) ; 
nfe . printStackTrace ( ) ; 
methodToAdd += "" + parametersInit ; 
methodToAdd += "" + argsInit ; 
methodToAdd += "try{" ; 
if ( callSuperMethod ) { 
if ( method . getName ( ) . equals ( "profileStore" ) ) { 
methodToAdd = methodToAdd + "super." + method . getName ( ) + "(" ; 
if ( parameterTypes != null && parameterTypes . length > 0 ) { 
methodToAdd = methodToAdd + "arg_" + argNumber ; 
methodToAdd = methodToAdd + ");" ; 
methodToAdd = methodToAdd 
+ method . getName ( ) + "\",classes" + ");" ; 
methodToAdd = methodToAdd + "result=" + interceptorName 
if ( ! method . getName ( ) . equals ( "profileStore" ) ) { 
methodToAdd += "," ; 
methodToAdd += ");" ; 
if ( hasReturn ) { 
if ( ! returnType . getName ( ) . equalsIgnoreCase ( "void" ) ) { 
if ( ! returnType . isPrimitive ( ) ) 
+ returnType . getName ( ) + ")result;" ; 
. getPrimitiveTypeFromObject ( returnType 
. getName ( ) , "result" ) + ";" ; 
methodToAdd += "}" ; 
CtMethod methodTest ; 
methodTest = CtNewMethod . make ( methodToAdd , concreteClass ) ; 
concreteClass . addMethod ( methodTest ) ; 
} public static String toArray ( CtClass typeClass ) { 
StringTokenizer st = new StringTokenizer ( typeClass . getName ( ) , "[" ) ; 
CtClass arrayClass ; 
arrayClass = typeClass . getComponentType ( ) ; 
if ( ! arrayClass . isPrimitive ( ) ) 
name = "L" + arrayClass . getName ( ) . replace ( '/' , '.' ) + ";" ; 
name = toJvmRepresentation ( arrayClass . getName ( ) ) ; 
st . nextToken ( ) ; 
name = "[" + name ; 
} catch ( NotFoundException e ) { 
} public static String toJvmRepresentation ( String primitiveTypeName ) { 
if ( primitiveTypeName . equals ( "int" ) ) 
return "I" ; 
if ( primitiveTypeName . equals ( "boolean" ) ) 
return "Z" ; 
if ( primitiveTypeName . equals ( "byte" ) ) 
return "B" ; 
if ( primitiveTypeName . equals ( "char" ) ) 
return "C" ; 
if ( primitiveTypeName . equals ( "double" ) ) 
return "D" ; 
if ( primitiveTypeName . equals ( "float" ) ) 
return "F" ; 
if ( primitiveTypeName . equals ( "long" ) ) 
return "J" ; 
if ( primitiveTypeName . equals ( "short" ) ) 
return "S" ; 
if ( primitiveTypeName . equals ( "void" ) ) 
return "V" ; 
return primitiveTypeName ; 
} public static void copyMethods ( CtClass source , CtClass destination , 
CtClass [ ] exceptions ) { 
copyMethods ( source . getDeclaredMethods ( ) , destination , exceptions ) ; 
} public static void copyMethods ( CtMethod [ ] methods , CtClass destination , 
CtMethod methodCopy = null ; 
for ( CtMethod method : methods ) { 
methodCopy = new CtMethod ( method , destination , null ) ; 
if ( exceptions != null ) { 
methodCopy . setExceptionTypes ( exceptions ) ; 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
destination . addMethod ( methodCopy ) ; 
} catch ( CannotCompileException e ) { 
} public ServiceActivity getActivity ( ) 
throws TransactionRequiredLocalException , FactoryException { 
final SleeContainer sleeContainer = serviceManagement . getSleeContainer ( ) ; 
final SleeTransactionManager stm = sleeContainer . getTransactionManager ( ) ; 
stm . mandateTransaction ( ) ; 
ServiceID serviceID = SleeThreadLocals . getInvokingService ( ) ; 
if ( serviceID == null ) { 
return new ServiceActivityImpl ( serviceID ) ; 
} private Collection < DeployableComponent > parseDescriptor ( ) 
Collection < DeployableComponent > deployableComponents = new ArrayList < DeployableComponent > ( ) ; 
SleeContainer sleeContainer = SleeContainer . lookupFromJndi ( ) ; 
ComponentDescriptorFactory componentDescriptorFactory = sleeContainer 
. getComponentManagement ( ) . getComponentDescriptorFactory ( ) ; 
if ( this . diShortName . endsWith ( ".xml" ) ) { 
is = diURL . openStream ( ) ; 
ServiceDescriptorFactory sdf = componentDescriptorFactory 
. getServiceDescriptorFactory ( ) ; 
List < ? extends ServiceDescriptor > serviceDescriptors = sdf 
. parse ( is ) ; 
for ( ServiceDescriptor sd : serviceDescriptors ) { 
DeployableComponent dc = new DeployableComponent ( this , sleeContainerDeployer ) ; 
dc . componentType = SERVICE_COMPONENT ; 
dc . componentID = sd . getServiceID ( ) ; 
dc . componentKey = getComponentIdAsString ( dc . componentID ) ; 
Set < ComponentID > serviceDependencies = sd 
. getDependenciesSet ( ) ; 
for ( ComponentID dependencyId : serviceDependencies ) { 
dc . dependencies 
. add ( getComponentIdAsString ( dependencyId ) ) ; 
logger . trace ( getComponentIdAsString ( dependencyId ) ) ; 
dc . installActions . add ( new ActivateServiceAction ( 
( ServiceID ) dc . componentID , sleeContainerDeployer . getSleeContainer ( ) . getServiceManagement ( ) ) ) ; 
dc . uninstallActions . add ( new DeactivateServiceAction ( 
deployableComponents . add ( dc ) ; 
return deployableComponents ; 
logger . error ( "" , e ) ; 
is = null ; 
URL descriptorXML = null ; 
if ( ( descriptorXML = duWrapper . getEntry ( "META-INF/sbb-jar.xml" ) ) != null ) { 
is = descriptorXML . openStream ( ) ; 
SbbDescriptorFactory sbbdf = componentDescriptorFactory 
. getSbbDescriptorFactory ( ) ; 
List < ? extends SbbDescriptor > sbbDescriptors = sbbdf 
if ( sbbDescriptors . isEmpty ( ) ) { 
+ duWrapper . getFileName ( ) 
for ( SbbDescriptor sbbDescriptor : sbbDescriptors ) { 
dc . componentType = SBB_COMPONENT ; 
dc . componentID = sbbDescriptor . getSbbID ( ) ; 
Set < ComponentID > sbbDependencies = sbbDescriptor 
for ( ComponentID dependencyId : sbbDependencies ) { 
for ( ResourceAdaptorTypeBindingDescriptor raTypeBinding : sbbDescriptor 
. getResourceAdaptorTypeBindings ( ) ) { 
for ( ResourceAdaptorEntityBindingDescriptor raEntityBinding : raTypeBinding 
. getResourceAdaptorEntityBinding ( ) ) { 
String raLink = raEntityBinding 
. getResourceAdaptorEntityLink ( ) ; 
dc . dependencies . add ( raLink ) ; 
logger . trace ( raLink ) ; 
} else if ( ( descriptorXML = duWrapper 
. getEntry ( "META-INF/profile-spec-jar.xml" ) ) != null ) { 
ProfileSpecificationDescriptorFactory psdf = componentDescriptorFactory 
. getProfileSpecificationDescriptorFactory ( ) ; 
List < ? extends ProfileSpecificationDescriptor > psDescriptors = psdf 
if ( psDescriptors . isEmpty ( ) ) { 
for ( ProfileSpecificationDescriptor psDescriptor : psDescriptors ) { 
dc . componentType = PROFILESPEC_COMPONENT ; 
dc . componentID = psDescriptor 
. getProfileSpecificationID ( ) ; 
Set < ComponentID > psDependencies = psDescriptor 
for ( ComponentID dependencyId : psDependencies ) { 
. getEntry ( "META-INF/event-jar.xml" ) ) != null ) { 
EventTypeDescriptorFactory etdf = componentDescriptorFactory 
. getEventTypeDescriptorFactory ( ) ; 
List < ? extends EventTypeDescriptor > etDescriptors = etdf 
if ( etDescriptors == null || etDescriptors . isEmpty ( ) ) { 
for ( EventTypeDescriptor etDescriptor : etDescriptors ) { 
dc . componentType = EVENTTYPE_COMPONENT ; 
dc . componentID = etDescriptor . getEventTypeID ( ) ; 
Set < ComponentID > etDependencies = etDescriptor 
for ( ComponentID dependencyId : etDependencies ) { 
. getEntry ( "META-INF/resource-adaptor-type-jar.xml" ) ) != null ) { 
ResourceAdaptorTypeDescriptorFactory ratdf = componentDescriptorFactory 
. getResourceAdaptorTypeDescriptorFactory ( ) ; 
List < ? extends ResourceAdaptorTypeDescriptor > ratDescriptors = ratdf 
if ( ratDescriptors == null || ratDescriptors . isEmpty ( ) ) { 
for ( ResourceAdaptorTypeDescriptor ratDescriptor : ratDescriptors ) { 
dc . componentType = RATYPE_COMPONENT ; 
dc . componentID = ratDescriptor 
. getResourceAdaptorTypeID ( ) ; 
Set < ComponentID > ratDependencies = ratDescriptor 
for ( ComponentID dependencyId : ratDependencies ) { 
. getEntry ( "META-INF/resource-adaptor-jar.xml" ) ) != null ) { 
ResourceAdaptorDescriptorFactory radf = componentDescriptorFactory 
. getResourceAdaptorDescriptorFactory ( ) ; 
List < ? extends ResourceAdaptorDescriptor > raDescriptors = radf 
DeployConfigParser sleeDeployConfigParser = sleeContainerDeployer . getSLEEDeployConfigParser ( ) ; 
for ( ResourceAdaptorDescriptor raDescriptor : raDescriptors ) { 
dc . componentType = RA_COMPONENT ; 
dc . componentID = raDescriptor . getResourceAdaptorID ( ) ; 
Set < ComponentID > raDependencies = raDescriptor 
for ( ComponentID dependencyId : raDependencies ) { 
if ( sleeDeployConfigParser != null ) { 
Collection < ManagementAction > managementActions = sleeDeployConfigParser . getPostInstallActions ( ) . get ( dc . getComponentKey ( ) ) ; 
if ( managementActions != null ) { 
dc . installActions . addAll ( managementActions ) ; 
managementActions = sleeDeployConfigParser . getPreUninstallActions ( ) . get ( dc . getComponentKey ( ) ) ; 
dc . uninstallActions . addAll ( managementActions ) ; 
. getEntry ( "META-INF/library-jar.xml" ) ) != null ) { 
LibraryDescriptorFactory ldf = componentDescriptorFactory 
. getLibraryDescriptorFactory ( ) ; 
List < ? extends LibraryDescriptor > libraryDescriptors = ldf 
for ( LibraryDescriptor libraryDescriptor : libraryDescriptors ) { 
dc . componentType = LIBRARY_COMPONENT ; 
dc . componentID = libraryDescriptor . getLibraryID ( ) ; 
Set < ComponentID > libraryDependencies = libraryDescriptor 
for ( ComponentID dependencyId : libraryDependencies ) { 
logger . warn ( "\r\n--------------------------------------------------------------------------------\r\n" 
+ "'.\r\n" 
+ "--------------------------------------------------------------------------------" ) ; 
return new ArrayList < DeployableComponent > ( ) ; 
} public static AddressPlan fromInt ( int plan ) throws IllegalArgumentException { 
switch ( plan ) { 
case ADDRESS_PLAN_NOT_PRESENT : return NOT_PRESENT ; 
case ADDRESS_PLAN_UNDEFINED : return UNDEFINED ; 
case ADDRESS_PLAN_IP : return IP ; 
case ADDRESS_PLAN_MULTICAST : return MULTICAST ; 
case ADDRESS_PLAN_UNICAST : return UNICAST ; 
case ADDRESS_PLAN_E164 : return E164 ; 
case ADDRESS_PLAN_AESA : return AESA ; 
case ADDRESS_PLAN_URI : return URI ; 
case ADDRESS_PLAN_NSAP : return NSAP ; 
case ADDRESS_PLAN_SMTP : return SMTP ; 
case ADDRESS_PLAN_X400 : return X400 ; 
case ADDRESS_PLAN_SIP : return SIP ; 
case ADDRESS_PLAN_E164_MOBILE : return E164_MOBILE ; 
case ADDRESS_PLAN_H323 : return H323 ; 
case ADDRESS_PLAN_GT : return GT ; 
case ADDRESS_PLAN_SSN : return SSN ; 
case ADDRESS_PLAN_SLEE_PROFILE_TABLE : return SLEE_PROFILE_TABLE ; 
case ADDRESS_PLAN_SLEE_PROFILE : return SLEE_PROFILE ; 
} public static AddressPlan fromString ( String plan ) throws NullPointerException , IllegalArgumentException { 
if ( plan . equalsIgnoreCase ( NOT_PRESENT_STRING ) ) return NOT_PRESENT ; 
if ( plan . equalsIgnoreCase ( UNDEFINED_STRING ) ) return UNDEFINED ; 
if ( plan . equalsIgnoreCase ( IP_STRING ) ) return IP ; 
if ( plan . equalsIgnoreCase ( MULTICAST_STRING ) ) return MULTICAST ; 
if ( plan . equalsIgnoreCase ( UNICAST_STRING ) ) return UNICAST ; 
if ( plan . equalsIgnoreCase ( E164_STRING ) ) return E164 ; 
if ( plan . equalsIgnoreCase ( AESA_STRING ) ) return AESA ; 
if ( plan . equalsIgnoreCase ( URI_STRING ) ) return URI ; 
if ( plan . equalsIgnoreCase ( NSAP_STRING ) ) return NSAP ; 
if ( plan . equalsIgnoreCase ( SMTP_STRING ) ) return SMTP ; 
if ( plan . equalsIgnoreCase ( X400_STRING ) ) return X400 ; 
if ( plan . equalsIgnoreCase ( SIP_STRING ) ) return SIP ; 
if ( plan . equalsIgnoreCase ( E164_MOBILE_STRING ) ) return E164_MOBILE ; 
if ( plan . equalsIgnoreCase ( H323_STRING ) ) return H323 ; 
if ( plan . equalsIgnoreCase ( GT_STRING ) ) return GT ; 
if ( plan . equalsIgnoreCase ( SSN_STRING ) ) return SSN ; 
if ( plan . equalsIgnoreCase ( SLEE_PROFILE_TABLE_STRING ) ) return SLEE_PROFILE_TABLE ; 
if ( plan . equalsIgnoreCase ( SLEE_PROFILE_STRING ) ) return SLEE_PROFILE ; 
} public TimerID setTimer ( ActivityContextInterface aci , Address address , 
long startTime , TimerOptions timerOptions ) 
throws NullPointerException , IllegalArgumentException , 
FacilityException { 
return setTimer ( aci , address , startTime , Long . MAX_VALUE , 1 , 
timerOptions ) ; 
long startTime , long period , int numRepetitions , 
TimerOptions timerOptions ) throws NullPointerException , 
IllegalArgumentException , TransactionRolledbackLocalException , 
if ( aci == null ) 
if ( startTime < 0 ) 
if ( period <= 0 ) 
if ( timerOptions == null ) 
if ( timerOptions . getTimeout ( ) > period ) 
if ( timerOptions . getTimeout ( ) < this . getResolution ( ) ) 
timerOptions . setTimeout ( Math . min ( period , this . getResolution ( ) ) ) ; 
if ( period == Long . MAX_VALUE && numRepetitions == 1 ) { 
period = - 1 ; 
if ( numRepetitions < 0 ) 
SleeTransactionManager txMgr = sleeContainer . getTransactionManager ( ) ; 
boolean startedTx = txMgr . requireTransaction ( ) ; 
TimerIDImpl timerID = new TimerIDImpl ( sleeContainer . getUuidGenerator ( ) . createUUID ( ) ) ; 
org . mobicents . slee . container . activity . ActivityContextInterface aciImpl = ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ; 
aciImpl . getActivityContext ( ) . attachTimer ( timerID ) ; 
TimerFacilityTimerTaskData taskData = new TimerFacilityTimerTaskData ( timerID , aciImpl . getActivityContext ( ) . getActivityContextHandle ( ) , address , startTime , period , numRepetitions , timerOptions ) ; 
final TimerFacilityTimerTask task = new TimerFacilityTimerTask ( taskData ) ; 
if ( configuration . getTaskExecutionWaitsForTxCommitConfirmation ( ) ) { 
final CountDownLatch countDownLatch = new CountDownLatch ( 1 ) ; 
task . setCountDownLatch ( countDownLatch ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
countDownLatch . countDown ( ) ; 
TransactionContext txContext = txMgr . getTransactionContext ( ) ; 
txContext . getAfterCommitActions ( ) . add ( action ) ; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
scheduler . schedule ( task ) ; 
if ( startedTx ) { 
txMgr . commit ( ) ; 
throw new TransactionRolledbackLocalException ( 
return timerID ; 
} public void cancelTimer ( TimerID timerID ) throws NullPointerException , 
TransactionRolledbackLocalException , FacilityException { 
if ( timerID == null ) 
boolean terminateTx = txMgr . requireTransaction ( ) ; 
boolean doRollback = true ; 
cancelTimer ( timerID , true ) ; 
doRollback = false ; 
txMgr . requireTransactionEnd ( terminateTx , doRollback ) ; 
throw new TransactionRolledbackLocalException ( e . getMessage ( ) , e ) ; 
} public ActivityContextInterface getActivityContextInterface ( TimerID timerID ) 
throws NullPointerException , TransactionRequiredLocalException , 
if ( timerID == null ) { 
sleeContainer . getTransactionManager ( ) . mandateTransaction ( ) ; 
TimerFacilityTimerTaskData taskData = ( TimerFacilityTimerTaskData ) scheduler . getTimerTaskData ( timerID ) ; 
if ( taskData != null ) { 
return sleeContainer . getActivityContextFactory ( ) . getActivityContext ( taskData . getActivityContextHandle ( ) ) . getActivityContextInterface ( ) ; 
throw new FacilityException ( e . getMessage ( ) , e ) ; 
} public boolean isNotificationEnabled ( Notification notification ) { 
if ( ! ( notification instanceof AlarmNotification ) ) return false ; 
if ( minLevel_10 != null ) { 
Level alarmLevel = ( ( AlarmNotification ) notification ) . getLevel ( ) ; 
return alarmLevel != null && ! minLevel_10 . isHigherLevel ( alarmLevel ) ; 
AlarmLevel alarmLevel = ( ( AlarmNotification ) notification ) . getAlarmLevel ( ) ; 
return alarmLevel != null && ! minLevel_11 . isHigherLevel ( alarmLevel ) ; 
} public List < SbbDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException 
List < SbbDescriptorImpl > result = new ArrayList < SbbDescriptorImpl > ( ) ; 
boolean isSlee11 = false ; 
MSbbJar mSbbJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . sbb . SbbJar ) 
mSbbJar = new MSbbJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . sbb . SbbJar ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . sbb . SbbJar ) 
mSbbJar = new MSbbJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . sbb . SbbJar ) jaxbPojo ) ; 
isSlee11 = true ; 
MSecurityPermissions mSbbJarSecurityPermissions = mSbbJar . getSecurityPermissions ( ) ; 
for ( MSbb mSbb : mSbbJar . getSbb ( ) ) 
result . add ( new SbbDescriptorImpl ( mSbb , mSbbJarSecurityPermissions , isSlee11 ) ) ; 
} private TreeItem doTree ( FQDNNode localRoot ) { 
TreeItem localLeaf = new TreeItem ( ) ; 
LogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; 
localLeaf . setWidget ( logTreeNode ) ; 
if ( localRoot . getChildren ( ) . size ( ) > 0 ) { 
Tree t = new Tree ( ) ; 
ArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; 
Collections . sort ( names ) ; 
Iterator it = names . iterator ( ) ; 
t . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; 
localLeaf . addItem ( t ) ; 
return localLeaf ; 
public void readExternal ( ObjectInput in ) throws IOException , 
ClassNotFoundException { 
serviceID = new ServiceID ( in . readUTF ( ) , in . readUTF ( ) , in . readUTF ( ) ) ; 
convergenceName = in . readUTF ( ) ; 
public void writeExternal ( ObjectOutput out ) throws IOException { 
out . writeUTF ( serviceID . getName ( ) ) ; 
out . writeUTF ( serviceID . getVendor ( ) ) ; 
out . writeUTF ( serviceID . getVersion ( ) ) ; 
out . writeUTF ( convergenceName ) ; 
} public void serviceInstall ( ServiceComponent serviceComponent ) { 
for ( SbbID sbbID : serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) ) { 
sbbPoolManagement . createObjectPool ( serviceComponent . getServiceID ( ) , sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbID ) , 
sleeContainer . getTransactionManager ( ) ) ; 
} public void serviceUninstall ( ServiceComponent serviceComponent ) { 
sbbPoolManagement . removeObjectPool ( serviceComponent . getServiceID ( ) , sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbID ) , 
} public SbbObjectPoolImpl getObjectPool ( ServiceID serviceID , SbbID sbbID ) { 
return sbbPoolManagement . getObjectPool ( serviceID , sbbID ) ; 
} public void installSbb ( final SbbComponent sbbComponent ) 
final SleeTransactionManager sleeTransactionManager = sleeContainer 
. getTransactionManager ( ) ; 
sleeTransactionManager . mandateTransaction ( ) ; 
ClassLoader oldClassLoader = Thread . currentThread ( ) 
. getContextClassLoader ( ) ; 
Thread . currentThread ( ) . setContextClassLoader ( 
sbbComponent . getClassLoader ( ) ) ; 
JndiManagement jndiManagement = sleeContainer . getJndiManagement ( ) ; 
jndiManagement . componentInstall ( sbbComponent ) ; 
jndiManagement . pushJndiContext ( sbbComponent ) ; 
setupSbbEnvironment ( sbbComponent ) ; 
jndiManagement . popJndiContext ( ) ; 
new SbbClassCodeGenerator ( ) . process ( sbbComponent ) ; 
Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; 
sleeContainer . getTraceManagement ( ) . getTraceFacility ( ) . setTraceLevelOnTransaction ( 
sbbComponent . getSbbID ( ) , Level . OFF ) ; 
sleeContainer . getAlarmManagement ( ) . registerComponent ( 
sbbComponent . getSbbID ( ) ) ; 
if ( ! sleeContainer . getCluster ( ) . getMobicentsCache ( ) . isLocalMode ( ) ) { 
final ReplicationClassLoader replicationClassLoader = sleeContainer . getReplicationClassLoader ( ) ; 
replicationClassLoader . addDomain ( sbbComponent . getClassLoaderDomain ( ) ) ; 
replicationClassLoader . removeDomain ( sbbComponent . getClassLoaderDomain ( ) ) ; 
sleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; 
} public void uninstallSbb ( final SbbComponent sbbComponent ) 
throws SystemException , Exception , NamingException { 
sleeContainer . getTraceManagement ( ) . getTraceFacility ( ) . unSetTraceLevel ( 
sleeContainer . getAlarmManagement ( ) . unRegisterComponent ( 
sleeContainer . getJndiManagement ( ) . componentUninstall ( sbbComponent ) ; 
TransactionalAction action2 = new TransactionalAction ( ) { 
sleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action2 ) ; 
} private void removeSbbEntityWithCurrentClassLoader ( 
final SbbEntity sbbEntity ) { 
sbbEntity . remove ( ) ; 
final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; 
final SbbEntityID sbbEntityID = sbbEntity . getSbbEntityId ( ) ; 
txContext . getData ( ) . remove ( sbbEntityID ) ; 
if ( sbbEntityID . isRootSbbEntity ( ) ) { 
TransactionalAction txAction = new TransactionalAction ( ) { 
lockFacility . remove ( sbbEntityID ) ; 
txContext . getAfterCommitActions ( ) . add ( txAction ) ; 
} public DeployableUnitID install ( String url ) throws NullPointerException , 
MalformedURLException , AlreadyDeployedException , 
DeploymentException , ManagementException { 
final SleeContainer sleeContainer = getSleeContainer ( ) ; 
final DeployableUnitBuilder deployableUnitBuilder = sleeContainer . getDeployableUnitManagement ( ) . getDeployableUnitBuilder ( ) ; 
final ComponentRepository componentRepositoryImpl = sleeContainer 
. getComponentRepository ( ) ; 
final DeployableUnitManagement deployableUnitManagement = sleeContainer 
. getDeployableUnitManagement ( ) ; 
synchronized ( sleeContainer . getManagementMonitor ( ) ) { 
DeployableUnitID deployableUnitID = new DeployableUnitID ( url ) ; 
if ( deployableUnitManagement 
. getDeployableUnit ( deployableUnitID ) != null ) { 
throw new AlreadyDeployedException ( 
DeployableUnit deployableUnit = null ; 
Thread currentThread = Thread . currentThread ( ) ; 
ClassLoader currentClassLoader = currentThread 
Set < SleeComponent > componentsInstalled = new HashSet < SleeComponent > ( ) ; 
boolean rollback = true ; 
sleeTransactionManager . begin ( ) ; 
deployableUnit = deployableUnitBuilder . build ( url , 
tempDUJarsDeploymentRoot , componentRepositoryImpl ) ; 
for ( LibraryComponent component : deployableUnit 
. getLibraryComponents ( ) . values ( ) ) { 
componentRepositoryImpl . putComponent ( component ) ; 
updateSecurityPermissions ( component , false ) ; 
for ( EventTypeComponent component : deployableUnit 
. getEventTypeComponents ( ) . values ( ) ) { 
for ( ResourceAdaptorTypeComponent component : deployableUnit 
. getResourceAdaptorTypeComponents ( ) . values ( ) ) { 
currentThread . setContextClassLoader ( component 
. getClassLoader ( ) ) ; 
sleeContainer . getResourceManagement ( ) 
. installResourceAdaptorType ( component ) ; 
componentsInstalled . add ( component ) ; 
for ( ProfileSpecificationComponent component : deployableUnit 
. getProfileSpecificationComponents ( ) . values ( ) ) { 
for ( ResourceAdaptorComponent component : deployableUnit 
. getResourceAdaptorComponents ( ) . values ( ) ) { 
for ( SbbComponent component : deployableUnit 
. getSbbComponents ( ) . values ( ) ) { 
sleeContainer . getSleeProfileTableManager ( ) 
. installProfileSpecification ( component ) ; 
. installResourceAdaptor ( component ) ; 
sleeContainer . getSbbManagement ( ) . installSbb ( component ) ; 
currentThread . setContextClassLoader ( currentClassLoader ) ; 
for ( ServiceComponent component : deployableUnit 
. getServiceComponents ( ) . values ( ) ) { 
sleeContainer . getServiceManagement ( ) . installService ( 
component ) ; 
deployableUnitManagement . addDeployableUnit ( deployableUnit ) ; 
updateSecurityPermissions ( null , true ) ; 
rollback = false ; 
return deployableUnitID ; 
if ( deployableUnit != null ) { 
removeSecurityPermissions ( component , false ) ; 
componentRepositoryImpl . removeComponent ( component . getLibraryID ( ) ) ; 
componentRepositoryImpl . removeComponent ( component . getEventTypeID ( ) ) ; 
. getResourceAdaptorTypeComponents ( ) 
. values ( ) ) { 
if ( componentsInstalled . contains ( component ) ) { 
sleeContainer . getResourceManagement ( ) . uninstallResourceAdaptorType ( component ) ; 
componentRepositoryImpl . removeComponent ( component . getResourceAdaptorTypeID ( ) ) ; 
. getProfileSpecificationComponents ( ) 
sleeContainer . getSleeProfileTableManager ( ) . uninstallProfileSpecification ( component ) ; 
componentRepositoryImpl . removeComponent ( component . getProfileSpecificationID ( ) ) ; 
sleeContainer . getResourceManagement ( ) . uninstallResourceAdaptor ( component ) ; 
componentRepositoryImpl . removeComponent ( component . getResourceAdaptorID ( ) ) ; 
sleeContainer . getSbbManagement ( ) . uninstallSbb ( component ) ; 
componentRepositoryImpl . removeComponent ( component . getSbbID ( ) ) ; 
sleeContainer . getServiceManagement ( ) . uninstallService ( component ) ; 
componentRepositoryImpl . removeComponent ( component . getServiceID ( ) ) ; 
removeSecurityPermissions ( null , true ) ; 
deployableUnit . undeploy ( ) ; 
sleeTransactionManager . rollback ( ) ; 
sleeTransactionManager . commit ( ) ; 
throw new ManagementException ( 
} catch ( AlreadyDeployedException e ) { 
} catch ( DeploymentException e ) { 
throw new DeploymentException ( 
logger . debug ( e . getMessage ( ) , e ) ; 
throw new ManagementException ( e . getMessage ( ) , e ) ; 
} public void uninstall ( DeployableUnitID deployableUnitID ) 
throws NullPointerException , UnrecognizedDeployableUnitException , 
DependencyException , InvalidStateException , ManagementException { 
final ServiceManagement serviceManagement = sleeContainer 
. getServiceManagement ( ) ; 
final ResourceManagement resourceManagement = sleeContainer 
. getResourceManagement ( ) ; 
if ( this . isInstalled ( deployableUnitID ) ) { 
deployableUnit = deployableUnitManagement 
. getDeployableUnit ( deployableUnitID ) ; 
for ( SleeComponent sleeComponent : deployableUnit 
. getDeployableUnitComponents ( ) ) { 
for ( SleeComponent referringComponent : sleeContainer 
. getComponentRepository ( ) 
. getReferringComponents ( sleeComponent ) ) { 
if ( ! referringComponent . getDeployableUnit ( ) 
. getDeployableUnitID ( ) . equals ( 
deployableUnitID ) ) { 
+ referringComponent 
+ sleeComponent ) ; 
serviceManagement . uninstallService ( component ) ; 
componentRepositoryImpl . removeComponent ( component 
. getServiceID ( ) ) ; 
sleeContainer . getSbbManagement ( ) 
. uninstallSbb ( component ) ; 
. getSbbID ( ) ) ; 
resourceManagement . uninstallResourceAdaptor ( component ) ; 
. getResourceAdaptorID ( ) ) ; 
. uninstallProfileSpecification ( component ) ; 
. getProfileSpecificationID ( ) ) ; 
resourceManagement 
. uninstallResourceAdaptorType ( component ) ; 
. getResourceAdaptorTypeID ( ) ) ; 
for ( EventTypeID componentID : deployableUnit 
. getEventTypeComponents ( ) . keySet ( ) ) { 
componentRepositoryImpl . removeComponent ( componentID ) ; 
for ( LibraryID componentID : deployableUnit 
. getLibraryComponents ( ) . keySet ( ) ) { 
removeSecurityPermissions ( componentRepositoryImpl . getComponentByID ( componentID ) , false ) ; 
deployableUnitManagement 
. removeDeployableUnit ( deployableUnitID ) ; 
} catch ( InvalidStateException ex ) { 
logger . error ( ex . getMessage ( ) , ex ) ; 
} catch ( DependencyException ex ) { 
logger . debug ( ex . getMessage ( ) , ex ) ; 
if ( componentRepositoryImpl . putComponent ( component ) ) { 
. addDeployableUnit ( deployableUnit ) ; 
. closeEntityManagerFactory ( component ) ; 
throw new UnrecognizedDeployableUnitException ( 
} public DeployableUnitID getDeployableUnit ( String deploymentUrl ) 
ManagementException { 
DeployableUnitID deployableUnitID = new DeployableUnitID ( deploymentUrl ) ; 
boolean duExists = true ; 
if ( getSleeContainer ( ) . getDeployableUnitManagement ( ) 
. getDeployableUnit ( deployableUnitID ) == null ) { 
duExists = false ; 
if ( duExists ) { 
throw new UnrecognizedDeployableUnitException ( deploymentUrl ) ; 
} public DeployableUnitID [ ] getDeployableUnits ( ) throws ManagementException { 
return getSleeContainer ( ) . getDeployableUnitManagement ( ) 
. getDeployableUnits ( ) ; 
} public SbbID [ ] getSbbs ( ) throws ManagementException { 
logger . debug ( "getSbbs()" ) ; 
return getSleeContainer ( ) . getComponentRepository ( ) 
. getSbbIDs ( ) . toArray ( new SbbID [ 0 ] ) ; 
throw new ManagementException ( ex . getMessage ( ) , ex ) ; 
} public EventTypeID [ ] getEventTypes ( ) throws ManagementException { 
logger . debug ( "getEventTypes()" ) ; 
. getEventComponentIDs ( ) . toArray ( new EventTypeID [ 0 ] ) ; 
} public ProfileSpecificationID [ ] getProfileSpecifications ( ) 
throws ManagementException { 
logger . debug ( "getProfileSpecifications()" ) ; 
. getProfileSpecificationIDs ( ) . toArray ( 
new ProfileSpecificationID [ 0 ] ) ; 
} public ServiceID [ ] getServices ( ) throws ManagementException { 
logger . debug ( "getServices()" ) ; 
. getServiceIDs ( ) . toArray ( new ServiceID [ 0 ] ) ; 
} public ResourceAdaptorTypeID [ ] getResourceAdaptorTypes ( ) 
logger . debug ( "getResourceAdaptorTypes()" ) ; 
. getResourceAdaptorTypeIDs ( ) . toArray ( 
new ResourceAdaptorTypeID [ 0 ] ) ; 
} public ResourceAdaptorID [ ] getResourceAdaptors ( ) throws ManagementException { 
logger . debug ( "getResourceAdaptors()" ) ; 
. getResourceAdaptorIDs ( ) . toArray ( new ResourceAdaptorID [ 0 ] ) ; 
} public ComponentID [ ] getReferringComponents ( ComponentID componentId ) 
throws NullPointerException , UnrecognizedComponentException , 
. getReferringComponents ( componentId ) ; 
} catch ( NullPointerException ex ) { 
} catch ( UnrecognizedComponentException ex ) { 
} public DeployableUnitDescriptor getDescriptor ( 
DeployableUnitID deployableUnitID ) throws NullPointerException , 
UnrecognizedDeployableUnitException , ManagementException { 
if ( deployableUnitID == null ) 
throw new NullPointerException ( 
DeployableUnitDescriptor dud = null ; 
DeployableUnit du = getSleeContainer ( ) 
. getDeployableUnitManagement ( ) . getDeployableUnit ( 
deployableUnitID ) ; 
if ( du != null ) { 
dud = du . getSpecsDeployableUnitDescriptor ( ) ; 
if ( dud == null ) { 
return dud ; 
} public DeployableUnitDescriptor [ ] getDescriptors ( DeployableUnitID [ ] duIds ) 
throws NullPointerException , ManagementException { 
if ( duIds == null ) 
final DeployableUnitManagement deployableUnitManagement = getSleeContainer ( ) . getDeployableUnitManagement ( ) ; 
Set < DeployableUnitDescriptor > result = new HashSet < DeployableUnitDescriptor > ( ) ; 
for ( DeployableUnitID deployableUnitID : deployableUnitManagement 
. getDeployableUnits ( ) ) { 
DeployableUnit deployableUnit = deployableUnitManagement 
result . add ( deployableUnit . getSpecsDeployableUnitDescriptor ( ) ) ; 
return result . toArray ( new DeployableUnitDescriptor [ 0 ] ) ; 
} public ComponentDescriptor getDescriptor ( ComponentID componentID ) 
if ( componentID == null ) 
ComponentRepository componentRepositoryImpl = getSleeContainer ( ) . getComponentRepository ( ) ; 
SleeComponent component = null ; 
if ( componentID instanceof EventTypeID ) { 
component = componentRepositoryImpl 
. getComponentByID ( ( EventTypeID ) componentID ) ; 
} else if ( componentID instanceof LibraryID ) { 
. getComponentByID ( ( LibraryID ) componentID ) ; 
} else if ( componentID instanceof ProfileSpecificationID ) { 
. getComponentByID ( ( ProfileSpecificationID ) componentID ) ; 
} else if ( componentID instanceof ResourceAdaptorID ) { 
. getComponentByID ( ( ResourceAdaptorID ) componentID ) ; 
} else if ( componentID instanceof ResourceAdaptorTypeID ) { 
. getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) ; 
} else if ( componentID instanceof SbbID ) { 
. getComponentByID ( ( SbbID ) componentID ) ; 
} else if ( componentID instanceof ServiceID ) { 
. getComponentByID ( ( ServiceID ) componentID ) ; 
if ( component != null ) 
return component . getComponentDescriptor ( ) ; 
} public ComponentDescriptor [ ] getDescriptors ( ComponentID [ ] componentIds ) 
if ( componentIds == null ) 
ComponentDescriptor [ ] descriptors = new ComponentDescriptor [ componentIds . length ] ; 
for ( int i = 0 ; i < descriptors . length ; i ++ ) { 
descriptors [ i ] = getDescriptor ( componentIds [ i ] ) ; 
return descriptors ; 
} catch ( ManagementException ex ) { 
} public boolean isInstalled ( DeployableUnitID deployableUnitID ) 
. getDeployableUnit ( deployableUnitID ) != null ; 
} public boolean isInstalled ( ComponentID componentID ) 
. isInstalled ( componentID ) ; 
} public int getActivitiesMapped ( ) { 
for ( int i = 0 ; i < getExecutors ( ) . length ; i ++ ) { 
result += getActivitiesMapped ( i ) ; 
} public int getActivitiesMapped ( int executor ) { 
final EventRouterExecutorStatistics executorStats = getExecutors ( ) [ executor ] . getStatistics ( ) ; 
return executorStats == null ? 0 : executorStats . getActivitiesMapped ( ) ; 
} public long getAverageEventRoutingTime ( ) { 
long time = 0L ; 
long events = 0L ; 
for ( EventTypeID eventTypeID : eventRouter . getSleeContainer ( ) . getComponentManagement ( ) . getComponentRepository ( ) . getEventComponentIDs ( ) ) { 
final EventRouterExecutorStatistics eventRouterExecutorStatistics = getEventRouterExecutorStatistics ( i ) ; 
if ( eventRouterExecutorStatistics != null ) { 
EventTypeRoutingStatistics eventTypeRoutingStatistics = eventRouterExecutorStatistics . getEventTypeRoutingStatistics ( eventTypeID ) ; 
if ( eventTypeRoutingStatistics != null ) { 
time += eventTypeRoutingStatistics . getRoutingTime ( ) ; 
events += eventTypeRoutingStatistics . getEventsRouted ( ) ; 
return time == 0L ? 0L : time / events ; 
} public long getAverageEventRoutingTime ( EventTypeID eventTypeID ) { 
} public long getAverageEventRoutingTime ( int executor ) { 
return executorStats == null ? 0 : executorStats . getAverageEventRoutingTime ( ) ; 
} public long getEventsRouted ( EventTypeID eventTypeID ) { 
long result = 0L ; 
result += getEventsRouted ( i , eventTypeID ) ; 
} public long getEventsRouted ( int executor , EventTypeID eventTypeID ) { 
return executorStats == null ? 0 : executorStats . getEventsRouted ( eventTypeID ) ; 
} public long getExecutedTasks ( ) { 
result += getExecutedTasks ( i ) ; 
} public long getExecutedTasks ( int executor ) { 
return executorStats == null ? 0 : executorStats . getExecutedTasks ( ) ; 
} public long getExecutingTime ( int executor ) { 
return executorStats == null ? 0 : executorStats . getExecutingTime ( ) ; 
} public long getIdleTime ( int executor ) { 
return executorStats == null ? 0 : executorStats . getIdleTime ( ) ; 
} public long getMiscTasksExecuted ( ) { 
result += getMiscTasksExecuted ( i ) ; 
} public long getMiscTasksExecuted ( int executor ) { 
return executorStats == null ? 0 : executorStats . getMiscTasksExecuted ( ) ; 
} public long getMiscTasksExecutingTime ( int executor ) { 
return executorStats == null ? 0 : executorStats . getMiscTasksExecutingTime ( ) ; 
} public long getRoutingTime ( EventTypeID eventTypeID ) { 
result += getRoutingTime ( i , eventTypeID ) ; 
public int getWorkingQueueSize ( int executor ) { 
return executorStats == null ? 0 : executorStats . getWorkingQueueSize ( ) ; 
} public boolean getNotificationsEnabled ( String paramName ) { 
Boolean areNotificationsEnabled = paramNames . get ( paramName ) ; 
if ( ! isSlee11 ) 
if ( areNotificationsEnabled == null 
|| areNotificationsEnabled . booleanValue ( ) ) { 
if ( areNotificationsEnabled != null 
&& areNotificationsEnabled . booleanValue ( ) ) { 
} public ServiceState getState ( ServiceID serviceID ) 
throws NullPointerException , UnrecognizedServiceException , 
if ( serviceID == null ) 
final ServiceComponent serviceComponent = componentRepositoryImpl 
. getComponentByID ( serviceID ) ; 
if ( serviceComponent == null ) 
throw new UnrecognizedServiceException ( serviceID . toString ( ) ) ; 
return serviceComponent . getServiceState ( ) ; 
} public ServiceID [ ] getServices ( ServiceState serviceState ) 
if ( serviceState == null ) 
ArrayList < ServiceID > retval = new ArrayList < ServiceID > ( ) ; 
for ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { 
ServiceComponent service = componentRepositoryImpl 
if ( service == null ) { 
if ( service . getServiceState ( ) . equals ( serviceState ) ) { 
retval . add ( serviceID ) ; 
return retval . toArray ( new ServiceID [ retval . size ( ) ] ) ; 
} public Set < String > getReferencedRAEntityLinksWhichNotExists ( 
ServiceComponent serviceComponent ) { 
Set < String > raLinkNames = sleeContainer . getResourceManagement ( ) 
. getLinkNamesSet ( ) ; 
for ( String raLink : serviceComponent 
. getResourceAdaptorEntityLinks ( componentRepositoryImpl ) ) { 
if ( ! raLinkNames . contains ( raLink ) ) { 
result . add ( raLink ) ; 
} public void activate ( ServiceID serviceID ) throws NullPointerException , 
UnrecognizedServiceException , InvalidStateException , 
InvalidLinkNameBindingStateException { 
activate ( serviceID , null ) ; 
} public void activate ( ServiceID [ ] serviceIDs ) throws NullPointerException , 
InvalidArgumentException , UnrecognizedServiceException , 
InvalidStateException , ManagementException { 
if ( serviceIDs . length == 0 ) { 
throw new InvalidArgumentException ( "InvalidArgumentException" ) ; 
for ( int i = 0 ; i < serviceIDs . length ; i ++ ) { 
if ( serviceIDs [ i ] == null ) { 
for ( int i = 0 ; i < serviceIDs . length - 1 ; i ++ ) 
for ( int j = i + 1 ; j < serviceIDs . length ; j ++ ) 
if ( serviceIDs [ i ] == ( serviceIDs [ j ] ) ) { 
throw new InvalidArgumentException ( 
"InvalidArgumentException" ) ; 
activate ( serviceIDs [ i ] ) ; 
} public void deactivate ( final ServiceID serviceID ) 
throw new NullPointerException ( "NullPointerException" ) ; 
+ serviceID ) ; 
+ serviceComponent . getServiceState ( ) ) ; 
final SleeState sleeState = sleeContainer . getSleeState ( ) ; 
if ( serviceComponent . getServiceState ( ) == ServiceState . STOPPING ) 
if ( serviceComponent . getServiceState ( ) == ServiceState . INACTIVE ) { 
serviceComponent . setServiceState ( ServiceState . STOPPING ) ; 
for ( String raEntityName : resourceManagement 
. getResourceAdaptorEntities ( ) ) { 
resourceManagement . getResourceAdaptorEntity ( raEntityName ) 
. serviceStopping ( serviceID ) ; 
if ( sleeContainer . getCluster ( ) . isSingleMember ( ) && ( sleeState == SleeState . RUNNING || sleeState == SleeState . STOPPING ) ) { 
if ( sleeState == SleeState . RUNNING ) { 
endServiceActivity ( serviceID ) ; 
synchronized ( serviceComponent ) { 
if ( serviceComponent . isActivityEnded ( ) ) { 
completeServiceStop ( serviceComponent ) ; 
serviceComponent . setServiceState ( ServiceState . INACTIVE ) ; 
. serviceInactive ( serviceID ) ; 
for ( EventEntryDescriptor mEventEntry : serviceComponent 
. getRootSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) 
if ( mEventEntry . isInitialEvent ( ) ) { 
EventTypeComponent eventTypeComponent = componentRepositoryImpl 
. getComponentByID ( mEventEntry . getEventReference ( ) ) ; 
eventTypeComponent 
. deactivatedServiceWhichDefineEventAsInitial ( serviceComponent ) ; 
} public void deactivate ( ServiceID [ ] arg0 ) throws NullPointerException , 
if ( arg0 . length == 0 ) { 
for ( int i = 0 ; i < arg0 . length ; i ++ ) { 
if ( arg0 [ i ] == null ) { 
for ( int i = 0 ; i < arg0 . length - 1 ; i ++ ) 
for ( int j = i + 1 ; j < arg0 . length ; j ++ ) 
if ( arg0 [ i ] == ( arg0 [ j ] ) ) { 
deactivate ( arg0 [ i ] ) ; 
} catch ( InvalidStateException ise ) { 
throw ise ; 
ex ) ; 
} public void deactivateAndActivate ( ServiceID arg0 , ServiceID arg1 ) 
throws NullPointerException , InvalidArgumentException , 
if ( logger . isInfoEnabled ( ) ) 
if ( arg0 == arg1 ) 
if ( ( arg0 == null ) || ( arg1 == null ) ) 
ServiceComponent serviceToDeactivate = componentRepositoryImpl 
. getComponentByID ( arg0 ) ; 
if ( serviceToDeactivate == null ) { 
throw new UnrecognizedServiceException ( ) ; 
activate ( arg1 , arg0 ) ; 
deactivate ( arg0 ) ; 
} public void deactivateAndActivate ( ServiceID [ ] arg0 , ServiceID [ ] arg1 ) 
if ( arg0 . length == 0 || arg1 . length == 0 ) 
if ( arg0 . length != arg1 . length ) 
Set < ServiceID > services = new HashSet < ServiceID > ( ) ; 
for ( int i = 0 ; i < arg0 . length - 1 ; i ++ ) { 
if ( arg0 [ i ] == null || arg1 [ i ] == null ) { 
if ( ! services . add ( arg0 [ i ] ) || ! services . add ( arg1 [ i ] ) ) { 
deactivateAndActivate ( arg0 [ i ] , arg1 [ i ] ) ; 
} catch ( ManagementException me ) { 
throw me ; 
} public ObjectName getServiceUsageMBean ( ServiceID serviceID ) 
if ( serviceComponent != null ) { 
return serviceComponent . getServiceUsageMBean ( ) . getObjectName ( ) ; 
} public void installService ( final ServiceComponent serviceComponent ) 
final ServiceUsageMBean serviceUsageMBean = sleeContainer 
. getUsageParametersManagement ( ) . newServiceUsageMBean ( 
serviceComponent ) ; 
serviceUsageMBean . remove ( ) ; 
logger . error ( e . getMessage ( ) , e ) ; 
final TransactionContext txContext = sleeContainer 
. getTransactionManager ( ) . getTransactionContext ( ) ; 
final TraceManagement traceMBeanImpl = sleeContainer 
. getTraceManagement ( ) ; 
for ( final SbbID sbbID : serviceComponent 
. getSbbIDs ( componentRepositoryImpl ) ) { 
traceMBeanImpl . registerNotificationSource ( new SbbNotification ( 
serviceComponent . getServiceID ( ) , sbbID ) ) ; 
action = new TransactionalAction ( ) { 
traceMBeanImpl 
. deregisterNotificationSource ( new SbbNotification ( 
NotificationSourceWrapperImpl sbbMNotificationSource = new NotificationSourceWrapperImpl ( 
new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
serviceComponent . getAlarmNotificationSources ( ) . putIfAbsent ( sbbID , 
sbbMNotificationSource ) ; 
sleeContainer . getSbbManagement ( ) . serviceInstall ( serviceComponent ) ; 
} public void uninstallService ( final ServiceComponent serviceComponent ) 
throws SystemException , UnrecognizedServiceException , 
InstanceNotFoundException , MBeanRegistrationException , 
NullPointerException , UnrecognizedResourceAdaptorEntityException , 
ManagementException , InvalidStateException { 
+ serviceComponent . getServiceID ( ) ) ; 
if ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { 
+ serviceComponent . getServiceID ( ) 
if ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { 
if ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { 
throw new InvalidStateException ( serviceComponent . toString ( ) 
ServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; 
if ( serviceUsageMBean != null ) { 
sleeContainer . getUsageParametersManagement ( ) 
. newServiceUsageMBean ( serviceComponent ) ; 
. registerNotificationSource ( new SbbNotification ( 
sleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; 
} public boolean isRAEntityLinkNameReferenced ( String raLinkName ) { 
if ( raLinkName == null ) { 
boolean b = false ; 
b = transactionManager . requireTransaction ( ) ; 
ServiceComponent serviceComponent = componentRepositoryImpl 
if ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE 
&& serviceComponent . getResourceAdaptorEntityLinks ( 
componentRepositoryImpl ) . contains ( raLinkName ) ) { 
transactionManager . requireTransactionEnd ( b , false ) ; 
throw new SLEEException ( ex . getMessage ( ) , ex ) ; 
} public void activityEnded ( final ServiceActivityHandle activityHandle ) { 
final Runnable r = new Runnable ( ) { 
final ServiceID serviceID = activityHandle . getServiceID ( ) ; 
ScheduledFuture < ? > scheduledFuture = activityEndingTasks . remove ( serviceID ) ; 
if ( scheduledFuture != null ) { 
scheduledFuture . cancel ( true ) ; 
serviceComponent . setActivityEnded ( true ) ; 
final ExecutorService executorService = Executors . newSingleThreadExecutor ( SLEE_THREAD_FACTORY ) ; 
TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; 
executorService . execute ( r ) ; 
executorService . shutdown ( ) ; 
} public void eventRouted ( EventTypeID eventTypeID , long routingTime ) { 
EventTypeRoutingStatisticsImpl eventTypeRoutingStatistics = eventTypeRoutingStatisticsMap . get ( eventTypeID ) ; 
if ( eventTypeRoutingStatistics == null ) { 
synchronized ( eventTypeRoutingStatisticsMap ) { 
eventTypeRoutingStatistics = new EventTypeRoutingStatisticsImpl ( eventTypeID ) ; 
eventTypeRoutingStatisticsMap . put ( eventTypeID , eventTypeRoutingStatistics ) ; 
eventTypeRoutingStatistics . eventRouted ( routingTime ) ; 
taskExecuted ( routingTime ) ; 
for ( EventTypeRoutingStatistics eventTypeRoutingStatistics : eventTypeRoutingStatisticsMap . values ( ) ) { 
final EventTypeRoutingStatistics eventTypeRoutingStatistics = getEventTypeRoutingStatistics ( eventTypeID ) ; 
return eventTypeRoutingStatistics == null ? 0L 
: eventTypeRoutingStatistics . getAverageEventRoutingTime ( ) ; 
: eventTypeRoutingStatistics . getEventsRouted ( ) ; 
: eventTypeRoutingStatistics . getRoutingTime ( ) ; 
} public static AlarmLevel fromInt ( int level ) throws IllegalArgumentException { 
case LEVEL_CLEAR : return CLEAR ; 
case LEVEL_CRITICAL : return CRITICAL ; 
case LEVEL_MAJOR : return MAJOR ; 
case LEVEL_WARNING : return WARNING ; 
case LEVEL_INDETERMINATE : return INDETERMINATE ; 
case LEVEL_MINOR : return MINOR ; 
} public static AlarmLevel fromString ( String level ) throws NullPointerException , IllegalArgumentException { 
if ( level . equalsIgnoreCase ( CLEAR_STRING ) ) return CLEAR ; 
if ( level . equalsIgnoreCase ( CRITICAL_STRING ) ) return CRITICAL ; 
if ( level . equalsIgnoreCase ( MAJOR_STRING ) ) return MAJOR ; 
if ( level . equalsIgnoreCase ( WARNING_STRING ) ) return WARNING ; 
if ( level . equalsIgnoreCase ( INDETERMINATE_STRING ) ) return INDETERMINATE ; 
if ( level . equalsIgnoreCase ( MINOR_STRING ) ) return MINOR ; 
} public boolean isHigherLevel ( AlarmLevel other ) throws NullPointerException { 
return this . level < other . level ; 
} public EventTypeID [ ] getEventTypes ( ) throws ManagementConsoleException { 
EventTypeID [ ] IDs = ( EventTypeID [ ] ) mbeanServer . getAttribute ( deploymentMBean , "EventTypes" ) ; 
return IDs ; 
throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; 
} public ActivityContextImpl createActivityContext ( final ActivityContextHandle ach , int activityFlags ) throws ActivityAlreadyExistsException { 
if ( sleeContainer . getCongestionControl ( ) . refuseStartActivity ( ) ) { 
ActivityContextCacheData activityContextCacheData = new ActivityContextCacheData ( ach , sleeContainer . getCluster ( ) ) ; 
if ( activityContextCacheData . exists ( ) ) { 
throw new ActivityAlreadyExistsException ( ach . toString ( ) ) ; 
ActivityContextImpl ac = new ActivityContextImpl ( ach , activityContextCacheData , tracksIdleTime ( ach , true ) , Integer . valueOf ( activityFlags ) , this ) ; 
return ac ; 
} public void eventProcessingFailed ( FailureReason failureReason ) { 
raEntity . getResourceAdaptorObject ( ) . eventProcessingFailed ( activityHandle , fireableEventType , 
failureReason , address , receivableService , eventFlags , 
failureReason ) ; 
} public void eventProcessingSucceed ( boolean sbbProcessedEvent ) { 
int flags = sbbProcessedEvent ? EventFlags . setSbbProcessedEvent ( eventFlags ) : eventFlags ; 
raEntity . getResourceAdaptorObject ( ) . eventProcessingSuccessful ( activityHandle , fireableEventType , 
event , address , receivableService , flags ) ; 
} public void eventUnreferenced ( ) { 
raEntity . getResourceAdaptorObject ( ) . eventUnreferenced ( activityHandle , fireableEventType , 
event , address , receivableService , eventFlags ) ; 
protected void processArguments ( String [ ] args ) throws CommandException { 
String sopts = ":lyi:u:dr:" ; 
LongOpt [ ] lopts = { 
new LongOpt ( "list" , LongOpt . NO_ARGUMENT , null , 'l' ) , 
new LongOpt ( "sbbs" , LongOpt . OPTIONAL_ARGUMENT , null , ListOperation . sbbs ) , 
new LongOpt ( "services" , LongOpt . NO_ARGUMENT , null , ListOperation . services ) , 
new LongOpt ( "libraries" , LongOpt . NO_ARGUMENT , null , ListOperation . libraries ) , 
new LongOpt ( "events" , LongOpt . NO_ARGUMENT , null , ListOperation . events ) , 
new LongOpt ( "ra-types" , LongOpt . NO_ARGUMENT , null , ListOperation . ra_types ) , 
new LongOpt ( "ras" , LongOpt . NO_ARGUMENT , null , ListOperation . ras ) , 
new LongOpt ( "dus" , LongOpt . NO_ARGUMENT , null , ListOperation . dus ) , 
new LongOpt ( "profile-spec" , LongOpt . NO_ARGUMENT , null , ListOperation . profile_specs ) , 
new LongOpt ( "installed" , LongOpt . NO_ARGUMENT , null , 'y' ) , 
new LongOpt ( "cid" , LongOpt . REQUIRED_ARGUMENT , null , IsInstalledOperation . cid ) , 
new LongOpt ( "duid" , LongOpt . REQUIRED_ARGUMENT , null , IsInstalledOperation . duid ) , 
new LongOpt ( "install" , LongOpt . REQUIRED_ARGUMENT , null , 'i' ) , 
new LongOpt ( "un-install" , LongOpt . REQUIRED_ARGUMENT , null , 'u' ) , 
new LongOpt ( "desc" , LongOpt . NO_ARGUMENT , null , 'd' ) , 
new LongOpt ( "ref" , LongOpt . REQUIRED_ARGUMENT , null , 'r' ) , 
Getopt getopt = new Getopt ( null , args , sopts , lopts ) ; 
getopt . setOpterr ( false ) ; 
while ( ( code = getopt . getopt ( ) ) != - 1 ) { 
case 'l' : 
super . operation = new ListOperation ( super . context , super . log , this ) ; 
super . operation . buildOperation ( getopt , args ) ; 
super . operation = new IsInstalledOperation ( super . context , super . log , this ) ; 
case 'i' : 
super . operation = new InstallOperation ( super . context , super . log , this ) ; 
case 'u' : 
super . operation = new UninstallOperation ( super . context , super . log , this ) ; 
case 'd' : 
super . operation = new GetDescriptorsOperation ( super . context , super . log , this ) ; 
super . operation = new GetReferringComponentsOperation ( super . context , super . log , this ) ; 
} public void createUsageParameterSet ( SbbID sbbId , String name ) 
throws NullPointerException , UnrecognizedSbbException , 
InvalidArgumentException , 
UsageParameterSetNameAlreadyExistsException , ManagementException { 
if ( name . length ( ) == 0 ) 
if ( ! isValidUsageParameterName ( name ) ) 
_createUsageParameterSet ( sbbId , name , true ) ; 
} public void createUsageParameterSet ( SbbID sbbId ) 
_createUsageParameterSet ( sbbId , null , false ) ; 
} private synchronized void _createUsageParameterSet ( SbbID sbbId , 
String name , boolean failIfSbbHasNoUsageParamSet ) 
if ( sbbId == null ) 
SbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) 
. getComponentByID ( sbbId ) ; 
if ( sbbComponent == null ) { 
throw new UnrecognizedSbbException ( sbbId . toString ( ) ) ; 
ServiceComponent serviceComponent = sleeContainer 
. getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; 
if ( ! serviceComponent . getSbbIDs ( 
sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) { 
throw new UnrecognizedSbbException ( sbbId . toString ( ) 
Class < ? > usageParameterClass = sbbComponent 
. getUsageParametersConcreteClass ( ) ; 
if ( usageParameterClass == null ) { 
if ( failIfSbbHasNoUsageParamSet ) { 
throw new InvalidArgumentException ( sbbId . toString ( ) 
SbbUsageMBeanMapKey mapKey = new SbbUsageMBeanMapKey ( sbbId , name ) ; 
if ( this . usageMBeans . containsKey ( mapKey ) ) { 
UsageMBeanImpl usageMbean = null ; 
UsageNotificationManagerMBeanImpl usageNotificationManagerMBean = null ; 
ClassLoader currentThreadClassLoader = currentThread 
currentThread . setContextClassLoader ( sbbComponent . getClassLoader ( ) ) ; 
SbbNotification sbbNotification = new SbbNotification ( serviceID , 
sbbId ) ; 
AbstractUsageParameterSet installedUsageParameterSet = ( AbstractUsageParameterSet ) AbstractUsageParameterSet . newInstance ( usageParameterClass , sbbNotification , name , sleeContainer ) ; 
Class < ? > usageParameterMBeanClass = sbbComponent 
. getUsageParametersMBeanImplConcreteClass ( ) ; 
Constructor < ? > constructor = null ; 
if ( sbbComponent . isSlee11 ( ) ) { 
constructor = usageParameterMBeanClass 
. getConstructor ( new Class [ ] { Class . class , 
NotificationSource . class } ) ; 
SbbNotification . class } ) ; 
ObjectName usageParameterMBeanObjectName = generateUsageParametersMBeanObjectName ( 
name , sbbId , sbbComponent . isSlee11 ( ) ) ; 
usageMbean = ( UsageMBeanImpl ) constructor . newInstance ( new Object [ ] { 
sbbComponent . getUsageParametersMBeanConcreteInterface ( ) , 
sbbNotification } ) ; 
usageMbean . setObjectName ( usageParameterMBeanObjectName ) ; 
usageMbean . setParent ( this ) ; 
sleeContainer . getMBeanServer ( ) . registerMBean ( usageMbean , 
usageParameterMBeanObjectName ) ; 
installedUsageParameterSet . setUsageMBean ( usageMbean ) ; 
usageMbean . setUsageParameter ( installedUsageParameterSet ) ; 
this . usageMBeans . put ( mapKey , usageMbean ) ; 
if ( sbbComponent . isSlee11 ( ) && name == null ) { 
Class < ? > usageNotificationManagerMBeanClass = sbbComponent 
. getUsageNotificationManagerMBeanImplConcreteClass ( ) ; 
constructor = usageNotificationManagerMBeanClass 
NotificationSource . class , SleeComponentWithUsageParametersInterface . class } ) ; 
usageNotificationManagerMBean = ( UsageNotificationManagerMBeanImpl ) constructor 
. newInstance ( new Object [ ] { 
sbbComponent 
. getUsageNotificationManagerMBeanConcreteInterface ( ) , 
sbbNotification , sbbComponent } ) ; 
ObjectName usageNotificationManagerMBeanObjectName = generateUsageNotificationManagerMBeanObjectName ( sbbId ) ; 
usageNotificationManagerMBean 
. setObjectName ( usageNotificationManagerMBeanObjectName ) ; 
sleeContainer . getMBeanServer ( ) . registerMBean ( 
usageNotificationManagerMBean , 
usageNotificationManagerMBeanObjectName ) ; 
this . notificationManagers . put ( sbbId , 
usageNotificationManagerMBean ) ; 
if ( mapKey != null && usageMbean != null ) { 
this . usageMBeans . remove ( mapKey ) ; 
sleeContainer . getMBeanServer ( ) . unregisterMBean ( 
usageMbean . getObjectName ( ) ) ; 
} catch ( Throwable f ) { 
+ usageMbean . getObjectName ( ) ) ; 
if ( usageNotificationManagerMBean != null ) { 
this . notificationManagers . remove ( sbbId ) ; 
usageNotificationManagerMBean . getObjectName ( ) ) ; 
+ usageNotificationManagerMBean 
. getObjectName ( ) ) ; 
currentThread . setContextClassLoader ( currentThreadClassLoader ) ; 
} public void removeUsageParameterSet ( SbbID sbbId , String name ) 
UnrecognizedUsageParameterSetNameException , ManagementException { 
_removeUsageParameterSet ( sbbId , name ) ; 
} public synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) 
InvalidArgumentException , ManagementException { 
if ( sbbComponent . getUsageParametersInterface ( ) == null ) { 
Set < String > resultSet = new HashSet < String > ( ) ; 
for ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { 
if ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) 
. getSbb ( ) . equals ( sbbId ) ) { 
String name = usageMBeanImpl . getUsageParameterSet ( ) ; 
resultSet . add ( name ) ; 
return resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; 
} public ObjectName getSbbUsageMBean ( SbbID sbbId ) 
return _getSbbUsageMBean ( sbbId , null ) ; 
} catch ( UnrecognizedUsageParameterSetNameException e ) { 
} public ObjectName getSbbUsageMBean ( SbbID sbbId , String name ) 
return _getSbbUsageMBean ( sbbId , name ) ; 
} public synchronized void resetAllUsageParameters ( SbbID sbbId ) 
SbbNotification sbbNotification = ( SbbNotification ) usageMBeanImpl 
. getNotificationSource ( ) ; 
if ( sbbNotification . getSbb ( ) . equals ( sbbId ) ) { 
usageMBeanImpl . resetAllUsageParameters ( ) ; 
} public synchronized void resetAllUsageParameters ( ) 
} public AbstractUsageParameterSet getInstalledUsageParameterSet ( 
SbbID sbbID , String name ) 
throws UnrecognizedUsageParameterSetNameException { 
AbstractUsageParameterSet installedUsageParameterSet = _getInstalledUsageParameterSet ( 
sbbID , name ) ; 
if ( installedUsageParameterSet == null ) { 
throw new UnrecognizedUsageParameterSetNameException ( name ) ; 
return installedUsageParameterSet ; 
} public void setResourceAdaptorContext ( ResourceAdaptorContext raContext ) { 
this . raContext = raContext ; 
this . tracer = raContext . getTracer ( StatisticsResourceAdaptor . class . getSimpleName ( ) ) ; 
this . sleeContainer = SleeContainer . lookupFromJndi ( ) ; 
if ( this . sleeContainer != null ) { 
this . resourceManagement = sleeContainer . getResourceManagement ( ) ; 
} boolean validateAbstractClassConstraints ( Map < String , Method > concreteMethods , Map < String , Method > concreteSuperClassesMethods ) { 
String errorBuffer = new String ( "" ) ; 
boolean passed = true ; 
Class sbbAbstractClass = this . component . getAbstractSbbClass ( ) ; 
int modifiers = sbbAbstractClass . getModifiers ( ) ; 
if ( ! Modifier . isAbstract ( modifiers ) || ! Modifier . isPublic ( modifiers ) ) { 
if ( this . component . isSlee11 ( ) ) { 
Package declaredPackage = sbbAbstractClass . getPackage ( ) ; 
if ( declaredPackage == null || declaredPackage . getName ( ) . compareTo ( "" ) == 0 ) { 
passed = false ; 
errorBuffer ) ; 
Constructor constructor = sbbAbstractClass . getConstructor ( ) ; 
int conMod = constructor . getModifiers ( ) ; 
if ( ! Modifier . isPublic ( conMod ) ) { 
+ e . getMessage ( ) , "6.1" , errorBuffer ) ; 
Class javaxSleeSbbInterface = ClassUtils . checkInterfaces ( sbbAbstractClass , "javax.slee.Sbb" ) ; 
if ( javaxSleeSbbInterface == null ) { 
errorBuffer = appendToBuffer ( this . component . getAbstractSbbClass ( ) 
if ( javaxSleeSbbInterface != null ) { 
Method [ ] sbbLifecycleMethods = javaxSleeSbbInterface . getDeclaredMethods ( ) ; 
for ( Method lifecycleMehtod : sbbLifecycleMethods ) { 
String methodKey = ClassUtils . getMethodKey ( lifecycleMehtod ) ; 
Method concreteLifeCycleImpl = null ; 
if ( concreteMethods . containsKey ( methodKey ) ) { 
concreteLifeCycleImpl = concreteMethods . remove ( methodKey ) ; 
} else if ( concreteSuperClassesMethods . containsKey ( methodKey ) ) { 
concreteLifeCycleImpl = concreteSuperClassesMethods . remove ( methodKey ) ; 
+ lifecycleMehtod . getName ( ) , "6.1.1" , errorBuffer ) ; 
int lifeCycleModifier = concreteLifeCycleImpl . getModifiers ( ) ; 
if ( ! Modifier . isPublic ( lifeCycleModifier ) || Modifier . isStatic ( lifeCycleModifier ) || Modifier . isFinal ( lifeCycleModifier ) ) { 
for ( Method concreteMethod : concreteMethods . values ( ) ) { 
if ( concreteMethod . getName ( ) . startsWith ( "ejb" ) || concreteMethod . getName ( ) . startsWith ( "sbb" ) ) { 
if ( concreteMethod . getName ( ) . compareTo ( "finalize" ) == 0 ) { 
"6.1" , errorBuffer ) ; 
for ( Method concreteMethod : concreteSuperClassesMethods . values ( ) ) { 
"6.12" , errorBuffer ) ; 
if ( ! passed ) { 
logger . error ( errorBuffer ) ; 
return passed ; 
} boolean validateSbbActivityContextInterface ( Map < String , Method > sbbAbstractClassAbstraMethod , 
Map < String , Method > sbbAbstractClassAbstraMethodFromSuperClasses ) { 
if ( this . component . getDescriptor ( ) . getSbbActivityContextInterface ( ) == null ) { 
Method asACIMethod = null ; 
Iterator < Method > it = sbbAbstractClassAbstraMethod . values ( ) . iterator ( ) ; 
while ( it . hasNext ( ) ) 
Method someMethod = it . next ( ) ; 
if ( someMethod . getName ( ) . compareTo ( _SBB_AS_SBB_ACTIVITY_CONTEXT_INTERFACE ) == 0 ) { 
if ( someMethod . getParameterTypes ( ) . length == 1 
&& someMethod . getParameterTypes ( ) [ 0 ] . getName ( ) . compareTo ( "javax.slee.ActivityContextInterface" ) == 0 ) { 
asACIMethod = someMethod ; 
if ( asACIMethod == null ) 
it = sbbAbstractClassAbstraMethodFromSuperClasses . values ( ) . iterator ( ) ; 
if ( asACIMethod == null ) { 
"7.7.2" , errorBuffer ) ; 
int asACIMethodModifiers = asACIMethod . getModifiers ( ) ; 
if ( ! Modifier . isPublic ( asACIMethodModifiers ) || ! Modifier . isAbstract ( asACIMethodModifiers ) || Modifier . isNative ( asACIMethodModifiers ) ) { 
Class returnType = asACIMethod . getReturnType ( ) ; 
Class definedReturnType = this . component . getActivityContextInterface ( ) ; 
if ( returnType . getName ( ) . compareTo ( "void" ) == 0 ) { 
} else if ( returnType . equals ( definedReturnType ) ) { 
if ( asACIMethod . getExceptionTypes ( ) != null && asACIMethod . getExceptionTypes ( ) . length > 0 ) { 
Class sbbActivityContextInterface = this . component . getActivityContextInterface ( ) ; 
if ( this . component . isSlee11 ( ) && sbbActivityContextInterface . getPackage ( ) == null ) { 
"7.5" , errorBuffer ) ; 
if ( ! Modifier . isPublic ( sbbActivityContextInterface . getModifiers ( ) ) ) { 
passed = checkSbbAciFieldsConstraints ( this . component . getActivityContextInterface ( ) ) ; 
if ( asACIMethod != null ) { 
sbbAbstractClassAbstraMethod . remove ( ClassUtils . getMethodKey ( asACIMethod ) ) ; 
sbbAbstractClassAbstraMethodFromSuperClasses . remove ( ClassUtils . getMethodKey ( asACIMethod ) ) ; 
} boolean checkSbbAciFieldsConstraints ( Class sbbAciInterface ) { 
if ( ! sbbAciInterface . isInterface ( ) ) { 
HashSet < String > ignore = new HashSet < String > ( ) ; 
ignore . add ( ActivityContextInterfaceExt . class . getName ( ) ) ; 
ignore . add ( ActivityContextInterface . class . getName ( ) ) ; 
Map < String , Method > aciInterfacesDefinedMethods = ClassUtils . getAllInterfacesMethods ( sbbAciInterface , ignore ) ; 
Map < String , Class > localNameToType = new HashMap < String , Class > ( ) ; 
for ( String methodKey : aciInterfacesDefinedMethods . keySet ( ) ) { 
Method fieldMethod = aciInterfacesDefinedMethods . get ( methodKey ) ; 
String methodName = fieldMethod . getName ( ) ; 
if ( ! ( methodName . startsWith ( "get" ) || methodName . startsWith ( "set" ) ) ) { 
String fieldName = methodName . replaceFirst ( "set" , "" ) . replaceFirst ( "get" , "" ) ; 
if ( ! Character . isUpperCase ( fieldName . charAt ( 0 ) ) ) { 
"7.5.1" , errorBuffer ) ; 
if ( fieldMethod . getExceptionTypes ( ) . length > 0 ) { 
boolean isGetter = methodName . startsWith ( "get" ) ; 
Class fieldType = null ; 
if ( isGetter ) { 
if ( fieldMethod . getParameterTypes ( ) != null && fieldMethod . getParameterTypes ( ) . length > 0 ) { 
fieldType = fieldMethod . getReturnType ( ) ; 
if ( fieldType . getName ( ) . compareTo ( "void" ) == 0 ) { 
if ( fieldMethod . getParameterTypes ( ) != null && fieldMethod . getParameterTypes ( ) . length != 1 ) { 
fieldType = fieldMethod . getParameterTypes ( ) [ 0 ] ; 
if ( fieldMethod . getReturnType ( ) . getName ( ) . compareTo ( "void" ) != 0 ) { 
if ( ! ( _PRIMITIVES . contains ( fieldType . getName ( ) ) || ClassUtils . checkInterfaces ( fieldType , "java.io.Serializable" ) != null ) ) { 
if ( localNameToType . containsKey ( fieldName ) ) { 
Class storedType = localNameToType . get ( fieldName ) ; 
if ( ! storedType . equals ( fieldType ) ) { 
localNameToType . put ( fieldName , fieldType ) ; 
} boolean validateCompatibilityReferenceConstraints ( ) { 
if ( ! this . component . isSlee11 ( ) ) { 
for ( ProfileSpecRefDescriptor profileReference : this . component . getDescriptor ( ) . getProfileSpecRefs ( ) ) { 
ProfileSpecificationComponent specComponent = this . repository . getComponentByID ( profileReference . getComponentID ( ) ) ; 
if ( specComponent == null ) { 
if ( specComponent . isSlee11 ( ) ) { 
if ( logger . isEnabledFor ( Level . ERROR ) ) { 
} public EventContext createActivityEndEventContext ( ActivityContext ac , 
EventUnreferencedCallback unreferencedCallback ) { 
final EventReferencesHandlerImpl referencesHandler = new EventReferencesHandlerImpl ( ) ; 
final EventContextData data = dataSource . newEventContextData ( 
ActivityEndEventImpl . EVENT_TYPE_ID , 
ActivityEndEventImpl . SINGLETON , ac , null , null , null , null , 
unreferencedCallback , referencesHandler ) ; 
final EventContextImpl eventContext = new ActivityEndEventContextImpl ( 
data , this ) ; 
referencesHandler . setEventContext ( eventContext ) ; 
return eventContext ; 
} public EventContext createEventContext ( EventTypeID eventTypeId , 
Object eventObject , ActivityContext ac , Address address , 
ServiceID serviceID , 
EventProcessingSucceedCallback succeedCallback , 
EventProcessingFailedCallback failedCallback , 
eventTypeId , eventObject , ac , address , serviceID , 
succeedCallback , failedCallback , unreferencedCallback , 
referencesHandler ) ; 
final EventContextImpl eventContext = new EventContextImpl ( data , this ) ; 
} public Collection getProfileTables ( ) throws ManagementConsoleException { 
return ( Collection ) mbeanServer . invoke ( profileProvisioningMBean , "getProfileTables" , new Object [ ] { } , new String [ ] { } ) ; 
} public Collection getProfilesByIndexedAttribute ( String arg0 , String arg1 , Object arg2 ) throws ManagementConsoleException { 
} public static ServiceState fromInt ( int state ) throws IllegalArgumentException { 
case SERVICE_INACTIVE : return INACTIVE ; 
case SERVICE_ACTIVE : return ACTIVE ; 
case SERVICE_STOPPING : return STOPPING ; 
} public static ServiceState fromString ( String state ) throws NullPointerException , IllegalArgumentException { 
if ( state . equalsIgnoreCase ( INACTIVE_STRING ) ) return INACTIVE ; 
if ( state . equalsIgnoreCase ( ACTIVE_STRING ) ) return ACTIVE ; 
if ( state . equalsIgnoreCase ( STOPPING_STRING ) ) return STOPPING ; 
} public static SleeProvider getSleeProvider ( String peerClassName ) throws NullPointerException , PeerUnavailableException { 
ClassLoader classloader = SleeProviderFactory . class . getClassLoader ( ) ; 
if ( classloader == null ) classloader = ClassLoader . getSystemClassLoader ( ) ; 
return getSleeProvider ( peerClassName , classloader ) ; 
} public static SleeProvider getSleeProvider ( String peerClassName , ClassLoader classloader ) throws NullPointerException , PeerUnavailableException { 
return ( SleeProvider ) classloader . loadClass ( peerClassName ) . newInstance ( ) ; 
} private void writeObject ( ObjectOutputStream out ) throws IOException { 
VendorExtensionUtils . writeObject ( out , vendorDataSerializationEnabled ? vendorData : null ) ; 
if ( cause != null ) { 
out . writeBoolean ( true ) ; 
out . writeObject ( new MarshalledObject ( cause ) ) ; 
cause . printStackTrace ( pw ) ; 
out . writeUTF ( sw . getBuffer ( ) . toString ( ) ) ; 
out . writeBoolean ( false ) ; 
} private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { 
vendorData = VendorExtensionUtils . readObject ( in , vendorDataDeserializationEnabled ) ; 
if ( in . readBoolean ( ) ) { 
cause = ( Throwable ) ( ( MarshalledObject ) in . readObject ( ) ) . get ( ) ; 
catch ( ClassNotFoundException cnfe ) { 
String causeString = in . readUTF ( ) ; 
if ( cause == null ) { 
} public Collection < ProfileID > getProfiles ( String profileTableName ) 
throws NullPointerException , UnrecognizedProfileTableNameException , 
profileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; 
return profileManagement . getProfileTable ( 
profileTableName ) . getProfiles ( ) ; 
} catch ( UnrecognizedProfileTableNameException e ) { 
} public ProfileTableActivity getProfileTableActivity ( String profileTableName ) 
final SleeTransactionManager sleeTransactionManager = profileManagement . getSleeContainer ( ) 
boolean terminateTx = sleeTransactionManager . requireTransaction ( ) ; 
return profileManagement . getProfileTable ( profileTableName ) . getActivity ( ) ; 
sleeTransactionManager . requireTransactionEnd ( terminateTx , false ) ; 
} public ProfileID getProfileByIndexedAttribute ( 
java . lang . String profileTableName , java . lang . String attributeName , 
java . lang . Object attributeValue ) throws NullPointerException , 
UnrecognizedProfileTableNameException , 
UnrecognizedAttributeException , AttributeNotIndexedException , 
AttributeTypeMismatchException , 
ProfileTableImpl profileTable = profileManagement . getProfileTable ( 
profileTableName ) ; 
if ( profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) { 
throw new FacilityException ( 
Collection < ProfileID > profileIDs = profileTable . getProfilesByAttribute ( attributeName , attributeValue , false ) ; 
if ( profileIDs . isEmpty ( ) ) { 
return profileIDs . iterator ( ) . next ( ) ; 
} catch ( UnrecognizedAttributeException e ) { 
} catch ( AttributeNotIndexedException e ) { 
} catch ( AttributeTypeMismatchException e ) { 
} public List < ProfileSpecificationDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException 
List < ProfileSpecificationDescriptorImpl > result = new ArrayList < ProfileSpecificationDescriptorImpl > ( ) ; 
MProfileSpecJar mProfileSpecJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . profile . ProfileSpecJar ) 
mProfileSpecJar = new MProfileSpecJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . profile . ProfileSpecJar ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . profile . ProfileSpecJar ) 
mProfileSpecJar = new MProfileSpecJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . profile . ProfileSpecJar ) jaxbPojo ) ; 
MSecurityPermissions securityPermissions = mProfileSpecJar . getSecurityPermissions ( ) ; 
for ( MProfileSpec mProfileSpec : mProfileSpecJar . getProfileSpec ( ) ) 
result . add ( new ProfileSpecificationDescriptorImpl ( mProfileSpec , securityPermissions , isSlee11 ) ) ; 
} public void displayResult ( ) { 
if ( ! context . isQuiet ( ) ) { 
String resultText = prepareResultText ( ) ; 
PrintWriter out = context . getWriter ( ) ; 
out . println ( resultText ) ; 
} protected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) 
StringBuffer sb = new StringBuffer ( "[" ) ; 
for ( int index = 0 ; index < array . length ; index ++ ) { 
editor . setValue ( array [ index ] ) ; 
sb . append ( editor . getAsText ( ) ) ; 
sb . append ( array [ index ] . toString ( ) ) ; 
if ( index < array . length - 1 ) { 
sb . append ( CID_SEPARATOR ) ; 
sb . append ( "]" ) ; 
} public int compareTo ( Object obj ) { 
if ( obj == this ) return 0 ; 
if ( obj == null ) throw new NullPointerException ( ) ; 
if ( obj . getClass ( ) == this . getClass ( ) ) { 
return ( ( CongestionControlNotification ) obj ) . localAddress . compareTo ( this . localAddress ) ; 
synchronized ( knownAlarms ) { 
clearStaleTimeouts ( ) ; 
if ( knownAlarms . containsKey ( notification ) ) return false ; 
knownAlarms . put ( notification , new Long ( System . currentTimeMillis ( ) ) ) ; 
} private void clearStaleTimeouts ( ) { 
Iterator iterator = knownAlarms . values ( ) . iterator ( ) ; 
long currentTime = System . currentTimeMillis ( ) ; 
Long firstSeenTime = ( Long ) iterator . next ( ) ; 
if ( ( firstSeenTime . longValue ( ) + period ) < currentTime ) { 
if ( ! ( notification instanceof UsageNotification ) ) return false ; 
UsageNotification usageNotification = ( UsageNotification ) notification ; 
if ( ! service . equals ( usageNotification . getService ( ) ) ) return false ; 
if ( ! sbb . equals ( usageNotification . getSbb ( ) ) ) return false ; 
if ( ! notificationSource . equals ( usageNotification . getNotificationSource ( ) ) ) return false ; 
if ( ! usageNotification . getUsageParameterName ( ) . equals ( paramName ) ) return false ; 
long current = usageNotification . getValue ( ) ; 
return ( previous != threshold ) 
? ( ( previous < threshold && current > threshold ) || 
( previous > threshold && current < threshold ) ) 
: ( getDirection ( previous , current ) == lastDir ) ; 
if ( previous != current ) { 
lastDir = getDirection ( previous , current ) ; 
previous = current ; 
} void execute ( final ActivityHandle realHandle , final ActivityHandle refHandle , 
final FireableEventType eventType , final Object event , 
final Address address , final ReceivableService receivableService , 
final int eventFlags ) throws ActivityIsEndingException , 
FireEventException , SLEEException , 
UnrecognizedActivityHandleException { 
final SleeTransaction tx = super . suspendTransaction ( ) ; 
sleeEndpoint . _fireEvent ( realHandle , refHandle , eventType , event , address , 
receivableService , eventFlags , tx ) ; 
if ( tx != null ) { 
super . resumeTransaction ( tx ) ; 
} public Class < ? > generateClass ( ) { 
CtClass ctClass = null ; 
ClassPool classPool = profileComponent . getClassPool ( ) ; 
Collection < ProfileAttribute > profileAttributes = profileComponent . getProfileAttributes ( ) . values ( ) ; 
String className = profileEntityClass . getName ( ) + "F" ; 
ctClass = classPool . makeClass ( className ) ; 
CtClass profileEntityFactoryClass = classPool . get ( ProfileEntityFactory . class . getName ( ) ) ; 
CtClass [ ] interfaces = new CtClass [ ] { profileEntityFactoryClass } ; 
ctClass . setInterfaces ( interfaces ) ; 
CtMethod newInstanceMethod = profileEntityFactoryClass . getDeclaredMethod ( "newInstance" ) ; 
CtMethod newInstanceMethodCopy = CtNewMethod . copy ( newInstanceMethod , ctClass , null ) ; 
String newInstanceMethodCopyBody = 
"}" ; 
newInstanceMethodCopy . setBody ( newInstanceMethodCopyBody ) ; 
ctClass . addMethod ( newInstanceMethodCopy ) ; 
CtMethod copyAttributesMethod = profileEntityFactoryClass . getDeclaredMethod ( "copyAttributes" ) ; 
CtMethod copyAttributesMethodCopy = CtNewMethod . copy ( copyAttributesMethod , ctClass , null ) ; 
String copyAttributesMethodCopyBody = 
String profileEntityAttributeArrayValueClassName = null ; 
if ( System . getSecurityManager ( ) == null ) 
for ( ProfileAttribute profileAttribute : profileAttributes ) { 
String accessorMethodSufix = ClassGeneratorUtils . getPojoCmpAccessorSufix ( profileAttribute . getName ( ) ) ; 
if ( profileAttribute . isArray ( ) ) { 
profileEntityAttributeArrayValueClassName = profileEntityAttributeArrayValueClasses . get ( profileAttribute . getName ( ) ) . getName ( ) ; 
copyAttributesMethodCopyBody += 
if ( profileAttribute . isPrimitive ( ) ) { 
"" + 
+ "}" ; 
copyAttributesMethodCopy . setBody ( copyAttributesMethodCopyBody ) ; 
ctClass . addMethod ( copyAttributesMethodCopy ) ; 
String deployDir = profileComponent . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
ctClass . writeFile ( deployDir ) ; 
return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; 
if ( ctClass != null ) { 
ctClass . defrost ( ) ; 
catch ( Throwable e ) { 
} public void bindName ( Object ach , String name ) 
throws NameAlreadyBoundException { 
final Node node = getNode ( ) ; 
if ( node . hasChild ( name ) ) { 
node . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; 
} public Object unbindName ( String name ) throws NameNotBoundException { 
final Node childNode = node . getChild ( name ) ; 
if ( childNode == null ) { 
final Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; 
node . removeChild ( name ) ; 
return ach ; 
} public Object lookupName ( String name ) { 
final Node childNode = getNode ( ) . getChild ( name ) ; 
return childNode . get ( CACHE_NODE_MAP_KEY ) ; 
} public Map getNameBindings ( ) { 
Map result = new HashMap ( ) ; 
Node childNode = null ; 
Object name = null ; 
for ( Object obj : getNode ( ) . getChildren ( ) ) { 
childNode = ( Node ) obj ; 
name = childNode . getFqn ( ) . getLastElement ( ) ; 
result . put ( name , childNode . get ( CACHE_NODE_MAP_KEY ) ) ; 
} public ObjectName preRegister ( MBeanServer mbs , ObjectName oname ) throws Exception { 
this . objectName = oname ; 
this . server = mbs ; 
return oname ; 
} public Result next ( ActivityContext ac , 
EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { 
SbbEntityID sbbEntityId = null ; 
SbbEntity sbbEntity = null ; 
EventEntryDescriptor mEventEntry = null ; 
for ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; iter 
sbbEntityId = iter . next ( ) ; 
sbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; 
if ( sbbEntity == null ) { 
if ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { 
if ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { 
if ( ! sleeEvent . isActivityEndEvent ( ) ) { 
return new Result ( sbbEntity , false ) ; 
mEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; 
if ( mEventEntry != null && mEventEntry . isReceived ( ) ) { 
return new Result ( sbbEntity , true ) ; 
} public static TraceLevel fromInt ( int level ) throws IllegalArgumentException { 
case LEVEL_OFF : return OFF ; 
case LEVEL_SEVERE : return SEVERE ; 
case LEVEL_INFO : return INFO ; 
case LEVEL_CONFIG : return CONFIG ; 
case LEVEL_FINE : return FINE ; 
case LEVEL_FINER : return FINER ; 
case LEVEL_FINEST : return FINEST ; 
} public static TraceLevel fromString ( String level ) throws NullPointerException , IllegalArgumentException { 
if ( level . equalsIgnoreCase ( OFF_STRING ) ) return OFF ; 
if ( level . equalsIgnoreCase ( SEVERE_STRING ) ) return SEVERE ; 
if ( level . equalsIgnoreCase ( INFO_STRING ) ) return INFO ; 
if ( level . equalsIgnoreCase ( CONFIG_STRING ) ) return CONFIG ; 
if ( level . equalsIgnoreCase ( FINE_STRING ) ) return FINE ; 
if ( level . equalsIgnoreCase ( FINER_STRING ) ) return FINER ; 
if ( level . equalsIgnoreCase ( FINEST_STRING ) ) return FINEST ; 
} public boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { 
} public void installProfileSpecification ( ProfileSpecificationComponent component ) throws DeploymentException { 
jndiManagement . componentInstall ( component ) ; 
jndiManagement . pushJndiContext ( component ) ; 
this . createJndiSpace ( component ) ; 
ProfileEntityFramework profileEntityFramework = new JPAProfileEntityFramework ( component , configuration , sleeContainer . getTransactionManager ( ) ) ; 
profileEntityFramework . install ( ) ; 
sleeProfileClassCodeGenerator . process ( component ) ; 
profileTableFramework . loadProfileTables ( component ) ; 
} catch ( DeploymentException de ) { 
throw new SLEEException ( t . getMessage ( ) , t ) ; 
} public void uninstallProfileSpecification ( ProfileSpecificationComponent component ) throws UnrecognizedProfileSpecificationException { 
Collection < String > profileTableNames = getDeclaredProfileTableNames ( component . getProfileSpecificationID ( ) ) ; 
for ( String profileTableName : profileTableNames ) { 
this . removeProfileTable ( profileTableName , true ) ; 
} public ProfileTableImpl getProfileTable ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException { 
ProfileTableImpl profileTable = null ; 
if ( sleeContainer . getCluster ( ) . getMobicentsCache ( ) . isLocalMode ( ) ) { 
profileTable = profileTablesLocalObjects . get ( profileTableName ) ; 
if ( profileTable == null ) { 
throw new UnrecognizedProfileTableNameException ( profileTableName ) ; 
if ( ! profileTableFramework . getConfiguration ( ) . isClusteredProfiles ( ) ) { 
throw new UnrecognizedProfileTableNameException ( ) ; 
final ProfileSpecificationID profileSpecificationID = profileTableFramework . getProfileSpecificationID ( profileTableName ) ; 
if ( profileSpecificationID != null ) { 
ProfileSpecificationComponent component = sleeContainer . getComponentRepository ( ) . getComponentByID ( profileSpecificationID ) ; 
if ( component != null ) { 
profileTable = addProfileTableLocally ( createProfileTableInstance ( profileTableName , component ) , false , false ) ; 
profileTablesLocalObjects . remove ( profileTableName ) ; 
if ( profileTable == null ) 
} public EventContextHandle getEventContextHandle ( ) { 
if ( handle == null ) { 
handle = new EventContextHandleImpl ( factory . getSleeContainer ( ) . getUuidGenerator ( ) . createUUID ( ) ) ; 
factory . getDataSource ( ) . addEventContext ( handle , this ) ; 
} public static int checkCombination ( ProfileSpecificationComponent component ) 
Object profileCmpInterface = component . getDescriptor ( ) . getProfileCMPInterface ( ) ; 
Object profileManagementInterface = component . getDescriptor ( ) . getProfileManagementInterface ( ) ; 
Object profileManagementAbstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; 
if ( profileCmpInterface == null ) 
if ( profileCmpInterface != null && profileManagementInterface != null && profileManagementAbstractClass != null ) 
if ( profileCmpInterface != null && profileManagementAbstractClass != null ) 
return 3 ; 
if ( profileCmpInterface != null && profileManagementInterface != null ) 
} private void validateInvocation ( ) throws TransactionRolledbackLocalException , NoSuchObjectLocalException , SLEEException { 
if ( this . rollbackOnly ) { 
sleeContainer . getTransactionManager ( ) . setRollbackOnly ( ) ; 
} catch ( SystemException ex ) { 
if ( this . isRemoved ) 
} public boolean isIdentical ( javax . slee . SbbLocalObject obj ) 
throws TransactionRequiredLocalException , SLEEException { 
validateInvocation ( ) ; 
return this . equals ( obj ) ; 
} public void remove ( ) throws TransactionRequiredLocalException , 
NoSuchObjectLocalException , SLEEException { 
if ( trace ) 
logger . trace ( "remove()" ) ; 
if ( ! sbbEntity . isReentrant ( ) 
&& sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) 
. getInvokedNonReentrantSbbEntities ( ) . contains ( sbbEntity . getSbbEntityId ( ) ) ) 
sleeContainer . getSbbEntityFactory ( ) . removeSbbEntity ( sbbEntity , false ) ; 
if ( sleeContainer . getTransactionManager ( ) . getRollbackOnly ( ) ) { 
EventRoutingTransactionData ertd = txContext . getEventRoutingTransactionData ( ) ; 
txContext . getAfterRollbackActions ( ) 
. add ( 
new RolledBackAction ( sbbEntity . getSbbEntityId ( ) , ertd . getEventBeingDelivered ( ) . getEvent ( ) , ertd . getAciReceivingEvent ( ) , true ) ) ; 
this . rollbackOnly = true ; 
this . isRemoved = true ; 
} public void setSbbPriority ( byte priority ) 
throws TransactionRequiredLocalException , 
sbbEntity . setPriority ( priority ) ; 
public List < AbstractSleeComponent > buildComponents ( 
String componentJarFileName , JarFile deployableUnitJar , 
File deploymentDir ) 
throws DeploymentException { 
File extractedFile = extractFile ( componentJarFileName , 
deployableUnitJar , deploymentDir ) ; 
JarFile componentJarFile = null ; 
componentJarFile = new JarFile ( extractedFile ) ; 
+ extractedFile ) ; 
List < AbstractSleeComponent > components = new ArrayList < AbstractSleeComponent > ( ) ; 
File componentJarDeploymentDir = new File ( deploymentDir , 
componentJarFileName + "-contents" ) ; 
if ( ! componentJarDeploymentDir . exists ( ) ) { 
LinkedList < File > dirsToCreate = new LinkedList < File > ( ) ; 
File dir = componentJarDeploymentDir . getParentFile ( ) ; 
while ( ! dir . equals ( deploymentDir ) ) { 
dirsToCreate . addFirst ( dir ) ; 
dir = dir . getParentFile ( ) ; 
for ( File f : dirsToCreate ) { 
f . mkdir ( ) ; 
if ( ! componentJarDeploymentDir . mkdir ( ) ) { 
+ deploymentDir ) ; 
extractJar ( componentJarFile , componentJarDeploymentDir ) ; 
JarEntry componentDescriptor = null ; 
if ( ( componentDescriptor = componentJarFile 
. getJarEntry ( "META-INF/sbb-jar.xml" ) ) != null ) { 
URLClassLoaderDomainImpl classLoaderDomain = componentManagement 
. getClassLoaderFactory ( ) 
. newClassLoaderDomain ( 
new URL [ ] { componentJarDeploymentDir . toURL ( ) } , 
componentDescriptorInputStream = componentJarFile 
. getInputStream ( componentDescriptor ) ; 
SbbDescriptorFactoryImpl descriptorFactory = componentManagement 
. getComponentDescriptorFactory ( ) 
List < SbbDescriptorImpl > descriptors = descriptorFactory 
. parse ( componentDescriptorInputStream ) ; 
for ( SbbDescriptorImpl descriptor : descriptors ) { 
PreferredPackagesBuilder . buildPreferredPackages ( descriptor , classLoaderDomain ) ; 
SbbComponentImpl component = new SbbComponentImpl ( 
descriptor ) ; 
component . setDeploymentDir ( componentJarDeploymentDir ) ; 
component . setClassLoaderDomain ( classLoaderDomain ) ; 
components . add ( component ) ; 
} else if ( ( componentDescriptor = componentJarFile 
. getJarEntry ( "META-INF/profile-spec-jar.xml" ) ) != null ) { 
ProfileSpecificationDescriptorFactoryImpl descriptorFactory = componentManagement 
List < ProfileSpecificationDescriptorImpl > descriptors = descriptorFactory 
for ( ProfileSpecificationDescriptorImpl descriptor : descriptors ) { 
ProfileSpecificationComponentImpl component = new ProfileSpecificationComponentImpl ( 
. getJarEntry ( "META-INF/library-jar.xml" ) ) != null ) { 
Set < LibraryComponentImpl > libraryComponents = new HashSet < LibraryComponentImpl > ( ) ; 
Set < URL > classLoaderDomainURLs = new HashSet < URL > ( ) ; 
classLoaderDomainURLs . add ( componentJarDeploymentDir . toURL ( ) ) ; 
LibraryDescriptorFactoryImpl descriptorFactory = componentManagement 
List < LibraryDescriptorImpl > descriptors = descriptorFactory 
for ( LibraryDescriptorImpl descriptor : descriptors ) { 
LibraryComponentImpl component = new LibraryComponentImpl ( 
for ( JarDescriptor mJar : descriptor . getJars ( ) ) { 
classLoaderDomainURLs . add ( new File ( 
componentJarDeploymentDir , mJar . getJarName ( ) ) 
. toURL ( ) ) ; 
libraryComponents . add ( component ) ; 
classLoaderDomainURLs 
. toArray ( new URL [ classLoaderDomainURLs . size ( ) ] ) , 
for ( LibraryComponentImpl component : libraryComponents ) { 
. getJarEntry ( "META-INF/event-jar.xml" ) ) != null ) { 
EventTypeDescriptorFactoryImpl descriptorFactory = componentManagement 
List < EventTypeDescriptorImpl > descriptors = descriptorFactory 
for ( EventTypeDescriptorImpl descriptor : descriptors ) { 
EventTypeComponentImpl component = new EventTypeComponentImpl ( 
. getJarEntry ( "META-INF/resource-adaptor-type-jar.xml" ) ) != null ) { 
URLClassLoaderDomainImpl classLoaderDomain = componentManagement . getClassLoaderFactory ( ) . newClassLoaderDomain ( new URL [ ] { componentJarDeploymentDir . toURL ( ) } , Thread 
. currentThread ( ) . getContextClassLoader ( ) ) ; 
ResourceAdaptorTypeDescriptorFactoryImpl descriptorFactory = componentManagement 
List < ResourceAdaptorTypeDescriptorImpl > descriptors = descriptorFactory 
for ( ResourceAdaptorTypeDescriptorImpl descriptor : descriptors ) { 
ResourceAdaptorTypeComponentImpl component = new ResourceAdaptorTypeComponentImpl ( 
. getJarEntry ( "META-INF/resource-adaptor-jar.xml" ) ) != null ) { 
ResourceAdaptorDescriptorFactoryImpl descriptorFactory = componentManagement 
List < ResourceAdaptorDescriptorImpl > descriptors = descriptorFactory 
for ( ResourceAdaptorDescriptorImpl descriptor : descriptors ) { 
ResourceAdaptorComponentImpl component = new ResourceAdaptorComponentImpl ( 
+ componentJarFile . getName ( ) 
+ componentJarFile . getName ( ) , e ) ; 
+ componentJarFile ) ; 
componentJarFile . close ( ) ; 
if ( ! extractedFile . delete ( ) ) { 
} private File extractFile ( String fileName , JarFile containingJar , File dstDir ) 
ZipEntry zipFileEntry = containingJar . getEntry ( fileName ) ; 
+ containingJar . getName ( ) ) ; 
if ( zipFileEntry == null ) { 
File extractedFile = new File ( dstDir , new File ( zipFileEntry . getName ( ) ) 
pipeStream ( containingJar . getInputStream ( zipFileEntry ) , 
new FileOutputStream ( extractedFile ) ) ; 
+ containingJar . getName ( ) , e ) ; 
return extractedFile ; 
} private void extractJar ( JarFile jarFile , File dstDir ) 
JarInputStream jarIs = null ; 
jarIs = new JarInputStream ( new BufferedInputStream ( 
new FileInputStream ( jarFile . getName ( ) ) ) ) ; 
for ( JarEntry entry = jarIs . getNextJarEntry ( ) ; jarIs . available ( ) > 0 
&& entry != null ; entry = jarIs . getNextJarEntry ( ) ) { 
if ( entry . isDirectory ( ) ) { 
File dir = new File ( dstDir , entry . getName ( ) ) ; 
+ dir . getAbsolutePath ( ) ) ; 
File file = new File ( dstDir , entry . getName ( ) ) ; 
File dir = file . getParentFile ( ) ; 
pipeStream ( jarFile . getInputStream ( entry ) , 
new FileOutputStream ( file ) ) ; 
+ jarFile . getName ( ) ) ; 
if ( jarIs != null ) { 
jarIs . close ( ) ; 
} private void pipeStream ( InputStream is , OutputStream os ) throws IOException { 
synchronized ( buffer ) { 
for ( int bytesRead = is . read ( buffer ) ; bytesRead != - 1 ; bytesRead = is 
. read ( buffer ) ) 
} catch ( Exception ioexc ) { 
public Object putObject ( Object key , Object value ) { 
return getNode ( ) . put ( key , value ) ; 
} public boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { 
final Node node = getAttachedSbbsNode ( true ) ; 
if ( ! node . hasChild ( sbbEntityId ) ) { 
node . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; 
} public boolean detachSbbEntity ( SbbEntityID sbbEntityId ) { 
final Node node = getAttachedSbbsNode ( false ) ; 
return node != null ? node . removeChild ( sbbEntityId ) : false ; 
} public boolean noSbbEntitiesAttached ( ) { 
return node != null ? node . getChildrenNames ( ) . isEmpty ( ) : true ; 
public Set < SbbEntityID > getSbbEntitiesAttached ( ) { 
return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; 
} public boolean attachTimer ( TimerID timerID ) { 
final Node node = getAttachedTimersNode ( true ) ; 
if ( ! node . hasChild ( timerID ) ) { 
node . addChild ( Fqn . fromElements ( timerID ) ) ; 
} public boolean detachTimer ( TimerID timerID ) { 
final Node node = getAttachedTimersNode ( false ) ; 
return node != null ? node . removeChild ( timerID ) : false ; 
} public boolean noTimersAttached ( ) { 
} public Set getAttachedTimers ( ) { 
} public void nameBound ( String name ) { 
final Node node = getNamesBoundNode ( true ) ; 
if ( ! node . hasChild ( name ) ) { 
node . addChild ( Fqn . fromElements ( name ) ) ; 
} public boolean nameUnbound ( String name ) { 
final Node node = getNamesBoundNode ( false ) ; 
return node != null ? node . removeChild ( name ) : false ; 
} public boolean noNamesBound ( ) { 
} public Set getNamesBoundCopy ( ) { 
public void setCmpAttribute ( String attrName , Object attrValue ) { 
final Node node = getCmpAttributesNode ( true ) ; 
Node cmpNode = node . getChild ( attrName ) ; 
if ( cmpNode == null ) { 
cmpNode = node . addChild ( Fqn . fromElements ( attrName ) ) ; 
cmpNode . put ( CMP_ATTRIBUTES_NODE_MAP_KEY , attrValue ) ; 
public Object getCmpAttribute ( String attrName ) { 
final Node node = getCmpAttributesNode ( false ) ; 
if ( node == null ) { 
final Node cmpNode = node . getChild ( attrName ) ; 
if ( cmpNode != null ) { 
return cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ; 
public Map getCmpAttributesCopy ( ) { 
return Collections . emptyMap ( ) ; 
Node cmpNode = null ; 
for ( Object obj : node . getChildren ( ) ) { 
cmpNode = ( Node ) obj ; 
result . put ( cmpNode . getFqn ( ) . getLastElement ( ) , cmpNode 
. get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ) ; 
} protected String appendToBuffer ( String message , String section , 
String buffer ) { 
buffer += ( this . component . getDescriptor ( ) . getResourceAdaptorID ( ) 
String sopts = ":a:f:sug" ; 
new LongOpt ( "tracers-used" , LongOpt . REQUIRED_ARGUMENT , null , 'a' ) , 
new LongOpt ( "tracers-set" , LongOpt . REQUIRED_ARGUMENT , null , 'f' ) , 
new LongOpt ( "set-level" , LongOpt . NO_ARGUMENT , null , 's' ) , 
new LongOpt ( "cid" , LongOpt . REQUIRED_ARGUMENT , null , SetLevelOperation . cid ) , 
new LongOpt ( "nsrc" , LongOpt . REQUIRED_ARGUMENT , null , SetLevelOperation . nsrc ) , 
new LongOpt ( "name" , LongOpt . REQUIRED_ARGUMENT , null , SetLevelOperation . name ) , 
new LongOpt ( "level" , LongOpt . REQUIRED_ARGUMENT , null , SetLevelOperation . level ) , 
new LongOpt ( "un-set-level" , LongOpt . NO_ARGUMENT , null , 'u' ) , 
new LongOpt ( "nsrc" , LongOpt . REQUIRED_ARGUMENT , null , UnsetLevelOperation . nsrc ) , 
new LongOpt ( "name" , LongOpt . REQUIRED_ARGUMENT , null , UnsetLevelOperation . name ) , 
new LongOpt ( "get-level" , LongOpt . NO_ARGUMENT , null , 'g' ) , 
new LongOpt ( "cid" , LongOpt . REQUIRED_ARGUMENT , null , GetLevelOperation . cid ) , 
new LongOpt ( "nsrc" , LongOpt . REQUIRED_ARGUMENT , null , GetLevelOperation . nsrc ) , 
new LongOpt ( "name" , LongOpt . REQUIRED_ARGUMENT , null , GetLevelOperation . name ) , } ; 
case 'a' : 
super . operation = new GetTracersUsedOperation ( super . context , super . log , this ) ; 
super . operation = new GetTracersSetOperation ( super . context , super . log , this ) ; 
case 's' : 
super . operation = new SetLevelOperation ( super . context , super . log , this ) ; 
super . operation = new UnsetLevelOperation ( super . context , super . log , this ) ; 
case 'g' : 
super . operation = new GetLevelOperation ( super . context , super . log , this ) ; 
} public ActivityContextInterface getActivityContextInterface ( 
ProfileTableActivity profileTableActivity ) 
UnrecognizedActivityException , FactoryException { 
if ( profileTableActivity == null 
|| profileTableActivity . getProfileTableName ( ) == null ) { 
serviceContainer . getTransactionManager ( ) . mandateTransaction ( ) ; 
ProfileTableImpl profileTableImpl = null ; 
profileTableImpl = profileManagementImpl . getProfileTable ( profileTableActivity . getProfileTableName ( ) ) ; 
throw new UnrecognizedActivityException ( profileTableActivity . getProfileTableName ( ) , e ) ; 
ActivityContext ac = profileTableImpl . getActivityContext ( ) ; 
if ( ac == null ) { 
return ac . getActivityContextInterface ( ) ; 
} private static MBeanNotificationInfo [ ] initNotificationInfo ( ) { 
String [ ] notificationTypes = new String [ ] { 
ProfileTableNotification . USAGE_NOTIFICATION_TYPE , 
ResourceAdaptorEntityNotification . USAGE_NOTIFICATION_TYPE , 
SbbNotification . USAGE_NOTIFICATION_TYPE , 
SubsystemNotification . USAGE_NOTIFICATION_TYPE 
return new MBeanNotificationInfo [ ] { new MBeanNotificationInfo ( 
notificationTypes , UsageNotification . class . getName ( ) , 
} public void sendUsageNotification ( long value , long seqno , 
String usageParameterSetName , String usageParameterName , 
boolean isCounter ) { 
UsageNotificationManagerMBeanImpl notificationManager = parent 
. getUsageNotificationManagerMBean ( notificationSource ) ; 
if ( notificationManager == null 
|| notificationManager 
. getNotificationsEnabled ( usageParameterName ) ) { 
UsageNotification notification = createUsageNotification ( value , 
seqno , usageParameterSetName , usageParameterName , isCounter ) ; 
for ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { 
if ( triplet . notificationFilter == null 
|| triplet . notificationFilter 
. isNotificationEnabled ( notification ) ) { 
triplet . notificationListener . handleNotification ( 
notification , triplet . handbackObject ) ; 
} protected UsageNotification createUsageNotification ( long value , long seqno , 
return new UsageNotification ( notificationSource 
. getUsageNotificationType ( ) , this , notificationSource , 
usageParameterSetName , usageParameterName , isCounter , value , 
seqno , System . currentTimeMillis ( ) ) ; 
} public javax . slee . resource . ResourceAdaptorTypeDescriptor getSpecsDescriptor ( ) { 
if ( specsDescriptor == null ) { 
final LibraryID [ ] libraryIDs = descriptor . getLibraryRefs ( ) . toArray ( new LibraryID [ descriptor . getLibraryRefs ( ) . size ( ) ] ) ; 
final String [ ] activityTypes = descriptor . getActivityTypes ( ) . toArray ( new String [ descriptor . getActivityTypes ( ) . size ( ) ] ) ; 
final EventTypeID [ ] eventTypes = descriptor . getEventTypeRefs ( ) . toArray ( new EventTypeID [ descriptor . getEventTypeRefs ( ) . size ( ) ] ) ; 
String raInterface = descriptor . getResourceAdaptorInterface ( ) == null ? null : descriptor . getResourceAdaptorInterface ( ) ; 
specsDescriptor = new javax . slee . resource . ResourceAdaptorTypeDescriptor ( getResourceAdaptorTypeID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , libraryIDs , activityTypes , raInterface , eventTypes ) ; 
return specsDescriptor ; 
String sopts = ":lcrng" ; 
new LongOpt ( "table" , LongOpt . OPTIONAL_ARGUMENT , null , ListOperation . table ) , 
new LongOpt ( "profile" , LongOpt . REQUIRED_ARGUMENT , null , ListOperation . profile ) , 
new LongOpt ( "create" , LongOpt . NO_ARGUMENT , null , 'c' ) , 
new LongOpt ( "profile-name" , LongOpt . REQUIRED_ARGUMENT , null , CreateOperation . profile_name ) , 
new LongOpt ( "table-name" , LongOpt . REQUIRED_ARGUMENT , null , CreateOperation . table_name ) , 
new LongOpt ( "profile-spec" , LongOpt . REQUIRED_ARGUMENT , null , CreateOperation . profile_spec ) , 
new LongOpt ( "remove" , LongOpt . NO_ARGUMENT , null , 'r' ) , 
new LongOpt ( "rename" , LongOpt . NO_ARGUMENT , null , 'n' ) , 
new LongOpt ( "current-name" , LongOpt . REQUIRED_ARGUMENT , null , RenameOperation . current_name ) , 
new LongOpt ( "new-name" , LongOpt . REQUIRED_ARGUMENT , null , RenameOperation . new_name ) , 
new LongOpt ( "get" , LongOpt . NO_ARGUMENT , null , 'g' ) , 
new LongOpt ( "profile-spec" , LongOpt . REQUIRED_ARGUMENT , null , GetOperation . profile_spec ) , 
case 'c' : 
super . operation = new CreateOperation ( super . context , super . log , this ) ; 
super . operation = new RemoveOperation ( super . context , super . log , this ) ; 
super . operation = new RenameOperation ( super . context , super . log , this ) ; 
super . operation = new GetOperation ( super . context , super . log , this ) ; 
} public void persistentInstall ( URL deployableUnitURL ) throws DeploymentException { 
doPersistentInstall ( deployableUnitURL , deployDir ) ; 
throw new DeploymentException ( e ) ; 
} public void persistentUninstall ( URL deployableUnitURL ) throws DeploymentException { 
String fullPath = deployableUnitURL . getFile ( ) ; 
String filename = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 ) ; 
String filePath = deployDir + File . separator + filename ; 
if ( ! new File ( filePath ) . delete ( ) ) { 
} public void clusterInstall ( URL deployableUnitURL ) throws DeploymentException { 
doPersistentInstall ( deployableUnitURL , farmDeployDir ) ; 
} public void clusterUninstall ( URL deployableUnitURL ) throws DeploymentException { 
String filePath = farmDeployDir + File . separator + filename ; 
} private File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { 
OutputStream out = null ; 
String filename = new File ( duURL . getPath ( ) ) . getName ( ) ; 
File tempFile = new File ( deploymentRoot , filename ) ; 
out = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; 
URLConnection conn = duURL . openConnection ( ) ; 
in = conn . getInputStream ( ) ; 
int numRead ; 
while ( ( numRead = in . read ( buffer ) ) != - 1 ) { 
out . write ( buffer , 0 , numRead ) ; 
return tempFile ; 
in . close ( ) ; 
in = null ; 
} public void updateDeployedComponents ( ) { 
ComponentRepository componentRepository = sleeContainerDeployer . getSleeContainer ( ) . getComponentRepository ( ) ; 
ConcurrentLinkedQueue < String > newDeployedComponents = new ConcurrentLinkedQueue < String > ( ) ; 
for ( ComponentID componentID : componentRepository . getProfileSpecificationIDs ( ) ) { 
newDeployedComponents . add ( componentID . toString ( ) ) ; 
for ( ComponentID componentID : componentRepository . getEventComponentIDs ( ) ) { 
for ( ComponentID componentID : componentRepository . getResourceAdaptorTypeIDs ( ) ) { 
for ( ComponentID componentID : componentRepository . getResourceAdaptorIDs ( ) ) { 
for ( ComponentID componentID : componentRepository . getSbbIDs ( ) ) { 
for ( ComponentID componentID : componentRepository . getServiceIDs ( ) ) { 
for ( ComponentID componentID : componentRepository . getLibraryIDs ( ) ) { 
ResourceManagement resourceManagement = sleeContainerDeployer . getSleeContainer ( ) . getResourceManagement ( ) ; 
String [ ] entityNames = resourceManagement . getResourceAdaptorEntities ( ) ; 
for ( String entityName : entityNames ) { 
newDeployedComponents . addAll ( Arrays . asList ( resourceManagement . getLinkNames ( entityName ) ) ) ; 
deployedComponents = newDeployedComponents ; 
} public void installDeployableUnit ( DeployableUnit du ) throws Exception { 
updateDeployedComponents ( ) ; 
if ( du . isReadyToInstall ( true ) ) { 
sciAction ( du . getInstallActions ( ) , du ) ; 
du . setInstalled ( true ) ; 
deployedDUs . add ( du ) ; 
Iterator < DeployableUnit > duIt = waitingForInstallDUs . iterator ( ) ; 
while ( duIt . hasNext ( ) ) { 
DeployableUnit waitingDU = duIt . next ( ) ; 
if ( waitingDU . isReadyToInstall ( false ) ) { 
sciAction ( waitingDU . getInstallActions ( ) , waitingDU ) ; 
waitingDU . setInstalled ( true ) ; 
deployedDUs . add ( waitingDU ) ; 
waitingForInstallDUs . remove ( waitingDU ) ; 
duIt = waitingForInstallDUs . iterator ( ) ; 
waitingForInstallDUs . add ( du ) ; 
} public void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { 
if ( ! du . isInstalled ( ) ) { 
if ( waitingForInstallDUs . remove ( du ) ) { 
else if ( ! du . areComponentsStillPresent ( ) ) { 
processInternalUndeploy ( du ) ; 
else if ( du . isReadyToUninstall ( ) ) { 
sciAction ( du . getUninstallActions ( ) , du ) ; 
if ( ! waitingForUninstallDUs . contains ( du ) ) { 
waitingForUninstallDUs . add ( du ) ; 
} private void processInternalUndeploy ( DeployableUnit du ) throws Exception { 
du . setInstalled ( false ) ; 
waitingForUninstallDUs . remove ( du ) ; 
Iterator < DeployableUnit > duIt = waitingForUninstallDUs . iterator ( ) ; 
if ( waitingDU . isReadyToUninstall ( ) ) { 
sleeContainerDeployer . getSleeSubDeployer ( ) . stop ( waitingDU . getURL ( ) , waitingDU . getDeploymentInfoShortName ( ) ) ; 
waitingForUninstallDUs . remove ( waitingDU ) ; 
duIt = waitingForUninstallDUs . iterator ( ) ; 
} private void sciAction ( Collection < ManagementAction > actions , DeployableUnit du ) 
for ( ManagementAction action : actions ) { 
if ( actionsToAvoidByDU . get ( du ) != null && actionsToAvoidByDU . get ( du ) . remove ( action ) ) { 
if ( actionsToAvoidByDU . get ( du ) . size ( ) == 0 ) { 
actionsToAvoidByDU . remove ( du ) ; 
action . invoke ( ) ; 
if ( e . getCause ( ) instanceof ResourceAdaptorEntityAlreadyExistsException || ( e . getCause ( ) instanceof InvalidStateException 
&& action instanceof ActivateResourceAdaptorEntityAction ) ) { 
Class < ? extends ManagementAction > actionToAvoid = null ; 
if ( action instanceof ActivateResourceAdaptorEntityAction ) { 
actionToAvoid = DeactivateResourceAdaptorEntityAction . class ; 
else if ( action instanceof CreateResourceAdaptorEntityAction ) { 
actionToAvoid = RemoveResourceAdaptorEntityAction . class ; 
Collection < Class < ? extends ManagementAction > > actionsToAvoid ; 
if ( ( actionsToAvoid = actionsToAvoidByDU . get ( du ) ) == null ) { 
actionsToAvoid = new ArrayList < Class < ? extends ManagementAction > > ( ) ; 
actionsToAvoid . add ( actionToAvoid ) ; 
actionsToAvoidByDU . put ( du , actionsToAvoid ) ; 
logger . warn ( e . getCause ( ) . getMessage ( ) ) ; 
else if ( e . getCause ( ) instanceof InvalidStateException && action instanceof DeactivateServiceAction ) { 
else if ( e . getCause ( ) instanceof InvalidStateException && action instanceof DeactivateResourceAdaptorEntityAction ) { 
else if ( e . getCause ( ) instanceof UnrecognizedLinkNameException && action instanceof UnbindLinkNameAction ) { 
else if ( action . getType ( ) == ManagementAction . Type . DEPLOY_MANAGEMENT ) { 
Thread . sleep ( waitTimeBetweenOperations ) ; 
} public String showStatus ( ) { 
String output = "" ; 
for ( DeployableUnit waitingDU : waitingForInstallDUs ) { 
for ( String dependency : waitingDU . getExternalDependencies ( ) ) { 
if ( ! deployedComponents . contains ( dependency ) ) 
for ( DeployableUnit waitingDU : waitingForUninstallDUs ) { 
} public void sleeShutdown ( ) { 
while ( ! deployedDUs . isEmpty ( ) ) { 
DeployableUnit du = deployedDUs . removeLast ( ) ; 
uninstallDeployableUnit ( du ) ; 
} public boolean isLoggable ( LogRecord record ) 
Logger logger = getLogger ( record ) ; 
if ( record . getThrown ( ) != null ) 
logWithThrowable ( logger , record ) ; 
logWithoutThrowable ( logger , record ) ; 
} private Logger getLogger ( LogRecord record ) 
String loggerName = record . getLoggerName ( ) ; 
Logger logger = loggerCache . get ( loggerName ) ; 
if ( logger == null ) 
logger = Logger . getLogger ( loggerName ) ; 
loggerCache . put ( loggerName , logger ) ; 
return logger ; 
} public Set < SleeComponent > getReferringComponents ( SleeComponent component ) { 
Set < SleeComponent > result = new HashSet < SleeComponent > ( ) ; 
for ( EventTypeComponent otherComponent : eventTypeComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( 
component . getComponentID ( ) ) ) { 
if ( otherComponent . getDependenciesSet ( ) . contains ( 
result . add ( otherComponent ) ; 
for ( LibraryComponent otherComponent : libraryComponents . values ( ) ) { 
for ( ProfileSpecificationComponent otherComponent : profileSpecificationComponents 
for ( ResourceAdaptorComponent otherComponent : resourceAdaptorComponents 
for ( ResourceAdaptorTypeComponent otherComponent : resourceAdaptorTypeComponents 
for ( SbbComponent otherComponent : sbbComponents . values ( ) ) { 
for ( ServiceComponent otherComponent : serviceComponents . values ( ) ) { 
public void displayHelp ( ) { 
out . println ( desc ) ; 
addHeaderDescription ( out ) ; 
out . println ( "operation:" ) ; 
out . println ( "" ) ; 
addExamples ( out ) ; 
String sopts = "-:lgrcdn" ; 
new LongOpt ( "noprefix" , LongOpt . NO_ARGUMENT , null , 0x1000 ) , 
new LongOpt ( "sets" , LongOpt . NO_ARGUMENT , null , ListOperation . sets ) , 
new LongOpt ( "parameters" , LongOpt . NO_ARGUMENT , null , ListOperation . parameters ) , 
new LongOpt ( "name" , LongOpt . REQUIRED_ARGUMENT , null , GetOperation . name ) , 
new LongOpt ( "rst" , LongOpt . NO_ARGUMENT , null , GetOperation . rst ) , 
new LongOpt ( "reset" , LongOpt . NO_ARGUMENT , null , 'r' ) , 
new LongOpt ( "all" , LongOpt . NO_ARGUMENT , null , ResetOperation . all ) , 
new LongOpt ( "delete" , LongOpt . NO_ARGUMENT , null , 'd' ) , 
new LongOpt ( "notify" , LongOpt . NO_ARGUMENT , null , 'n' ) , 
new LongOpt ( "value" , LongOpt . REQUIRED_ARGUMENT , null , NotifyOperation . value ) , 
new LongOpt ( "is-notify" , LongOpt . NO_ARGUMENT , null , NotifyOperation . is ) , 
int nonOptArgIndex = 0 ; 
case 0x1000 : 
switch ( nonOptArgIndex ) { 
resourceName = getopt . getOptarg ( ) ; 
if ( resourceName . startsWith ( PREFIX_SERVICEID ) ) 
editor . setAsText ( resourceName ) ; 
} catch ( Exception e ) 
this . serviceID = ( ServiceID ) editor . getValue ( ) ; 
this . resourceName = null ; 
nonOptArgIndex ++ ; 
if ( this . serviceID != null ) 
this . editor . setAsText ( getopt . getOptarg ( ) ) ; 
this . sbbID = ( SbbID ) this . editor . getValue ( ) ; 
usageSetName = getopt . getOptarg ( ) ; 
if ( this . serviceID == null ) 
prepareCommand ( ) ; 
super . operation = new ResetOperation ( super . context , super . log , this ) ; 
super . operation = new DeleteOperation ( super . context , super . log , this ) ; 
super . operation = new NotifyOperation ( super . context , super . log , this ) ; 
} public static TimerPreserveMissed fromInt ( int option ) throws IllegalArgumentException { 
switch ( option ) { 
case PRESERVE_NONE : return NONE ; 
case PRESERVE_ALL : return ALL ; 
case PRESERVE_LAST : return LAST ; 
} public static TimerPreserveMissed fromString ( String option ) throws NullPointerException , IllegalArgumentException { 
if ( option . equalsIgnoreCase ( NONE_STRING ) ) return NONE ; 
if ( option . equalsIgnoreCase ( ALL_STRING ) ) return ALL ; 
if ( option . equalsIgnoreCase ( LAST_STRING ) ) return LAST ; 
} public Set < SbbEntityID > getSbbEntities ( ) { 
HashSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; 
ServiceID serviceID = null ; 
for ( Object obj : node . getChildrenNames ( ) ) { 
serviceID = ( ServiceID ) obj ; 
for ( SbbEntityID sbbEntityID : getRootSbbEntityIDs ( serviceID ) ) { 
result . add ( sbbEntityID ) ; 
collectSbbEntities ( sbbEntityID , result ) ; 
} public ActivityContextInterface [ ] getActivities ( ) 
throws TransactionRequiredLocalException , IllegalStateException , 
SLEEException { 
if ( SbbObjectState . READY != this . sbbObject . getState ( ) ) { 
+ this . sbbObject . getState ( ) ) ; 
ActivityContextFactory acf = sleeContainer . getActivityContextFactory ( ) ; 
List < ActivityContextInterface > result = new ArrayList < ActivityContextInterface > ( ) ; 
ActivityContext ac = null ; 
for ( ActivityContextHandle ach : sbbObject . getSbbEntity ( ) 
. getActivityContexts ( ) ) { 
ac = acf . getActivityContext ( ach ) ; 
if ( ac != null ) { 
result . add ( ac . getActivityContextInterface ( ) ) ; 
return result . toArray ( EMPTY_ACI_ARRAY ) ; 
} public boolean getRollbackOnly ( ) throws TransactionRequiredLocalException , 
txMgr . mandateTransaction ( ) ; 
return txMgr . getRollbackOnly ( ) ; 
} public SbbLocalObject getSbbLocalObject ( ) 
if ( this . sbbObject . getState ( ) != SbbObjectState . READY ) 
return sbbObject . getSbbEntity ( ) . getSbbLocalObject ( ) ; 
} public void maskEvent ( String [ ] eventNames , ActivityContextInterface aci ) 
IllegalStateException , UnrecognizedEventException , 
NotAttachedException , SLEEException { 
if ( this . sbbObject . getSbbEntity ( ) == null ) { 
ActivityContextHandle ach = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) 
. getActivityContext ( ) . getActivityContextHandle ( ) ; 
if ( ! sbbObject . getSbbEntity ( ) . isAttached ( ach ) ) 
sbbObject . getSbbEntity ( ) . setEventMask ( ach , eventNames ) ; 
} public void setRollbackOnly ( ) throws TransactionRequiredLocalException , 
sleeTransactionManager . setRollbackOnly ( ) ; 
} public Object getActivityContextInterfaceFactory ( 
ResourceAdaptorTypeID raTypeID ) throws NullPointerException , 
IllegalArgumentException { 
if ( raTypeID == null ) { 
if ( ! sbbObject . getSbbComponent ( ) . getDependenciesSet ( ) . contains ( raTypeID ) ) { 
return sleeContainer . getComponentRepository ( ) . getComponentByID ( raTypeID ) . getActivityContextInterfaceFactory ( ) ; 
} public Object getResourceAdaptorInterface ( ResourceAdaptorTypeID raTypeID , 
String raLink ) throws NullPointerException , 
if ( raLink == null ) { 
final ResourceManagement resourceManagement = sleeContainer . getResourceManagement ( ) ; 
String raEntityName = null ; 
raEntityName = resourceManagement . getResourceAdaptorEntityName ( raLink ) ; 
} catch ( UnrecognizedLinkNameException e ) { 
return resourceManagement . getResourceAdaptorEntity ( raEntityName ) . getResourceAdaptorInterface ( raTypeID ) ; 
} public List < EventTypeDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException { 
List < EventTypeDescriptorImpl > result = new ArrayList < EventTypeDescriptorImpl > ( ) ; 
MEventJar mEventJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . event . EventJar ) { 
mEventJar = new MEventJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . event . EventJar ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . event . EventJar ) { 
mEventJar = new MEventJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . event . EventJar ) jaxbPojo ) ; 
List < LibraryID > libraryRefs = mEventJar . getLibraryRef ( ) ; 
for ( MEventDefinition mEventDefinition : mEventJar . getEventDefinition ( ) ) { 
result . add ( new EventTypeDescriptorImpl ( mEventDefinition , libraryRefs , isSlee11 ) ) ; 
} private Permissions getPermissions ( Permissions permissions , final CodeSource cs , Principal [ ] principals ) { 
List < PolicyHolderEntry > entries = this . currentPolicy . get ( ) . policyHolderEntries ; 
for ( PolicyHolderEntry phe : entries ) { 
selectPermissions ( permissions , cs , principals , phe ) ; 
return permissions ; 
} private boolean loadPolicy ( String policyURLString , GlobalPolicyHolder newGlobalPolicyHolder ) { 
URI policyURI = null ; 
if ( policyURLString . startsWith ( _PROTOCOL_FILE ) ) { 
File policyFile = new File ( policyURLString . replaceFirst ( _PROTOCOL_FILE_PREFIX , "" ) ) ; 
if ( ! policyFile . exists ( ) || ! policyFile . isFile ( ) || ! policyFile . canRead ( ) ) { 
policyURI = policyFile . toURI ( ) . normalize ( ) ; 
policyURI = new URI ( policyURLString ) ; 
PolicyParser pp = new PolicyParser ( true ) ; 
InputStream is = getStream ( policyURI ) ; 
InputStreamReader reader = new InputStreamReader ( is ) ; 
pp . read ( reader ) ; 
KeyStore ks = null ; 
Enumeration < PolicyParser . GrantEntry > grantEntries = pp . grantElements ( ) ; 
while ( grantEntries . hasMoreElements ( ) ) { 
parseGrantEntry ( grantEntries . nextElement ( ) , ks , newGlobalPolicyHolder ) ; 
} private InputStream getStream ( URI uri ) throws IOException { 
if ( uri . toURL ( ) . getProtocol ( ) . equals ( _PROTOCOL_FILE ) ) { 
String path = uri . toURL ( ) . getFile ( ) . replace ( '\\' , File . separatorChar ) ; 
return new FileInputStream ( path ) ; 
return uri . toURL ( ) . openStream ( ) ; 
} catch ( java . lang . IllegalArgumentException e ) { 
return new FileInputStream ( new File ( uri ) ) ; 
} CodeSource performUrlConversion ( CodeSource cs , boolean extractSignerCerts ) { 
CodeSource parsedCodeSource = null ; 
URL locationURL = cs . getLocation ( ) ; 
if ( locationURL != null ) { 
Permission urlAccessPermission = null ; 
urlAccessPermission = locationURL . openConnection ( ) . getPermission ( ) ; 
if ( urlAccessPermission != null && urlAccessPermission instanceof FilePermission ) { 
path = ( ( FilePermission ) urlAccessPermission ) . getName ( ) ; 
} else if ( ( urlAccessPermission == null ) && ( locationURL . getProtocol ( ) . equals ( "file" ) ) ) { 
path = locationURL . getFile ( ) . replace ( "/" , File . separator ) ; 
if ( extractSignerCerts ) { 
parsedCodeSource = new CodeSource ( cs . getLocation ( ) , getSignerCertificates ( cs ) ) ; 
if ( path . endsWith ( "*" ) ) { 
boolean removeTrailingFileSep = false ; 
if ( path . endsWith ( File . separator ) ) 
removeTrailingFileSep = true ; 
if ( path . equals ( "" ) ) { 
path = System . getProperty ( "user.dir" ) ; 
File f = new File ( path ) ; 
path = f . getCanonicalPath ( ) ; 
StringBuffer sb = new StringBuffer ( path ) ; 
if ( ! path . endsWith ( File . separator ) && removeTrailingFileSep ) 
sb . append ( File . separator ) ; 
sb . append ( '*' ) ; 
path = sb . toString ( ) ; 
} else if ( path . endsWith ( File . separator ) ) { 
if ( path . endsWith ( "!" ) ) { 
path = new File ( path ) . getCanonicalPath ( ) ; 
locationURL = fileToEncodedURL ( new File ( path ) ) ; 
parsedCodeSource = new CodeSource ( locationURL , getSignerCertificates ( cs ) ) ; 
parsedCodeSource = new CodeSource ( locationURL , cs . getCertificates ( ) ) ; 
return parsedCodeSource ; 
} public String getCodeSources ( ) { 
List < String > css = new ArrayList < String > ( ) ; 
for ( PolicyHolderEntry phe : this . currentPolicy . get ( ) . policyHolderEntries ) { 
css . add ( phe . getCodeSource ( ) . getLocation ( ) == null ? "default" : phe . getCodeSource ( ) . getLocation ( ) . toString ( ) ) ; 
return Arrays . toString ( css . toArray ( ) ) ; 
public void dataRemoved ( FqnWrapper fqnWrapper ) { 
final Fqn fqn = fqnWrapper . getFqn ( ) ; 
ra . dataRemoved ( ( K ) fqn . getLastElement ( ) ) ; 
} public Object makeObject ( ) { 
SbbObject retval ; 
if ( doTraceLogs ) { 
final ClassLoader oldClassLoader = SleeContainerUtils 
. getCurrentThreadClassLoader ( ) ; 
final ClassLoader cl = sbbComponent . getClassLoader ( ) ; 
if ( System . getSecurityManager ( ) != null ) 
AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { 
public Object run ( ) { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
retval = new SbbObjectImpl ( serviceID , sbbComponent ) ; 
oldClassLoader ) ; 
retval . setState ( SbbObjectState . POOLED ) ; 
} public ProfileLocalObject create ( String profileName ) 
TransactionRequiredLocalException , ReadOnlyProfileException , 
ProfileAlreadyExistsException , CreateException , SLEEException { 
checkProfileSpecIsNotReadOnly ( ) ; 
ProfileObjectImpl profileObject = createProfile ( profileName ) ; 
profileObject . profilePersist ( ) ; 
return profileObject . getProfileLocalObject ( ) ; 
} public ProfileLocalObject find ( String profileName ) 
if ( profileName == null ) { 
ProfileObjectImpl profileObject = getProfile ( profileName ) ; 
return profileObject == null ? null : profileObject . getProfileLocalObject ( ) ; 
} public Collection < ProfileLocalObject > findAll ( ) throws TransactionRequiredLocalException , 
Collection < ProfileLocalObject > result = new ArrayList < ProfileLocalObject > ( ) ; 
for ( ProfileEntity profileEntity : component . getProfileEntityFramework ( ) . findAll ( this . getProfileTableName ( ) ) ) { 
result . add ( transactionView . getProfile ( profileEntity ) . getProfileLocalObject ( ) ) ; 
return Collections . unmodifiableCollection ( result ) ; 
} public boolean remove ( String profileName ) throws NullPointerException , 
ReadOnlyProfileException , TransactionRequiredLocalException , 
return this . removeProfile ( profileName , true , false ) ; 
} public ProfileLocalObject findProfileByAttribute ( String attributeName , 
Object attributeValue ) throws NullPointerException , 
IllegalArgumentException , TransactionRequiredLocalException , 
Collection < ProfileLocalObject > plocs = findProfilesByAttribute ( attributeName , attributeValue ) ; 
if ( plocs . size ( ) == 0 ) { 
return plocs . iterator ( ) . next ( ) ; 
} public Collection < ProfileLocalObject > findProfilesByAttribute ( String attributeName , 
Collection < ProfileEntity > profileEntities = null ; 
profileEntities = getProfileEntitiesByAttribute ( attributeName , attributeValue , true ) ; 
catch ( AttributeNotIndexedException e ) { 
ArrayList < ProfileLocalObject > plocs = new ArrayList < ProfileLocalObject > ( ) ; 
for ( ProfileEntity profileEntity : profileEntities ) { 
plocs . add ( transactionView . getProfile ( profileEntity ) . getProfileLocalObject ( ) ) ; 
return Collections . unmodifiableCollection ( plocs ) ; 
} public Collection < ProfileID > getProfilesByAttribute ( 
String attributeName , Object attributeValue , boolean isSlee11 ) 
throws UnrecognizedAttributeException , 
AttributeNotIndexedException , AttributeTypeMismatchException , 
Collection < ProfileEntity > profileEntities = getProfileEntitiesByAttribute ( attributeName , attributeValue , isSlee11 ) ; 
Collection < ProfileID > profileIDs = new ArrayList < ProfileID > ( ) ; 
profileIDs . add ( new ProfileID ( profileEntity . getTableName ( ) , profileEntity . getProfileName ( ) ) ) ; 
return Collections . unmodifiableCollection ( profileIDs ) ; 
} private Collection < ProfileEntity > getProfileEntitiesByAttribute ( 
ProfileAttribute profileAttribute = getProfileAttribute ( attributeName , attributeValue ) ; 
if ( isSlee11 ) { 
if ( ! ProfileTableImpl . PROFILE_ATTR_ALLOWED_TYPES . contains ( attributeValue . getClass ( ) . getName ( ) ) ) { 
if ( ! profileAttribute . isIndex ( ) ) { 
return component . getProfileEntityFramework ( ) . findProfilesByAttribute ( this . getProfileTableName ( ) , profileAttribute , attributeValue ) ; 
} private ProfileAttribute getProfileAttribute ( String attributeName , 
Object attributeValue ) throws NullPointerException , UnrecognizedAttributeException , 
AttributeTypeMismatchException { 
if ( attributeName == null ) { 
if ( attributeValue == null ) { 
ProfileAttribute profileAttribute = component . getProfileAttributes ( ) . get ( attributeName ) ; 
if ( profileAttribute == null ) { 
Class < ? > allowedProfileAttributeType = profileAttribute . getNonPrimitiveType ( ) . isArray ( ) ? profileAttribute . getNonPrimitiveType ( ) . getComponentType ( ) : profileAttribute . getNonPrimitiveType ( ) ; 
if ( ! allowedProfileAttributeType . getName ( ) . equals ( attributeValue . getClass ( ) . getName ( ) ) ) { 
return profileAttribute ; 
} public boolean profileExists ( String profileName ) { 
boolean result = component . getProfileEntityFramework ( ) . findProfile ( this . getProfileTableName ( ) , profileName ) != null ; 
} public void rename ( String newProfileTableName ) { 
Collection < ProfileID > profileIDs = this . getProfiles ( ) ; 
component . getProfileEntityFramework ( ) . renameProfileTable ( this . profileTableName , newProfileTableName ) ; 
for ( ProfileID pid : profileIDs ) 
AbstractProfileMBeanImpl . close ( pid . getProfileTableName ( ) , pid . getProfileName ( ) ) ; 
if ( logger . isEnabledFor ( Level . WARN ) ) 
} public void remove ( boolean isUninstall ) throws SLEEException { 
+ profileTableName ) ; 
for ( ProfileID profileID : getProfiles ( ) ) { 
this . removeProfile ( profileID . getProfileName ( ) , false , isUninstall ) ; 
if ( getDefaultProfileEntity ( ) != null ) { 
this . removeProfile ( null , false , false ) ; 
TransactionalAction commitAction = new TransactionalAction ( ) { 
final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; 
traceMBeanImpl . deregisterNotificationSource ( new ProfileTableNotification ( profileTableName ) ) ; 
closeUncommittedProfileMBeans ( ) ; 
sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( commitAction ) ; 
if ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { 
endActivity ( ) ; 
unregisterUsageMBean ( ) ; 
profileManagement . getObjectPoolManagement ( ) . removeObjectPool ( this , sleeContainer . getTransactionManager ( ) ) ; 
} public javax . slee . management . SbbDescriptor getSpecsDescriptor ( ) { 
Set < SbbID > sbbIDSet = new HashSet < SbbID > ( ) ; 
for ( SbbRefDescriptor mSbbRef : descriptor . getSbbRefs ( ) ) { 
sbbIDSet . add ( mSbbRef . getComponentID ( ) ) ; 
SbbID [ ] sbbIDs = sbbIDSet . toArray ( new SbbID [ sbbIDSet . size ( ) ] ) ; 
Set < ProfileSpecificationID > profileSpecSet = new HashSet < ProfileSpecificationID > ( ) ; 
for ( ProfileSpecRefDescriptor mProfileSpecRef : descriptor . getProfileSpecRefs ( ) ) { 
profileSpecSet . add ( mProfileSpecRef . getComponentID ( ) ) ; 
ProfileSpecificationID [ ] profileSpecs = profileSpecSet . toArray ( new ProfileSpecificationID [ profileSpecSet . size ( ) ] ) ; 
Set < EventTypeID > eventTypeSet = new HashSet < EventTypeID > ( ) ; 
for ( EventEntryDescriptor mEventEntry : descriptor . getEventEntries ( ) . values ( ) ) { 
eventTypeSet . add ( mEventEntry . getEventReference ( ) ) ; 
EventTypeID [ ] eventTypes = eventTypeSet . toArray ( new EventTypeID [ eventTypeSet . size ( ) ] ) ; 
Set < ResourceAdaptorTypeID > raTypeIDSet = new HashSet < ResourceAdaptorTypeID > ( ) ; 
Set < String > raLinksSet = new HashSet < String > ( ) ; 
for ( ResourceAdaptorTypeBindingDescriptor mResourceAdaptorTypeBinding : descriptor . getResourceAdaptorTypeBindings ( ) ) { 
raTypeIDSet . add ( mResourceAdaptorTypeBinding . getResourceAdaptorTypeRef ( ) ) ; 
for ( ResourceAdaptorEntityBindingDescriptor mResourceAdaptorEntityBinding : mResourceAdaptorTypeBinding . getResourceAdaptorEntityBinding ( ) ) { 
raLinksSet . add ( mResourceAdaptorEntityBinding . getResourceAdaptorEntityLink ( ) ) ; 
ResourceAdaptorTypeID [ ] raTypeIDs = raTypeIDSet . toArray ( new ResourceAdaptorTypeID [ raTypeIDSet . size ( ) ] ) ; 
String [ ] raLinks = raLinksSet . toArray ( new String [ raLinksSet . size ( ) ] ) ; 
specsDescriptor = new javax . slee . management . SbbDescriptor ( getSbbID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , libraryIDs , sbbIDs , eventTypes , profileSpecs , 
descriptor . getAddressProfileSpecRef ( ) , raTypeIDs , raLinks ) ; 
} public Object getActivity ( ) throws TransactionRequiredLocalException , 
return activityContext . getActivityContextHandle ( ) . getActivityObject ( ) ; 
} public void attach ( SbbLocalObject sbbLocalObject ) 
TransactionRolledbackLocalException , SLEEException { 
if ( sbbLocalObject == null ) 
org . mobicents . slee . container . sbb . SbbLocalObject sbbLocalObjectImpl = ( org . mobicents . slee . container . sbb . SbbLocalObject ) sbbLocalObject ; 
SbbEntity sbbEntity = sbbLocalObjectImpl . getSbbEntity ( ) ; 
boolean attached = getActivityContext ( ) . attachSbbEntity ( sbbEntity . getSbbEntityId ( ) ) ; 
boolean setRollbackAndThrowException = false ; 
if ( attached ) { 
if ( sbbEntity . isRemoved ( ) ) { 
setRollbackAndThrowException = true ; 
sbbEntity . afterACAttach ( getActivityContext ( ) . getActivityContextHandle ( ) ) ; 
if ( setRollbackAndThrowException ) { 
final EventRoutingTask routingTask = activityContext . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) ; 
EventContext eventContextImpl = routingTask != null ? routingTask . getEventContext ( ) : null ; 
if ( eventContextImpl != null && eventContextImpl . getSbbEntitiesThatHandledEvent ( ) . remove ( sbbEntity . getSbbEntityId ( ) ) ) { 
+ sbbEntity . getSbbEntityId ( ) 
+ getActivityContext ( ) . getActivityContextHandle ( ) 
} public void detach ( SbbLocalObject sbbLocalObject ) 
final ActivityContext ac = getActivityContext ( ) ; 
ac . detachSbbEntity ( sbbEntity . getSbbEntityId ( ) ) ; 
sbbEntity . afterACDetach ( getActivityContext ( ) . getActivityContextHandle ( ) ) ; 
} public boolean isAttached ( SbbLocalObject sbbLocalObject ) throws NullPointerException , 
TransactionRequiredLocalException , 
if ( sbbLocalObject == null ) { 
if ( sbbLocalObject instanceof org . mobicents . slee . container . sbb . SbbLocalObject ) { 
if ( sbbEntity != null && ! sbbEntity . isRemoved ( ) ) { 
return sbbEntity . isAttached ( activityContext . getActivityContextHandle ( ) ) ; 
} public void addDeployableUnit ( final DeployableUnit deployableUnit ) { 
if ( deployableUnit == null ) 
+ deployableUnit . getDeployableUnitID ( ) ) ; 
deployableUnits . put ( deployableUnit . getDeployableUnitID ( ) , 
( DeployableUnitImpl ) deployableUnit ) ; 
} public DeployableUnitID [ ] getDeployableUnits ( ) { 
Set < DeployableUnitID > deployableUnitIDs = deployableUnits . keySet ( ) ; 
return deployableUnitIDs . toArray ( new DeployableUnitID [ deployableUnitIDs 
. size ( ) ] ) ; 
} public void removeDeployableUnit ( DeployableUnitID deployableUnitID ) { 
deployableUnits . remove ( deployableUnitID ) ; 
} public void updateConfigurationProperties ( ConfigProperties properties ) 
throws InvalidConfigurationException , InvalidStateException { 
if ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) 
&& ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) 
&& ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) { 
throw new InvalidStateException ( 
object . raConfigurationUpdate ( properties ) ; 
public void sleeRunning ( ) throws InvalidStateException { 
if ( this . state . isActive ( ) ) { 
if ( setFTContext ) { 
setFTContext = false ; 
if ( object . isFaultTolerant ( ) ) { 
this . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; 
object . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; 
object . raActive ( ) ; 
} public void sleeStopping ( ) throws InvalidStateException , TransactionRequiredLocalException { 
if ( state != null && state . isActive ( ) ) { 
object . raStopping ( ) ; 
scheduleAllActivitiesEnd ( ) ; 
public void activate ( ) throws InvalidStateException { 
if ( ! this . state . isInactive ( ) ) { 
+ this . state ) ; 
this . state = ResourceAdaptorEntityState . ACTIVE ; 
} public void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { 
if ( ! this . state . isActive ( ) ) { 
this . state = ResourceAdaptorEntityState . STOPPING ; 
if ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) { 
TimerTask t = new TimerTask ( ) { 
cancel ( ) ; 
if ( state == ResourceAdaptorEntityState . STOPPING ) { 
if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { 
allActivitiesEnded ( ) ; 
resourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; 
} private void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { 
boolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; 
if ( ! skipActivityEnding && hasActivities ( ) ) { 
timerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; 
} private boolean hasActivities ( ) { 
for ( ActivityContextHandle handle : sleeContainer 
. getActivityContextFactory ( ) 
. getAllActivityContextsHandles ( ) ) { 
if ( handle . getActivityType ( ) == ActivityType . RA ) { 
ResourceAdaptorActivityContextHandle raHandle = ( ResourceAdaptorActivityContextHandle ) handle ; 
if ( raHandle . getResourceAdaptorEntity ( ) . equals ( this ) ) { 
. getAllActivityContextsHandles ( ) ) ; 
sleeContainer . getActivityContextFactory ( ) . WAremove ( "RA" ) ; 
} public void remove ( ) throws InvalidStateException { 
object . raUnconfigure ( ) ; 
object . unsetFaultTolerantResourceAdaptorContext ( ) ; 
ftResourceAdaptorContext . shutdown ( ) ; 
object . unsetResourceAdaptorContext ( ) ; 
this . sleeContainer . getTraceManagement ( ) 
. deregisterNotificationSource ( this . getNotificationSource ( ) ) ; 
state = null ; 
} public Object getResourceAdaptorInterface ( ResourceAdaptorTypeID raType ) { 
return object . getResourceAdaptorInterface ( sleeContainer 
. getComponentRepository ( ) . getComponentByID ( raType ) 
. getDescriptor ( ) . getResourceAdaptorInterface ( ) ) ; 
} public void serviceActive ( ServiceID serviceID ) { 
ReceivableService receivableService = resourceAdaptorContext 
. getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; 
if ( receivableService . getReceivableEvents ( ) . length > 0 ) { 
object . serviceActive ( receivableService ) ; 
} ActivityHandle derreferActivityHandle ( ActivityHandle handle ) { 
ActivityHandle ah = null ; 
if ( resourceManagement . getHandleReferenceFactory ( ) != null && handle . getClass ( ) == ActivityHandleReference . class ) { 
ActivityHandleReference ahReference = ( ActivityHandleReference ) handle ; 
ah = resourceManagement . getHandleReferenceFactory ( ) . getActivityHandle ( ahReference ) ; 
ah = handle ; 
return ah ; 
} public void activityEnded ( final ActivityHandle handle , int activityFlags ) { 
if ( handle instanceof ActivityHandleReference ) { 
ah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; 
if ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) { 
object . activityEnded ( ah ) ; 
if ( ! hasActivities ( ) ) { 
if ( timerTask != null ) { 
timerTask . cancel ( ) ; 
InvalidLinkNameBindingStateException , ManagementException { 
serviceManagement . activate ( serviceID ) ; 
catch ( NullPointerException e ) { 
catch ( UnrecognizedServiceException e ) { 
catch ( InvalidLinkNameBindingStateException e ) { 
catch ( InvalidStateException e ) { 
InvalidStateException , InvalidLinkNameBindingStateException , 
serviceManagement . activate ( serviceIDs ) ; 
catch ( InvalidArgumentException e ) { 
} public void setResourceAdaptorContext ( ResourceAdaptorContext context ) 
throws InvalidStateException { 
if ( state == null ) { 
state = ResourceAdaptorObjectState . UNCONFIGURED ; 
object . setResourceAdaptorContext ( context ) ; 
public void setFaultTolerantResourceAdaptorContext ( 
FaultTolerantResourceAdaptorContext < Serializable , Serializable > context ) 
if ( isFaultTolerant ( ) ) { 
( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) 
. setFaultTolerantResourceAdaptorContext ( context ) ; 
} public void raConfigure ( ConfigProperties properties ) 
throws InvalidConfigurationException { 
verifyConfigProperties ( properties ) ; 
object . raConfigure ( configProperties ) ; 
if ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { 
state = ResourceAdaptorObjectState . INACTIVE ; 
} public void raConfigurationUpdate ( ConfigProperties properties ) 
object . raConfigurationUpdate ( configProperties ) ; 
} private void verifyConfigProperties ( ConfigProperties newProperties ) 
for ( ConfigProperties . Property configProperty : configProperties 
. getProperties ( ) ) { 
if ( newProperties . getProperty ( configProperty . getName ( ) ) == null ) { 
newProperties . addProperty ( configProperty ) ; 
for ( ConfigProperties . Property entityProperty : newProperties 
if ( entityProperty . getValue ( ) == null ) { 
object . raVerifyConfiguration ( newProperties ) ; 
configProperties = newProperties ; 
} public void raActive ( ) throws InvalidStateException { 
logger . trace ( "raActive()" ) ; 
if ( state == ResourceAdaptorObjectState . INACTIVE ) { 
state = ResourceAdaptorObjectState . ACTIVE ; 
} public void raStopping ( ) throws InvalidStateException { 
logger . trace ( "raStopping()" ) ; 
if ( state == ResourceAdaptorObjectState . ACTIVE ) { 
state = ResourceAdaptorObjectState . STOPPING ; 
} public void raInactive ( ) throws InvalidStateException { 
logger . trace ( "raInactive()" ) ; 
if ( state == ResourceAdaptorObjectState . STOPPING ) { 
object . raInactive ( ) ; 
} public void raUnconfigure ( ) throws InvalidStateException { 
logger . trace ( "raUnconfigure()" ) ; 
} public void unsetResourceAdaptorContext ( ) throws InvalidStateException { 
logger . trace ( "unsetResourceAdaptorContext()" ) ; 
public void unsetFaultTolerantResourceAdaptorContext ( ) 
logger . trace ( "unsetFaultTolerantResourceAdaptorContext()" ) ; 
. unsetFaultTolerantResourceAdaptorContext ( ) ; 
} private void buildProfileAttributeMap ( ) throws DeploymentException { 
HashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; 
Class < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; 
String attributeGetterMethodPrefix = "get" ; 
for ( Method method : cmpInterface . getMethods ( ) ) { 
if ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { 
String attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; 
switch ( attributeName . length ( ) ) { 
attributeName = attributeName . toLowerCase ( ) ; 
attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; 
ProfileAttributeImpl profileAttribute = null ; 
profileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; 
if ( isSlee11 ( ) ) { 
for ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { 
if ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) { 
profileAttribute . setUnique ( cmpField . isUnique ( ) ) ; 
for ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { 
if ( profileIndex . getName ( ) . equals ( attributeName ) ) { 
profileAttribute . setIndex ( true ) ; 
profileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; 
map . put ( attributeName , profileAttribute ) ; 
profileAttributeMap = Collections . unmodifiableMap ( map ) ; 
} public javax . slee . profile . ProfileSpecificationDescriptor getSpecsDescriptor ( ) { 
final ProfileSpecificationID [ ] profileSpecs = new ProfileSpecificationID [ descriptor . getProfileSpecRefs ( ) . size ( ) ] ; 
for ( int i = 0 ; i < profileSpecs . length ; i ++ ) { 
profileSpecs [ i ] = descriptor . getProfileSpecRefs ( ) . get ( i ) . getComponentID ( ) ; 
specsDescriptor = new javax . slee . profile . ProfileSpecificationDescriptor ( getProfileSpecificationID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , libraryIDs , profileSpecs , 
getDescriptor ( ) . getProfileCMPInterface ( ) . getProfileCmpInterfaceName ( ) ) ; 
} private void resume ( ) { 
Runnable runnable = new Runnable ( ) { 
if ( scheduledFuture == null ) { 
scheduledFuture . cancel ( false ) ; 
scheduledFuture = null ; 
for ( EventContext ec : barriedEvents ) { 
ec . getLocalActivityContext ( ) . getExecutorService ( ) . routeEvent ( ec ) ; 
barriedEvents = null ; 
event . getLocalActivityContext ( ) . getEventQueueManager ( ) . removeBarrier ( transaction ) ; 
suspended = false ; 
event . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) . run ( ) ; 
event . getLocalActivityContext ( ) . getExecutorService ( ) . execute ( runnable ) ; 
public void wonOwnership ( ClusteredCacheData clusteredCacheData ) { 
ra . failOver ( ( K ) clusteredCacheData . getNodeFqn ( ) . getLastElement ( ) ) ; 
public Set < ActivityContextHandle > getActivityContextHandles ( ) { 
public TimerTask newTimerTask ( TimerTaskData data ) { 
FaultTolerantTimerTaskDataWrapper dataWrapper = ( FaultTolerantTimerTaskDataWrapper ) data ; 
FaultTolerantTimerTask task = taskFactory . getTask ( dataWrapper 
. getWrappedData ( ) ) ; 
return new FaultTolerantTimerTaskWrapper ( task , dataWrapper ) ; 
if ( obj instanceof ProfileTableNotification ) { 
ProfileTableNotification that = ( ProfileTableNotification ) obj ; 
return this . profileTableName . compareTo ( that . profileTableName ) ; 
return super . compareTo ( TYPE , obj ) ; 
logger . trace ( "makeObject()" ) ; 
ProfileObjectImpl profileObject = new ProfileObjectImpl ( profileTable ) ; 
profileObject . setProfileContext ( new ProfileContextImpl ( profileTable ) ) ; 
return profileObject ; 
} public List < LibraryDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException { 
List < LibraryDescriptorImpl > result = new ArrayList < LibraryDescriptorImpl > ( ) ; 
boolean isSlee11 = true ; 
MLibraryJar mLibraryJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . library . LibraryJar ) 
mLibraryJar = new MLibraryJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . library . LibraryJar ) jaxbPojo ) ; 
MSecurityPermissions securityPermissions = mLibraryJar . getSecurityPermissions ( ) ; 
for ( MLibrary mLibrary : mLibraryJar . getLibrary ( ) ) 
result . add ( new LibraryDescriptorImpl ( mLibrary , securityPermissions , isSlee11 ) ) ; 
} public ProfileTableUsageMBean newProfileTableUsageMBean ( 
String profileTableName , ProfileSpecificationComponent component ) 
throws NotCompliantMBeanException , MalformedObjectNameException , 
NullPointerException { 
return new ProfileTableUsageMBeanImpl ( profileTableName , component , 
sleeContainer ) ; 
} public ResourceUsageMBean newResourceUsageMBean ( String entityName , 
ResourceAdaptorComponent component ) 
return new ResourceUsageMBeanImpl ( entityName , component , sleeContainer ) ; 
} public ServiceUsageMBean newServiceUsageMBean ( ServiceComponent component ) 
return new ServiceUsageMBeanImpl ( component , sleeContainer ) ; 
} public void remove ( ) { 
Logger logger = getLogger ( ) ; 
final MBeanServer mbeanServer = sleeContainer . getMBeanServer ( ) ; 
mbeanServer . unregisterMBean ( getObjectName ( ) ) ; 
+ toString ( ) ) ; 
for ( String name : usageMBeans . keySet ( ) ) { 
_removeUsageParameterSet ( name , false ) ; 
removeUsageParameterSet ( ) ; 
} public void createUsageParameterSet ( String paramSetName ) 
if ( paramSetName == null ) 
if ( paramSetName . length ( ) == 0 ) 
if ( ! isValidUsageParameterName ( paramSetName ) ) 
_createUsageParameterSet ( paramSetName ) ; 
} public ObjectName getUsageMBean ( String paramSetName ) 
throws NullPointerException , 
return _getUsageMBean ( paramSetName ) ; 
} public void removeUsageParameterSet ( String paramSetName ) 
_removeUsageParameterSet ( paramSetName , true ) ; 
} public AbstractUsageParameterSet getInstalledUsageParameterSet ( String name ) { 
return getDefaultInstalledUsageParameterSet ( ) ; 
UsageMBeanImpl usageMBean = usageMBeans . get ( name ) ; 
if ( usageMBean == null ) { 
return usageMBean . getUsageParameter ( ) ; 
} public List < ResourceAdaptorDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException 
List < ResourceAdaptorDescriptorImpl > result = new ArrayList < ResourceAdaptorDescriptorImpl > ( ) ; 
MResourceAdaptorJar mResourceAdaptorJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . ra . ResourceAdaptorJar ) 
mResourceAdaptorJar = new MResourceAdaptorJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . ra . ResourceAdaptorJar ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . ra . ResourceAdaptorJar ) 
mResourceAdaptorJar = new MResourceAdaptorJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . ra . ResourceAdaptorJar ) jaxbPojo ) ; 
MSecurityPermissions securityPermissions = mResourceAdaptorJar . getSecurityPermissions ( ) ; 
for ( MResourceAdaptor mResourceAdaptor : mResourceAdaptorJar . getResourceAdaptor ( ) ) 
result . add ( new ResourceAdaptorDescriptorImpl ( mResourceAdaptor , securityPermissions , isSlee11 ) ) ; 
} public boolean decorateAbstractClass ( ) throws DeploymentException { 
ClassPool pool = component . getClassPool ( ) ; 
ProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; 
if ( abstractClass == null ) { 
String abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; 
ctClass = pool . get ( abstractClassName ) ; 
+ abstractClassName , nfe ) ; 
decorateClassJNDIAddToEnvironmentCalls ( ) ; 
if ( isAbstractClassDecorated ) { 
String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
ctClass . detach ( ) ; 
+ ctClass . getName ( ) 
+ deployDir ) ; 
} public boolean create ( ) { 
ConcurrentHashMap < String , UsageParamSetLocalData > notificationSourceUsageParamSets = notificationSourceUsageParamSetsMap . get ( notificationSource ) ; 
if ( notificationSourceUsageParamSets == null ) { 
ConcurrentHashMap < String , UsageParamSetLocalData > newNotificationSourceUsageParamSets = new ConcurrentHashMap < String , UsageParamSetLocalData > ( ) ; 
notificationSourceUsageParamSets = notificationSourceUsageParamSetsMap . putIfAbsent ( notificationSource , newNotificationSourceUsageParamSets ) ; 
notificationSourceUsageParamSets = newNotificationSourceUsageParamSets ; 
if ( ! notificationSourceUsageParamSets . containsKey ( usageParameterSetName ) ) { 
return notificationSourceUsageParamSets . putIfAbsent ( usageParameterSetName , new UsageParamSetLocalData ( usageParameterSetName ) ) == null ; 
} public UsageParameter getParameter ( String parameterName ) { 
Map < String , UsageParamSetLocalData > notificationSourceUsageParamSets = notificationSourceUsageParamSetsMap . get ( notificationSource ) ; 
if ( notificationSourceUsageParamSets != null ) { 
UsageParamSetLocalData data = notificationSourceUsageParamSets . get ( usageParameterSetName ) ; 
return data . getUsageParam ( parameterName ) ; 
} public Collection < String > getParameterNames ( ) { 
return data . getParameterNames ( ) ; 
} public boolean remove ( ) { 
final Map < String , UsageParamSetLocalData > notificationSourceUsageParamSets = notificationSourceUsageParamSetsMap . get ( notificationSource ) ; 
return notificationSourceUsageParamSets . remove ( usageParameterSetName ) != null ; 
} public void setParameter ( String parameterName , UsageParameter usageParameter ) { 
data . setUsageParam ( parameterName , usageParameter ) ; 
} public static ChildRelation getChildRelation ( SbbEntity sbbEntity , 
String childRelationMethodName ) { 
if ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) 
+ childRelationMethodName ) ; 
return sbbEntity . getChildRelation ( childRelationMethodName ) ; 
} public static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , 
Object eventObject , ActivityContextInterface aci , Address address ) { 
fireEvent ( sbbEntity , eventTypeID , eventObject , aci , address , null ) ; 
Object eventObject , ActivityContextInterface aci , Address address , 
ServiceID serviceID ) { 
if ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) { 
if ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null 
|| sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) 
if ( eventObject == null ) 
final SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; 
txManager . mandateTransaction ( ) ; 
ActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) 
. getActivityContext ( ) ; 
+ ac ) ; 
if ( ac . isEnding ( ) ) { 
final EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; 
if ( transactionData != null ) { 
final EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; 
if ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { 
ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; 
ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; 
} public static Object getProfileCMPMethod ( SbbEntity sbbEntity , 
String getProfileCMPMethodName , ProfileID profileID ) 
throws UnrecognizedProfileTableNameException , 
UnrecognizedProfileNameException { 
GetProfileCMPMethodDescriptor mGetProfileCMPMethod = sbbEntity . getSbbComponent ( ) 
. getDescriptor ( ) . getGetProfileCMPMethods ( ) . get ( 
getProfileCMPMethodName ) ; 
if ( mGetProfileCMPMethod == null ) 
if ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) { 
ProfileManagement sleeProfileManager = sleeContainer 
. getSleeProfileTableManager ( ) ; 
ProfileTable profileTable = sleeProfileManager . getProfileTable ( profileID . getProfileTableName ( ) ) ; 
if ( ! profileTable . profileExists ( profileID . getProfileName ( ) ) ) { 
throw new UnrecognizedProfileNameException ( profileID . toString ( ) ) ; 
return profileTable . getProfile ( profileID . getProfileName ( ) ) . getProfileCmpSlee10Wrapper ( ) ; 
} public static Object getSbbUsageParameterSet ( SbbEntity sbbEntity , String name ) 
return getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) 
. getInstalledUsageParameterSet ( sbbEntity . getSbbId ( ) , name ) ; 
} public NullActivityImpl createNullActivity ( 
NullActivityHandle nullActivityHandle , boolean mandateTransaction ) 
if ( sleeContainer . getSleeState ( ) != SleeState . RUNNING ) { 
if ( mandateTransaction ) { 
NullActivityImpl nullActivity = new NullActivityImpl ( nullActivityHandle ) ; 
sleeContainer . getActivityContextFactory ( ) . createActivityContext ( 
new NullActivityContextHandle ( nullActivityHandle ) , 
ActivityFlags . REQUEST_ACTIVITY_UNREFERENCED_CALLBACK ) ; 
} catch ( ActivityAlreadyExistsException e ) { 
throw new FactoryException ( e . getMessage ( ) , e ) ; 
+ nullActivity ) ; 
return nullActivity ; 
} public void afterCompletion ( int status ) { 
TransactionContextThreadLocal . setTransactionContext ( null ) ; 
switch ( status ) { 
case Status . STATUS_COMMITTED : 
txContext . executeAfterCommitPriorityActions ( ) ; 
txContext . executeAfterCommitActions ( ) ; 
case Status . STATUS_ROLLEDBACK : 
txContext . executeAfterRollbackActions ( ) ; 
+ status ) ; 
txContext . cleanup ( ) ; 
} private String computeConvergenceName ( EventContext eventContext , 
ServiceComponent serviceComponent , SleeContainer sleeContainer ) throws Exception { 
final SbbComponent sbbComponent = serviceComponent . getRootSbbComponent ( ) ; 
final EventEntryDescriptor eventEntryDescriptor = sbbComponent . getDescriptor ( ) . getEventEntries ( ) . get ( eventContext . getEventTypeId ( ) ) ; 
StringBuilder buff = null ; 
if ( eventEntryDescriptor . getInitialEventSelectorMethod ( ) != null ) { 
InitialEventSelectorImpl selector = new InitialEventSelectorImpl ( eventContext , eventEntryDescriptor ) ; 
SbbObjectPool pool = sleeContainer . getSbbManagement ( ) . getObjectPool ( serviceComponent . getServiceID ( ) , 
SbbObject sbbObject = pool . borrowObject ( ) ; 
Object [ ] args = new Object [ ] { selector } ; 
ClassLoader oldCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
final JndiManagement jndiManagement = sleeContainer . getJndiManagement ( ) ; 
final Method m = sbbComponent . getInitialEventSelectorMethods ( ) . get ( eventEntryDescriptor . getInitialEventSelectorMethod ( ) ) ; 
selector = ( InitialEventSelectorImpl ) m . invoke ( sbbObject . getSbbConcrete ( ) , 
args ) ; 
if ( selector == null ) { 
if ( ! selector . isInitialEvent ( ) ) { 
Thread . currentThread ( ) . setContextClassLoader ( oldCl ) ; 
pool . returnObject ( sbbObject ) ; 
if ( selector . isActivityContextSelected ( ) ) { 
buff = new StringBuilder ( eventContext . getLocalActivityContext ( ) . getStringId ( ) ) ; 
buff = new StringBuilder ( NOT_SELECTED_STRING ) ; 
if ( selector . isAddressSelected ( ) && selector . getAddress ( ) != null ) { 
buff . append ( selector . getAddress ( ) . toString ( ) ) ; 
buff . append ( NOT_SELECTED ) ; 
if ( selector . isEventTypeSelected ( ) ) { 
buff . append ( eventContext . getEventTypeId ( ) ) ; 
if ( selector . isEventSelected ( ) ) { 
buff . append ( eventContext . getEventContextHandle ( ) . getId ( ) ) ; 
if ( selector . isAddressProfileSelected ( ) && selector . getAddress ( ) != null ) { 
final Collection < ProfileID > profileIDs = getAddressProfilesMatching ( selector . getAddress ( ) , serviceComponent , sbbComponent , sleeContainer ) ; 
if ( profileIDs . isEmpty ( ) ) 
buff . append ( profileIDs . iterator ( ) . next ( ) ) ; 
if ( selector . getCustomName ( ) != null ) { 
buff . append ( selector . getCustomName ( ) ) ; 
final InitialEventSelectorVariables initialEventSelectorVariables = eventEntryDescriptor . getInitialEventSelectVariables ( ) ; 
if ( initialEventSelectorVariables . isActivityContextSelected ( ) ) { 
if ( initialEventSelectorVariables . isActivityContextOnlySelected ( ) ) { 
return new StringBuilder ( eventContext . getLocalActivityContext ( ) . getStringId ( ) ) . append ( ALL_NOT_SELECTED_EXCEPT_AC ) . toString ( ) ; 
if ( initialEventSelectorVariables . isAddressSelected ( ) && eventContext . getAddress ( ) != null ) { 
buff . append ( eventContext . getAddress ( ) . toString ( ) ) ; 
if ( initialEventSelectorVariables . isEventTypeSelected ( ) ) { 
if ( initialEventSelectorVariables . isEventSelected ( ) ) { 
if ( initialEventSelectorVariables . isAddressProfileSelected ( ) && eventContext . getAddress ( ) != null ) { 
final Collection < ProfileID > profileIDs = getAddressProfilesMatching ( eventContext . getAddress ( ) , serviceComponent , sbbComponent , sleeContainer ) ; 
} public static Set getCMPFields ( CtClass clazz ) { 
Set properties = new HashSet ( ) ; 
Set methods = getPublicAbstractMethods ( clazz ) ; 
Iterator iter = methods . iterator ( ) ; 
HashMap getters = new HashMap ( ) ; 
HashMap setters = new HashMap ( ) ; 
CtMethod method = ( CtMethod ) iter . next ( ) ; 
String mname = method . getName ( ) ; 
if ( Modifier . isStatic ( method . getModifiers ( ) ) ) continue ; 
String property = "" ; 
if ( method . getExceptionTypes ( ) . length > 0 ) continue ; 
if ( mname . startsWith ( GET_PREFIX ) ) { 
property = mname . substring ( GET_PREFIX . length ( ) ) ; 
getters . put ( property , method ) ; 
} else if ( mname . startsWith ( IS_PREFIX ) && method . getReturnType ( ) . equals ( CtClass . booleanType ) ) { 
property = mname . substring ( IS_PREFIX . length ( ) ) ; 
} else if ( mname . startsWith ( SET_PREFIX ) ) { 
property = mname . substring ( SET_PREFIX . length ( ) ) ; 
setters . put ( property , method ) ; 
logger . warn ( e ) ; 
if ( property . length ( ) == 0 || ! Character . isUpperCase ( property . charAt ( 0 ) ) || property . equals ( PUBLIC_IDENTIFIER ) ) { 
getters . remove ( property ) ; 
setters . remove ( property ) ; 
iter = getters . entrySet ( ) . iterator ( ) ; 
Map . Entry entry = ( Map . Entry ) iter . next ( ) ; 
String property = ( String ) entry . getKey ( ) ; 
CtMethod getter = ( CtMethod ) entry . getValue ( ) ; 
CtMethod setter = ( CtMethod ) setters . get ( property ) ; 
if ( setter != null ) { 
CtClass [ ] sparams = setter . getParameterTypes ( ) ; 
if ( sparams . length == 1 && sparams [ 0 ] . equals ( getter . getReturnType ( ) ) ) { 
return properties ; 
} public static String getObjectFromPrimitiveType ( String argumentType , 
String argument ) { 
if ( argumentType . equals ( "int" ) ) 
if ( argumentType . equals ( "boolean" ) ) 
if ( argumentType . equals ( "byte" ) ) 
if ( argumentType . equals ( "char" ) ) 
if ( argumentType . equals ( "double" ) ) 
if ( argumentType . equals ( "float" ) ) 
if ( argumentType . equals ( "long" ) ) 
if ( argumentType . equals ( "short" ) ) 
} public static String getClassFromPrimitiveType ( String argumentType ) { 
return "java.lang.Integer" ; 
return "java.lang.Boolean" ; 
return "java.lang.Byte" ; 
return "java.lang.Character" ; 
return "java.lang.Double" ; 
return "java.lang.Float" ; 
return "java.lang.Long" ; 
return "java.lang.Short" ; 
} public static String getPrimitiveTypeFromObject ( String argumentType , 
return "((Integer)" + argument + ").intValue()" ; 
return "((Boolean)" + argument + ").booleanValue()" ; 
return "((Byte)" + argument + ").byteValue()" ; 
return "((Character)" + argument + ").charValue()" ; 
return "((Double)" + argument + ").doubleValue()" ; 
return "((Float)" + argument + ").floatValue()" ; 
return "((Long)" + argument + ").longValue()" ; 
return "((Short)" + argument + ").shortValue()" ; 
} public static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { 
HashMap abstractMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; i < methods . length ; i ++ ) { 
if ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { 
abstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; 
return abstractMethods ; 
} public static Map getConcreteMethodsFromClass ( CtClass sbbClass ) { 
HashMap concreteMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbClass . getDeclaredMethods ( ) ; 
int mods = methods [ i ] . getModifiers ( ) ; 
if ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { 
concreteMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
return concreteMethods ; 
} public static Set getConcreteMethodsNamesFromClass ( CtClass sbbClass ) { 
Set concreteMethods = new HashSet ( ) ; 
concreteMethods . add ( methods [ i ] . getName ( ) ) ; 
} public static Map getSuperClassesAbstractMethodsFromInterface ( CtClass sbbAbstractClass ) { 
CtMethod [ ] methods = null ; 
ArrayList < CtClass > superClasses = new ArrayList < CtClass > ( ) ; 
superClasses . add ( sbbAbstractClass ) ; 
ArrayList < CtClass > superClassesProcessed = new ArrayList < CtClass > ( ) ; 
while ( ! superClasses . isEmpty ( ) ) { 
CtClass ctClass = superClasses . remove ( 0 ) ; 
superClassesProcessed . add ( ctClass ) ; 
methods = ctClass . getDeclaredMethods ( ) ; 
for ( CtMethod ctMethod : methods ) { 
abstractMethods . put ( getMethodKey ( ctMethod ) , ctMethod ) ; 
for ( CtClass anotherCtClass : ctClass . getInterfaces ( ) ) { 
if ( ! superClassesProcessed . contains ( anotherCtClass ) ) { 
superClasses . add ( anotherCtClass ) ; 
logger . error ( e ) ; 
} public static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , 
Map exceptMethods ) { 
HashMap interfaceMethods = new HashMap ( ) ; 
CtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; i < methods . length ; i ++ ) 
if ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) 
ConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; 
interfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
Map temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; 
for ( Iterator i = temp . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) 
String key = ( String ) i . next ( ) ; 
if ( ! exceptMethods . containsKey ( key ) ) { 
interfaceMethods . put ( key , temp . get ( key ) ) ; 
return interfaceMethods ; 
} public void createObjectPool ( final ProfileTableImpl profileTable , 
final SleeTransactionManager sleeTransactionManager ) { 
createObjectPool ( profileTable ) ; 
if ( sleeTransactionManager != null ) { 
removeObjectPool ( profileTable ) ; 
} public void removeObjectPool ( final ProfileTableImpl profileTable , 
sleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; 
action . execute ( ) ; 
} private void removeObjectPool ( final ProfileTableImpl profileTable ) { 
final ProfileObjectPool objectPool = pools . remove ( profileTable . getProfileTableName ( ) ) ; 
if ( objectPool != null ) { 
objectPool . close ( ) ; 
} public void register ( ) { 
MBeanServer mBeanServer = sleeContainer . getMBeanServer ( ) ; 
mBeanServer . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; 
} @ CacheEntryRemoved 
public void onNodeRemovedEvent ( CacheEntryRemovedEvent event ) { 
if ( ! event . isOriginLocal ( ) && ! event . isPre ( ) ) { 
Fqn fqn = ( ( NodeKey ) event . getKey ( ) ) . getFqn ( ) ; 
if ( fqn != null ) { 
if ( doInfoLogs ) { 
if ( fqn . get ( 0 ) . equals ( SbbEntityFactoryCacheData . SBB_ENTITY_FACTORY_FQN_NAME ) ) { 
int fqnSize = fqn . size ( ) ; 
if ( fqnSize < 3 ) { 
SbbEntityID sbbEntityID = null ; 
if ( fqnSize == 3 ) { 
ServiceID serviceID = ( ServiceID ) fqn . get ( 1 ) ; 
String convergenceName = ( String ) fqn . get ( 2 ) ; 
sbbEntityID = new RootSbbEntityID ( serviceID , convergenceName ) ; 
if ( ! fqn . get ( fqnSize - 3 ) . equals ( SbbEntityCacheData . CHILD_RELATIONs_CHILD_NODE_NAME ) ) { 
int i = 3 ; 
while ( fqnSize >= i + 3 ) { 
String childRelationName = ( String ) fqn . get ( i + 1 ) ; 
String childId = ( String ) fqn . get ( i + 2 ) ; 
sbbEntityID = new NonRootSbbEntityID ( sbbEntityID , childRelationName , childId ) ; 
i += 3 ; 
if ( locks . remove ( sbbEntityID ) != null ) { 
public void undeployed ( ) { 
super . undeployed ( ) ; 
usageNotificationManagerMBeanConcreteInterface = null ; 
usageNotificationManagerMBeanImplConcreteClass = null ; 
usageParametersConcreteClass = null ; 
usageParametersInterface = null ; 
usageParametersMBeanConcreteInterface = null ; 
usageParametersMBeanImplConcreteClass = null ; 
protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { 
for ( AttributeDefinition ad : SleeSubsystemDefinition . ATTRIBUTES ) { 
ad . validateAndSet ( operation , model ) ; 
public void performBoottime ( OperationContext context , ModelNode operation , ModelNode model , 
ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > newControllers ) 
throws OperationFailedException { 
context . addStep ( new AbstractDeploymentChainStep ( ) { 
public void execute ( DeploymentProcessorTarget processorTarget ) { 
processorTarget . addDeploymentProcessor ( SleeExtension . SUBSYSTEM_NAME , 
SleeDeploymentParseProcessor . PHASE , 
SleeDeploymentParseProcessor . PRIORITY , 
new SleeDeploymentParseProcessor ( ) ) ; 
SleeDeploymentInstallProcessor . PHASE , 
SleeDeploymentInstallProcessor . PRIORITY , 
new SleeDeploymentInstallProcessor ( ) ) ; 
} , OperationContext . Stage . RUNTIME ) ; 
ModelNode fullModel = Resource . Tools . readModel ( context . readResource ( PathAddress . EMPTY_ADDRESS ) ) ; 
final ModelNode cacheConfigModel = SleeSubsystemDefinition . CACHE_CONFIG . resolveModelAttribute ( context , model ) ; 
final String cacheConfig = cacheConfigModel . isDefined ( ) ? cacheConfigModel . asString ( ) : null ; 
final ServiceTarget target = context . getServiceTarget ( ) ; 
final SleeContainerService sleeContainerService = new SleeContainerService ( fullModel , cacheConfig ) ; 
String dbConfigMBean = getPropertyString ( fullModel , "ProfileManagement" , "dbConfigMBean" , "H2DBConfig" ) ; 
String datasourceServiceName = getPropertyString ( fullModel , dbConfigMBean , "datasourceServiceName" , "ExampleDS" ) ; 
final ServiceBuilder < ? > sleeContainerServiceBuilder = target 
. addService ( SleeServiceNames . SLEE_CONTAINER , sleeContainerService ) 
. addDependency ( PathManagerService . SERVICE_NAME , PathManager . class , sleeContainerService . getPathManagerInjector ( ) ) 
. addDependency ( MBeanServerService . SERVICE_NAME , MBeanServer . class , sleeContainerService . getMbeanServer ( ) ) 
. addDependency ( TransactionManagerService . SERVICE_NAME , TransactionManager . class , sleeContainerService . getTransactionManager ( ) ) 
. addDependency ( DataSourceReferenceFactoryService . SERVICE_NAME_BASE . append ( datasourceServiceName ) , 
ManagedReferenceFactory . class , sleeContainerService . getManagedReferenceFactory ( ) ) ; 
newControllers . add ( sleeContainerServiceBuilder . setInitialMode ( Mode . ACTIVE ) . install ( ) ) ; 
return service . equals ( usageNotification . getService ( ) ) 
&& sbb . equals ( usageNotification . getSbb ( ) ) 
&& paramName . equals ( usageNotification . getUsageParameterName ( ) ) 
&& ( usageNotification . getValue ( ) < lowValue || usageNotification . getValue ( ) > highValue ) ; 
return notificationSource . equals ( usageNotification . getNotificationSource ( ) ) 
} public static AddressPresentation fromInt ( int value ) throws IllegalArgumentException { 
switch ( value ) { 
case ADDRESS_PRESENTATION_UNDEFINED : return UNDEFINED ; 
case ADDRESS_PRESENTATION_ALLOWED : return ALLOWED ; 
case ADDRESS_PRESENTATION_RESTRICTED : return RESTRICTED ; 
case ADDRESS_PRESENTATION_ADDRESS_NOT_AVAILABLE : return ADDRESS_NOT_AVAILABLE ; 
} public static AddressPresentation fromString ( String value ) throws NullPointerException , IllegalArgumentException { 
if ( value . equalsIgnoreCase ( UNDEFINED_STRING ) ) return UNDEFINED ; 
if ( value . equalsIgnoreCase ( ALLOWED_STRING ) ) return ALLOWED ; 
if ( value . equalsIgnoreCase ( RESTRICTED_STRING ) ) return RESTRICTED ; 
if ( value . equalsIgnoreCase ( ADDRESS_NOT_AVAILABLE_STRING ) ) return ADDRESS_NOT_AVAILABLE ; 
} public boolean clearAlarm ( String alarmID ) throws NullPointerException , ManagementException { 
if ( alarmID == null ) { 
AlarmPlaceHolder aph = alarmIdToAlarm . remove ( alarmID ) ; 
placeHolderToNotificationSource . remove ( aph ) ; 
if ( aph == null ) { 
generateNotification ( aph , true ) ; 
} public int clearAlarms ( NotificationSource notificationSource ) throws NullPointerException , UnrecognizedNotificationSourceException , ManagementException { 
if ( notificationSource == null ) { 
mandateSource ( notificationSource ) ; 
for ( Map . Entry < AlarmPlaceHolder , NotificationSource > e : placeHolderToNotificationSource . entrySet ( ) ) { 
if ( e . getValue ( ) . equals ( notificationSource ) ) { 
if ( clearAlarm ( e . getKey ( ) . getAlarm ( ) . getAlarmID ( ) ) ) { 
} public String [ ] getAlarms ( ) throws ManagementException { 
Set < String > ids = new HashSet < String > ( ) ; 
ids . addAll ( alarmIdToAlarm . keySet ( ) ) ; 
return ids . toArray ( new String [ ids . size ( ) ] ) ; 
} public String [ ] getAlarms ( NotificationSource notificationSource ) throws NullPointerException , UnrecognizedNotificationSourceException , ManagementException { 
ids . add ( e . getKey ( ) . getAlarm ( ) . getAlarmID ( ) ) ; 
} public Alarm getDescriptor ( String alarmID ) throws NullPointerException , ManagementException { 
AlarmPlaceHolder aph = this . alarmIdToAlarm . get ( alarmID ) ; 
if ( aph == null ) 
return aph . getAlarm ( ) ; 
} public Alarm [ ] getDescriptors ( String [ ] alarmIDs ) throws NullPointerException , ManagementException { 
if ( alarmIDs == null ) { 
Set < Alarm > alarms = new HashSet < Alarm > ( ) ; 
for ( String id : alarmIDs ) { 
Alarm a = getDescriptor ( id ) ; 
alarms . add ( a ) ; 
return alarms . toArray ( new Alarm [ alarms . size ( ) ] ) ; 
} public boolean isSourceOwnerOfAlarm ( NotificationSourceWrapper notificationSource , String alarmID ) { 
return aph . getNotificationSource ( ) . getNotificationSource ( ) . equals ( notificationSource . getNotificationSource ( ) ) ; 
} public String raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { 
synchronized ( notificationSource ) { 
if ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) { 
Alarm a = null ; 
AlarmPlaceHolder localAPH = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID ) ; 
for ( Map . Entry < String , AlarmPlaceHolder > e : this . alarmIdToAlarm . entrySet ( ) ) { 
if ( e . getValue ( ) . equals ( localAPH ) ) { 
a = e . getValue ( ) . getAlarm ( ) ; 
return a . getAlarmID ( ) ; 
return this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; 
Alarm a = new Alarm ( UUID . randomUUID ( ) . toString ( ) , notificationSource . getNotificationSource ( ) , alarmType , instanceID , level , message , cause , System . currentTimeMillis ( ) ) ; 
AlarmPlaceHolder aph = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID , a ) ; 
this . alarmIdToAlarm . put ( a . getAlarmID ( ) , aph ) ; 
this . placeHolderToNotificationSource . put ( aph , aph . getNotificationSource ( ) . getNotificationSource ( ) ) ; 
generateNotification ( aph , false ) ; 
} public static Object getUsageParameterSet ( ProfileObjectImpl profileObject , 
String name ) throws UnrecognizedUsageParameterSetNameException { 
+ profileObject ) ; 
ProfileTableImpl profileTable = profileObject 
. getProfileTable ( ) ; 
Object result = profileTable . getProfileTableUsageMBean ( ) 
. getInstalledUsageParameterSet ( name ) ; 
throw new UnrecognizedUsageParameterSetNameException ( ) ; 
this . activityHandle = new NullActivityHandleImpl ( in . readUTF ( ) ) ; 
out . writeUTF ( ( ( NullActivityHandleImpl ) activityHandle ) . getId ( ) ) ; 
} public javax . slee . management . EventTypeDescriptor getSpecsDescriptor ( ) { 
specsDescriptor = new javax . slee . management . EventTypeDescriptor ( getEventTypeID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , descriptor . getLibraryRefs ( ) . toArray ( new LibraryID [ descriptor . getLibraryRefs ( ) . size ( ) ] ) , getDescriptor ( ) . getEventClassName ( ) ) ; 
} public void activatedServiceWhichDefineEventAsInitial ( ServiceComponent serviceComponent ) { 
SortedSet < ServiceComponent > activeServicesWhichDefineEventAsInitial = new TreeSet < ServiceComponent > ( new ActiveServicesWhichDefineEventAsInitialComparator ( ) ) ; 
ServiceID oldVersion = serviceComponent . getOldVersion ( ) ; 
if ( oldVersion == null ) { 
activeServicesWhichDefineEventAsInitial . addAll ( this . activeServicesWhichDefineEventAsInitial ) ; 
for ( ServiceComponent existentServiceComponent : this . activeServicesWhichDefineEventAsInitial ) { 
if ( ! existentServiceComponent . getServiceID ( ) . equals ( oldVersion ) ) { 
activeServicesWhichDefineEventAsInitial . add ( existentServiceComponent ) ; 
activeServicesWhichDefineEventAsInitial . add ( serviceComponent ) ; 
this . activeServicesWhichDefineEventAsInitial = activeServicesWhichDefineEventAsInitial ; 
} public void deactivatedServiceWhichDefineEventAsInitial ( ServiceComponent serviceComponent ) { 
if ( ! existentServiceComponent . equals ( serviceComponent ) ) { 
} public boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
URL url = du . getUrl ( ) ; 
String fullPath = url . getFile ( ) ; 
String fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , 
fullPath . length ( ) ) ; 
if ( toAccept . containsKey ( fileName ) ) { 
else if ( fileName . endsWith ( ".jar" ) ) { 
JarFile duJarFile = null ; 
if ( du . getEntry ( "META-INF/deployable-unit.xml" ) != null ) { 
if ( duJarFile != null ) { 
duJarFile . close ( ) ; 
} catch ( IOException ignore ) { 
duJarFile = null ; 
} public void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
URL url = deployableUnitURL ; 
String fullPath = du . getFullPath ( ) ; 
String fileName = du . getFileName ( ) ; 
DeployableUnitWrapper duWrapper = null ; 
if ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { 
DeployableComponent dc = new DeployableComponent ( du , url , 
fileName , sleeContainerDeployer ) ; 
DeployableUnit deployerDU = deployableUnits . get ( duWrapper 
. getFileName ( ) ) ; 
for ( DeployableComponent subDC : dc . getSubComponents ( ) ) { 
deployerDU . addComponent ( subDC ) ; 
duJarFile = new JarFile ( fullPath ) ; 
JarEntry duXmlEntry = duJarFile 
. getJarEntry ( "META-INF/deployable-unit.xml" ) ; 
if ( duXmlEntry != null ) { 
DeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; 
DeployableUnitDescriptorFactory dudf = sleeContainerDeployer 
. getSleeContainer ( ) . getComponentManagement ( ) 
. getDeployableUnitManagement ( ) 
. getDeployableUnitDescriptorFactory ( ) ; 
DeployableUnitDescriptor duDesc = dudf . parse ( duJarFile 
. getInputStream ( duXmlEntry ) ) ; 
while ( deployableUnits . containsKey ( fileName ) ) { 
Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; 
deployableUnits . put ( fileName , deployerDU ) ; 
for ( String componentJarName : duDesc . getJarEntries ( ) ) { 
int beginIndex ; 
if ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) 
beginIndex = componentJarName . lastIndexOf ( '\\' ) ; 
beginIndex ++ ; 
componentJarName = componentJarName . substring ( 
beginIndex , componentJarName . length ( ) ) ; 
toAccept . put ( componentJarName , du ) ; 
for ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { 
if ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) 
beginIndex = serviceXMLName . lastIndexOf ( '\\' ) ; 
serviceXMLName = serviceXMLName . substring ( 
beginIndex , serviceXMLName . length ( ) ) ; 
toAccept . put ( serviceXMLName , du ) ; 
} public void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
DeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; 
if ( realDU != null ) { 
while ( isInUndeployList ( du . getFileName ( ) ) ) { 
sleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; 
} public void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
DeployableUnit realDU = null ; 
if ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { 
if ( ! isInUndeployList ( fileName ) ) { 
addToUndeployList ( fileName ) ; 
sleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; 
deployableUnits . remove ( fileName ) ; 
removeFromUndeployList ( fileName ) ; 
} catch ( DependencyException e ) { 
if ( cause instanceof InvalidStateException ) { 
} else if ( e instanceof DeploymentException ) { 
throw new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; 
} public String showStatus ( ) throws DeploymentException { 
for ( String key : deployableUnits . keySet ( ) ) { 
+ "]<br>" ; 
for ( String duComponent : deployableUnits . get ( key ) . getComponents ( ) ) { 
for ( String key : toAccept . keySet ( ) ) { 
for ( String undeploy : undeploys ) { 
output += sleeContainerDeployer . getDeploymentManager ( ) . showStatus ( ) ; 
} private boolean addToUndeployList ( String du ) { 
boolean added = undeploys . add ( du ) ; 
+ added ) ; 
return added ; 
} public void mandateTransaction ( ) throws TransactionRequiredLocalException { 
final Transaction tx = getTransaction ( ) ; 
if ( tx == null ) 
throw new TransactionRequiredLocalException ( 
final int status = tx . getStatus ( ) ; 
if ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) { 
} public boolean requireTransaction ( ) { 
if ( tx == null ) { 
begin ( ) ; 
} catch ( NotSupportedException e ) { 
} public void requireTransactionEnd ( boolean terminateTx , boolean doRollback ) throws IllegalStateException , SecurityException , SystemException , RollbackException , HeuristicMixedException , HeuristicRollbackException { 
if ( terminateTx ) { 
if ( doRollback ) { 
setRollbackOnly ( ) ; 
} public void asyncCommit ( CommitListener commitListener ) throws IllegalStateException , 
final SleeTransaction sleeTransaction = getSleeTransaction ( ) ; 
if ( sleeTransaction == null ) { 
sleeTransaction . asyncCommit ( commitListener ) ; 
if ( commitListener != null ) { 
commitListener . systemException ( e ) ; 
sleeTransaction . asyncRollback ( rollbackListener ) ; 
if ( rollbackListener != null ) { 
rollbackListener . systemException ( e ) ; 
} public SleeTransaction beginSleeTransaction ( ) throws NotSupportedException , 
SystemException { 
transactionManager . begin ( ) ; 
return getAsSleeTransaction ( transactionManager . getTransaction ( ) , true ) ; 
} public SleeTransaction asSleeTransaction ( Transaction transaction ) 
if ( transaction == null ) { 
if ( transaction . getClass ( ) == SleeTransactionImpl . class ) { 
return ( SleeTransaction ) transaction ; 
if ( transaction instanceof TransactionImple ) { 
return new SleeTransactionImpl ( ( TransactionImple ) transaction , getTransactionContext ( ) , this ) ; 
transactionManager . commit ( ) ; 
} public void resume ( Transaction transaction ) throws InvalidTransactionException , 
final SleeTransactionImpl sleeTransactionImpl = ( SleeTransactionImpl ) transaction ; 
transactionManager . resume ( sleeTransactionImpl . getWrappedTransaction ( ) ) ; 
TransactionContextThreadLocal . setTransactionContext ( sleeTransactionImpl . getTransactionContext ( ) ) ; 
throw new InvalidTransactionException ( ) ; 
} public void rollback ( ) throws IllegalStateException , SecurityException , 
transactionManager . rollback ( ) ; 
} public void setRollbackOnly ( ) throws IllegalStateException , SystemException { 
transactionManager . setRollbackOnly ( ) ; 
} public Transaction suspend ( ) throws SystemException { 
final Transaction tx = getAsSleeTransaction ( transactionManager . suspend ( ) , false ) ; 
return tx ; 
} public TransactionContext getTransactionContext ( ) { 
TransactionContext txContext = TransactionContextThreadLocal . getTransactionContext ( ) ; 
if ( txContext == null ) { 
final Transaction tx = transactionManager . getTransaction ( ) ; 
if ( tx != null && tx . getStatus ( ) == Status . STATUS_ACTIVE ) { 
txContext = bindToTransaction ( tx ) ; 
return txContext ; 
} protected void executeAfterCommitActions ( ) { 
if ( afterCommitActions != null ) { 
executeActions ( afterCommitActions , trace ) ; 
afterCommitActions = null ; 
} protected void executeAfterCommitPriorityActions ( ) { 
if ( afterCommitPriorityActions != null ) { 
executeActions ( afterCommitPriorityActions , trace ) ; 
afterCommitPriorityActions = null ; 
} protected void executeAfterRollbackActions ( ) { 
if ( afterRollbackActions != null ) { 
executeActions ( afterRollbackActions , trace ) ; 
afterRollbackActions = null ; 
} protected void executeBeforeCommitActions ( ) { 
if ( beforeCommitActions != null ) { 
executeActions ( beforeCommitActions , trace ) ; 
beforeCommitActions = null ; 
} protected void executeBeforeCommitPriorityActions ( ) { 
if ( beforeCommitPriorityActions != null ) { 
executeActions ( beforeCommitPriorityActions , trace ) ; 
beforeCommitPriorityActions = null ; 
} public String [ ] getRequestedTracerNames ( ) { 
Set < String > names = new HashSet < String > ( ) ; 
for ( TracerImpl t : this . tracers . values ( ) ) { 
if ( t . isRequestedBySource ( ) ) 
names . add ( t . getTracerName ( ) ) ; 
if ( names . isEmpty ( ) ) 
return names . toArray ( new String [ names . size ( ) ] ) ; 
} public String [ ] getDefinedTracerNames ( ) { 
if ( t . isExplicitlySetTracerLevel ( ) ) 
} public Tracer createTracer ( String tracerName , boolean requestedBySource ) { 
TracerImpl tparent = null ; 
TracerImpl t = tracers . get ( tracerName ) ; 
String [ ] split = tracerName . split ( "\\." ) ; 
String currentName = "" ; 
for ( String s : split ) { 
if ( tparent == null ) { 
tparent = rootTracer ; 
currentName = s ; 
currentName = currentName + "." + s ; 
t = tracers . get ( currentName ) ; 
t = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; 
final TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; 
if ( u != null ) { 
t = u ; 
tparent = t ; 
if ( requestedBySource ) 
t . setRequestedBySource ( requestedBySource ) ; 
} public void bind ( ActivityContextInterface aci , String aciName ) 
TransactionRequiredLocalException , NameAlreadyBoundException , 
if ( aciName == null ) 
else if ( aciName . equals ( "" ) ) 
else if ( aci == null ) 
org . mobicents . slee . container . activity . ActivityContextInterface sleeAci = ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ; 
ActivityContext ac = sleeAci . getActivityContext ( ) ; 
ActivityContextHandle ach = ac . getActivityContextHandle ( ) ; 
cacheData . bindName ( ach , aciName ) ; 
ac . addNameBinding ( aciName ) ; 
} catch ( NameAlreadyBoundException ex ) { 
} public void unbind ( String aciName ) throws NullPointerException , 
TransactionRequiredLocalException , NameNotBoundException , 
ActivityContextHandle ach = ( ActivityContextHandle ) cacheData . unbindName ( aciName ) ; 
ActivityContext ac = sleeContainer . 
getActivityContextFactory ( ) . getActivityContext ( ach ) ; 
if ( ac != null ) 
ac . removeNameBinding ( aciName ) ; 
} catch ( NameNotBoundException ex ) { 
} public ActivityContextInterface lookup ( String acName ) 
if ( acName == null ) 
ActivityContextHandle ach = ( ActivityContextHandle ) cacheData . lookupName ( acName ) ; 
if ( ach == null ) { 
ActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; 
cacheData . unbindName ( acName ) ; 
} public void generateProfileMBeanInterface ( ) throws Exception { 
if ( SleeProfileClassCodeGenerator . checkCombination ( component ) == - 1 ) { 
String profileMBeanConcreteInterfaceName = cmpProfileInterfaceName + "MBean" ; 
profileMBeanConcreteInterface = pool . makeInterface ( profileMBeanConcreteInterfaceName ) ; 
cmpProfileInterface = pool . get ( cmpProfileInterfaceName ) ; 
profileManagementInterface = profileManagementInterfaceName != null ? pool . get ( profileManagementInterfaceName ) : null ; 
catch ( NotFoundException nfe ) { 
profileMBeanConcreteInterface . addInterface ( pool . get ( AbstractProfileMBean . class . getName ( ) ) ) ; 
CtClass [ ] managementMethodExceptions = new CtClass [ 3 ] ; 
managementMethodExceptions [ 0 ] = pool . get ( ManagementException . class . getName ( ) ) ; 
managementMethodExceptions [ 1 ] = pool . get ( InvalidStateException . class . getName ( ) ) ; 
managementMethodExceptions [ 2 ] = pool . get ( ProfileImplementationException . class . getName ( ) ) ; 
catch ( NotFoundException e ) { 
CtClass [ ] cmpGetAcessorMethodExceptions = new CtClass [ ] { managementMethodExceptions [ 0 ] } ; 
CtClass [ ] cmpSetAcessorMethodExceptions = new CtClass [ ] { managementMethodExceptions [ 0 ] , managementMethodExceptions [ 1 ] } ; 
Set < CtMethod > objectMethods = new HashSet < CtMethod > ( ) ; 
CtClass objectClass = pool . get ( Object . class . getName ( ) ) ; 
for ( CtMethod ctMethod : objectClass . getMethods ( ) ) { 
objectMethods . add ( ctMethod ) ; 
Set < CtMethod > cmpAcessorMethods = new HashSet < CtMethod > ( ) ; 
Set < CtMethod > managementMethods = new HashSet < CtMethod > ( ) ; 
if ( profileManagementInterface != null ) { 
for ( CtMethod ctMethod : profileManagementInterface . getMethods ( ) ) { 
if ( ! objectMethods . contains ( ctMethod ) ) { 
managementMethods . add ( ctMethod ) ; 
for ( CtMethod ctMethod : cmpProfileInterface . getMethods ( ) ) { 
if ( managementMethods . remove ( ctMethod ) ) { 
cmpAcessorMethods . add ( ctMethod ) ; 
for ( CtMethod ctMethod : cmpAcessorMethods ) { 
CtMethod methodCopy = new CtMethod ( ctMethod , profileMBeanConcreteInterface , null ) ; 
CtClass [ ] exceptions = null ; 
if ( ctMethod . getName ( ) . startsWith ( "set" ) ) { 
exceptions = cmpSetAcessorMethodExceptions ; 
else if ( ctMethod . getName ( ) . startsWith ( "get" ) ) { 
exceptions = cmpGetAcessorMethodExceptions ; 
profileMBeanConcreteInterface . addMethod ( methodCopy ) ; 
mBeanCmpAcessorMethods . add ( methodCopy ) ; 
for ( CtMethod ctMethod : managementMethods ) { 
methodCopy . setExceptionTypes ( managementMethodExceptions ) ; 
mBeanManagementMethods . add ( methodCopy ) ; 
profileMBeanConcreteInterface . writeFile ( this . component . getDeploymentDir ( ) . getAbsolutePath ( ) ) ; 
profileMBeanConcreteInterface . defrost ( ) ; 
this . component . setProfileMBeanConcreteInterfaceClass ( Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileMBeanConcreteInterfaceName ) ) ; 
} public void generateProfileMBean ( ) throws Exception 
if ( SleeProfileClassCodeGenerator . checkCombination ( component ) == - 1 ) 
String profileMBeanConcreteClassName = profileMBeanConcreteInterface . getName ( ) + "Impl" ; 
profileMBeanConcreteClass = pool . makeClass ( profileMBeanConcreteClassName ) ; 
profileMBeanConcreteClass . setInterfaces ( new CtClass [ ] { profileMBeanConcreteInterface } ) ; 
profileMBeanConcreteClass . setSuperclass ( pool . get ( AbstractProfileMBeanImpl . class . getName ( ) ) ) ; 
for ( CtMethod method : mBeanCmpAcessorMethods ) { 
CtMethod newMethod = CtNewMethod . copy ( method , profileMBeanConcreteClass , null ) ; 
String body = null ; 
if ( method . getName ( ) . startsWith ( "set" ) ) { 
"	beforeSetCmpField();" + 
"		((" + component . getProfileCmpConcreteClass ( ) . getName ( ) + ")getProfileObject().getProfileConcrete())." + method . getName ( ) + "($1);" + 
"		afterSetCmpField();" + 
"	}" + 
"		afterGetCmpField(activatedTransaction);" + 
newMethod . setBody ( body ) ; 
profileMBeanConcreteClass . addMethod ( newMethod ) ; 
for ( CtMethod method : mBeanManagementMethods ) { 
boolean voidReturnType = newMethod . getReturnType ( ) . equals ( CtClass . voidType ) ; 
if ( ! voidReturnType ) { 
profileMBeanConcreteClass . writeFile ( this . component . getDeploymentDir ( ) . getAbsolutePath ( ) ) ; 
profileMBeanConcreteClass . defrost ( ) ; 
component . setProfileMBeanConcreteImplClass ( Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileMBeanConcreteClassName ) ) ; 
} public ReplicatedDataWithFailover < K , V > getReplicatedDataWithFailover ( 
boolean activateDataRemovedCallback ) { 
if ( replicatedDataWithFailover == null ) { 
replicatedDataWithFailover = new ReplicatedDataWithFailoverImpl < K , V > ( 
REPLICATED_DATA_WITH_FAILOVER_NAME , raEntity , 
sleeContainer . getCluster ( ) , ra , activateDataRemovedCallback ) ; 
return replicatedDataWithFailover ; 
} public ReplicatedData < K , V > getReplicateData ( 
if ( replicatedData == null ) { 
replicatedData = new ReplicatedDataImpl < K , V > ( REPLICATED_DATA_NAME , 
raEntity , sleeContainer . getCluster ( ) , ra , 
activateDataRemovedCallback ) ; 
return replicatedData ; 
} public MemberAddress [ ] getMembers ( ) { 
final Address [ ] addresses = sleeContainer . getCluster ( ) 
. getClusterMembers ( ) . toArray ( EMPTY_ADDRESS_ARRAY ) ; 
final MemberAddressImpl [ ] members = new MemberAddressImpl [ addresses . length ] ; 
for ( int i = 0 ; i < members . length ; i ++ ) { 
members [ i ] = new MemberAddressImpl ( addresses [ i ] ) ; 
} public MemberAddress getLocalAddress ( ) { 
Address localAddress = sleeContainer . getCluster ( ) . getLocalAddress ( ) ; 
return localAddress != null ? new MemberAddressImpl ( localAddress ) 
} public void removeReplicateData ( ) { 
if ( replicatedDataWithFailover != null ) { 
replicatedDataWithFailover . remove ( ) ; 
replicatedDataWithFailover = null ; 
if ( replicatedData != null ) { 
replicatedData . remove ( ) ; 
replicatedData = null ; 
PropertyEditorManager . registerEditor ( ComponentID . class , 
ComponentIDPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( EventTypeID . class , 
PropertyEditorManager . registerEditor ( LibraryID . class , 
PropertyEditorManager . registerEditor ( ProfileSpecificationID . class , 
PropertyEditorManager . registerEditor ( ResourceAdaptorID . class , 
PropertyEditorManager . registerEditor ( ResourceAdaptorTypeID . class , 
PropertyEditorManager . registerEditor ( SbbID . class , 
PropertyEditorManager . registerEditor ( ServiceID . class , 
PropertyEditorManager . registerEditor ( ComponentID [ ] . class , 
ComponentIDArrayPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( EventTypeID [ ] . class , 
PropertyEditorManager . registerEditor ( LibraryID [ ] . class , 
PropertyEditorManager . registerEditor ( ProfileSpecificationID [ ] . class , 
PropertyEditorManager . registerEditor ( ResourceAdaptorID [ ] . class , 
PropertyEditorManager . registerEditor ( ResourceAdaptorTypeID [ ] . class , 
PropertyEditorManager . registerEditor ( SbbID [ ] . class , 
PropertyEditorManager . registerEditor ( ServiceID [ ] . class , 
PropertyEditorManager . registerEditor ( DeployableUnitID . class , 
DeployableUnitIDPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( Level . class , 
LevelPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( TraceLevel . class , 
TraceLevelPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( ConfigProperties . class , 
ConfigPropertiesPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( NotificationSource . class , 
NotificationSourcePropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( Object . class , 
ObjectPropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( ServiceState . class , 
ServiceStatePropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( ResourceAdaptorEntityState . class , 
ResourceAdaptorEntityStatePropertyEditor . class ) ; 
PropertyEditorManager . registerEditor ( Address . class , 
AddressPropertyEditor . class ) ; 
} public void process ( SleeComponentWithUsageParametersInterface component ) throws DeploymentException { 
ClassPool classPool = component . getClassPool ( ) ; 
String deploymentDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
Class < ? > usageParametersInterface = component 
. getUsageParametersInterface ( ) ; 
if ( usageParametersInterface != null ) { 
component 
. setUsageParametersConcreteClass ( new ConcreteUsageParameterClassGenerator ( 
usageParametersInterface . getName ( ) , 
deploymentDir , classPool ) 
. generateConcreteUsageParameterClass ( ) ) ; 
if ( LOGGER . isDebugEnabled ( ) ) { 
new ConcreteUsageParameterMBeanGenerator ( component ) 
. generateConcreteUsageParameterMBean ( ) ; 
} catch ( DeploymentException ex ) { 
} protected final int compareTo ( String thisClassName , ComponentID that ) { 
int typeComparison = thisClassName . compareTo ( that . getClassName ( ) ) ; 
if ( typeComparison != 0 ) return typeComparison ; 
int nameComparison = this . name . compareTo ( that . name ) ; 
if ( nameComparison != 0 ) return nameComparison ; 
int vendorComparison = this . vendor . compareTo ( that . vendor ) ; 
if ( vendorComparison != 0 ) return vendorComparison ; 
return this . version . compareTo ( that . version ) ; 
} private int rotateLeft ( int value , int bits ) { 
long l = value & 0x00000000ffffffffL ; 
l <<= bits ; 
return ( int ) l | ( int ) ( l > > 32 ) ; 
return pools . get ( new ObjectPoolMapKey ( serviceID , sbbID ) ) ; 
} public void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , 
createObjectPool ( serviceID , sbbComponent ) ; 
if ( sleeTransactionManager != null && sleeTransactionManager . getTransactionContext ( ) != null ) { 
removeObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; 
} private void removeObjectPool ( final ServiceID serviceID , final SbbID sbbID ) { 
ObjectPoolMapKey key = new ObjectPoolMapKey ( serviceID , sbbID ) ; 
final SbbObjectPoolImpl objectPool = pools . remove ( key ) ; 
ServiceActivity serviceActivityImpl ) throws NullPointerException , 
TransactionRequiredLocalException , UnrecognizedActivityException , 
FactoryException { 
ActivityContextHandle ach = new ServiceActivityContextHandle ( new ServiceActivityHandleImpl ( ( ( ServiceActivityImpl ) serviceActivityImpl ) . getServiceID ( ) ) ) ; 
throw new UnrecognizedActivityException ( serviceActivityImpl ) ; 
} void execute ( final ActivityHandle handle ) 
throws UnrecognizedActivityHandleException { 
sleeEndpoint . _endActivity ( handle , tx ) ; 
} public void startActivity ( ActivityHandle handle , Object activity ) 
throws NullPointerException , IllegalStateException , 
ActivityAlreadyExistsException , StartActivityException , 
startActivity ( handle , activity , ActivityFlags . NO_FLAGS ) ; 
} public void startActivity ( final ActivityHandle handle , Object activity , 
final int activityFlags ) throws NullPointerException , 
IllegalStateException , ActivityAlreadyExistsException , 
StartActivityException , SLEEException { 
checkStartActivityParameters ( handle , activity ) ; 
startActivityNotTransactedExecutor . execute ( handle , activityFlags , false ) ; 
} public void startActivitySuspended ( ActivityHandle handle , Object activity ) 
TransactionRequiredLocalException , ActivityAlreadyExistsException , 
startActivitySuspended ( handle , activity , ActivityFlags . NO_FLAGS ) ; 
} public void startActivitySuspended ( ActivityHandle handle , Object activity , 
int activityFlags ) throws NullPointerException , 
IllegalStateException , TransactionRequiredLocalException , 
startActivityNotTransactedExecutor . execute ( handle , activityFlags , true ) ; 
} public void startActivityTransacted ( ActivityHandle handle , Object activity , 
_startActivity ( handle , activityFlags , null ) ; 
} private void checkStartActivityParameters ( ActivityHandle handle , 
Object activity ) throws NullPointerException , IllegalStateException { 
if ( activity == null ) { 
if ( raEntity . getResourceAdaptorObject ( ) . getState ( ) != ResourceAdaptorObjectState . ACTIVE ) { 
+ raEntity . getResourceAdaptorObject ( ) . getState ( ) ) ; 
} ActivityContextHandle _startActivity ( ActivityHandle handle , 
int activityFlags , final SleeTransaction barrierTx ) { 
if ( raEntity . getHandleReferenceFactory ( ) != null 
&& ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { 
final ActivityHandleReference reference = raEntity 
. getHandleReferenceFactory ( ) . createActivityHandleReference ( 
handle ) ; 
ac = acFactory . createActivityContext ( 
new ResourceAdaptorActivityContextHandleImpl ( raEntity , 
reference ) , activityFlags ) ; 
raEntity . getHandleReferenceFactory ( ) 
. removeActivityHandleReference ( reference ) ; 
handle ) , activityFlags ) ; 
if ( barrierTx != null && ac != null ) { 
final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; 
aeqm . createBarrier ( barrierTx ) ; 
aeqm . removeBarrier ( barrierTx ) ; 
final TransactionContext tc = barrierTx . getTransactionContext ( ) ; 
tc . getAfterCommitActions ( ) . add ( action ) ; 
tc . getAfterRollbackActions ( ) . add ( action ) ; 
return ac . getActivityContextHandle ( ) ; 
} void _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) 
final ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( 
raEntity , handle ) ; 
final ActivityContext ac = acFactory . getActivityContext ( ach ) ; 
if ( barrierTx != null ) { 
ac . endActivity ( ) ; 
throw new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; 
} public void fireEvent ( ActivityHandle handle , FireableEventType eventType , 
Object event , Address address , ReceivableService receivableService ) 
throws NullPointerException , UnrecognizedActivityHandleException , 
IllegalEventException , ActivityIsEndingException , 
FireEventException , SLEEException { 
fireEvent ( handle , eventType , event , address , receivableService , 
EventFlags . NO_FLAGS , true ) ; 
} private void checkFireEventPreconditions ( ActivityHandle handle , 
FireableEventType eventType , Object event ) 
throws NullPointerException , IllegalEventException , 
IllegalStateException { 
if ( event == null ) 
if ( handle == null ) 
if ( eventType == null ) { 
final EventTypeComponent eventTypeComponent = componentRepository 
. getComponentByID ( eventType . getEventType ( ) ) ; 
if ( eventTypeComponent == null ) { 
throw new IllegalEventException ( 
if ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( 
event . getClass ( ) ) ) { 
if ( eventType . getClass ( ) != FireableEventTypeImpl . class ) { 
if ( raEntity . getAllowedEventTypes ( ) != null 
&& ! raEntity . getAllowedEventTypes ( ) . contains ( 
eventType . getEventType ( ) ) ) { 
+ eventType . getEventType ( ) 
} void _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , 
FireableEventType eventType , Object event , Address address , 
ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) 
throws ActivityIsEndingException , SLEEException { 
raEntity , refHandle ) ; 
+ realHandle 
final EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( 
realHandle , eventType , event , address , receivableService , 
eventFlags , raEntity ) ; 
final EventProcessingSucceedCallback succeedCallback = EventFlags 
. hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks 
final EventProcessingFailedCallback failedCallback = EventFlags 
. hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks 
final EventUnreferencedCallback unreferencedCallback = EventFlags 
. hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks 
ac . fireEvent ( eventType . getEventType ( ) , event , address , 
receivableService == null ? null : receivableService 
. getService ( ) , succeedCallback , failedCallback , 
unreferencedCallback ) ; 
} public void suspendActivity ( ActivityHandle handle ) 
UnrecognizedActivityHandleException , SLEEException { 
suspendActivity ( handle , true ) ; 
} public void suspendReplicatedActivity ( ActivityHandle handle ) 
suspendActivity ( handle , false ) ; 
} public Class generateSbbLocalObjectConcreteClass ( ) { 
+ sbbLocalObjectName 
+ deployPath ) ; 
concreteSbbLocalObject = pool . makeClass ( ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_PREFIX + sbbLocalObjectName + ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_SUFFIX ) ; 
sleeSbbLocalObject = pool . get ( SbbLocalObjectImpl . class 
sbbLocalObjectInterface = pool . get ( sbbLocalObjectName ) ; 
logger . error ( s , nfe ) ; 
throw new RuntimeException ( s , nfe ) ; 
CtClass concreteClassInterface ; 
concreteClassInterface = pool . get ( SbbLocalObjectConcrete . class 
ConcreteClassGeneratorUtils . createInterfaceLinks ( 
concreteSbbLocalObject , new CtClass [ ] { 
sbbLocalObjectInterface , concreteClassInterface } ) ; 
ConcreteClassGeneratorUtils . createInheritanceLink ( 
concreteSbbLocalObject , sleeSbbLocalObject ) ; 
Map interfaceMethods = ClassUtils 
. getInterfaceMethodsFromInterface ( sbbLocalObjectInterface ) ; 
generateConcreteMethods ( interfaceMethods , sbbAbstractClassName ) ; 
concreteSbbLocalObject . writeFile ( deployPath ) ; 
+ concreteSbbLocalObject . getName ( ) 
logger . fatal ( s , e ) ; 
throw new RuntimeException ( s , e ) ; 
logger . error ( s , e ) ; 
return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteSbbLocalObject . getName ( ) ) ; 
if ( this . concreteSbbLocalObject != null ) 
this . concreteSbbLocalObject . defrost ( ) ; 
} private void generateConcreteMethods ( Map interfaceMethods , 
String sbbAbstractClassName ) { 
if ( interfaceMethods == null ) 
Iterator it = interfaceMethods . values ( ) . iterator ( ) ; 
CtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; 
if ( interfaceMethod == null ) 
if ( interfaceMethod . getName ( ) . equals ( "isIdentical" ) 
|| interfaceMethod . getName ( ) . equals ( "equals" ) 
|| interfaceMethod . getName ( ) . equals ( "hashCode" ) 
|| interfaceMethod . getName ( ) . equals ( "getSbbPriority" ) 
|| interfaceMethod . getName ( ) . equals ( "remove" ) 
|| interfaceMethod . getName ( ) . equals ( "setSbbPriority" ) 
|| interfaceMethod . getName ( ) . equals ( "getName" ) 
|| interfaceMethod . getName ( ) . equals ( "getChildRelation" ) 
|| interfaceMethod . getName ( ) . equals ( "getParent" ) ) 
returnType = interfaceMethod . getReturnType ( ) ; 
if ( returnType . equals ( CtClass . voidType ) ) { 
methodToAdd += interfaceMethod . getName ( ) + "(" ; 
parameterTypes = interfaceMethod . getParameterTypes ( ) ; 
if ( parameterTypes [ argNumber ] . isPrimitive ( ) ) { 
CtClass ptype = parameterTypes [ argNumber ] ; 
if ( ptype . equals ( CtClass . intType ) ) { 
methodToAdd += "Integer.valueOf(" + "arg_" + argNumber 
+ ");" ; 
} else if ( ptype . equals ( CtClass . booleanType ) ) { 
methodToAdd += "Boolean.valueOf(" + "arg_" + argNumber 
} else if ( ptype . equals ( CtClass . longType ) ) { 
methodToAdd += "Long.valueOf(" + "arg_" + argNumber 
} else if ( ptype . equals ( CtClass . shortType ) ) { 
methodToAdd += "Short.valueOf(" + "arg_" + argNumber 
} else if ( ptype . equals ( CtClass . floatType ) ) { 
methodToAdd += "Float.valueOf(" + "arg_" + argNumber 
} else if ( ptype . equals ( CtClass . doubleType ) ) { 
methodToAdd += "Double.valueOf(" + "arg_" + argNumber 
} else if ( ptype . equals ( CtClass . charType ) ) { 
methodToAdd += "Character.valueOf(" + "arg_" 
+ argNumber + ");" ; 
methodToAdd += "arg_" + argNumber + ";" ; 
for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { 
if ( parameterTypes [ i ] . isPrimitive ( ) ) { 
CtClass ptype = parameterTypes [ i ] ; 
methodToAdd += "Integer.TYPE;" ; 
methodToAdd += "Boolean.TYPE;" ; 
methodToAdd += "Long.TYPE;" ; 
methodToAdd += "Short.TYPE;" ; 
methodToAdd += "Float.TYPE;" ; 
methodToAdd += "Double.TYPE;" ; 
methodToAdd += "Character.TYPE;" ; 
if ( returnType . isPrimitive ( ) ) { 
methodToAdd += "sbbLocalObjectInterceptor.invokeAndReturn" 
+ returnType . getSimpleName ( ) + "(concrete," + "\"" 
methodToAdd += "sbbLocalObjectInterceptor.invokeAndReturnObject(concrete," 
+ "\"" 
+ interfaceMethod . getName ( ) 
methodTest = CtNewMethod . make ( methodToAdd , 
concreteSbbLocalObject ) ; 
concreteSbbLocalObject . addMethod ( methodTest ) ; 
} protected void makeGetter ( ) { 
if ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) { 
super . operationName = "is" + this . beanFieldName ; 
super . operationName = "get" + this . beanFieldName ; 
} protected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , 
InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { 
if ( fieldClass . isPrimitive ( ) ) { 
if ( fieldClass . equals ( int . class ) ) { 
return new Integer ( optArg ) ; 
} else if ( fieldClass . equals ( long . class ) ) { 
return new Long ( optArg ) ; 
} else if ( fieldClass . equals ( int . class ) ) { 
} else if ( fieldClass . equals ( byte . class ) ) { 
return new Byte ( optArg ) ; 
} else if ( fieldClass . equals ( short . class ) ) { 
return new Short ( optArg ) ; 
} else if ( fieldClass . equals ( float . class ) ) { 
return new Float ( optArg ) ; 
} else if ( fieldClass . equals ( double . class ) ) { 
return new Double ( optArg ) ; 
} else if ( fieldClass . equals ( boolean . class ) ) { 
return new Boolean ( optArg ) ; 
} else if ( fieldClass . equals ( char . class ) ) { 
return new Character ( optArg . charAt ( 0 ) ) ; 
} else if ( isClassNumber ( ) ) { 
Constructor < ? > con = fieldClass . getConstructor ( String . class ) ; 
return con . newInstance ( optArg ) ; 
return optArg ; 
} public Set < K > getLocalKeyset ( ) { 
Set < K > set = new HashSet < K > ( ) ; 
ReplicatedDataKeyClusteredCacheData < K , V > handleCacheData = null ; 
Address handleCacheDataClusterNode = null ; 
for ( K handle : cacheData . getAllKeys ( ) ) { 
handleCacheData = new ReplicatedDataKeyClusteredCacheData < K , V > ( 
cacheData , handle , cluster ) ; 
handleCacheDataClusterNode = handleCacheData 
. getClusterNodeAddress ( ) ; 
if ( handleCacheDataClusterNode == null 
|| handleCacheDataClusterNode . equals ( cluster 
. getLocalAddress ( ) ) ) { 
set . add ( handle ) ; 
return Collections . unmodifiableSet ( set ) ; 
} public boolean put ( K key , V value ) { 
final ReplicatedDataKeyClusteredCacheData < K , V > keyCacheData = new ReplicatedDataKeyClusteredCacheData < K , V > ( 
cacheData , key , cluster ) ; 
boolean created = keyCacheData . create ( ) ; 
keyCacheData . setValue ( value ) ; 
return created ; 
final ReplicatedDataKeyClusteredCacheData < K , V > handleCacheData = new ReplicatedDataKeyClusteredCacheData < K , V > ( 
return handleCacheData . exists ( ) ? handleCacheData . getValue ( ) : null ; 
} public boolean contains ( K key ) { 
return new ReplicatedDataKeyClusteredCacheData < K , V > ( cacheData , key , 
cluster ) . exists ( ) ; 
} public boolean remove ( K key ) { 
return new ReplicatedDataKeyClusteredCacheData < K , V > ( cacheData , key , cluster ) 
. remove ( ) ; 
if ( ! ( notification instanceof TraceNotification ) ) return false ; 
Level traceLevel = ( ( TraceNotification ) notification ) . getLevel ( ) ; 
return traceLevel != null && ! minLevel_10 . isHigherLevel ( traceLevel ) ; 
TraceLevel traceLevel = ( ( TraceNotification ) notification ) . getTraceLevel ( ) ; 
return traceLevel != null && ! minLevel_11 . isHigherLevel ( traceLevel ) ; 
} public final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { 
this . profileTableName = profileTableName ; 
this . profileName = profileName ; 
this . address = null ; 
} public Address toAddress ( ) { 
if ( address == null ) { 
address = new Address ( AddressPlan . SLEE_PROFILE , profileTableName + '/' + profileName ) ; 
} public void barrierEvent ( EventContext eventContext ) { 
if ( barriedEvents == null ) { 
barriedEvents = new LinkedList < EventContext > ( ) ; 
barriedEvents . add ( eventContext ) ; 
} public EventContext [ ] removeEventsBarried ( ) { 
final EventContext [ ] result = barriedEvents 
. toArray ( new EventContext [ barriedEvents . size ( ) ] ) ; 
public EventRouterExecutor getExecutor ( 
ActivityContextHandle activityContextHandle ) { 
return executors [ ( activityContextHandle . hashCode ( ) & Integer . MAX_VALUE ) 
% executors . length ] ; 
} public static SleeState fromInt ( int state ) throws IllegalArgumentException { 
case SLEE_STOPPED : return STOPPED ; 
case SLEE_STARTING : return STARTING ; 
case SLEE_RUNNING : return RUNNING ; 
case SLEE_STOPPING : return STOPPING ; 
} public static SleeState fromString ( String state ) throws NullPointerException , IllegalArgumentException { 
if ( state . equalsIgnoreCase ( STOPPED_STRING ) ) return STOPPED ; 
if ( state . equalsIgnoreCase ( STARTING_STRING ) ) return STARTING ; 
if ( state . equalsIgnoreCase ( RUNNING_STRING ) ) return RUNNING ; 
} private String extractMessage ( String result ) { 
String startPreTag = "<pre>" ; 
String endPreTag = "</pre>" ; 
result = result . trim ( ) ; 
if ( result . startsWith ( startPreTag ) && result . endsWith ( endPreTag ) ) { 
result = result . substring ( startPreTag . length ( ) , result . length ( ) - endPreTag . length ( ) ) ; 
NotificationInfo info = ( NotificationInfo ) knownAlarms . get ( notification ) ; 
knownAlarms . put ( notification , new NotificationInfo ( System . currentTimeMillis ( ) ) ) ; 
if ( ++ info . count == threshold ) { 
knownAlarms . remove ( notification ) ; 
NotificationInfo info = ( NotificationInfo ) iterator . next ( ) ; 
if ( ( info . firstSeenTime + period ) < currentTime ) { 
} public void installResourceAdaptorType ( 
ResourceAdaptorTypeComponent component ) throws DeploymentException { 
new ResourceAdaptorTypeClassCodeGenerator ( ) . process ( component ) ; 
if ( component . getActivityContextInterfaceFactoryConcreteClass ( ) != null ) { 
Constructor < ? > constructor = component 
. getActivityContextInterfaceFactoryConcreteClass ( ) 
. getConstructor ( 
new Class [ ] { SleeContainer . class , 
ResourceAdaptorTypeID . class } ) ; 
Object aciFactory = constructor . newInstance ( new Object [ ] { 
sleeContainer , component . getResourceAdaptorTypeID ( ) } ) ; 
component . setActivityContextInterfaceFactory ( aciFactory ) ; 
throw new SLEEException ( 
final ResourceAdaptorTypeID resourceAdaptorTypeID = component . getResourceAdaptorTypeID ( ) ; 
entitiesPerType . put ( 
resourceAdaptorTypeID , 
new HashSet < ResourceAdaptorEntity > ( ) ) ; 
entitiesPerType . remove ( resourceAdaptorTypeID ) ; 
sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; 
} public void installResourceAdaptor ( final ResourceAdaptorComponent component ) throws DeploymentException { 
new ResourceAdaptorClassCodeGenerator ( ) . process ( component ) ; 
replicationClassLoader . addDomain ( component . getClassLoaderDomain ( ) ) ; 
replicationClassLoader . removeDomain ( component . getClassLoaderDomain ( ) ) ; 
} public void uninstallResourceAdaptorType ( final ResourceAdaptorTypeComponent component ) { 
TransactionalAction action1 = new TransactionalAction ( ) { 
txContext . getAfterCommitActions ( ) . add ( action1 ) ; 
action1 . execute ( ) ; 
txContext . getAfterCommitActions ( ) . add ( action2 ) ; 
action2 . execute ( ) ; 
} public void uninstallResourceAdaptor ( ResourceAdaptorComponent component ) throws DependencyException { 
for ( ResourceAdaptorEntity raEntity : resourceAdaptorEntities . values ( ) ) { 
if ( raEntity . getResourceAdaptorID ( ) . equals ( component . getResourceAdaptorID ( ) ) ) { 
} public boolean contains ( Object object ) { 
if ( ! ( object instanceof SbbLocalObject ) ) 
final SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; 
final SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; 
if ( ! idBelongsToChildRelation ( sbbEntityId ) ) { 
return new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; 
public void clear ( ) { 
for ( Iterator it = iterator ( ) ; it . hasNext ( ) ; ) { 
it . next ( ) ; 
} public boolean remove ( Object object ) { 
final SbbLocalObjectImpl sbbLocalObjectImpl = ( SbbLocalObjectImpl ) object ; 
if ( ! idBelongsToChildRelation ( sbbLocalObjectImpl . getSbbEntityId ( ) ) && ! sbbLocalObjectImpl . getSbbEntity ( ) . isRemoved ( ) ) { 
sbbLocalObjectImpl . remove ( ) ; 
public boolean containsAll ( Collection c ) { 
if ( c == null ) 
for ( Iterator it = c . iterator ( ) ; it . hasNext ( ) ; ) { 
if ( ! contains ( it . next ( ) ) ) { 
public boolean removeAll ( Collection c ) { 
boolean flag = true ; 
flag &= this . remove ( it . next ( ) ) ; 
return flag ; 
public boolean retainAll ( Collection c ) { 
boolean flag = false ; 
for ( Iterator it = this . iterator ( ) ; it . hasNext ( ) ; ) { 
if ( ! c . contains ( it . next ( ) ) ) { 
flag = true ; 
public Object [ ] toArray ( Object [ ] a ) { 
if ( a == null ) 
HashSet localObjects = this . getLocalObjects ( ) ; 
return localObjects . toArray ( a ) ; 
} private void validateChildName ( String childName ) throws IllegalArgumentException , NullPointerException { 
if ( childName == null ) { 
if ( childName . isEmpty ( ) ) { 
String sopts = ":rsdi" ; 
new LongOpt ( "start" , LongOpt . NO_ARGUMENT , null , 'r' ) , 
new LongOpt ( "stopt" , LongOpt . NO_ARGUMENT , null , 's' ) , 
new LongOpt ( "shutdown" , LongOpt . NO_ARGUMENT , null , 'd' ) , 
new LongOpt ( "info" , LongOpt . NO_ARGUMENT , null , 'i' ) , 
super . operation = new StartOperation ( super . context , super . log , this ) ; 
super . operation = new StopOperation ( super . context , super . log , this ) ; 
super . operation = new ShutdownOperation ( super . context , super . log , this ) ; 
super . operation = new InfoOperation ( super . context , super . log , this ) ; 
} public static FailureReason fromInt ( int reason ) throws IllegalArgumentException { 
switch ( reason ) { 
case REASON_OTHER_REASON : return OTHER_REASON ; 
case REASON_EVENT_QUEUE_FULL : return EVENT_QUEUE_FULL ; 
case REASON_EVENT_QUEUE_TIMEOUT : return EVENT_QUEUE_TIMEOUT ; 
case REASON_SYSTEM_OVERLOAD : return SYSTEM_OVERLOAD ; 
case REASON_EVENT_MARSHALING_ERROR : return EVENT_MARSHALING_ERROR ; 
case REASON_FIRING_TRANSACTION_ROLLED_BACK : return FIRING_TRANSACTION_ROLLED_BACK ; 
if ( reason > 0 ) 
return new FailureReason ( reason ) ; 
} public static String getUsageMBeanProperties ( String subsystemName ) { 
return SUBSYSTEM_NAME_KEY + '=' + ObjectName . quote ( subsystemName ) ; 
if ( obj instanceof SubsystemNotification ) { 
SubsystemNotification that = ( SubsystemNotification ) obj ; 
return this . subsystemName . compareTo ( that . subsystemName ) ; 
} public void setBoolean ( Boolean attrValue ) { 
if ( attrValue != null ) { 
setString ( attrValue . toString ( ) ) ; 
setString ( null ) ; 
} public void setByte ( Byte attrValue ) { 
} public void setCharacter ( Character attrValue ) { 
} public void setDouble ( Double attrValue ) { 
} public void setFloat ( Float attrValue ) { 
} public void setInteger ( Integer attrValue ) { 
} public void setLong ( Long attrValue ) { 
} public void setShort ( Short attrValue ) { 
} public void setAddress ( Address attrValue ) { 
setSerializable ( attrValue ) ; 
} public void setTimerThreads ( int value ) { 
if ( this . timerThreads == null ) { 
+ value 
this . timerThreads = value ; 
} public boolean isHigherLevel ( Level other ) throws NullPointerException { 
} private Object readResolve ( ) throws StreamCorruptedException { 
if ( level == LEVEL_OFF ) return OFF ; 
if ( level == LEVEL_SEVERE ) return SEVERE ; 
if ( level == LEVEL_WARNING ) return WARNING ; 
if ( level == LEVEL_INFO ) return INFO ; 
if ( level == LEVEL_CONFIG ) return CONFIG ; 
if ( level == LEVEL_FINE ) return FINE ; 
if ( level == LEVEL_FINER ) return FINER ; 
if ( level == LEVEL_FINEST ) return FINEST ; 
} private void parseDeployConfig ( InputStream deployConfigInputStream , 
ResourceManagement resourceManagement ) throws SAXException , 
ParserConfigurationException , IOException { 
if ( deployConfigInputStream == null ) { 
SchemaFactory schemaFactory = SchemaFactory 
. newInstance ( XMLConstants . W3C_XML_SCHEMA_NS_URI ) ; 
Schema schema = schemaFactory . newSchema ( DeployConfigParser . class 
. getClassLoader ( ) . getResource ( "deploy-config.xsd" ) ) ; 
DocumentBuilderFactory factory = DocumentBuilderFactory 
. newInstance ( ) ; 
factory . setSchema ( schema ) ; 
DocumentBuilder builder = factory . newDocumentBuilder ( ) ; 
builder . setErrorHandler ( new ErrorHandler ( ) { 
public void error ( SAXParseException e ) throws SAXException { 
public void fatalError ( SAXParseException e ) throws SAXException { 
public void warning ( SAXParseException e ) throws SAXException { 
doc = builder . parse ( deployConfigInputStream ) ; 
deployConfigInputStream . close ( ) ; 
Map < String , Collection < ManagementAction > > postInstallActions = new HashMap < String , Collection < ManagementAction > > ( ) ; 
Map < String , Collection < ManagementAction > > preUninstallActions = new HashMap < String , Collection < ManagementAction > > ( ) ; 
NodeList raEntities = doc . getElementsByTagName ( "ra-entity" ) ; 
String raId = null ; 
Collection < ManagementAction > cPostInstallActions = new ArrayList < ManagementAction > ( ) ; 
Collection < ManagementAction > cPreUninstallActions = new ArrayList < ManagementAction > ( ) ; 
for ( int i = 0 ; i < raEntities . getLength ( ) ; i ++ ) { 
Element raEntity = ( Element ) raEntities . item ( i ) ; 
ComponentIDPropertyEditor cidpe = new ComponentIDPropertyEditor ( ) ; 
cidpe . setAsText ( raEntity . getAttribute ( "resource-adaptor-id" ) ) ; 
raId = cidpe . getValue ( ) . toString ( ) ; 
String entityName = raEntity . getAttribute ( "entity-name" ) ; 
NodeList propsNodeList = raEntity 
. getElementsByTagName ( "properties" ) ; 
if ( propsNodeList . getLength ( ) > 1 ) { 
ConfigProperties props = new ConfigProperties ( ) ; 
Element propsNode = ( Element ) propsNodeList . item ( 0 ) ; 
if ( propsNode != null ) { 
NodeList propsList = propsNode . getElementsByTagName ( "property" ) ; 
for ( int j = 0 ; j < propsList . getLength ( ) ; j ++ ) { 
Element property = ( Element ) propsList . item ( j ) ; 
String propertyName = property . getAttribute ( "name" ) ; 
String propertyType = property . getAttribute ( "type" ) ; 
String propertyValue = property . getAttribute ( "value" ) ; 
props . addProperty ( new ConfigProperties . Property ( 
propertyName , propertyType , 
ConfigProperties . Property . toObject ( propertyType , 
propertyValue ) ) ) ; 
ResourceAdaptorID componentID = ( ResourceAdaptorID ) cidpe 
. getValue ( ) ; 
cPostInstallActions . add ( new CreateResourceAdaptorEntityAction ( 
componentID , entityName , props , resourceManagement ) ) ; 
cPostInstallActions . add ( new ActivateResourceAdaptorEntityAction ( 
entityName , resourceManagement ) ) ; 
NodeList links = raEntity . getElementsByTagName ( "ra-link" ) ; 
for ( int j = 0 ; j < links . getLength ( ) ; j ++ ) { 
String linkName = ( ( Element ) links . item ( j ) ) 
. getAttribute ( "name" ) ; 
cPostInstallActions . add ( new BindLinkNameAction ( linkName , 
cPreUninstallActions . add ( new UnbindLinkNameAction ( linkName , 
resourceManagement ) ) ; 
cPreUninstallActions . add ( new DeactivateResourceAdaptorEntityAction ( 
cPreUninstallActions . add ( new RemoveResourceAdaptorEntityAction ( 
if ( raId != null ) { 
if ( postInstallActions . containsKey ( raId ) ) { 
postInstallActions . get ( raId ) . addAll ( cPostInstallActions ) ; 
postInstallActions . put ( raId , cPostInstallActions ) ; 
if ( preUninstallActions . containsKey ( raId ) ) { 
preUninstallActions . get ( raId ) . addAll ( cPreUninstallActions ) ; 
preUninstallActions . put ( raId , cPreUninstallActions ) ; 
cPostInstallActions = new ArrayList < ManagementAction > ( ) ; 
cPreUninstallActions = new ArrayList < ManagementAction > ( ) ; 
raId = null ; 
this . postInstallActions = Collections 
. unmodifiableMap ( postInstallActions ) ; 
this . preUninstallActions = Collections 
. unmodifiableMap ( preUninstallActions ) ; 
} public List < ServiceDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException { 
List < ServiceDescriptorImpl > result = new ArrayList < ServiceDescriptorImpl > ( ) ; 
MServiceXML serviceXML = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . service . ServiceXml ) { 
serviceXML = new MServiceXML ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . service . ServiceXml ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . service . ServiceXml ) { 
serviceXML = new MServiceXML ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . service . ServiceXml ) jaxbPojo ) ; 
for ( MService mService : serviceXML . getMServices ( ) ) { 
result . add ( new ServiceDescriptorImpl ( mService ) ) ; 
} public void clean ( ) { 
for ( ClassPath classPath : classPaths ) { 
classPool . removeClassPath ( classPath ) ; 
for ( String classMade : classesMade ) { 
classPool . get ( classMade ) . detach ( ) ; 
} public ExternalActivityHandle createActivityHandle ( ) throws ResourceException { 
if ( sleeContainer == null ) 
if ( sleeContainer . getSleeState ( ) != SleeState . RUNNING ) 
return sleeContainer . getNullActivityFactory ( ) . createNullActivityHandle ( ) ; 
} public void fireEvent ( Object event , EventTypeID eventType , 
ExternalActivityHandle activityHandle , Address address ) throws NullPointerException , 
UnrecognizedActivityException , UnrecognizedEventException , ResourceException { 
logger . debug ( "fireEvent(event=" + event + ",eventType=" + eventType 
+ ",activityHandle=" + activityHandle + ",address=" 
+ address + ")" ) ; 
if ( event == null ) { 
if ( activityHandle == null ) { 
EventTypeComponent eventTypeComponent = sleeContainer 
. getComponentRepository ( ) . getComponentByID ( eventType ) ; 
if ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) { 
logger . info ( "" + eventTypeComponent . getEventTypeClass ( ) . toString ( ) ) ; 
logger . info ( "" + eventTypeComponent . getEventTypeClass ( ) . getCanonicalName ( ) ) ; 
logger . info ( "" + Arrays . toString ( eventTypeComponent . getEventTypeClass ( ) . getDeclaredMethods ( ) ) ) ; 
logger . info ( "" + eventTypeComponent . getEventTypeClass ( ) . getClass ( ) . toString ( ) ) ; 
logger . info ( "" + eventTypeComponent . getEventTypeClass ( ) . getClass ( ) . getCanonicalName ( ) ) ; 
logger . info ( "" + event . getClass ( ) . toString ( ) ) ; 
logger . info ( "" + event . getClass ( ) . getCanonicalName ( ) ) ; 
logger . info ( "" + Arrays . toString ( event . getClass ( ) . getDeclaredMethods ( ) ) ) ; 
logger . info ( "*" + eventTypeComponent ) ; 
logger . info ( "*" + eventTypeComponent . getEventTypeID ( ) ) ; 
logger . info ( "*" + event ) ; 
logger . info ( "&" + eventTypeComponent . getClassLoader ( ) ) ; 
logger . info ( "&" + eventTypeComponent . getEventTypeClass ( ) . getClassLoader ( ) ) ; 
logger . info ( "&" + event . getClass ( ) . getClassLoader ( ) ) ; 
if ( ! ( activityHandle instanceof NullActivityHandle ) ) { 
throw new UnrecognizedActivityException ( activityHandle ) ; 
boolean newTx = txMgr . requireTransaction ( ) ; 
final NullActivityHandle nullActivityHandle = ( NullActivityHandle ) activityHandle ; 
final ActivityContextHandle ach = nullActivityHandle . getActivityContextHandle ( ) ; 
ActivityContext ac = sleeContainer . getActivityContextFactory ( ) 
. getActivityContext ( ach ) ; 
sleeContainer . getNullActivityFactory ( ) . createNullActivity ( 
nullActivityHandle , false ) ; 
ac = sleeContainer . getActivityContextFactory ( ) 
+ activityHandle ) ; 
ac . fireEvent ( eventType , event , address , null , null , null , null ) ; 
if ( newTx ) { 
txMgr . rollback ( ) ; 
} public EventTypeID getEventTypeID ( String name , String vendor , String version ) throws UnrecognizedEventException , ResourceException { 
EventTypeID eventTypeID = new EventTypeID ( name , vendor , version ) ; 
. getComponentRepository ( ) . getComponentByID ( eventTypeID ) ; 
return eventTypeID ; 
parentSbbEntityID = ( SbbEntityID ) in . readObject ( ) ; 
parentChildRelation = in . readUTF ( ) ; 
childID = in . readUTF ( ) ; 
out . writeObject ( parentSbbEntityID ) ; 
out . writeUTF ( parentChildRelation ) ; 
out . writeUTF ( childID ) ; 
String sopts = "-:l:xdwecrog:s" ; 
new LongOpt ( "extlist" , LongOpt . NO_ARGUMENT , null , 'x' ) , 
new LongOpt ( "dirty" , LongOpt . NO_ARGUMENT , null , 'd' ) , 
new LongOpt ( "write" , LongOpt . NO_ARGUMENT , null , 'w' ) , 
new LongOpt ( "edit" , LongOpt . NO_ARGUMENT , null , 'e' ) , 
new LongOpt ( "commit" , LongOpt . NO_ARGUMENT , null , 'c' ) , 
new LongOpt ( "restore" , LongOpt . NO_ARGUMENT , null , 'r' ) , 
new LongOpt ( "close" , LongOpt . NO_ARGUMENT , null , 'o' ) , 
new LongOpt ( "get" , LongOpt . REQUIRED_ARGUMENT , null , 'g' ) , 
new LongOpt ( "set" , LongOpt . NO_ARGUMENT , null , 's' ) , 
new LongOpt ( "name" , LongOpt . REQUIRED_ARGUMENT , null , SetAttributeOperation . name ) , 
new LongOpt ( "separator" , LongOpt . OPTIONAL_ARGUMENT , null , SetAttributeOperation . separator ) , 
new LongOpt ( "value" , LongOpt . OPTIONAL_ARGUMENT , null , SetAttributeOperation . value ) , 
switch ( nonOptArgIndex ) 
profileTableName = getopt . getOptarg ( ) ; 
profileName = getopt . getOptarg ( ) ; 
case 'x' : 
super . operation = new ExtListOperation ( super . context , super . log , this ) ; 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "isProfileDirty" ) ; 
case 'w' : 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "isProfileWriteable" ) ; 
case 'e' : 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "editProfile" ) ; 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "commitProfile" ) ; 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "restoreProfile" ) ; 
case 'o' : 
super . operation = new SimpleInvokeOperation ( super . context , super . log , this , "closeProfile" ) ; 
super . operation = new GetAttributeOperation ( super . context , super . log , this ) ; 
super . operation = new SetAttributeOperation ( super . context , super . log , this ) ; 
public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException 
SleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; 
if ( sleeTransactionManager . getTransaction ( ) == null ) { 
catch ( SystemException se ) { 
String key = makeKey ( po ) ; 
final TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; 
ProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; 
data = new ProfileCallRecorderTransactionData ( ) ; 
txContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; 
if ( ! po . isProfileReentrant ( ) ) 
if ( data . invokedProfiles . contains ( key ) && data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) { 
data . invokedProfiles . add ( key ) ; 
data . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; 
} public ProfileObjectImpl getProfile ( String profileName ) 
Map txData = getTxData ( ) ; 
ProfileTransactionID key = new ProfileTransactionID ( profileName , 
profileTable . getProfileTableName ( ) ) ; 
ProfileObjectImpl value = ( ProfileObjectImpl ) txData . get ( key ) ; 
ProfileObjectPool pool = profileTable . getProfileManagement ( ) 
. getObjectPoolManagement ( ) . getObjectPool ( 
value = pool . borrowObject ( ) ; 
passivateProfileObjectOnTxEnd ( profileTable . getSleeContainer ( ) 
. getTransactionManager ( ) , value , pool ) ; 
value . profileActivate ( profileName ) ; 
} catch ( UnrecognizedProfileNameException e ) { 
value . invalidateObject ( ) ; 
pool . invalidateObject ( value ) ; 
txData . put ( key , value ) ; 
} public static void passivateProfileObjectOnTxEnd ( 
SleeTransactionManager txManager , 
final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { 
TransactionalAction afterRollbackAction = new TransactionalAction ( ) { 
profileObject . invalidateObject ( ) ; 
pool . returnObject ( profileObject ) ; 
TransactionalAction beforeCommitAction = new TransactionalAction ( ) { 
if ( profileObject . getState ( ) == ProfileObjectState . READY ) { 
if ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { 
profileObject . fireAddOrUpdatedEventIfNeeded ( ) ; 
profileObject . profilePassivate ( ) ; 
profileObject . profileRemove ( true , false ) ; 
final TransactionContext txContext = txManager . getTransactionContext ( ) ; 
txContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; 
txContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; 
} public boolean validate ( ) { 
if ( ! validateDescriptor ( ) ) { 
if ( ! validateCMPInterface ( ) ) { 
if ( ! validateProfileTableInterface ( ) ) { 
if ( ! validateProfileLocalInterface ( ) ) { 
if ( ! validateProfileManagementInterface ( ) ) { 
if ( ! validateAbstractClass ( ) ) { 
} boolean validateProfileManagementInterface ( ) { 
if ( this . component . getProfileManagementInterfaceClass ( ) == null ) { 
Class profileManagementInterfaceClass = this . component 
. getProfileManagementInterfaceClass ( ) ; 
if ( ! profileManagementInterfaceClass . isInterface ( ) ) { 
errorBuffer = appendToBuffer ( 
"10.10" , errorBuffer ) ; 
if ( this . component . isSlee11 ( ) 
&& profileManagementInterfaceClass . getPackage ( ) == null ) { 
if ( ! Modifier . isPublic ( profileManagementInterfaceClass 
. getModifiers ( ) ) ) { 
Set < String > ignore = new HashSet < String > ( ) ; 
ignore . add ( "java.lang.Object" ) ; 
Map < String , Method > cmpInterfaceMethods = ClassUtils 
. getAllInterfacesMethods ( this . component 
. getProfileCmpInterfaceClass ( ) , ignore ) ; 
Map < String , Method > managementInterfaceMethods = ClassUtils 
. getAllInterfacesMethods ( profileManagementInterfaceClass , 
ignore ) ; 
Iterator < Entry < String , Method > > entryIterator = managementInterfaceMethods 
while ( entryIterator . hasNext ( ) ) { 
Entry < String , Method > entry = entryIterator . next ( ) ; 
if ( cmpInterfaceMethods . containsKey ( key ) ) { 
if ( ! compareMethod ( entry . getValue ( ) , cmpInterfaceMethods 
. get ( key ) ) ) { 
if ( _FORBIDEN_METHODS . contains ( key ) ) { 
+ entry . getKey ( ) , "10.18" , errorBuffer ) ; 
requiredProfileAbstractClass = true ; 
if ( key . startsWith ( "ejb" ) ) { 
Class [ ] params = entry . getValue ( ) . getParameterTypes ( ) ; 
for ( int index = 0 ; index < params . length ; index ++ ) { 
if ( _ALLOWED_MANAGEMENT_TYPES . contains ( params [ index ] 
. toString ( ) ) || ClassUtils . checkInterfaces ( params [ index ] , "java.io.Serializable" ) != null ) { 
+ index 
+ entry . getKey ( ) , "10.18" , 
if ( logger . isEnabledFor ( Level . ERROR ) ) 
} boolean validateAbstractClass ( ) { 
if ( this . component . getDescriptor ( ) . getProfileAbstractClass ( ) == null ) { 
if ( this . requiredProfileAbstractClass ) { 
"3.X" , errorBuffer ) ; 
if ( this . component . getProfileAbstractClass ( ) == null ) { 
Class profileAbstractClass = this . component . getProfileAbstractClass ( ) ; 
if ( profileAbstractClass == null ) 
if ( profileAbstractClass . getPackage ( ) == null ) { 
"10.11" , errorBuffer ) ; 
Constructor c = null ; 
c = profileAbstractClass . getConstructor ( null ) ; 
if ( ! Modifier . isPublic ( c . getModifiers ( ) ) ) { 
if ( c . getExceptionTypes ( ) . length > 0 ) { 
int modifiers = profileAbstractClass . getModifiers ( ) ; 
if ( ! Modifier . isAbstract ( modifiers ) ) { 
if ( ! Modifier . isPublic ( modifiers ) ) { 
Map < String , Method > requiredLifeCycleMethods = null ; 
Class javaxSleeProfileProfileClass = ClassUtils 
. checkInterfaces ( profileAbstractClass , 
"javax.slee.profile.Profile" ) ; 
if ( javaxSleeProfileProfileClass == null ) { 
requiredLifeCycleMethods = ClassUtils 
. getAllInterfacesMethods ( 
javax . slee . profile . ProfileLocalObject . class , 
javaxSleeProfileProfileClass , ignore ) ; 
Class javaxSleeProfileProfileManagement = ClassUtils 
"javax.slee.profile.ProfileManagement" ) ; 
if ( javaxSleeProfileProfileManagement == null ) { 
"10.8" , errorBuffer ) ; 
javax . slee . profile . ProfileManagement . class , 
javaxSleeProfileProfileManagement , ignore ) ; 
Map < String , Method > abstractMethods = ClassUtils 
. getAbstractMethodsFromClass ( profileAbstractClass ) ; 
Map < String , Method > abstractMethodsFromSuperClasses = ClassUtils 
. getAbstractMethodsFromSuperClasses ( profileAbstractClass ) ; 
Map < String , Method > concreteMethods = ClassUtils 
. getConcreteMethodsFromClass ( profileAbstractClass ) ; 
Map < String , Method > concreteMethodsFromSuperClasses = ClassUtils 
. getConcreteMethodsFromSuperClasses ( profileAbstractClass ) ; 
Set < String > toBeImplementedBySlee = new HashSet < String > ( ) ; 
toBeImplementedBySlee . add ( "isProfileDirty" ) ; 
toBeImplementedBySlee . add ( "markProfileDirty" ) ; 
toBeImplementedBySlee . add ( "isProfileValid" ) ; 
for ( Entry < String , Method > entry : requiredLifeCycleMethods 
. entrySet ( ) ) { 
Method m = entry . getValue ( ) ; 
Method methodFromClass = ClassUtils . getMethodFromMap ( m 
. getName ( ) , m . getParameterTypes ( ) , concreteMethods , 
concreteMethodsFromSuperClasses ) ; 
if ( methodFromClass == null ) 
if ( this . component . isSlee11 ( ) || ( ! this . component . isSlee11 ( ) && ! toBeImplementedBySlee . contains ( m . getName ( ) ) ) ) 
+ m . getName ( ) , "10.11" , errorBuffer ) ; 
if ( methodFromClass != null && toBeImplementedBySlee . contains ( m . getName ( ) ) ) 
if ( ! m . getReturnType ( ) . getName ( ) . equals ( methodFromClass . getReturnType ( ) . getName ( ) ) ) { 
+ m . getName ( ) 
+ methodFromClass . getReturnType ( ) 
+ m . getReturnType ( ) , "10.11" , errorBuffer ) ; 
if ( ! Arrays . equals ( m . getExceptionTypes ( ) , methodFromClass 
. getExceptionTypes ( ) ) ) { 
modifiers = methodFromClass . getModifiers ( ) ; 
if ( Modifier . isStatic ( modifiers ) ) { 
if ( Modifier . isFinal ( modifiers ) ) { 
Class profileCMPInterface = ClassUtils . checkInterfaces ( 
profileAbstractClass , this . component 
. getProfileCmpInterfaceClass ( ) . getName ( ) ) ; 
if ( profileCMPInterface == null ) { 
. getAllInterfacesMethods ( profileCMPInterface , ignore ) ; 
for ( Entry < String , Method > entry : cmpInterfaceMethods 
if ( methodFromClass != null ) { 
methodFromClass = ClassUtils . getMethodFromMap ( m . getName ( ) , 
m . getParameterTypes ( ) , abstractMethods , 
abstractMethodsFromSuperClasses ) ; 
if ( m . getReturnType ( ) . getName ( ) . compareTo ( 
methodFromClass . getReturnType ( ) . getName ( ) ) != 0 ) { 
+ m . getReturnType ( ) , "10.11" , 
abstractMethods . remove ( entry . getKey ( ) ) ; 
abstractMethodsFromSuperClasses . remove ( entry . getKey ( ) ) ; 
if ( this . component . getDescriptor ( ) . getProfileManagementInterface ( ) != null ) { 
if ( this . component . getProfileAbstractClass ( ) != null && ! profileManagementInterfaceClass . isAssignableFrom ( this . component . getProfileAbstractClass ( ) ) ) { 
Map < String , Method > profileManagementInterfaceMethods = ClassUtils 
profileManagementInterfaceClass , ignore ) ; 
for ( Entry < String , Method > entry : profileManagementInterfaceMethods 
if ( cmpInterfaceMethods . containsKey ( entry . getKey ( ) ) ) { 
Method concreteMethodFromAbstractClass = ClassUtils 
. getMethodFromMap ( m . getName ( ) , m 
. getParameterTypes ( ) , concreteMethods , 
if ( concreteMethodFromAbstractClass == null ) { 
int concreteMethodModifiers = concreteMethodFromAbstractClass 
. getModifiers ( ) ; 
if ( ! Modifier . isPublic ( concreteMethodModifiers ) ) { 
+ concreteMethodFromAbstractClass 
. getName ( ) , "10.11" , 
if ( Modifier . isStatic ( concreteMethodModifiers ) ) { 
if ( Modifier . isFinal ( concreteMethodModifiers ) ) { 
if ( this . component . getDescriptor ( ) . getProfileLocalInterface ( ) != null ) { 
if ( ClassUtils . checkInterfaces ( profileAbstractClass , 
this . component . getDescriptor ( ) 
. getProfileLocalInterface ( ) 
. getProfileLocalInterfaceName ( ) ) != null 
|| ClassUtils . checkInterfaces ( profileAbstractClass , 
"javax.slee.profile.ProfileLocalObject" ) != null ) { 
Class profileLocalObjectClass = this . component 
. getProfileLocalInterfaceClass ( ) ; 
ignore . add ( "javax.slee.profile.ProfileLocalObject" ) ; 
Map < String , Method > profileLocalObjectInterfaceMethods = ClassUtils 
. getAllInterfacesMethods ( profileLocalObjectClass , 
ignore . remove ( "javax.slee.profile.ProfileLocalObject" ) ; 
for ( Entry < String , Method > entry : profileLocalObjectInterfaceMethods 
. getParameterTypes ( ) , 
concreteMethods , 
if ( this . component . getDescriptor ( ) 
. getProfileUsageParameterInterface ( ) != null ) { 
if ( ! validateProfileUsageInterface ( abstractMethods , 
abstractMethodsFromSuperClasses ) ) { 
} boolean validateDescriptor ( ) { 
HashSet < String > collatorAlliases = new HashSet < String > ( ) ; 
ProfileSpecificationDescriptorImpl desc = this . component 
. getDescriptor ( ) ; 
for ( CollatorDescriptor mc : desc . getCollators ( ) ) { 
if ( collatorAlliases . contains ( mc . getCollatorAlias ( ) ) ) { 
+ mc . getCollatorAlias ( ) , "3.3.7" , 
collatorAlliases . add ( mc . getCollatorAlias ( ) ) ; 
Map < String , ProfileCMPFieldDescriptor > cmpName2Field = new HashMap < String , ProfileCMPFieldDescriptor > ( ) ; 
for ( ProfileCMPFieldDescriptor c : desc . getProfileCMPInterface ( ) . getCmpFields ( ) ) { 
if ( ! Character . isLowerCase ( c . getCmpFieldName ( ) . charAt ( 0 ) ) ) { 
+ c . getCmpFieldName ( ) , "3.3.7" , errorBuffer ) ; 
if ( cmpName2Field . containsKey ( c . getCmpFieldName ( ) ) ) { 
cmpName2Field . put ( c . getCmpFieldName ( ) , c ) ; 
if ( c . getUniqueCollatorRef ( ) != null 
&& ! collatorAlliases . contains ( c . getUniqueCollatorRef ( ) ) ) { 
+ c . getCmpFieldName ( ) 
+ c . getUniqueCollatorRef ( ) , "3.3.7" , 
for ( IndexHintDescriptor indexHint : c . getIndexHints ( ) ) { 
if ( indexHint . getCollatorRef ( ) != null 
&& ! collatorAlliases . contains ( indexHint 
. getCollatorRef ( ) ) ) { 
Set < String > queriesNames = new HashSet < String > ( ) ; 
for ( QueryDescriptor mq : desc . getQueryElements ( ) ) { 
if ( queriesNames . contains ( mq . getName ( ) ) ) { 
+ mq . getName ( ) , "3.3.7" , errorBuffer ) ; 
HashSet < String > decalredParameters = new HashSet < String > ( ) ; 
HashSet < String > usedParameters = new HashSet < String > ( ) ; 
for ( QueryParameterDescriptor mqp : mq . getQueryParameters ( ) ) { 
if ( decalredParameters . contains ( mqp . getName ( ) ) ) { 
+ mq . getName ( ) , "3.3.7" , 
decalredParameters . add ( mqp . getName ( ) ) ; 
if ( ! validateExpression ( mq . getName ( ) , mq 
. getQueryExpression ( ) , usedParameters , 
cmpName2Field . keySet ( ) , collatorAlliases ) ) { 
if ( ! usedParameters . containsAll ( decalredParameters ) 
&& ! decalredParameters . containsAll ( usedParameters ) ) { 
decalredParameters . retainAll ( usedParameters ) ; 
+ mq . getName ( ) 
+ Arrays . toString ( decalredParameters 
. toArray ( ) ) , "3.3.7" , 
if ( ! validateEnvEntries ( ) ) { 
} boolean validateExpression ( String queryName , QueryExpressionDescriptor expression , 
Set < String > usedQueryParameter , Set < String > cmpFieldNames , 
Set < String > collatorAliasses ) { 
String collatorRef = null ; 
String parameter = null ; 
boolean ignoreAbsence = false ; 
switch ( expression . getType ( ) ) { 
case And : 
for ( QueryExpressionDescriptor mqe : expression . getAnd ( ) ) { 
if ( ! validateExpression ( queryName , mqe , usedQueryParameter , 
cmpFieldNames , collatorAliasses ) ) { 
case Or : 
for ( QueryExpressionDescriptor mqe : expression . getOr ( ) ) { 
case Not : 
if ( ! validateExpression ( queryName , expression . getNot ( ) , 
usedQueryParameter , cmpFieldNames , collatorAliasses ) ) { 
case Compare : 
attributeName = expression . getCompare ( ) . getAttributeName ( ) ; 
collatorRef = expression . getCompare ( ) . getCollatorRef ( ) ; 
parameter = expression . getCompare ( ) . getParameter ( ) ; 
value = expression . getCompare ( ) . getValue ( ) ; 
case HasPrefix : 
attributeName = expression . getHasPrefix ( ) . getAttributeName ( ) ; 
collatorRef = expression . getHasPrefix ( ) . getCollatorRef ( ) ; 
parameter = expression . getHasPrefix ( ) . getParameter ( ) ; 
value = expression . getHasPrefix ( ) . getValue ( ) ; 
case LongestPrefixMatch : 
attributeName = expression . getLongestPrefixMatch ( ) 
. getAttributeName ( ) ; 
collatorRef = expression . getLongestPrefixMatch ( ) 
. getCollatorRef ( ) ; 
parameter = expression . getLongestPrefixMatch ( ) . getParameter ( ) ; 
value = expression . getLongestPrefixMatch ( ) . getValue ( ) ; 
case RangeMatch : 
attributeName = expression . getRangeMatch ( ) . getAttributeName ( ) ; 
collatorRef = expression . getRangeMatch ( ) . getCollatorRef ( ) ; 
RangeMatchDescriptor mrm = expression . getRangeMatch ( ) ; 
ignoreAbsence = true ; 
if ( mrm . getFromParameter ( ) == null 
&& mrm . getFromValue ( ) == null ) { 
+ queryName , "10.20.2" , errorBuffer ) ; 
if ( mrm . getFromParameter ( ) != null 
&& mrm . getFromValue ( ) != null ) { 
if ( mrm . getToParameter ( ) == null && mrm . getToValue ( ) == null ) { 
if ( mrm . getToParameter ( ) != null && mrm . getToValue ( ) != null ) { 
if ( mrm . getFromParameter ( ) != null ) { 
usedQueryParameter . add ( mrm . getFromParameter ( ) ) ; 
if ( mrm . getToParameter ( ) != null ) { 
usedQueryParameter . add ( mrm . getToParameter ( ) ) ; 
if ( attributeName != null ) { 
if ( ! Character . isLowerCase ( attributeName . charAt ( 0 ) ) ) { 
+ attributeName 
} else if ( ! cmpFieldNames . contains ( attributeName ) && ! checkForCmpMethodFromFieldName ( attributeName ) ) { 
if ( collatorRef != null 
&& ! collatorAliasses . contains ( collatorRef ) ) { 
+ collatorRef 
if ( ! ignoreAbsence && parameter != null && value != null ) { 
if ( ! ignoreAbsence && parameter == null && value == null ) { 
if ( parameter != null ) { 
usedQueryParameter . add ( parameter ) ; 
} public void setAsText ( String text ) { 
if ( text == null || text . equals ( "" ) ) { 
super . setValue ( new ComponentID [ 0 ] ) ; 
java . util . ArrayList results = new java . util . ArrayList ( ) ; 
java . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; 
ComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; 
cidPropEditor . setAsText ( st . nextToken ( ) ) ; 
results . add ( cidPropEditor . getValue ( ) ) ; 
ComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; 
results . toArray ( cid ) ; 
this . setValue ( cid ) ; 
} public void execute ( Runnable task ) { 
if ( stats == null ) { 
executor . execute ( task ) ; 
executor . execute ( new MiscTaskStatsCollector ( task ) ) ; 
} public void executeNow ( Runnable task ) throws InterruptedException , ExecutionException { 
executor . submit ( task ) . get ( ) ; 
executor . submit ( new MiscTaskStatsCollector ( task ) ) . get ( ) ; 
} public void routeEvent ( EventContext event ) { 
final EventRoutingTaskImpl eventRoutingTask = new EventRoutingTaskImpl ( event , sleeContainer ) ; 
executor . execute ( eventRoutingTask ) ; 
executor . execute ( new EventRoutingTaskStatsCollector ( 
eventRoutingTask ) ) ; 
} public void createResourceAdaptorEntity ( ResourceAdaptorID id , 
String entityName , ConfigProperties properties ) 
UnrecognizedResourceAdaptorException , 
ResourceAdaptorEntityAlreadyExistsException , 
InvalidConfigurationException , ManagementException { 
synchronized ( getSleeContainer ( ) . getManagementMonitor ( ) ) { 
resourceManagement . createResourceAdaptorEntity ( id , entityName , properties ) ; 
} catch ( InvalidArgumentException e ) { 
} catch ( UnrecognizedResourceAdaptorException e ) { 
} catch ( ResourceAdaptorEntityAlreadyExistsException e ) { 
} catch ( InvalidConfigurationException e ) { 
throw new ManagementException ( s , e ) ; 
} public Class generateActivityContextInterfaceConcreteClass ( ) 
String tmpClassName = ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_PREFIX 
+ activityContextInterfaceName 
+ ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_SUFFIX ; 
concreteActivityContextInterface = pool . makeClass ( tmpClassName ) ; 
CtClass sbbActivityContextInterface = null ; 
activityContextInterface = pool . get ( activityContextInterfaceName ) ; 
sbbActivityContextInterface = pool 
. get ( SbbActivityContextInterfaceImpl . class . getName ( ) ) ; 
+ activityContextInterfaceName , nfe ) ; 
concreteActivityContextInterface , sbbActivityContextInterface ) ; 
concreteActivityContextInterface , 
new CtClass [ ] { activityContextInterface } ) ; 
. getInterfaceMethodsFromInterface ( activityContextInterface ) ; 
generateConcreteMethods ( interfaceMethods ) ; 
String sbbDeploymentPathStr = deployDir ; 
concreteActivityContextInterface . writeFile ( sbbDeploymentPathStr ) ; 
+ sbbDeploymentPathStr ) ; 
Class clazz = null ; 
clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( 
tmpClassName ) ; 
this . concreteActivityContextInterface . defrost ( ) ; 
} private void generateConcreteMethods ( Map interfaceMethods ) { 
if ( interfaceMethod != null 
&& ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( 
javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( 
ActivityContextInterfaceExt . class . getName ( ) ) ) ) 
CtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , 
concreteActivityContextInterface , null ) ; 
String fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; 
fieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) 
+ fieldName . substring ( 1 ) ; 
String concreteMethodBody = null ; 
if ( interfaceMethod . getName ( ) . startsWith ( "get" ) ) { 
} else if ( interfaceMethod . getName ( ) . startsWith ( "set" ) ) { 
+ concreteMethodBody ) ; 
concreteMethod . setBody ( concreteMethodBody ) ; 
concreteActivityContextInterface . addMethod ( concreteMethod ) ; 
} catch ( Exception cce ) { 
+ interfaceMethod . getName ( ) , cce ) ; 
} private static ProfileEntityArrayAttributeValue newProfileEntityArrayAttributeValueInstance ( 
Class < ? > profileAttrArrayValueClass , ProfileEntity owner ) { 
ProfileEntityArrayAttributeValue profileAttrArrayValue = null ; 
profileAttrArrayValue = ( ProfileEntityArrayAttributeValue ) profileAttrArrayValueClass 
profileAttrArrayValue . setProfileEntity ( owner ) ; 
return profileAttrArrayValue ; 
} private String getLog4jPath ( String profile ) { 
return ( profile == null || profile . equals ( "" ) || profile . equalsIgnoreCase ( "current" ) ) ? log4jConfigFilePath : log4jTemplatesPath + profile ; 
Alarm that = ( Alarm ) obj ; 
return this . alarmID . compareTo ( that . alarmID ) ; 
} public javax . slee . resource . ResourceAdaptorDescriptor getSpecsDescriptor ( ) { 
final ResourceAdaptorTypeID [ ] raTypeIDs = descriptor . getResourceAdaptorTypeRefs ( ) . toArray ( new ResourceAdaptorTypeID [ descriptor . getResourceAdaptorTypeRefs ( ) . size ( ) ] ) ; 
specsDescriptor = new javax . slee . resource . ResourceAdaptorDescriptor ( getResourceAdaptorID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , libraryIDs , raTypeIDs , profileSpecs , 
getDescriptor ( ) . getSupportsActiveReconfiguration ( ) ) ; 
} public ConfigProperties getDefaultConfigPropertiesInstance ( ) { 
ConfigProperties defaultProperties = new ConfigProperties ( ) ; 
for ( ConfigPropertyDescriptor mConfigProperty : getDescriptor ( ) . getConfigProperties ( ) ) { 
Object configPropertyValue = mConfigProperty . getConfigPropertyValue ( ) == null ? null : ConfigProperties . Property . toObject ( mConfigProperty . getConfigPropertyType ( ) , mConfigProperty 
. getConfigPropertyValue ( ) ) ; 
defaultProperties . addProperty ( new ConfigProperties . Property ( mConfigProperty . getConfigPropertyName ( ) , mConfigProperty . getConfigPropertyType ( ) , configPropertyValue ) ) ; 
return defaultProperties ; 
} public int getActivityFlags ( ) { 
if ( flags == null ) { 
if ( localActivityContext != null ) { 
flags = localActivityContext . getActivityFlags ( ) ; 
flags = ( Integer ) cacheData 
. getObject ( NODE_MAP_KEY_ACTIVITY_FLAGS ) ; 
return flags != null ? flags : ActivityFlags . NO_FLAGS ; 
} public void setDataAttribute ( String key , Object newValue ) { 
cacheData . setCmpAttribute ( key , newValue ) ; 
} public void addNameBinding ( String aciName ) { 
cacheData . nameBound ( aciName ) ; 
if ( acReferencesHandler != null ) { 
acReferencesHandler . nameReferenceCreated ( ) ; 
} private void removeNamingBindings ( ) { 
ActivityContextNamingFacility acf = sleeContainer 
. getActivityContextNamingFacility ( ) ; 
for ( Object obj : cacheData . getNamesBoundCopy ( ) ) { 
String aciName = ( String ) obj ; 
acf . removeName ( aciName ) ; 
+ getActivityContextHandle ( ) , e ) ; 
} public boolean removeNameBinding ( String aciName ) { 
boolean removed = cacheData . nameUnbound ( aciName ) ; 
if ( removed && acReferencesHandler != null ) { 
acReferencesHandler . nameReferenceRemoved ( ) ; 
if ( cacheData . attachTimer ( timerID ) ) { 
acReferencesHandler . timerReferenceCreated ( ) ; 
boolean detached = cacheData . detachTimer ( timerID ) ; 
if ( detached && acReferencesHandler != null ) { 
acReferencesHandler . timerReferenceRemoved ( ) ; 
return detached ; 
} private void removeFromTimers ( ) { 
TimerFacility timerFacility = sleeContainer . getTimerFacility ( ) ; 
for ( Object obj : cacheData . getAttachedTimers ( ) ) { 
timerFacility . cancelTimer ( ( TimerID ) obj , false ) ; 
boolean attached = cacheData . attachSbbEntity ( sbbEntityId ) ; 
acReferencesHandler . sbbeReferenceCreated ( false ) ; 
+ attached ) ; 
return attached ; 
} public void detachSbbEntity ( SbbEntityID sbbEntityId ) 
throws javax . slee . TransactionRequiredLocalException { 
boolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; 
if ( detached && acReferencesHandler != null && ! isEnding ( ) ) { 
acReferencesHandler . sbbeReferenceRemoved ( ) ; 
} public Set < SbbEntityID > getSortedSbbAttachmentSet ( 
Set < SbbEntityID > excludeSet ) { 
final Set < SbbEntityID > sbbAttachementSet = cacheData 
. getSbbEntitiesAttached ( ) ; 
Set < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; 
for ( SbbEntityID sbbEntityId : sbbAttachementSet ) { 
if ( ! excludeSet . contains ( sbbEntityId ) ) { 
result . add ( sbbEntityId ) ; 
if ( result . size ( ) > 1 ) { 
result = sleeContainer . getSbbEntityFactory ( ) . sortByPriority ( result ) ; 
} private void updateLastAccessTime ( boolean creation ) { 
if ( creation ) { 
cacheData . putObject ( NODE_MAP_KEY_LAST_ACCESS , 
Long . valueOf ( System . currentTimeMillis ( ) ) ) ; 
ActivityManagementConfiguration configuration = factory 
. getConfiguration ( ) ; 
Long lastUpdate = ( Long ) cacheData 
. getObject ( NODE_MAP_KEY_LAST_ACCESS ) ; 
if ( lastUpdate != null ) { 
if ( ( now - configuration . getMinTimeBetweenUpdatesInMs ( ) ) > lastUpdate 
. longValue ( ) ) { 
+ getActivityContextHandle ( ) ) ; 
Long . valueOf ( now ) ) ; 
} public void fireEvent ( EventTypeID eventTypeId , Object event , 
Address address , ServiceID serviceID , 
EventUnreferencedCallback unreferencedCallback ) 
if ( isEnding ( ) ) { 
throw new ActivityIsEndingException ( getActivityContextHandle ( ) 
acReferencesHandler . eventReferenceCreated ( ) ; 
fireEvent ( 
sleeContainer . getEventContextFactory ( ) . createEventContext ( 
eventTypeId , event , this , address , serviceID , 
succeedCallback , failedCallback , unreferencedCallback ) , 
sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ) ; 
} public void endActivity ( ) { 
if ( cacheData . setEnding ( true ) ) { 
sleeContainer 
. getEventContextFactory ( ) 
. createActivityEndEventContext ( 
new ActivityEndEventUnreferencedCallback ( 
getActivityContextHandle ( ) , factory ) ) , 
sleeContainer . getTransactionManager ( ) 
. getTransactionContext ( ) ) ; 
} public void addComponent ( DeployableComponent dc ) { 
if ( logger . isTraceEnabled ( ) ) 
components . add ( dc ) ; 
componentIDs . add ( dc . getComponentKey ( ) ) ; 
dependencies . addAll ( dc . getDependencies ( ) ) ; 
installActions . addAll ( dc . getInstallActions ( ) ) ; 
Collection < ManagementAction > postInstallActionsStrings = postInstallActions 
. remove ( dc . getComponentKey ( ) ) ; 
if ( postInstallActionsStrings != null 
&& ! postInstallActionsStrings . isEmpty ( ) ) { 
installActions . addAll ( postInstallActionsStrings ) ; 
Collection < ManagementAction > preUninstallActionsStrings = preUninstallActions 
if ( preUninstallActionsStrings != null ) 
uninstallActions . addAll ( preUninstallActionsStrings ) ; 
uninstallActions . addAll ( dc . getUninstallActions ( ) ) ; 
} public Collection < String > getExternalDependencies ( ) { 
Collection < String > externalDependencies = new HashSet < String > ( dependencies ) ; 
externalDependencies . removeAll ( componentIDs ) ; 
return externalDependencies ; 
} public boolean hasDependenciesSatisfied ( boolean showMissing ) { 
if ( isSelfSufficient ( ) ) 
Collection < String > externalDependencies = getExternalDependencies ( ) ; 
externalDependencies . removeAll ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) ) ; 
if ( ! externalDependencies . isEmpty ( ) ) { 
if ( showMissing ) { 
String missingDepList = "" ; 
for ( String missingDep : externalDependencies ) 
+ ":" + missingDepList ) ; 
} public boolean hasDuplicates ( ) { 
ArrayList < String > duplicates = new ArrayList < String > ( ) ; 
for ( String componentId : componentIDs ) { 
if ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) . contains ( componentId ) ) { 
duplicates . add ( componentId ) ; 
if ( ! duplicates . isEmpty ( ) ) { 
for ( String dupComponent : duplicates ) { 
} public Collection < ManagementAction > getInstallActions ( ) { 
ArrayList < ManagementAction > iActions = new ArrayList < ManagementAction > ( ) ; 
if ( ! postInstallActions . values ( ) . isEmpty ( ) ) { 
for ( String componentId : postInstallActions . keySet ( ) ) { 
iActions . addAll ( postInstallActions . get ( componentId ) ) ; 
iActions . addAll ( installActions ) ; 
return iActions ; 
} public Collection < ManagementAction > getUninstallActions ( ) { 
Collection < ManagementAction > uActions = new ArrayList < ManagementAction > ( uninstallActions ) ; 
uActions . add ( new UninstallDeployableUnitAction ( diURL . toString ( ) , sleeContainerDeployer . getDeploymentMBean ( ) ) ) ; 
if ( ! preUninstallActions . values ( ) . isEmpty ( ) ) { 
for ( String componentId : preUninstallActions . keySet ( ) ) { 
uActions . addAll ( preUninstallActions . get ( componentId ) ) ; 
return uActions ; 
} private boolean hasReferringDU ( ) throws Exception { 
SleeContainer sC = SleeContainer . lookupFromJndi ( ) ; 
for ( String componentIdString : this . getComponents ( ) ) { 
cidpe . setAsText ( componentIdString ) ; 
ComponentID componentId = ( ComponentID ) cidpe . getValue ( ) ; 
for ( ComponentID referringComponentId : sC . getComponentRepository ( ) . getReferringComponents ( componentId ) ) { 
ComponentIDPropertyEditor rcidpe = new ComponentIDPropertyEditor ( ) ; 
rcidpe . setValue ( referringComponentId ) ; 
String referringComponentIdString = rcidpe . getAsText ( ) ; 
if ( ! this . getComponents ( ) . contains ( referringComponentIdString ) ) { 
} private void parseDUDeployConfig ( ) throws Exception { 
JarFile componentJarFile = new JarFile ( diURL . getFile ( ) ) ; 
JarEntry deployInfoXML = componentJarFile 
. getJarEntry ( "META-INF/deploy-config.xml" ) ; 
if ( deployInfoXML != null ) { 
DeployConfigParser deployConfigParser = new DeployConfigParser ( 
componentJarFile . getInputStream ( deployInfoXML ) , 
sleeContainerDeployer . getSleeContainer ( ) 
. getResourceManagement ( ) ) ; 
for ( Entry < String , Collection < ManagementAction > > e : deployConfigParser . getPostInstallActions ( ) . entrySet ( ) ) { 
postInstallActions . put ( e . getKey ( ) , e . getValue ( ) ) ; 
for ( Entry < String , Collection < ManagementAction > > e : deployConfigParser . getPreUninstallActions ( ) . entrySet ( ) ) { 
preUninstallActions . put ( e . getKey ( ) , e . getValue ( ) ) ; 
} public static void close ( String profileTableName , String profileName ) { 
final ObjectName objectName = getObjectName ( profileTableName , profileName ) ; 
if ( sleeContainer . getMBeanServer ( ) . isRegistered ( objectName ) ) { 
Runnable r = new Runnable ( ) { 
sleeContainer . getMBeanServer ( ) . invoke ( objectName , "close" , new Object [ ] { } , new String [ ] { } ) ; 
Thread t = new Thread ( r ) ; 
} public static ObjectName getObjectName ( 
String profileTableName , String profileName ) { 
return new ObjectName ( ProfileMBean . BASE_OBJECT_NAME + ',' 
+ ProfileMBean . PROFILE_TABLE_NAME_KEY + '=' 
+ profileTableName + ',' 
+ ProfileMBean . PROFILE_NAME_KEY + '=' 
+ ( profileName != null ? profileName : "" ) ) ; 
+ ObjectName . quote ( profileTableName ) + ',' 
+ ObjectName . quote ( profileName != null ? profileName : "" ) ) ; 
} private void writeMode ( ) throws SLEEException , ManagementException { 
if ( ! isProfileWriteable ( ) ) { 
ProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; 
profileObject . getProfileEntity ( ) . setReadOnly ( false ) ; 
state = State . write ; 
} public void closeProfile ( ) throws InvalidStateException , ManagementException { 
if ( this . isProfileWriteable ( ) ) 
throw new InvalidStateException ( ) ; 
unregister ( ) ; 
} public void commitProfile ( ) throws InvalidStateException , ProfileVerificationException , ManagementException { 
if ( ! this . isProfileWriteable ( ) ) 
ProfileEntity profileEntity = null ; 
txManager . resume ( this . transaction ) ; 
ProfileObjectImpl profileObject = getProfileObject ( ) ; 
profileObject . profileVerify ( ) ; 
if ( txManager . getRollbackOnly ( ) ) { 
EntityManager em = getEntityManager ( txManager ) ; 
txManager . rollback ( ) ; 
if ( em != null && em . isOpen ( ) ) { 
em . close ( ) ; 
readMode ( ) ; 
this . transaction = null ; 
profileEntity = profileObject . getProfileEntity ( ) ; 
txManager . commit ( ) ; 
} catch ( ProfileVerificationException e ) { 
} catch ( RollbackException e ) { 
if ( e . getCause ( ) instanceof PersistenceException && e . getCause ( ) . getCause ( ) instanceof ConstraintViolationException ) { 
throw new ProfileVerificationException ( e . getCause ( ) . getMessage ( ) , e ) ; 
if ( this . transaction == null ) { 
if ( isProfileWriteable ( ) ) { 
txManager . begin ( ) ; 
this . transaction = txManager . getTransaction ( ) ; 
ProfileEntity newTxProfileEntity = profileEntity . isCreate ( ) ? profileTable . createProfile ( profileName ) . getProfileEntity ( ) : getProfileObject ( ) . getProfileEntity ( ) ; 
profileTable . getProfileSpecificationComponent ( ) . getProfileEntityFramework ( ) . getProfileEntityFactory ( ) . copyAttributes ( profileEntity , newTxProfileEntity ) ; 
newTxProfileEntity . setReadOnly ( false ) ; 
txManager . suspend ( ) ; 
logger . error ( f . getMessage ( ) , f ) ; 
} protected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { 
sleeContainer . getTransactionManager ( ) . resume ( transaction ) ; 
} protected void afterSetCmpField ( ) throws ManagementException { 
sleeContainer . getTransactionManager ( ) . suspend ( ) ; 
} protected boolean beforeGetCmpField ( ) throws ManagementException { 
return beforeNonSetCmpField ( ) ; 
} protected void afterGetCmpField ( boolean activatedTransaction ) throws ManagementException { 
afterNonSetCmpField ( activatedTransaction ) ; 
} protected boolean beforeManagementMethodInvocation ( ) throws ManagementException { 
jndiManagement = sleeContainer . getJndiManagement ( ) ; 
jndiManagement . pushJndiContext ( profileTable . getProfileSpecificationComponent ( ) ) ; 
} protected void afterManagementMethodInvocation ( boolean activatedTransaction ) throws ManagementException { 
} protected void throwableOnManagementMethodInvocation ( Throwable t ) throws ProfileImplementationException , InvalidStateException , ManagementException { 
if ( t instanceof ProfileImplementationException ) { 
throw ( ProfileImplementationException ) t ; 
} else if ( t instanceof InvalidStateException ) { 
throw ( InvalidStateException ) t ; 
} else if ( t instanceof ReadOnlyProfileException ) { 
throw new InvalidStateException ( t . getMessage ( ) ) ; 
} else if ( t instanceof ManagementException ) { 
throw ( ManagementException ) t ; 
} else if ( t instanceof RuntimeException ) { 
getProfileObject ( ) . invalidateObject ( ) ; 
throw new ProfileImplementationException ( t ) ; 
} public void suspendDelivery ( int arg0 ) throws IllegalArgumentException , 
suspensionHandlerLazyInit ( ) ; 
suspensionHandler . suspendDelivery ( arg0 ) ; 
} public void eventProcessingFailed ( FailureReason reason ) { 
if ( data . getFailedCallback ( ) != null ) { 
data . getFailedCallback ( ) . eventProcessingFailed ( reason ) ; 
canceled ( ) ; 
if ( data . getSucceedCallback ( ) != null ) { 
data . getSucceedCallback ( ) . eventProcessingSucceed ( sbbProcessedEvent ) ; 
data . unsetFailedCallback ( ) ; 
} public boolean routedRequiresTransaction ( ) { 
final EventUnreferencedCallback unreferencedCallback = data . getUnreferencedCallback ( ) ; 
if ( unreferencedCallback == null ) { 
return unreferencedCallback . requiresTransaction ( ) ; 
} public static String getUsageMBeanProperties ( String entityName ) { 
return RESOURCE_ADAPTOR_ENTITY_NAME_KEY + '=' + ObjectName . quote ( entityName ) ; 
if ( obj instanceof ResourceAdaptorEntityNotification ) { 
ResourceAdaptorEntityNotification that = ( ResourceAdaptorEntityNotification ) obj ; 
return this . entityName . compareTo ( that . entityName ) ; 
} public static String getUsageMBeanProperties ( ServiceID service , SbbID sbb ) { 
buf . append ( SERVICE_NAME_KEY ) . append ( '=' ) . append ( ObjectName . quote ( service . getName ( ) ) ) . append ( ',' ) ; 
buf . append ( SERVICE_VENDOR_KEY ) . append ( '=' ) . append ( ObjectName . quote ( service . getVendor ( ) ) ) . append ( ',' ) ; 
buf . append ( SERVICE_VERSION_KEY ) . append ( '=' ) . append ( ObjectName . quote ( service . getVersion ( ) ) ) . append ( ',' ) ; 
buf . append ( SBB_NAME_KEY ) . append ( '=' ) . append ( ObjectName . quote ( sbb . getName ( ) ) ) . append ( ',' ) ; 
buf . append ( SBB_VENDOR_KEY ) . append ( '=' ) . append ( ObjectName . quote ( sbb . getVendor ( ) ) ) . append ( ',' ) ; 
buf . append ( SBB_VERSION_KEY ) . append ( '=' ) . append ( ObjectName . quote ( sbb . getVersion ( ) ) ) ; 
if ( obj instanceof SbbNotification ) { 
SbbNotification that = ( SbbNotification ) obj ; 
int serviceComparison = this . service . compareTo ( that . service ) ; 
return serviceComparison != 0 ? serviceComparison : this . sbb . compareTo ( that . sbb ) ; 
} public Set < SleeComponent > getDeployableUnitComponents ( ) { 
result . addAll ( getEventTypeComponents ( ) . values ( ) ) ; 
result . addAll ( getLibraryComponents ( ) . values ( ) ) ; 
result . addAll ( getProfileSpecificationComponents ( ) . values ( ) ) ; 
result . addAll ( getResourceAdaptorComponents ( ) . values ( ) ) ; 
result . addAll ( getResourceAdaptorTypeComponents ( ) . values ( ) ) ; 
result . addAll ( getSbbComponents ( ) . values ( ) ) ; 
result . addAll ( getServiceComponents ( ) . values ( ) ) ; 
return Collections . unmodifiableSet ( result ) ; 
} private void deletePath ( File path ) { 
if ( path . isDirectory ( ) ) { 
File [ ] files = path . listFiles ( ) ; 
deletePath ( file ) ; 
path . delete ( ) ; 
} public javax . slee . management . DeployableUnitDescriptor getSpecsDeployableUnitDescriptor ( ) { 
Set < ComponentID > componentIDs = new HashSet < ComponentID > ( ) ; 
for ( SleeComponent component : getDeployableUnitComponents ( ) ) { 
componentIDs . add ( component . getComponentID ( ) ) ; 
return new DeployableUnitDescriptor ( getDeployableUnitID ( ) , date , 
componentIDs . toArray ( new ComponentID [ 0 ] ) ) ; 
ActivityContextImpl ac = factory . getActivityContext ( ach ) ; 
ac . activityEnded ( ) ; 
this . activityHandle = new ProfileTableActivityHandleImpl ( in . readUTF ( ) , 
( Address ) in . readObject ( ) ) ; 
out . writeUTF ( activityHandle . getProfileTable ( ) ) ; 
out . writeObject ( activityHandle . getClusterLocalAddress ( ) ) ; 
} private void createConstructor ( CtClass concreteClass , CtClass usageMBeanInterface , CtClass notificationSource , CtClass usageComponent ) 
CtConstructor ctCons = new CtConstructor ( new CtClass [ ] { usageMBeanInterface , notificationSource , usageComponent } , concreteClass ) ; 
concreteClass . addConstructor ( ctCons ) ; 
} public void setMinFreeMemoryToTurnOn ( int minFreeMemoryToTurnOn ) throws IllegalArgumentException { 
if ( minFreeMemoryToTurnOn < 0 || minFreeMemoryToTurnOn > 100 ) { 
this . minFreeMemoryToTurnOn = minFreeMemoryToTurnOn ; 
if ( congestureControl != null ) { 
congestureControl . configurationUpdate ( ) ; 
} public void setMinFreeMemoryToTurnOff ( int minFreeMemoryToTurnOff ) throws IllegalArgumentException { 
if ( minFreeMemoryToTurnOff < 0 || minFreeMemoryToTurnOff > 100 ) { 
this . minFreeMemoryToTurnOff = minFreeMemoryToTurnOff ; 
} public void setPeriodBetweenChecks ( int periodBetweenChecks ) throws IllegalArgumentException { 
if ( periodBetweenChecks < 0 ) { 
this . periodBetweenChecks = periodBetweenChecks ; 
} public void generateConcreteSbb ( ) throws DeploymentException { 
String sbbAbstractClassName = sbbComponent . getAbstractSbbClass ( ) 
. getName ( ) ; 
String sbbConcreteClassName = ConcreteClassGeneratorUtils 
. getSbbConcreteClassName ( sbbAbstractClassName ) ; 
sbbConcreteClass = pool . makeClass ( sbbConcreteClassName ) ; 
sbbAbstractClass = pool . get ( sbbAbstractClassName ) ; 
throw new DeploymentException ( nfe . getMessage ( ) , nfe ) ; 
generateAbstractSbbClassInfo ( ) ; 
sbbConcreteClass , new CtClass [ ] { pool 
. get ( SbbConcrete . class . getName ( ) ) } ) ; 
ConcreteClassGeneratorUtils . createInheritanceLink ( sbbConcreteClass , 
sbbAbstractClass ) ; 
abstractMethods = ClassUtils 
. getAbstractMethodsFromClass ( sbbAbstractClass ) ; 
superClassesAbstractMethods = ClassUtils 
. getSuperClassesAbstractMethodsFromClass ( sbbAbstractClass ) ; 
createFields ( new CtClass [ ] { 
pool . get ( SbbEntity . class . getName ( ) ) , 
pool . get ( SbbObjectState . class . getName ( ) ) } ) ; 
CtClass [ ] parameters = new CtClass [ ] { pool . get ( SbbEntity . class 
. getName ( ) ) } ; 
createSbbEntityGetterAndSetter ( sbbConcreteClass ) ; 
createDefaultUsageParameterGetter ( sbbConcreteClass ) ; 
createNamedUsageParameterGetter ( sbbConcreteClass ) ; 
createDefaultConstructor ( ) ; 
createConstructorWithParameter ( parameters ) ; 
SbbAbstractClassDescriptor mSbbAbstractClass = sbbComponent . getDescriptor ( ) 
. getSbbAbstractClass ( ) ; 
createCMPAccessors ( mSbbAbstractClass . getCmpFields ( ) ) ; 
createGetChildRelationsMethod ( mSbbAbstractClass 
. getChildRelationMethods ( ) . values ( ) ) ; 
createGetProfileCMPMethods ( mSbbAbstractClass . getProfileCMPMethods ( ) 
. values ( ) ) ; 
createFireEventMethods ( sbbComponent . getDescriptor ( ) 
. getEventEntries ( ) . values ( ) ) ; 
if ( sbbComponent . getDescriptor ( ) 
. getSbbActivityContextInterface ( ) != null ) { 
Class < ? > activityContextInterfaceClass = null ; 
activityContextInterfaceClass = Thread . currentThread ( ) 
. getContextClassLoader ( ) . loadClass ( 
sbbComponent . getDescriptor ( ) 
. getSbbActivityContextInterface ( ) ) ; 
} catch ( ClassNotFoundException e2 ) { 
logger . error ( s , e2 ) ; 
throw new DeploymentException ( s , e2 ) ; 
Method [ ] methods = activityContextInterfaceClass . getMethods ( ) ; 
ArrayList < String > allSetters = new ArrayList < String > ( ) ; 
ArrayList < String > missingSetters = new ArrayList < String > ( ) ; 
if ( methods != null ) { 
if ( ! methods [ i ] . getDeclaringClass ( ) . getName ( ) . equals ( 
javax . slee . ActivityContextInterface . class . getName ( ) ) && ! methods [ i ] . getDeclaringClass ( ) . getName ( ) . equals ( 
ActivityContextInterfaceExt . class . getName ( ) ) ) { 
String methodName = methods [ i ] . getName ( ) ; 
if ( methodName . startsWith ( "set" ) ) { 
Class < ? > [ ] args = methods [ i ] . getParameterTypes ( ) ; 
if ( args . length != 1 ) 
+ methodName 
Class < ? > returnClass = methods [ i ] . getReturnType ( ) ; 
if ( ! returnClass . equals ( Void . TYPE ) ) 
allSetters . add ( methodName ) ; 
} else if ( methodName . startsWith ( "get" ) ) { 
if ( args != null && args . length != 0 ) 
if ( methods [ i ] . getReturnType ( ) 
. equals ( Void . TYPE ) ) 
String setterName = methodName . replaceFirst ( 
"get" , "set" ) ; 
activityContextInterfaceClass . getMethod ( 
setterName , methods [ i ] 
. getReturnType ( ) ) ; 
} catch ( NoSuchMethodException nsme ) { 
missingSetters . add ( setterName ) ; 
for ( String setter : missingSetters ) 
if ( allSetters . contains ( setter ) ) 
+ setter . replaceFirst ( "set" , "" ) 
. toLowerCase ( ) 
CtClass activityContextInterface = null ; 
activityContextInterface = pool 
. get ( activityContextInterfaceClass . getName ( ) ) ; 
createField ( activityContextInterface , 
"sbbActivityContextInterface" ) ; 
this 
. createSetActivityContextInterfaceMethod ( activityContextInterface ) ; 
ConcreteActivityContextInterfaceGenerator concreteActivityContextInterfaceGenerator = new ConcreteActivityContextInterfaceGenerator ( 
activityContextInterfaceClass . getName ( ) , deployDir , 
pool ) ; 
Class < ? > concreteActivityContextInterfaceClass = concreteActivityContextInterfaceGenerator 
. generateActivityContextInterfaceConcreteClass ( ) ; 
createGetSbbActivityContextInterfaceMethod ( 
activityContextInterface , 
concreteActivityContextInterfaceClass ) ; 
+ concreteActivityContextInterfaceClass 
. setActivityContextInterfaceConcreteClass ( concreteActivityContextInterfaceClass ) ; 
Class < ? > sbbLocalInterfaceClass = sbbComponent 
. getSbbLocalInterfaceClass ( ) ; 
+ sbbLocalInterfaceClass ) ; 
if ( sbbLocalInterfaceClass != null 
&& ! sbbLocalInterfaceClass . getName ( ) . equals ( 
"javax.slee.SbbLocalObject" ) ) { 
pool . get ( sbbLocalInterfaceClass . getName ( ) ) ; 
ConcreteSbbLocalObjectGenerator concreteSbbLocalObjectGenerator = new ConcreteSbbLocalObjectGenerator ( 
sbbLocalInterfaceClass . getName ( ) , 
sbbAbstractClassName , this . deployDir , pool ) ; 
Class < ? > concreteSbbLocalObjectClass = concreteSbbLocalObjectGenerator 
. generateSbbLocalObjectConcreteClass ( ) ; 
. setSbbLocalInterfaceConcreteClass ( concreteSbbLocalObjectClass ) ; 
+ sbbLocalInterfaceClass . getName ( ) ; 
throw new DeploymentException ( s , nfe ) ; 
. setSbbLocalInterfaceClass ( SbbLocalObject . class ) ; 
. setSbbLocalInterfaceConcreteClass ( SbbLocalObjectImpl . class ) ; 
throw new DeploymentException ( e . getMessage ( ) , e ) ; 
sbbConcreteClass . writeFile ( deployDir ) ; 
throw new DeploymentException ( s , e ) ; 
clazz = Thread . currentThread ( ) . getContextClassLoader ( ) 
. loadClass ( sbbConcreteClassName ) ; 
} catch ( ClassNotFoundException e1 ) { 
throw new DeploymentException ( s , e1 ) ; 
sbbComponent . setConcreteSbbClass ( clazz ) ; 
if ( sbbConcreteClass != null ) { 
sbbConcreteClass . defrost ( ) ; 
if ( sbbComponent . getConcreteSbbClass ( ) == null ) { 
} private void generateAbstractSbbClassInfo ( ) { 
CtClass sbbClass = null ; 
sbbClass = pool . get ( Sbb . class . getName ( ) ) ; 
AbstractSbbClassInfo abstractSbbClassInfo = sbbComponent . getAbstractSbbClassInfo ( ) ; 
for ( CtMethod sbbClassMethod : sbbClass . getDeclaredMethods ( ) ) { 
for ( CtMethod sbbAbstractClassMethod : sbbAbstractClass 
. getMethods ( ) ) { 
if ( sbbAbstractClassMethod . getName ( ) . equals ( 
sbbClassMethod . getName ( ) ) 
&& sbbAbstractClassMethod . getSignature ( ) . equals ( 
sbbClassMethod . getSignature ( ) ) ) { 
abstractSbbClassInfo . setInvokeInfo ( sbbAbstractClassMethod 
. getMethodInfo ( ) . getName ( ) , ! sbbAbstractClassMethod 
. isEmpty ( ) ) ; 
} protected void createConstructorWithParameter ( CtClass [ ] parameters ) 
CtConstructor constructorWithParameter = new CtConstructor ( parameters , 
sbbConcreteClass ) ; 
String constructorBody = "{" + "this();" ; 
constructorBody += "this.setSbbEntity($1);" ; 
constructorBody += "}" ; 
sbbConcreteClass . addConstructor ( constructorWithParameter ) ; 
constructorWithParameter . setBody ( constructorBody ) ; 
} protected void createDefaultConstructor ( ) throws DeploymentException { 
CtConstructor defaultConstructor = new CtConstructor ( null , 
defaultConstructor . setBody ( constructorBody ) ; 
sbbConcreteClass . addConstructor ( defaultConstructor ) ; 
} private void createDefaultUsageParameterGetter ( CtClass sbbConcrete ) 
String methodName = "getDefaultSbbUsageParameterSet" ; 
CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; 
method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; 
if ( method != null ) { 
CtMethod concreteMethod = CtNewMethod . copy ( method , 
sbbConcreteClass , null ) ; 
+ SbbAbstractMethodHandler . class . getName ( ) 
sbbConcreteClass . addMethod ( concreteMethod ) ; 
+ method . getName ( ) , cce ) ; 
} private void createSbbEntityGetterAndSetter ( CtClass sbbConcrete ) 
CtMethod getSbbEntity = CtNewMethod 
sbbConcrete ) ; 
getSbbEntity . setModifiers ( Modifier . PUBLIC ) ; 
sbbConcrete . addMethod ( getSbbEntity ) ; 
CtMethod setSbbEntity = CtNewMethod . make ( 
setSbbEntity . setModifiers ( Modifier . PUBLIC ) ; 
sbbConcrete . addMethod ( setSbbEntity ) ; 
} protected void createCMPAccessors ( Collection < CMPFieldDescriptor > cmps ) 
for ( CMPFieldDescriptor cmp : cmps ) { 
String fieldName = cmp . getCmpFieldName ( ) ; 
fieldName = fieldName . substring ( 0 , 1 ) . toUpperCase ( ) 
String getterMethodName = "get" + fieldName ; 
CtMethod getterMethod = ( CtMethod ) abstractMethods 
. get ( getterMethodName ) ; 
if ( getterMethod == null ) { 
getterMethod = ( CtMethod ) this . superClassesAbstractMethods 
+ getterMethodName ) ; 
String getterHandlerMethodName = "getCMPFieldOfType" ; 
boolean getterHandlerMethodNeedResultCast = false ; 
String setterHandlerMethodName = "setCMPFieldOfType" ; 
CtClass ctClassCmpType = getterMethod . getReturnType ( ) ; 
if ( ctClassCmpType . isPrimitive ( ) ) { 
String ctClassCmpTypeName = ctClassCmpType . getName ( ) ; 
if ( ctClassCmpTypeName . equals ( boolean . class . getName ( ) ) ) { 
getterHandlerMethodName += "Boolean" ; 
else if ( ctClassCmpTypeName . equals ( byte . class . getName ( ) ) ) { 
getterHandlerMethodName += "Byte" ; 
else if ( ctClassCmpTypeName . equals ( char . class . getName ( ) ) ) { 
getterHandlerMethodName += "Char" ; 
else if ( ctClassCmpTypeName . equals ( short . class . getName ( ) ) ) { 
getterHandlerMethodName += "Short" ; 
else if ( ctClassCmpTypeName . equals ( int . class . getName ( ) ) ) { 
getterHandlerMethodName += "Integer" ; 
else if ( ctClassCmpTypeName . equals ( long . class . getName ( ) ) ) { 
getterHandlerMethodName += "Long" ; 
else if ( ctClassCmpTypeName . equals ( float . class . getName ( ) ) ) { 
getterHandlerMethodName += "Float" ; 
else if ( ctClassCmpTypeName . equals ( double . class . getName ( ) ) ) { 
getterHandlerMethodName += "Double" ; 
+ ctClassCmpTypeName ) ; 
getterHandlerMethodNeedResultCast = true ; 
setterHandlerMethodName += "PrimitiveOrUnknown" ; 
if ( ! ctClassCmpType . isArray ( ) && ! ctClassCmpType . isEnum ( ) && ! ctClassCmpType . isAnnotation ( ) ) { 
Class < ? > classCmpType = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( ctClassCmpType . getName ( ) ) ; 
if ( javax . slee . ActivityContextInterface . class . isAssignableFrom ( classCmpType ) ) { 
getterHandlerMethodName += "ActivityContextInterface" ; 
setterHandlerMethodName += "ActivityContextInterface" ; 
else if ( EventContext . class . isAssignableFrom ( classCmpType ) ) { 
getterHandlerMethodName += "EventContext" ; 
setterHandlerMethodName += "EventContext" ; 
else if ( ProfileLocalObject . class . isAssignableFrom ( classCmpType ) ) { 
getterHandlerMethodName += "ProfileLocalObject" ; 
setterHandlerMethodName += "ProfileLocalObject" ; 
else if ( SbbLocalObject . class . isAssignableFrom ( classCmpType ) ) { 
getterHandlerMethodName += "SbbLocalObject" ; 
setterHandlerMethodName += "SbbLocalObject" ; 
if ( this . initializeReferenceDataTypesWithNull ) { 
getterHandlerMethodName += "Unknown" ; 
if ( ctClassCmpTypeName . equals ( Boolean . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Byte . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Character . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Short . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Integer . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Long . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Float . class . getName ( ) ) ) { 
} else if ( ctClassCmpTypeName . equals ( Double . class . getName ( ) ) ) { 
CtMethod concreteGetterMethod = CtNewMethod . copy ( getterMethod , 
concreteGetterMethod . setBody ( concreteGetterMethodBody ) ; 
sbbConcreteClass . addMethod ( concreteGetterMethod ) ; 
+ getterMethod . getName ( ) , cce ) ; 
String setterMethodName = "set" + fieldName ; 
CtMethod setterMethod = ( CtMethod ) abstractMethods 
. get ( setterMethodName ) ; 
if ( setterMethod == null ) { 
setterMethod = ( CtMethod ) this . superClassesAbstractMethods 
+ setterMethodName ) ; 
CtMethod concreteSetterMethod = CtNewMethod . copy ( setterMethod , 
+ "." + setterHandlerMethodName + "(sbbEntity,\"" + cmp . getCmpFieldName ( ) 
concreteSetterMethod . setBody ( concreteSetterMethodBody ) ; 
sbbConcreteClass . addMethod ( concreteSetterMethod ) ; 
} protected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { 
if ( mEventEntries == null ) 
for ( EventEntryDescriptor mEventEntry : mEventEntries ) { 
if ( mEventEntry . isFired ( ) ) { 
String methodName = "fire" + mEventEntry . getEventName ( ) ; 
method = ( CtMethod ) superClassesAbstractMethods 
. get ( methodName ) ; 
String concreteMethodBody = "{" ; 
concreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; 
concreteMethodBody += SbbAbstractMethodHandler . class 
+ ".fireEvent(sbbEntity,eventTypeID" ; 
for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { 
concreteMethodBody += ",$" + ( i + 1 ) ; 
concreteMethodBody += ");}" ; 
+ method . getName ( ) , e ) ; 
} protected void createGetChildRelationsMethod ( 
Collection < GetChildRelationMethodDescriptor > childRelations ) { 
if ( childRelations == null ) 
for ( GetChildRelationMethodDescriptor childRelation : childRelations ) { 
String methodName = childRelation . getChildRelationMethodName ( ) ; 
+ ".getChildRelation(sbbEntity,\"" + methodName 
} protected void createGetProfileCMPMethods ( 
Collection < GetProfileCMPMethodDescriptor > cmpProfiles ) { 
if ( cmpProfiles == null ) { 
for ( GetProfileCMPMethodDescriptor cmpProfile : cmpProfiles ) { 
String methodName = cmpProfile . getProfileCmpMethodName ( ) ; 
if ( method == null ) 
if ( method != null ) 
+ ".getProfileCMPMethod(sbbEntity,\"" + methodName 
} protected void createGetSbbActivityContextInterfaceMethod ( 
CtClass activityContextInterface , 
Class < ? > concreteActivityContextInterfaceClass ) 
+ activityContextInterface . getName ( ) 
+ "if(aci==null)" 
+ IllegalStateException . class . getName ( ) 
+ concreteActivityContextInterfaceClass . getName ( ) 
+ "sbbEntity.getSbbComponent());" + "}" ; 
methodTest = CtNewMethod . make ( methodToAdd , sbbConcreteClass ) ; 
sbbConcreteClass . addMethod ( methodTest ) ; 
} protected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { 
if ( expr instanceof CompositeQueryExpression ) { 
( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; 
else if ( expr instanceof Not ) { 
( ( Not ) expr ) . checkForCycles ( this ) ; 
exprs . add ( expr ) ; 
} void checkForCycles ( QueryExpression expr ) throws IllegalArgumentException { 
for ( int i = 0 ; i < exprs . size ( ) ; i ++ ) { 
QueryExpression nested = ( QueryExpression ) exprs . get ( i ) ; 
if ( nested instanceof CompositeQueryExpression ) { 
( ( CompositeQueryExpression ) nested ) . checkForCycles ( expr ) ; 
else if ( nested instanceof Not ) { 
( ( Not ) nested ) . checkForCycles ( expr ) ; 
} public static synchronized void bind ( String key , Object target ) throws NameAlreadyBoundException 
if ( wrapperMap . containsKey ( key ) == true ) 
wrapperMap . put ( key , target ) ; 
} public static void unbind ( String key ) throws NameNotFoundException 
if ( wrapperMap . remove ( key ) == null ) 
} public static void unbind ( Name name ) throws NameNotFoundException 
String key = name . toString ( ) ; 
} public static synchronized void rebind ( Name name , Object target ) throws NamingException 
rebind ( name , target , false ) ; 
} private static Context createSubcontext ( Context ctx , Name name ) throws NamingException 
Context subctx = ctx ; 
for ( int pos = 0 ; pos < name . size ( ) ; pos ++ ) 
String ctxName = name . get ( pos ) ; 
subctx = ( Context ) ctx . lookup ( ctxName ) ; 
catch ( NameNotFoundException e ) 
subctx = ctx . createSubcontext ( ctxName ) ; 
ctx = subctx ; 
return subctx ; 
} public void setLoggerLevel ( String loggerName , String level ) throws ManagementConsoleException { 
sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . setLoggerLevel ( loggerName , level ) ; 
} public LoggerInfo fetchLoggerInfo ( String loggerName ) throws ManagementConsoleException { 
if ( ! sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getLoggerNames ( null ) . contains ( loggerName ) ) 
sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . addLogger ( loggerName , Level . OFF ) ; 
int handlerNum = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . numberOfHandlers ( loggerName ) ; 
String _name = loggerName ; 
String _level = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getLoggerLevel ( loggerName ) ; 
boolean _parent = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getUseParentHandlersFlag ( loggerName ) ; 
String _filter = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getLoggerFilterClassName ( loggerName ) ; 
HandlerInfo [ ] hInfos = new HandlerInfo [ handlerNum ] ; 
for ( int i = 0 ; i < handlerNum ; i ++ ) { 
String _formatterClass = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getGenericHandlerFormatterClassName ( loggerName , i ) ; 
String _filterClass = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getGenericHandlerFilterClassName ( loggerName , i ) ; 
String _h_level = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getGenericHandlerLevel ( loggerName , i ) ; 
String _h_name = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getHandlerName ( loggerName , i ) ; 
String _h_className = sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . getHandlerClassName ( loggerName , i ) ; 
HandlerInfo hi = new HandlerInfo ( i , ( _h_name == null ? "" : _h_name ) , _filterClass , _formatterClass , _h_className , _h_level , new HashMap ( ) ) ; 
hInfos [ i ] = hi ; 
return new LoggerInfo ( _parent , _name , _filter , _level , hInfos ) ; 
} public void setUseParentHandlers ( String loggerName , boolean value ) throws ManagementConsoleException { 
sleeConnection . getSleeManagementMBeanUtils ( ) . getLogManagementMBeanUtils ( ) . setUseParentHandlersFlag ( loggerName , value ) ; 
} public Level getTraceLevel ( ComponentID componentId ) throws NullPointerException , UnrecognizedComponentException , FacilityException { 
checkComponentID ( componentId ) ; 
return this . traceLevelTable . get ( componentId ) . getLevel ( ) ; 
} public void createTrace ( ComponentID componentId , Level level , String messageType , String message , long timeStamp ) throws NullPointerException , IllegalArgumentException , 
UnrecognizedComponentException , FacilityException { 
MTraceLevel tl = this . traceLevelTable . get ( componentId ) ; 
this . notificationTypes . add ( messageType ) ; 
if ( tl == null ) 
Level lev = tl . getLevel ( ) ; 
int seqno = tl . getSeqno ( ) ; 
if ( lev . isOff ( ) ) 
if ( ! lev . isHigherLevel ( level ) ) { 
TraceNotification traceNotification = new TraceNotification ( traceMBeanImpl , messageType , componentId , level , message , null , seqno , timeStamp ) ; 
this . traceMBeanImpl . sendNotification ( traceNotification ) ; 
} private void gatherInfoFromURL ( URL url ) throws MalformedURLException { 
if ( url . getProtocol ( ) . equals ( "jar" ) ) { 
this . url = new URL ( url . getFile ( ) . replaceFirst ( "!/" , "/" ) ) ; 
this . url = url ; 
this . fullPath = this . url . getFile ( ) ; 
this . fileName = getFileNameInternal ( fullPath ) ; 
if ( this . serializedEvent == null ) 
out . writeInt ( this . serializedEvent . length ) ; 
out . write ( this . serializedEvent ) ; 
public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { 
int len = in . readInt ( ) ; 
this . serializedEvent = new byte [ len ] ; 
in . readFully ( serializedEvent ) ; 
} public void endActivity ( ) throws TransactionRequiredLocalException , 
logger . debug ( "NullActivity.endActivity()" ) ; 
sleeContainer . getActivityContextFactory ( ) . getActivityContext ( 
new NullActivityContextHandle ( handle ) ) 
. endActivity ( ) ; 
QueryExpression nested = this . expr ; 
} public boolean decorateAbstractSbb ( ) throws DeploymentException { 
String sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; 
+ sbbAbstractClassName , nfe ) ; 
concreteMethods = new HashMap ( ) ; 
concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; 
decorateENCBindCalls ( ) ; 
decorateNewThreadCalls ( ) ; 
if ( isAbstractSbbClassDecorated ) { 
sbbAbstractClass . writeFile ( deployDir ) ; 
sbbAbstractClass . detach ( ) ; 
+ sbbAbstractClass . getName ( ) 
sbbAbstractClass . defrost ( ) ; 
} public void invokeAndReturnvoid ( SbbConcrete proxy , String methodName , 
Object [ ] args , Class < ? > [ ] argTypes ) throws Exception { 
invokeAndReturnObject ( proxy , methodName , args , argTypes ) ; 
} private void createConstructor ( CtClass concreteClass , CtClass sleeContainerClass , CtClass resourceAdaptorTypeIDClass ) 
CtConstructor ctCons = new CtConstructor ( new CtClass [ ] { sleeContainerClass , resourceAdaptorTypeIDClass } , concreteClass ) ; 
} public void setTimeBetweenLivenessQueries ( long set ) { 
acFactory . getConfiguration ( ) . setTimeBetweenLivenessQueries ( set ) ; 
if ( set == 0 ) { 
cancelLivenessQuery ( ) ; 
scheduleLivenessQuery ( ) ; 
} public void endActivity ( ActivityContextHandle ach ) throws ManagementException { 
ActivityContext ac = acFactory . getActivityContext ( ach ) ; 
+ ach + "]!!" ) ; 
if ( ac . getActivityContextHandle ( ) . getActivityType ( ) == ActivityType . NULL ) { 
+ "]" ) ; 
NullActivity nullActivity = ( NullActivity ) ac . getActivityContextHandle ( ) . getActivityObject ( ) ; 
if ( nullActivity != null ) { 
nullActivity . endActivity ( ) ; 
} private Object [ ] listWithCriteria ( boolean listIDsOnly , boolean inDetails , 
int criteria , String comparisonCriteria ) { 
Iterator < ActivityContextHandle > it = this . acFactory . getAllActivityContextsHandles ( ) . iterator ( ) ; 
ArrayList < Object > lst = new ArrayList < Object > ( ) ; 
HashMap < SbbEntityID , SbbID > sbbEntityIdToSbbID = new HashMap < SbbEntityID , SbbID > ( ) ; 
ActivityContextHandle achOrig = it . next ( ) ; 
ActivityContextImpl ac = this . acFactory . getActivityContext ( achOrig ) ; 
Object activity = achOrig . getActivityObject ( ) ; 
if ( activity != null ) { 
String acId = ac . getStringID ( ) ; 
String acSource = achOrig . getActivityType ( ) == ActivityType . RA ? ( ( ResourceAdaptorActivityContextHandle ) achOrig ) . getResourceAdaptorEntity ( ) . getName ( ) : "" ; 
case LIST_BY_ACTIVITY_CLASS : 
if ( ! activity . getClass ( ) . getCanonicalName ( ) . equals ( comparisonCriteria ) ) { 
ac = null ; 
case LIST_BY_RAENTITY : 
if ( achOrig . getActivityType ( ) == ActivityType . RA ) { 
if ( ! acSource . equals ( comparisonCriteria ) ) 
case LIST_BY_SBBENTITY : 
for ( SbbEntityID sbbEntityID : ac . getSbbAttachmentSet ( ) ) { 
if ( sbbEntityID . toString ( ) . equals ( comparisonCriteria ) ) { 
case LIST_BY_SBBID : 
ComponentIDPropertyEditor propertyEditor = new ComponentIDPropertyEditor ( ) ; 
propertyEditor . setAsText ( comparisonCriteria ) ; 
SbbID idBeingLookedUp = ( SbbID ) propertyEditor . getValue ( ) ; 
SbbID implSbbID = null ; 
if ( sbbEntityIdToSbbID . containsKey ( sbbEntityID ) ) { 
implSbbID = sbbEntityIdToSbbID . get ( sbbEntityID ) ; 
SbbEntity sbbe = sbbEntityFactory . getSbbEntity ( sbbEntityID , false ) ; 
if ( sbbe == null ) { 
implSbbID = sbbe . getSbbId ( ) ; 
sbbEntityIdToSbbID . put ( sbbEntityID , implSbbID ) ; 
if ( ! implSbbID . equals ( idBeingLookedUp ) ) { 
match = true ; 
if ( ! match ) { 
case LIST_BY_NO_CRITERIA : 
if ( ac == null ) 
Object singleResult = null ; 
if ( ! listIDsOnly ) { 
Object [ ] o = getDetails ( ac ) ; 
if ( ! inDetails ) { 
o [ SBB_ATTACHMENTS ] = Integer . toString ( ( ( Object [ ] ) o [ SBB_ATTACHMENTS ] ) . length ) ; 
o [ NAMES_BOUND_TO ] = Integer . toString ( ( ( Object [ ] ) o [ NAMES_BOUND_TO ] ) . length ) ; 
o [ TIMERS_ATTACHED ] = Integer . toString ( ( ( Object [ ] ) o [ TIMERS_ATTACHED ] ) . length ) ; 
o [ DATA_PROPERTIES ] = Integer . toString ( ( ( Object [ ] ) o [ DATA_PROPERTIES ] ) . length ) ; 
singleResult = o ; 
singleResult = acId ; 
lst . add ( singleResult ) ; 
if ( lst . isEmpty ( ) ) 
Object [ ] ret = new Object [ lst . size ( ) ] ; 
ret = lst . toArray ( ret ) ; 
private Object [ ] getDetails ( ActivityContextImpl ac ) { 
+ ac . getActivityContextHandle ( ) + "]" ) ; 
Object [ ] o = new Object [ ARRAY_SIZE ] ; 
ActivityContextHandle achOrig = ac . getActivityContextHandle ( ) ; 
o [ ActivityManagementMBeanImplMBean . AC_ID ] = acId ; 
logger . debug ( "======[getDetails][" 
+ o [ ActivityManagementMBeanImplMBean . AC_ID ] + "][" 
+ ac . hashCode ( ) + "]" ) ; 
o [ RA ] = ( ( ResourceAdaptorActivityContextHandle ) achOrig ) . getResourceAdaptorEntity ( ) . getName ( ) ; 
o [ ACTIVITY_CLASS ] = achOrig . getActivityObject ( ) . getClass ( ) . getName ( ) ; 
logger . debug ( "======[getDetails][ACTIVITY_CLASS][" + o [ ACTIVITY_CLASS ] 
o [ LAST_ACCESS_TIME ] = ac . getLastAccessTime ( ) + "" ; 
logger . debug ( "======[getDetails][LAST_ACCESS_TIME][" 
+ o [ LAST_ACCESS_TIME ] + "][" 
+ new Date ( Long . parseLong ( ( String ) o [ LAST_ACCESS_TIME ] ) ) + "]" ) ; 
Set < SbbEntityID > sbbAttachmentSet = ac . getSbbAttachmentSet ( ) ; 
String [ ] tmp = new String [ sbbAttachmentSet . size ( ) ] ; 
Iterator < ? > it = sbbAttachmentSet . iterator ( ) ; 
tmp [ counter ++ ] = it . next ( ) . toString ( ) ; 
o [ SBB_ATTACHMENTS ] = tmp ; 
Set < String > nameBindindsSet = ac . getNamingBindings ( ) ; 
tmp = new String [ nameBindindsSet . size ( ) ] ; 
tmp = nameBindindsSet . toArray ( tmp ) ; 
o [ NAMES_BOUND_TO ] = tmp ; 
Set < TimerID > attachedTimersSet = ac . getAttachedTimers ( ) ; 
tmp = new String [ attachedTimersSet . size ( ) ] ; 
it = attachedTimersSet . iterator ( ) ; 
tmp [ counter ++ ] = ( ( TimerID ) it . next ( ) ) . toString ( ) ; 
o [ TIMERS_ATTACHED ] = tmp ; 
Map m = ac . getDataAttributes ( ) ; 
tmp = new String [ m . size ( ) ] ; 
it = m . keySet ( ) . iterator ( ) ; 
Object k = it . next ( ) ; 
Object v = m . get ( k ) ; 
tmp [ counter ++ ] = k + "=" + v ; 
o [ DATA_PROPERTIES ] = tmp ; 
} public Object [ ] retrieveActivityContextIDByActivityType ( 
String fullQualifiedActivityClassName ) { 
+ fullQualifiedActivityClassName + "]" ) ; 
return listWithCriteria ( true , true , LIST_BY_ACTIVITY_CLASS , 
fullQualifiedActivityClassName ) ; 
} private String getRealFieldName ( String fieldName ) { 
String realFieldName = sbbComponent . getDescriptor ( ) 
. getActivityContextAttributeAliases ( ) . get ( fieldName ) ; 
if ( realFieldName == null ) { 
realFieldName = sbbComponent . getSbbID ( ) . toString ( ) + "." 
+ fieldName ; 
final Map < String , String > aliases = sbbComponent . getDescriptor ( ) 
. getActivityContextAttributeAliases ( ) ; 
synchronized ( aliases ) { 
aliases . put ( fieldName , realFieldName ) ; 
return realFieldName ; 
} public void setFieldValue ( String fieldName , Object value ) { 
String realFieldName = getRealFieldName ( fieldName ) ; 
aciImpl . getActivityContext ( ) . setDataAttribute ( realFieldName , value ) ; 
} public Object getFieldValue ( String fieldName , Class < ? > returnType ) { 
Object value = aciImpl . getActivityContext ( ) . getDataAttribute ( 
realFieldName ) ; 
if ( returnType . equals ( Integer . TYPE ) ) { 
return Integer . valueOf ( 0 ) ; 
} else if ( returnType . equals ( Boolean . TYPE ) ) { 
} else if ( returnType . equals ( Long . TYPE ) ) { 
return Long . valueOf ( 0 ) ; 
} else if ( returnType . equals ( Double . TYPE ) ) { 
return Double . valueOf ( 0 ) ; 
} else if ( returnType . equals ( Float . TYPE ) ) { 
return Float . valueOf ( 0 ) ; 
if ( service == null ) 
this . service . fireEvent ( event , eventType , activityHandle , address ) ; 
return service . getEventTypeID ( name , vendor , version ) ; 
} public SleeConnection getConnection ( ) throws ResourceException { 
synchronized ( connectionList ) { 
SleeConnectionImpl conn ; 
if ( connectionList . size ( ) > 0 ) 
conn = ( SleeConnectionImpl ) connectionList . remove ( 0 ) ; 
conn . start ( this . service ) ; 
conn = new SleeConnectionImpl ( this . service , this ) ; 
} public void setProfileContext ( ProfileContextImpl profileContext ) { 
if ( profileContext == null ) { 
if ( state != ProfileObjectState . DOES_NOT_EXIST ) { 
this . profileContext = profileContext ; 
this . profileContext . setProfileObject ( this ) ; 
if ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { 
final ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; 
final ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; 
if ( System . getSecurityManager ( ) != null ) { 
profileConcrete . setProfileContext ( profileContext ) ; 
catch ( RuntimeException e ) { 
runtimeExceptionOnProfileInvocation ( e ) ; 
state = ProfileObjectState . POOLED ; 
} private void profileInitialize ( String profileName ) { 
if ( this . state != ProfileObjectState . POOLED ) { 
throw new SLEEException ( this . toString ( ) ) ; 
profileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; 
this . state = ProfileObjectState . PROFILE_INITIALIZATION ; 
if ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) { 
profileConcrete . profileInitialize ( ) ; 
profileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; 
profileEntity . setProfileName ( profileName ) ; 
profileEntity . create ( ) ; 
profileEntity . setDirty ( true ) ; 
} public void unsetProfileContext ( ) { 
if ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { 
final ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; 
profileConcrete . unsetProfileContext ( ) ; 
profileContext . setProfileObject ( null ) ; 
state = ProfileObjectState . DOES_NOT_EXIST ; 
} public ProfileLocalObject getProfileLocalObject ( ) { 
final Class < ? > profileLocalObjectConcreteClass = profileTable . getProfileSpecificationComponent ( ) . getProfileLocalObjectConcreteClass ( ) ; 
ProfileLocalObject profileLocalObject = null ; 
if ( profileLocalObjectConcreteClass == null ) { 
profileLocalObject = new ProfileLocalObjectImpl ( this ) ; 
profileLocalObject = ( ProfileLocalObject ) profileLocalObjectConcreteClass . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; 
return profileLocalObject ; 
} public void fireAddOrUpdatedEventIfNeeded ( ) { 
if ( state == ProfileObjectState . READY ) { 
if ( profileEntity . isDirty ( ) ) { 
if ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { 
ActivityContext ac = profileTable . getActivityContext ( ) ; 
AbstractProfileEvent event = null ; 
if ( profileEntity . isCreate ( ) ) { 
if ( persisted ) { 
event = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; 
persisted = false ; 
event = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; 
ac . fireEvent ( event . getEventTypeID ( ) , event , 
event . getProfileAddress ( ) , null , null , null , null ) ; 
} public AbstractProfileCmpSlee10Wrapper getProfileCmpSlee10Wrapper ( ) { 
if ( profileCmpSlee10Wrapper == null ) { 
profileCmpSlee10Wrapper = ( AbstractProfileCmpSlee10Wrapper ) profileTable . getProfileSpecificationComponent ( ) . getProfileCmpSlee10WrapperClass ( ) . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; 
return profileCmpSlee10Wrapper ; 
final ServiceID serviceID = new ServiceID ( in . readUTF ( ) , in . readUTF ( ) , 
in . readUTF ( ) ) ; 
activityHandle = new ServiceActivityHandleImpl ( serviceID ) ; 
} public javax . slee . management . LibraryDescriptor getSpecsDescriptor ( ) { 
final JarDescriptor [ ] jars = descriptor . getJars ( ) . toArray ( new JarDescriptor [ descriptor . getJars ( ) . size ( ) ] ) ; 
String [ ] libraryJars = new String [ jars . length ] ; 
for ( JarDescriptor jar : jars ) { 
libraryJars [ i ++ ] = jar . getJarName ( ) ; 
specsDescriptor = new javax . slee . management . LibraryDescriptor ( getLibraryID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , libraryIDs , libraryJars ) ; 
} public static CtClass createClass ( String className , String [ ] interfaces ) throws Exception 
CtClass clazz = classPool . makeClass ( className ) ; 
if ( interfaces != null && interfaces . length > 0 ) 
clazz . setInterfaces ( classPool . get ( interfaces ) ) ; 
} public static void createInterfaceLinks ( CtClass concreteClass , String [ ] interfaceNames ) 
if ( interfaceNames != null && interfaceNames . length > 0 ) 
for ( String interfaceName : interfaceNames ) 
for ( CtClass existingInterfaces : concreteClass . getInterfaces ( ) ) 
if ( existingInterfaces . getName ( ) . equals ( interfaceName ) ) 
concreteClass . addInterface ( classPool . get ( interfaceName ) ) ; 
} public static void createInheritanceLink ( CtClass concreteClass , String superClassName ) 
if ( superClassName != null && superClassName . length ( ) >= 0 ) 
concreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; 
catch ( CannotCompileException e ) { 
} public static CtField addField ( CtClass fieldType , String fieldName , CtClass declaringClass ) throws CannotCompileException 
return addField ( fieldType , fieldName , declaringClass , Modifier . PRIVATE ) ; 
} public static CtField addField ( CtClass fieldType , String fieldName , CtClass declaringClass , int modifier ) throws CannotCompileException 
return addField ( fieldType , fieldName , declaringClass , modifier , null ) ; 
} public static CtField addField ( CtClass fieldType , String fieldName , CtClass declaringClass , int modifier , String initializerExpr ) throws CannotCompileException 
CtField field = new CtField ( fieldType , decapitalize ( fieldName ) , declaringClass ) ; 
field . setModifiers ( modifier ) ; 
if ( initializerExpr != null ) 
declaringClass . addField ( field , CtField . Initializer . byExpr ( initializerExpr ) ) ; 
declaringClass . addField ( field ) ; 
} public static CtMethod generateGetter ( CtField field , String interceptorAccess ) throws NotFoundException , CannotCompileException 
String getterName = "get" + capitalize ( field . getName ( ) ) ; 
CtMethod getter = CtNewMethod . getter ( getterName , field ) ; 
if ( interceptorAccess != null ) 
getter . setBody ( interceptorAccess + "." + getterName + "($$);" ) ; 
field . getDeclaringClass ( ) . addMethod ( getter ) ; 
return getter ; 
} public static CtMethod generateSetter ( CtField field , String interceptorAccess ) throws NotFoundException , CannotCompileException 
String setterName = "set" + capitalize ( field . getName ( ) ) ; 
CtMethod setter = CtNewMethod . setter ( setterName , field ) ; 
setter . setBody ( interceptorAccess + "." + setterName + "($$);" ) ; 
field . getDeclaringClass ( ) . addMethod ( setter ) ; 
return setter ; 
} public static void generateGetterAndSetter ( CtField field , String interceptorAccess ) throws NotFoundException , CannotCompileException 
generateGetter ( field , interceptorAccess ) ; 
generateSetter ( field , interceptorAccess ) ; 
} public static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) 
if ( toAnnotate instanceof CtClass ) 
CtClass classToAnnotate = ( CtClass ) toAnnotate ; 
ClassFile cf = classToAnnotate . getClassFile ( ) ; 
ConstPool cp = cf . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; 
Annotation a = new Annotation ( annotation , cp ) ; 
if ( memberValues != null ) 
addMemberValuesToAnnotation ( a , cp , memberValues ) ; 
attr . addAnnotation ( a ) ; 
cf . addAttribute ( attr ) ; 
else if ( toAnnotate instanceof CtMethod ) 
CtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; 
MethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; 
ConstPool cp = mi . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
mi . addAttribute ( attr ) ; 
else if ( toAnnotate instanceof CtField ) 
CtField fieldToAnnotate = ( CtField ) toAnnotate ; 
FieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; 
ConstPool cp = fi . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
fi . addAttribute ( attr ) ; 
} private static void addMemberValuesToAnnotation ( Annotation annotation , ConstPool cp , LinkedHashMap < String , Object > memberValues ) 
for ( String mvName : memberValues . keySet ( ) ) 
Object mvValue = memberValues . get ( mvName ) ; 
MemberValue mv = getMemberValue ( mvValue , cp ) ; 
annotation . addMemberValue ( mvName , mv ) ; 
} protected ActivityContextInterface getACI ( Object activity ) 
throws NullPointerException , UnrecognizedActivityException , 
ActivityHandle handle = null ; 
for ( ResourceAdaptorEntity raEntity : sleeContainer 
. getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { 
handle = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( 
activity ) ; 
if ( handle != null ) { 
ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; 
throw new UnrecognizedActivityException ( activity . toString ( ) ) ; 
} public ClassPool getClassPool ( ) { 
if ( classPool == null ) { 
if ( classLoader == null ) { 
classPool = new ClassPool ( ) ; 
classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain ) ) ; 
for ( ClassLoader domainDependencies : classLoaderDomain . getAllDependencies ( ) ) { 
classPool . appendClassPath ( new LoaderClassPath ( domainDependencies ) ) ; 
classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain . getParent ( ) ) ) ; 
return classPool ; 
} public void setDeployableUnit ( DeployableUnit deployableUnit ) 
throws AlreadyDeployedException { 
if ( this . deployableUnit != null ) { 
this . deployableUnit = deployableUnit ; 
if ( ! addToDeployableUnit ( ) ) { 
+ getComponentID ( ) ) ; 
} public void undeployed ( ) { 
classLoader = null ; 
if ( classLoaderDomain != null ) { 
classLoaderDomain . clear ( ) ; 
classLoaderDomain = null ; 
if ( classPool != null ) { 
classPool . clean ( ) ; 
classPool = null ; 
if ( permissions != null ) { 
permissions . clear ( ) ; 
permissions = null ; 
if ( ! shutdown ) { 
sleeSubDeployer . init ( deployableUnitURL , deployableUnitName ) ; 
sleeSubDeployer . start ( deployableUnitURL , deployableUnitName ) ; 
if ( LOGGER . isDebugEnabled ( ) ) 
} private ReceivableService createReceivableService ( 
ComponentRepository componentRepository = container 
HashSet < ReceivableEvent > resultSet = new HashSet < ReceivableEvent > ( ) ; 
for ( SbbID sbbID : serviceComponent . getSbbIDs ( componentRepository ) ) { 
SbbComponent sbbComponent = componentRepository 
. getComponentByID ( sbbID ) ; 
for ( EventEntryDescriptor eventEntry : sbbComponent . getDescriptor ( ) 
. getEventEntries ( ) . values ( ) ) { 
EventTypeID eventTypeID = eventEntry . getEventReference ( ) ; 
final Set < EventTypeID > allowedEventTypes = raEntity . getAllowedEventTypes ( ) ; 
if ( allowedEventTypes == null 
|| allowedEventTypes . contains ( eventTypeID ) ) { 
ReceivableEventImpl receivableEventImpl = new ReceivableEventImpl ( 
eventTypeID , eventEntry . getResourceOption ( ) , 
eventEntry . isInitialEvent ( ) ) ; 
if ( ! resultSet . contains ( receivableEventImpl ) 
|| receivableEventImpl . isInitialEvent ( ) ) { 
resultSet . add ( receivableEventImpl ) ; 
return new ReceivableServiceImpl ( serviceComponent . getServiceID ( ) , 
resultSet . toArray ( new ReceivableEventImpl [ resultSet . size ( ) ] ) ) ; 
} void execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) 
throws SLEEException { 
ActivityContextHandle ach = null ; 
ach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; 
if ( ach != null && ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) { 
acFactory . getActivityContext ( ach ) ; 
} public Collator getCollator ( ) { 
if ( collator == null ) { 
collator = Collator . getInstance ( locale ) ; 
if ( hasStrength ) collator . setStrength ( strength ) ; 
if ( hasDecomposition ) collator . setDecomposition ( decomposition ) ; 
return collator ; 
} public static QueryWrapper parseDynamicQuery ( QueryExpression query ) 
ArrayList < Object > params = new ArrayList < Object > ( ) ; 
long s = System . currentTimeMillis ( ) ; 
long e = System . currentTimeMillis ( ) ; 
return new QueryWrapper ( sqlQuery , params ) ; 
} private static String replaceLast ( String sourceString , String toBeReplaced , String replacement ) 
StringBuilder x = new StringBuilder ( sourceString ) ; 
int liof = x . lastIndexOf ( toBeReplaced ) ; 
if ( liof >= 0 ) 
x . replace ( liof , liof + 4 , replacement ) ; 
return new String ( x ) ; 
} static boolean validateUsageParameterInterface ( ComponentID id , boolean isSlee11 , Class < ? > usageInterface , List < UsageParameterDescriptor > parameters ) { 
if ( ! usageInterface . isInterface ( ) ) { 
if ( isSlee11 && usageInterface . getPackage ( ) == null ) { 
if ( ! Modifier . isPublic ( usageInterface . getModifiers ( ) ) ) { 
Map < String , Method > interfaceMethods = ClassUtils . getAllInterfacesMethods ( usageInterface , ignore ) ; 
Map < String , UsageParameterDescriptor > localParametersMap = new HashMap < String , UsageParameterDescriptor > ( ) ; 
Set < String > identifiedIncrement = new HashSet < String > ( ) ; 
Set < String > identifiedGetIncrement = new HashSet < String > ( ) ; 
Set < String > identifiedSample = new HashSet < String > ( ) ; 
Set < String > identifiedGetSample = new HashSet < String > ( ) ; 
if ( isSlee11 ) 
for ( UsageParameterDescriptor usage : parameters ) { 
char c = usage . getName ( ) . charAt ( 0 ) ; 
if ( ! Character . isLowerCase ( c ) ) { 
errorBuffer = appendToBuffer ( id , 
localParametersMap . put ( usage . getName ( ) , usage ) ; 
for ( Entry < String , Method > entry : interfaceMethods . entrySet ( ) ) { 
String declaredMethodName = m . getName ( ) ; 
String declaredPrameterName = null ; 
Character c = null ; 
boolean isIncrement = false ; 
boolean isGetIncrement = false ; 
boolean isGetSample = false ; 
boolean isSample = false ; 
if ( declaredMethodName . startsWith ( _SAMPLE_METHOD_PREFIX ) ) { 
declaredPrameterName = declaredMethodName . replaceFirst ( _SAMPLE_METHOD_PREFIX , "" ) ; 
c = declaredPrameterName . charAt ( 0 ) ; 
isSample = true ; 
} else if ( declaredMethodName . startsWith ( _INCREMENT_METHOD_PREFIX ) ) { 
declaredPrameterName = declaredMethodName . replaceFirst ( _INCREMENT_METHOD_PREFIX , "" ) ; 
isIncrement = true ; 
} else if ( declaredMethodName . startsWith ( _GET_METHOD_PREFIX ) ) { 
declaredPrameterName = declaredMethodName . replaceFirst ( _GET_METHOD_PREFIX , "" ) ; 
if ( ! isSlee11 ) { 
+ declaredMethodName , "11.2.X" , errorBuffer ) ; 
if ( m . getReturnType ( ) . getName ( ) . compareTo ( "javax.slee.usage.SampleStatistics" ) == 0 ) { 
isGetSample = true ; 
isGetIncrement = true ; 
if ( ! Character . isUpperCase ( c ) ) { 
"11.2" , errorBuffer ) ; 
declaredPrameterName = Introspector . decapitalize ( declaredPrameterName ) ; 
if ( ! isValidJavaIdentifier ( declaredPrameterName ) ) { 
if ( isIncrement ) { 
if ( identifiedIncrement . contains ( declaredMethodName ) ) { 
identifiedIncrement . add ( declaredPrameterName ) ; 
if ( ! validateParameterSetterSignatureMethod ( id , m , "11.2.3" ) ) { 
} else if ( isGetIncrement ) { 
if ( identifiedGetIncrement . contains ( declaredMethodName ) ) { 
identifiedGetIncrement . add ( declaredPrameterName ) ; 
if ( ! validateParameterGetterSignatureMethod ( id , m , "11.2.2" , Long . TYPE ) ) { 
} else if ( isGetSample ) { 
if ( identifiedGetSample . contains ( declaredMethodName ) ) { 
identifiedGetSample . add ( declaredPrameterName ) ; 
if ( ! validateParameterGetterSignatureMethod ( id , m , "11.2.4" , javax . slee . usage . SampleStatistics . class ) ) { 
} else if ( isSample ) { 
if ( identifiedSample . contains ( declaredMethodName ) ) { 
identifiedSample . add ( declaredPrameterName ) ; 
if ( ! validateParameterSetterSignatureMethod ( id , m , "11.2.1" ) ) { 
Set < String > agregatedIncrement = new HashSet < String > ( ) ; 
Set < String > agregatedSample = new HashSet < String > ( ) ; 
agregatedIncrement . addAll ( identifiedGetIncrement ) ; 
agregatedIncrement . addAll ( identifiedIncrement ) ; 
agregatedSample . addAll ( identifiedGetSample ) ; 
agregatedSample . addAll ( identifiedSample ) ; 
Set < String > tmp = new HashSet < String > ( agregatedSample ) ; 
tmp . retainAll ( agregatedIncrement ) ; 
if ( ! tmp . isEmpty ( ) ) { 
tmp . clear ( ) ; 
tmp . addAll ( agregatedSample ) ; 
tmp . addAll ( agregatedIncrement ) ; 
if ( localParametersMap . size ( ) != tmp . size ( ) && localParametersMap . size ( ) != 0 ) { 
String errorPart = null ; 
if ( localParametersMap . size ( ) > tmp . size ( ) ) { 
for ( String s : localParametersMap . keySet ( ) ) 
tmp . remove ( s ) ; 
for ( String s : tmp ) 
localParametersMap . remove ( s ) ; 
} public static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { 
Class returnValue = null ; 
if ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { 
return classOrInterfaceWithInterfaces ; 
for ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { 
if ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { 
returnValue = iface ; 
returnValue = checkInterfaces ( iface , interfaceSearched ) ; 
if ( returnValue != null ) 
if ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { 
Class superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; 
if ( superClass != null ) { 
returnValue = checkInterfaces ( superClass , interfaceSearched ) ; 
} public static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { 
HashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; 
Method [ ] methods = null ; 
Class [ ] superInterfaces ; 
superInterfaces = xInterfaceClass . getInterfaces ( ) ; 
for ( Class superInterface : superInterfaces ) { 
if ( ! ignore . contains ( superInterface . getName ( ) ) ) 
abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; 
methods = xInterfaceClass . getDeclaredMethods ( ) ; 
abstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
} public static Method getMethodFromMap ( String name , Class [ ] parameters , Map < String , Method > ... methods ) { 
String key = name + Arrays . toString ( parameters ) ; 
for ( Map < String , Method > m : methods ) { 
if ( m . containsKey ( key ) ) { 
return m . get ( key ) ; 
} public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException 
URL resourceURL = resources . get ( publicId ) ; 
if ( resourceURL != null ) { 
InputStream resourceStream = resourceURL . openStream ( ) ; 
InputSource is = new InputSource ( resourceStream ) ; 
is . setPublicId ( publicId ) ; 
is . setSystemId ( resourceURL . toExternalForm ( ) ) ; 
} public void setTraceLevel ( ComponentID componentId , Level level ) throws NullPointerException , UnrecognizedComponentException , ManagementException { 
if ( componentId == null ) 
this . traceFacility . checkComponentID ( componentId ) ; 
this . traceFacility . setTraceLevel ( componentId , level ) ; 
} public Level getTraceLevel ( ComponentID componentId ) throws NullPointerException , UnrecognizedComponentException , ManagementException { 
return this . traceFacility . getTraceLevel ( componentId ) ; 
} public MBeanNotificationInfo [ ] getNotificationInfo ( ) { 
if ( this . traceFacility == null ) 
String [ ] notificationTypes = this . traceFacility . getNotificationTypes ( ) ; 
return new MBeanNotificationInfo [ ] { new MBeanNotificationInfo ( notificationTypes , TraceMBean . TRACE_NOTIFICATION_TYPE , 
} public TraceLevel getTraceLevel ( NotificationSource src , String tracerName ) throws NullPointerException , InvalidArgumentException , UnrecognizedNotificationSourceException , ManagementException { 
if ( src == null ) 
if ( ! this . isNotificationSourceDefined ( src ) ) 
TracerImpl . checkTracerName ( tracerName , src ) ; 
if ( ! this . isTracerDefined ( src , tracerName ) ) 
this . createTracer ( src , tracerName , false ) ; 
TracerStorage ts = this . tracerStorage . get ( src ) ; 
if ( ts == null ) { 
return ts . getTracerLevel ( tracerName ) ; 
} public String [ ] getTracersSet ( NotificationSource src ) throws NullPointerException , UnrecognizedNotificationSourceException , ManagementException { 
return ts . getDefinedTracerNames ( ) ; 
} public String [ ] getTracersUsed ( NotificationSource src ) throws NullPointerException , UnrecognizedNotificationSourceException , ManagementException { 
return ts . getRequestedTracerNames ( ) ; 
} public void setTraceLevel ( NotificationSource src , final String tracerName , TraceLevel lvl ) throws NullPointerException , UnrecognizedNotificationSourceException , InvalidArgumentException , 
if ( lvl == null ) 
if 
( ! this . isNotificationSourceDefined ( src ) ) 
final TracerStorage ts = this . tracerStorage . get ( src ) ; 
final SleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; 
if ( sleeTransactionManager . getTransaction ( ) != null ) 
final TraceLevel _oldLevel = ts . getTracerLevel ( tracerName ) ; 
TraceLevel oldLevel = _oldLevel ; 
ts . setTracerLevel ( oldLevel , tracerName ) ; 
ts . setTracerLevel ( lvl , tracerName ) ; 
} public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { 
if ( tracerName . compareTo ( "" ) == 0 ) { 
StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , "." , true ) ; 
int fqdnPartIndex = 0 ; 
String lastToken = null ; 
while ( stringTokenizer . hasMoreTokens ( ) ) { 
String token = stringTokenizer . nextToken ( ) ; 
if ( lastToken == null ) { 
lastToken = token ; 
if ( lastToken . compareTo ( token ) == 0 && token . compareTo ( "." ) == 0 ) { 
if ( token . compareTo ( "." ) != 0 ) { 
for ( int charIndex = 0 ; charIndex < token . length ( ) ; charIndex ++ ) { 
Character c = token . charAt ( charIndex ) ; 
if ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { 
fqdnPartIndex ++ ; 
if ( lastToken . compareTo ( "." ) == 0 ) { 
} public void registerNotificationSource ( final NotificationSource src ) { 
if ( ! this . tracerStorage . containsKey ( src ) ) { 
TracerStorage ts = new TracerStorage ( src , this ) ; 
this . tracerStorage . put ( src , ts ) ; 
} public boolean isTracerDefined ( NotificationSource src , String tracerName ) throws ManagementException { 
return ts . isTracerDefined ( tracerName ) ; 
} public Tracer createTracer ( NotificationSource src , String tracerName , boolean createdBySource ) throws NullPointerException , InvalidArgumentException { 
return ts . createTracer ( tracerName , createdBySource ) ; 
} public static Collection < ProfileLocalObject > handle ( 
ProfileTableImpl profileTable , String queryName , Object [ ] arguments ) 
throws NullPointerException , TransactionRequiredLocalException , SLEEException , 
UnrecognizedQueryNameException , AttributeTypeMismatchException , 
InvalidArgumentException { 
return profileTable . getProfilesByStaticQuery ( queryName , arguments ) ; 
} public DeployableUnitImpl build ( String url , File deploymentRoot , 
ComponentRepository componentRepository ) 
throws DeploymentException , AlreadyDeployedException , 
MalformedURLException { 
if ( deploymentRoot == null ) { 
URL sourceUrl = new URL ( url ) ; 
if ( sourceUrl . getProtocol ( ) . equals ( "http" ) || sourceUrl . getProtocol ( ) . equals ( "https" ) ) { 
File downloadedFile = downloadRemoteDU ( sourceUrl , deploymentRoot ) ; 
sourceUrl = downloadedFile . toURI ( ) . toURL ( ) ; 
url = sourceUrl . toString ( ) ; 
JarFile deployableUnitJar = null ; 
deployableUnitJar = new JarFile ( sourceUrl . getFile ( ) ) ; 
+ sourceUrl . getFile ( ) , e ) ; 
JarEntry duXmlEntry = deployableUnitJar 
if ( duXmlEntry == null ) { 
+ deployableUnitJar . getName ( ) ) ; 
DeployableUnitDescriptorFactoryImpl descriptorFactory = componentManagement . getComponentDescriptorFactory ( ) . getDeployableUnitDescriptorFactory ( ) ; 
DeployableUnitDescriptorImpl deployableUnitDescriptor = null ; 
deployableUnitDescriptor = descriptorFactory 
. parse ( deployableUnitJar . getInputStream ( duXmlEntry ) ) ; 
deployableUnitJar . close ( ) ; 
File deploymentDir = createTempDUDeploymentDir ( deploymentRoot , 
DeployableUnitImpl deployableUnit = null ; 
deployableUnit = new DeployableUnitImpl ( deployableUnitID , 
deployableUnitDescriptor , componentRepository , 
deploymentDir ) ; 
for ( String jarFileName : deployableUnitDescriptor . getJarEntries ( ) ) { 
for ( SleeComponent sleeComponent : duComponentBuilder 
. buildComponents ( jarFileName , deployableUnitJar , 
deployableUnit . getDeploymentDir ( ) ) ) { 
sleeComponent . setDeployableUnit ( deployableUnit ) ; 
if ( componentRepository . isInstalled ( sleeComponent 
. getComponentID ( ) ) ) { 
+ sleeComponent . getComponentID ( ) 
sleeComponent . setDeploymentUnitSource ( jarFileName ) ; 
for ( String serviceDescriptorFileName : deployableUnitDescriptor 
. getServiceEntries ( ) ) { 
for ( ServiceComponentImpl serviceComponent : duServiceComponentBuilder 
. buildComponents ( serviceDescriptorFileName , 
deployableUnitJar ) ) { 
serviceComponent . setDeployableUnit ( deployableUnit ) ; 
if ( componentRepository . isInstalled ( serviceComponent 
+ serviceComponent . getComponentID ( ) 
serviceComponent . setRootSbbComponent ( deployableUnit 
. getDeployableUnitRepository ( ) . getComponentByID ( 
serviceComponent . getDescriptor ( ) 
. getRootSbbID ( ) ) ) ; 
serviceComponent 
. setDeploymentUnitSource ( serviceDescriptorFileName ) ; 
Set < SleeComponent > duComponentsSet = deployableUnit 
. getDeployableUnitComponents ( ) ; 
for ( SleeComponent sleeComponent : duComponentsSet ) { 
checkDependencies ( sleeComponent , deployableUnit ) ; 
createClassLoader ( ( AbstractSleeComponent ) sleeComponent ) ; 
loadAndSetNonGeneratedComponentClasses ( ( AbstractSleeComponent ) sleeComponent ) ; 
ClassLoader componentClassLoader = sleeComponent 
. getClassLoader ( ) ; 
if ( componentClassLoader != null ) { 
componentClassLoader ) ; 
if ( ! sleeComponent . validate ( ) ) { 
sleeComponent . toString ( ) 
sleeComponent . processSecurityPermissions ( ) ; 
+ sleeComponent , e ) ; 
return deployableUnit ; 
if ( deployableUnit == null ) { 
deploymentDir . delete ( ) ; 
if ( e instanceof DeploymentException ) { 
throw ( DeploymentException ) e ; 
} else if ( e instanceof AlreadyDeployedException ) { 
throw ( AlreadyDeployedException ) e ; 
} private void loadAndSetNonGeneratedComponentClasses ( 
AbstractSleeComponent sleeComponent ) throws DeploymentException { 
ComponentClassLoaderImpl componentClassLoader = sleeComponent 
if ( sleeComponent instanceof EventTypeComponentImpl ) { 
EventTypeComponentImpl component = ( EventTypeComponentImpl ) sleeComponent ; 
Class < ? > eventTypeClass = componentClassLoader 
. loadClass ( component . getDescriptor ( ) 
. getEventClassName ( ) ) ; 
component . setEventTypeClass ( eventTypeClass ) ; 
} else if ( sleeComponent instanceof ProfileSpecificationComponentImpl ) { 
ProfileSpecificationComponentImpl component = ( ProfileSpecificationComponentImpl ) sleeComponent ; 
Class < ? > profileCmpInterfaceClass = componentClassLoader 
. getProfileCMPInterface ( ) 
. getProfileCmpInterfaceName ( ) ) ; 
. setProfileCmpInterfaceClass ( profileCmpInterfaceClass ) ; 
if ( component . getDescriptor ( ) 
. getProfileLocalInterface ( ) != null ) { 
Class < ? > profileLocalInterfaceClass = componentClassLoader 
. getProfileLocalInterfaceName ( ) ) ; 
. setProfileLocalInterfaceClass ( profileLocalInterfaceClass ) ; 
. getProfileManagementInterface ( ) != null ) { 
Class < ? > profileManagementInterfaceClass = componentClassLoader 
. getProfileManagementInterface ( ) ) ; 
. setProfileManagementInterfaceClass ( profileManagementInterfaceClass ) ; 
. getProfileAbstractClass ( ) != null ) { 
boolean decoratedClass = new ProfileAbstractClassDecorator ( component ) . decorateAbstractClass ( ) ; 
Class < ? > profileAbstractClass = null ; 
if ( decoratedClass ) { 
profileAbstractClass = componentClassLoader 
. loadClassLocally ( component . getDescriptor ( ) 
. getProfileAbstractClass ( ) 
. getProfileAbstractClassName ( ) ) ; 
component . setProfileAbstractClass ( profileAbstractClass ) ; 
String mProfileTableInterface = component 
. getDescriptor ( ) 
. getProfileTableInterface ( ) ; 
if ( mProfileTableInterface != null ) { 
. setProfileTableInterfaceClass ( componentClassLoader 
. loadClass ( mProfileTableInterface ) ) ; 
UsageParametersInterfaceDescriptor mUsageParametersInterface = component 
. getProfileUsageParameterInterface ( ) ; 
if ( mUsageParametersInterface != null ) { 
. setUsageParametersInterface ( componentClassLoader 
. loadClass ( mUsageParametersInterface 
. getUsageParametersInterfaceName ( ) ) ) ; 
} else if ( sleeComponent instanceof ResourceAdaptorComponentImpl ) { 
ResourceAdaptorComponentImpl component = ( ResourceAdaptorComponentImpl ) sleeComponent ; 
Class < ? > resourceAdaptorClass = componentClassLoader 
. getResourceAdaptorClassName ( ) ) ; 
component . setResourceAdaptorClass ( resourceAdaptorClass ) ; 
MUsageParametersInterface mUsageParametersInterface = component 
. getResourceAdaptorUsageParametersInterface ( ) ; 
} else if ( sleeComponent instanceof ResourceAdaptorTypeComponentImpl ) { 
ResourceAdaptorTypeComponentImpl component = ( ResourceAdaptorTypeComponentImpl ) sleeComponent ; 
. getActivityContextInterfaceFactoryInterface ( ) != null ) { 
Class < ? > activityContextInterfaceFactoryInterface = componentClassLoader 
. loadClass ( component 
. getActivityContextInterfaceFactoryInterface ( ) ) ; 
. setActivityContextInterfaceFactoryInterface ( activityContextInterfaceFactoryInterface ) ; 
} else if ( sleeComponent instanceof SbbComponentImpl ) { 
SbbComponentImpl component = ( SbbComponentImpl ) sleeComponent ; 
boolean decoratedClass = new SbbAbstractClassDecorator ( component ) . decorateAbstractSbb ( ) ; 
Class < ? > abstractSbbClass = null ; 
abstractSbbClass = componentClassLoader 
. getSbbAbstractClass ( ) 
. getSbbAbstractClassName ( ) ) ; 
component . setAbstractSbbClass ( abstractSbbClass ) ; 
SbbLocalInterfaceDescriptor mSbbLocalInterface = component 
. getSbbLocalInterface ( ) ; 
if ( mSbbLocalInterface != null ) { 
. setSbbLocalInterfaceClass ( componentClassLoader 
. loadClass ( mSbbLocalInterface 
. getSbbLocalInterfaceName ( ) ) ) ; 
String mSbbActivityContextInterface = component 
. getSbbActivityContextInterface ( ) ; 
if ( mSbbActivityContextInterface != null ) { 
. setActivityContextInterface ( componentClassLoader 
. loadClass ( mSbbActivityContextInterface ) ) ; 
. getSbbUsageParametersInterface ( ) ; 
} catch ( NoClassDefFoundError e ) { 
} private void checkDependencies ( SleeComponent sleeComponent , 
DeployableUnitImpl deployableUnit ) throws DependencyException { 
for ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { 
if ( deployableUnit . getDeployableUnitRepository ( ) 
. getComponentByID ( ( EventTypeID ) componentID ) == null ) { 
throw new DependencyException ( 
+ componentID 
. getComponentByID ( ( LibraryID ) componentID ) == null ) { 
. getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { 
. getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { 
. getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { 
. getComponentByID ( ( SbbID ) componentID ) == null ) { 
} private File createTempDUDeploymentDir ( File deploymentRoot , 
DeployableUnitID deployableUnitID ) { 
File tempFile = File . createTempFile ( "restcomm-slee-du-" , "" , 
deploymentRoot ) ; 
File tempDUDeploymentDir = new File ( tempFile . getAbsolutePath ( ) 
+ "-contents" ) ; 
if ( ! tempDUDeploymentDir . exists ( ) ) { 
tempDUDeploymentDir . mkdirs ( ) ; 
+ tempDUDeploymentDir 
+ deployableUnitID ) ; 
tempFile . delete ( ) ; 
return tempDUDeploymentDir ; 
+ deployableUnitID , e ) ; 
} public void addEventContext ( EventContextHandle handle , 
EventContext eventContext ) { 
dataSource . put ( handle , eventContext ) ; 
} public EventContextData newEventContextData ( EventTypeID eventTypeId , 
Object event , ActivityContext ac , Address address , 
EventUnreferencedCallback unreferencedCallback , 
ReferencesHandler referencesHandler ) { 
return new DefaultEventContextData ( eventTypeId , event , ac , address , serviceID , succeedCallback , failedCallback , unreferencedCallback , referencesHandler ) ; 
} public void removeEventContext ( EventContextHandle handle ) { 
dataSource . remove ( handle ) ; 
AccessController . doPrivileged ( 
new PrivilegedAction < Object > ( ) { 
routeQueuedEvent ( ) ; 
} private void routeQueuedEvent ( ) { 
boolean debugLogging = logger . isDebugEnabled ( ) ; 
final SleeTransactionManager txMgr = container . getTransactionManager ( ) ; 
ClassLoader oldClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
final LocalActivityContext lac = eventContext . getLocalActivityContext ( ) ; 
final EventRoutingTask activityCurrentEventRoutingTask = lac . getCurrentEventRoutingTask ( ) ; 
EventContext activityCurrentEventContext = activityCurrentEventRoutingTask == null ? null : activityCurrentEventRoutingTask . getEventContext ( ) ; 
if ( activityCurrentEventContext == null ) { 
if ( debugLogging ) 
activityCurrentEventContext = eventContext ; 
lac . setCurrentEventRoutingTask ( this ) ; 
EventTypeComponent eventTypeComponent = container . getComponentRepository ( ) . getComponentByID ( eventContext . getEventTypeId ( ) ) ; 
eventContext . eventProcessingFailed ( FailureReason . OTHER_REASON ) ; 
if ( eventContext . getService ( ) != null ) { 
ServiceComponent serviceComponent = container . getComponentRepository ( ) . getComponentByID ( eventContext . getService ( ) ) ; 
if ( eventTypeComponent . getActiveServicesWhichDefineEventAsInitial ( ) . contains ( serviceComponent ) ) { 
activityCurrentEventContext . getActiveServicesToProcessEventAsInitial ( ) . add ( serviceComponent ) ; 
Set < ServiceComponent > services = eventTypeComponent . getActiveServicesWhichDefineEventAsInitial ( ) ; 
if ( services != null ) { 
activityCurrentEventContext . getActiveServicesToProcessEventAsInitial ( ) . addAll ( services ) ; 
if ( activityCurrentEventContext . isSuspendedNotTransacted ( ) ) { 
activityCurrentEventContext . barrierEvent ( eventContext ) ; 
Thread . sleep ( 10 ) ; 
LinkedList < ServiceComponent > serviceComponents = activityCurrentEventContext . getActiveServicesToProcessEventAsInitial ( ) ; 
+ serviceComponents ) ; 
boolean finished ; 
SbbEntityID rootSbbEntityId ; 
ClassLoader invokerClassLoader ; 
SbbEntity sbbEntity ; 
SbbObject sbbObject ; 
ServiceComponent serviceComponent ; 
boolean keepSbbEntityIfTxRollbacks ; 
NextSbbEntityFinder . Result nextSbbEntityFinderResult ; 
Exception caught = null ; 
Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent ; 
boolean deliverEvent ; 
boolean rollbackTx ; 
boolean rollbackOnlySet ; 
boolean sbbHandledEvent = false ; 
rootSbbEntityId = null ; 
invokerClassLoader = null ; 
sbbEntity = null ; 
sbbObject = null ; 
serviceComponent = null ; 
keepSbbEntityIfTxRollbacks = false ; 
nextSbbEntityFinderResult = null ; 
finished = false ; 
caught = null ; 
deliverEvent = true ; 
rollbackTx = true ; 
rollbackOnlySet = false ; 
txMgr . begin ( ) ; 
sbbEntitiesThatHandledCurrentEvent = activityCurrentEventContext . getSbbEntitiesThatHandledEvent ( ) ; 
ac = container . getActivityContextFactory ( ) . getActivityContext ( eventContext . getActivityContextHandle ( ) , true ) ; 
if ( routingPhase == RoutingPhase . DELIVERING ) { 
nextSbbEntityFinderResult = nextSbbEntityFinder . next ( ac , eventContext , sbbEntitiesThatHandledCurrentEvent , container ) ; 
if ( ! serviceComponents . isEmpty ( ) ) { 
serviceComponent = serviceComponents . getFirst ( ) ; 
if ( nextSbbEntityFinderResult == null ) { 
serviceComponents . removeFirst ( ) ; 
sbbEntity = initialEventProcessor . processInitialEvent ( serviceComponent , eventContext , container , ac ) ; 
if ( sbbEntity == null && serviceComponents . isEmpty ( ) ) { 
if ( serviceComponent != null && serviceComponent . getDescriptor ( ) . getDefaultPriority ( ) >= nextSbbEntityFinderResult . sbbEntity . getPriority ( ) ) { 
sbbEntity = nextSbbEntityFinderResult . sbbEntity ; 
deliverEvent = nextSbbEntityFinderResult . deliverEvent ; 
if ( sbbEntity != null ) { 
sbbEntitiesThatHandledCurrentEvent . add ( sbbEntity . getSbbEntityId ( ) ) ; 
if ( debugLogging ) { 
+ sbbEntity . getSbbEntityId ( ) ) ; 
invokerClassLoader = sbbEntity . getSbbComponent ( ) . getClassLoader ( ) ; 
Thread . currentThread ( ) . setContextClassLoader ( invokerClassLoader ) ; 
if ( ! sbbEntity . getSbbEntityId ( ) . isRootSbbEntity ( ) ) { 
rootSbbEntityId = sbbEntity . getSbbEntityId ( ) . getRootSBBEntityID ( ) ; 
SleeThreadLocals . setInvokingService ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) ; 
if ( deliverEvent ) { 
sbbEntity . assignSbbObject ( ) ; 
sbbObject = sbbEntity . getSbbObject ( ) ; 
if ( sbbEntity . isCreated ( ) && ! txMgr . getRollbackOnly ( ) ) { 
keepSbbEntityIfTxRollbacks = true ; 
Set < EventTypeID > eventMask = sbbEntity . getMaskedEventTypes ( eventContext . getActivityContextHandle ( ) ) ; 
if ( eventMask == null || ! eventMask . contains ( eventContext . getEventTypeId ( ) ) ) { 
sbbObject . setSbbInvocationState ( SbbInvocationState . INVOKING_EVENT_HANDLER ) ; 
ac . beforeDeliveringEvent ( eventContext ) ; 
sbbEntity . invokeEventHandler ( eventContext , ac , activityCurrentEventContext ) ; 
sbbHandledEvent = true ; 
rollbackOnlySet = txMgr . getRollbackOnly ( ) ; 
if ( ! rollbackOnlySet ) { 
sbbObject . setSbbInvocationState ( SbbInvocationState . NOT_INVOKING ) ; 
if ( eventContext . isActivityEndEvent ( ) && activityCurrentEventContext . getSbbEntitiesThatHandledEvent ( ) . contains ( sbbEntity . getSbbEntityId ( ) ) ) { 
sbbEntity . afterACDetach ( eventContext . getActivityContextHandle ( ) ) ; 
if ( rootSbbEntityId != null ) { 
SbbEntity rootSbbEntity = container . getSbbEntityFactory ( ) . getSbbEntity ( rootSbbEntityId , false ) ; 
if ( rootSbbEntity == null || rootSbbEntity . getAttachmentCount ( ) != 0 ) { 
if ( ! sbbEntity . isRemoved ( ) && sbbEntity . getAttachmentCount ( ) == 0 ) { 
container . getSbbEntityFactory ( ) . removeSbbEntity ( sbbEntity , true ) ; 
caught = e ; 
if ( ! finished ) { 
if ( serviceComponents . isEmpty ( ) ) { 
if ( nextSbbEntityFinder . next ( ac , eventContext , sbbEntitiesThatHandledCurrentEvent , container ) == null ) { 
boolean invokeSbbRolledBack = handleRollback . handleRollback ( sbbObject , caught , invokerClassLoader , txMgr ) ; 
boolean invokeSbbRolledBackRemove = false ; 
ClassLoader rootInvokerClassLoader = null ; 
SbbEntity rootSbbEntity = null ; 
if ( ! invokeSbbRolledBack && rootSbbEntityId != null ) { 
rootSbbEntity = container . getSbbEntityFactory ( ) . getSbbEntity ( rootSbbEntityId , false ) ; 
if ( rootSbbEntity != null ) { 
container . getSbbEntityFactory ( ) . removeSbbEntity ( rootSbbEntity , false ) ; 
invokeSbbRolledBackRemove = handleRollback . handleRollback ( null , caught , rootSbbEntity . getSbbComponent ( ) . getClassLoader ( ) , txMgr ) ; 
if ( invokeSbbRolledBack && sbbEntity == null ) { 
handleSbbRollback . handleSbbRolledBack ( null , sbbObject , null , null , invokerClassLoader , false , container , false ) ; 
} else if ( sbbEntity != null && ! txMgr . getRollbackOnly ( ) 
&& sbbEntity . getSbbObject ( ) != null ) { 
sbbEntity . passivateAndReleaseSbbObject ( ) ; 
final Collection coll = txMgr . getTransactionContext ( ) . getData ( ) . keySet ( ) ; 
final SbbEntityID ongoingEntID = sbbEntity . getSbbEntityId ( ) ; 
TransactionalAction removeLoadedSBBAction = new TransactionalAction ( ) { 
for ( Object obj : coll ) { 
if ( obj instanceof SbbEntityID ) { 
if ( ! obj . equals ( ongoingEntID ) ) { 
SbbEntity currentEntity = ( SbbEntity ) txMgr . getTransactionContext ( ) . getData ( ) . get ( obj ) ; 
if ( currentEntity . getSbbObject ( ) != null ) { 
currentEntity . passivateAndReleaseSbbObject ( ) ; 
txMgr . getTransactionContext ( ) . getBeforeCommitPriorityActions ( ) . add ( removeLoadedSBBAction ) ; 
if ( txMgr . getRollbackOnly ( ) ) { 
if ( finished ) { 
switch ( routingPhase ) { 
case DELIVERING : 
if ( eventContext . routedRequiresTransaction ( ) ) { 
routingPhase = RoutingPhase . DELIVERED ; 
eventContext . routed ( ) ; 
case DELIVERED : 
if ( routingPhase != RoutingPhase . DELIVERING ) { 
if ( invokeSbbRolledBack && sbbEntity != null ) { 
handleSbbRollback . handleSbbRolledBack ( sbbEntity , null , eventContext , ac , invokerClassLoader , false , container , keepSbbEntityIfTxRollbacks ) ; 
if ( invokeSbbRolledBackRemove ) { 
handleSbbRollback . handleSbbRolledBack ( rootSbbEntity , null , null , null , rootInvokerClassLoader , true , container , keepSbbEntityIfTxRollbacks ) ; 
rollbackTx = false ; 
final Transaction forgottenTx = txMgr . getTransaction ( ) ; 
if ( forgottenTx != null ) { 
if ( rollbackTx ) { 
} catch ( SystemException se ) { 
logger . error ( se . getMessage ( ) , se ) ; 
+ eventContext 
+ "\n\n\n" ) ; 
SleeThreadLocals . setInvokingService ( null ) ; 
+ eventContext + "\n\n\n" ) ; 
} while ( ! finished ) ; 
eventContext . eventProcessingSucceed ( sbbHandledEvent ) ; 
lac . setCurrentEventRoutingTask ( null ) ; 
if ( ! eventContext . routedRequiresTransaction ( ) ) { 
final String raEntityName = in . readUTF ( ) ; 
this . raEntity = SleeContainer . lookupFromJndi ( ) . getResourceManagement ( ) 
. getResourceAdaptorEntity ( raEntityName ) ; 
if ( raEntity == null ) { 
boolean handleReference = in . readBoolean ( ) ; 
if ( handleReference ) { 
activityHandle = new ActivityHandleReference ( null , ( Address ) in . readObject ( ) , in . readUTF ( ) ) ; 
final Marshaler marshaler = raEntity . getMarshaler ( ) ; 
if ( marshaler != null ) { 
activityHandle = marshaler . unmarshalHandle ( in ) ; 
out . writeUTF ( raEntity . getName ( ) ) ; 
if ( activityHandle . getClass ( ) == ActivityHandleReference . class ) { 
final ActivityHandleReference reference = ( ActivityHandleReference ) activityHandle ; 
out . writeObject ( reference . getAddress ( ) ) ; 
out . writeUTF ( reference . getId ( ) ) ; 
marshaler . marshalHandle ( activityHandle , out ) ; 
} public void generateClasses ( ) { 
ProfileSpecificationDescriptor profileDescriptor = profileComponent . getDescriptor ( ) ; 
ProfileCMPInterfaceDescriptor cmpInterface = profileDescriptor . getProfileCMPInterface ( ) ; 
String concreteProfileEntityClassName = cmpInterface . getProfileCmpInterfaceName ( ) + "_PE" ; 
CtClass concreteProfileEntityClass = ClassGeneratorUtils . createClass ( concreteProfileEntityClassName , new String [ ] { cmpInterface . getProfileCmpInterfaceName ( ) , Serializable . class . getName ( ) } ) ; 
ClassGeneratorUtils . createInheritanceLink ( concreteProfileEntityClass , ProfileEntity . class . getName ( ) ) ; 
ClassGeneratorUtils . addAnnotation ( Entity . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , concreteProfileEntityClass ) ; 
LinkedHashMap < String , Object > idClassMVs = new LinkedHashMap < String , Object > ( ) ; 
idClassMVs . put ( "value" , JPAProfileId . class ) ; 
ClassGeneratorUtils . addAnnotation ( IdClass . class . getName ( ) , idClassMVs , concreteProfileEntityClass ) ; 
Set < String > uniqueConstraints = new HashSet < String > ( ) ; 
CtMethod getProfileNameMethod = CtNewMethod . make ( getProfileNameMethodSrc , concreteProfileEntityClass ) ; 
ClassGeneratorUtils . addAnnotation ( Id . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , getProfileNameMethod ) ; 
concreteProfileEntityClass . addMethod ( getProfileNameMethod ) ; 
CtMethod getTableNameMethod = CtNewMethod . make ( getTableNameMethodSrc , concreteProfileEntityClass ) ; 
ClassGeneratorUtils . addAnnotation ( Id . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , getTableNameMethod ) ; 
concreteProfileEntityClass . addMethod ( getTableNameMethod ) ; 
ClassPool pool = profileComponent . getClassPool ( ) ; 
CtClass cmpInterfaceClass = pool . get ( cmpInterface . getProfileCmpInterfaceName ( ) ) ; 
CtClass listClass = pool . get ( List . class . getName ( ) ) ; 
Map < String , Class < ? > > profileEntityArrayAttrValueClassMap = new HashMap < String , Class < ? > > ( ) ; 
for ( CtMethod method : cmpInterfaceClass . getMethods ( ) ) { 
if ( ! method . getDeclaringClass ( ) . getName ( ) . equals ( Object . class . getName ( ) ) && method . getName ( ) . startsWith ( "get" ) ) { 
String fieldName = Introspector . decapitalize ( method . getName ( ) . replaceFirst ( "get" , "" ) ) ; 
boolean array = method . getReturnType ( ) . isArray ( ) ; 
CtClass returnType = array ? listClass : method . getReturnType ( ) ; 
CtField genField = ClassGeneratorUtils . addField ( returnType , fieldName , concreteProfileEntityClass ) ; 
fieldName = genField . getName ( ) ; 
String pojoCmpAccessorSufix = ClassGeneratorUtils . getPojoCmpAccessorSufix ( genField . getName ( ) ) ; 
CtMethod ctMethod = CtNewMethod . getter ( "get" + pojoCmpAccessorSufix , genField ) ; 
ProfileAttribute profileAttribute = profileComponent . getProfileAttributes ( ) . get ( fieldName ) ; 
concreteProfileEntityClass . addMethod ( ctMethod ) ; 
if ( array ) { 
Class < ? > profileAttributeArrayValueClass = generateProfileAttributeArrayValueClass ( concreteProfileEntityClass , fieldName , profileAttribute . isUnique ( ) ) ; 
profileEntityArrayAttrValueClassMap . put ( fieldName , profileAttributeArrayValueClass ) ; 
LinkedHashMap < String , Object > map = new LinkedHashMap < String , Object > ( ) ; 
map . put ( "targetEntity" , profileAttributeArrayValueClass ) ; 
map . put ( "mappedBy" , "owner" ) ; 
map . put ( "cascade" , new CascadeType [ ] { CascadeType . ALL } ) ; 
ClassGeneratorUtils . addAnnotation ( OneToMany . class . getName ( ) , map , ctMethod ) ; 
map = new LinkedHashMap < String , Object > ( ) ; 
map . put ( "value" , new org . hibernate . annotations . CascadeType [ ] { org . hibernate . annotations . CascadeType . DELETE_ORPHAN } ) ; 
ClassGeneratorUtils . addAnnotation ( Cascade . class . getName ( ) , map , ctMethod ) ; 
if ( profileAttribute . isUnique ( ) ) { 
uniqueConstraints . add ( Introspector . decapitalize ( pojoCmpAccessorSufix ) ) ; 
if ( ! returnType . isPrimitive ( ) && ! returnType . getName ( ) . equals ( "java.lang.String" ) ) 
map . put ( "length" , 512 ) ; 
ClassGeneratorUtils . addAnnotation ( Column . class . getName ( ) , map , ctMethod ) ; 
ctMethod = CtNewMethod . setter ( "set" + pojoCmpAccessorSufix , genField ) ; 
String tableName = "SLEE_PE_" + profileComponent . getProfileCmpInterfaceClass ( ) . getSimpleName ( ) + "_" + Math . abs ( ( long ) profileComponent . getComponentID ( ) . hashCode ( ) ) ; 
addTableAnnotation ( tableName , uniqueConstraints , concreteProfileEntityClass ) ; 
jpaProfileDataSource . setProfileEntityArrayAttrValueClassMap ( profileEntityArrayAttrValueClassMap ) ; 
concreteProfileEntityClass . writeFile ( deployDir ) ; 
jpaProfileDataSource . setProfileEntityClass ( Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteProfileEntityClass . getName ( ) ) ) ; 
concreteProfileEntityClass . defrost ( ) ; 
} private Class < ? > generateProfileAttributeArrayValueClass ( CtClass concreteProfileEntityClass , String profileAttributeName , boolean unique ) { 
CtClass concreteArrayValueClass = null ; 
String concreteArrayValueClassName = profileComponent . getProfileCmpInterfaceClass ( ) . getName ( ) + "PEAAV_" + ClassGeneratorUtils . capitalize ( profileAttributeName ) ; 
concreteArrayValueClass = ClassGeneratorUtils . createClass ( concreteArrayValueClassName , new String [ ] { Serializable . class . getName ( ) } ) ; 
ClassGeneratorUtils . createInheritanceLink ( concreteArrayValueClass , ProfileEntityArrayAttributeValue . class . getName ( ) ) ; 
ClassGeneratorUtils . addAnnotation ( Entity . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , concreteArrayValueClass ) ; 
addTableAnnotationToPEAAV ( "SLEE_PEAAV_" + profileComponent . getProfileCmpInterfaceClass ( ) . getSimpleName ( ) + "_" + Math . abs ( ( long ) profileComponent . getComponentID ( ) . hashCode ( ) ) + profileAttributeName , unique , concreteArrayValueClass ) ; 
CtMethod getIdNameMethod = CtNewMethod . make ( getIdNameMethodSrc , concreteArrayValueClass ) ; 
ClassGeneratorUtils . addAnnotation ( Id . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , getIdNameMethod ) ; 
ClassGeneratorUtils . addAnnotation ( GeneratedValue . class . getName ( ) , new LinkedHashMap < String , Object > ( ) , getIdNameMethod ) ; 
concreteArrayValueClass . addMethod ( getIdNameMethod ) ; 
CtMethod getSerializableMethod = CtNewMethod . make ( getSerializableMethodSrc , concreteArrayValueClass ) ; 
map . put ( "name" , "serializable" ) ; 
ClassGeneratorUtils . addAnnotation ( Column . class . getName ( ) , map , getSerializableMethod ) ; 
concreteArrayValueClass . addMethod ( getSerializableMethod ) ; 
CtMethod getStringMethod = CtNewMethod . make ( getStringMethodSrc , concreteArrayValueClass ) ; 
map . put ( "name" , "string" ) ; 
ClassGeneratorUtils . addAnnotation ( Column . class . getName ( ) , map , getStringMethod ) ; 
concreteArrayValueClass . addMethod ( getStringMethod ) ; 
CtField ctField = ClassGeneratorUtils . addField ( concreteProfileEntityClass , "owner" , concreteArrayValueClass ) ; 
ClassGeneratorUtils . generateSetter ( ctField , null ) ; 
CtMethod getter = ClassGeneratorUtils . generateGetter ( ctField , null ) ; 
ConstPool cp = getter . getMethodInfo ( ) . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) getter . getMethodInfo ( ) . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
if ( attr == null ) { 
Annotation manyToOne = new Annotation ( ManyToOne . class . getName ( ) , cp ) ; 
manyToOne . addMemberValue ( "optional" , new BooleanMemberValue ( false , cp ) ) ; 
attr . addAnnotation ( manyToOne ) ; 
Annotation joinColumns = new Annotation ( JoinColumns . class . getName ( ) , cp ) ; 
Annotation joinColumn1 = new Annotation ( JoinColumn . class . getName ( ) , cp ) ; 
joinColumn1 . addMemberValue ( "name" , new StringMemberValue ( "owner_tableName" , cp ) ) ; 
joinColumn1 . addMemberValue ( "referencedColumnName" , new StringMemberValue ( "tableName" , cp ) ) ; 
Annotation joinColumn2 = new Annotation ( JoinColumn . class . getName ( ) , cp ) ; 
joinColumn2 . addMemberValue ( "name" , new StringMemberValue ( "owner_profileName" , cp ) ) ; 
joinColumn2 . addMemberValue ( "referencedColumnName" , new StringMemberValue ( "profileName" , cp ) ) ; 
ArrayMemberValue joinColumnsMemberValue = new ArrayMemberValue ( cp ) ; 
joinColumnsMemberValue . setValue ( new MemberValue [ ] { new AnnotationMemberValue ( joinColumn1 , cp ) , new AnnotationMemberValue ( joinColumn2 , cp ) } ) ; 
joinColumns . addMemberValue ( "value" , joinColumnsMemberValue ) ; 
attr . addAnnotation ( joinColumns ) ; 
getter . getMethodInfo ( ) . addAttribute ( attr ) ; 
CtMethod setProfileEntityMethod = CtMethod . make ( setProfileEntityMethodSrc , concreteArrayValueClass ) ; 
concreteArrayValueClass . addMethod ( setProfileEntityMethod ) ; 
concreteArrayValueClass . writeFile ( deployDir ) ; 
return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteArrayValueClass . getName ( ) ) ; 
if ( concreteArrayValueClass != null ) { 
concreteArrayValueClass . defrost ( ) ; 
} public int compare ( SbbEntityID sbbEntityID1 , SbbEntityID sbbEntityID2 ) { 
if ( sbbEntityID1 == sbbEntityID2 ) { 
if ( sbbEntityID1 == null ) { 
if ( sbbEntityID2 == null ) { 
return higherPrioritySbb ( sbbEntityID1 , sbbEntityID2 ) ; 
public Collection < ProfileEntity > findProfilesByAttribute ( 
String profileTable , ProfileAttribute profileAttribute , 
Object attributeValue ) { 
EntityManager em = getEntityManager ( ) ; 
Query query = null ; 
query = em 
. createQuery ( 
+ profileEntityClassName 
. setParameter ( "tableName" , profileTable ) ; 
+ profileAttribute . getName ( ) 
. setParameter ( "tableName" , profileTable ) . setParameter ( 
"attrValue" , attributeValue . toString ( ) ) ; 
"tableName" , profileTable ) . setParameter ( 
"attrValue" , attributeValue ) ; 
Collection < ProfileEntity > result = query . getResultList ( ) ; 
} public ProfileEntity findProfile ( String profileTable , String profileName ) { 
Query query = em . createQuery ( 
. setParameter ( 1 , profileTable ) . setParameter ( 2 , profileName ) ; 
List < ? > resultList = query . getResultList ( ) ; 
if ( resultList . isEmpty ( ) ) { 
return ( ProfileEntity ) resultList . get ( 0 ) ; 
public Collection < ProfileEntity > getProfilesByStaticQuery ( 
String profileTable , String queryName , final Object [ ] parameters ) 
throws NullPointerException , UnrecognizedQueryNameException , 
AttributeTypeMismatchException , InvalidArgumentException { 
final QueryWrapper wQuery = JPAQueryBuilder . getQuery ( queryName ) ; 
final EntityManager em = getEntityManager ( ) ; 
Query staticQuery = em . createQuery ( wQuery 
. getQuerySQL ( profileEntityClassName ) ) ; 
if ( wQuery . getMaxMatches ( ) > 0 ) 
staticQuery . setMaxResults ( ( int ) wQuery . getMaxMatches ( ) ) ; 
for ( int i = 0 ; i < parameters . length ; i ++ ) { 
staticQuery . setParameter ( i + 1 , parameters [ i ] ) ; 
return staticQuery . getResultList ( ) ; 
return AccessController . doPrivileged ( new PrivilegedExceptionAction < Collection < ProfileEntity > > ( ) { 
public Collection < ProfileEntity > run ( ) throws Exception { 
} catch ( PrivilegedActionException e ) { 
Throwable t = e . getCause ( ) ; 
if ( t instanceof NullPointerException ) 
throw ( NullPointerException ) t ; 
if ( t instanceof UnrecognizedQueryNameException ) 
throw ( UnrecognizedQueryNameException ) t ; 
if ( t instanceof AttributeTypeMismatchException ) 
throw ( AttributeTypeMismatchException ) t ; 
if ( t instanceof InvalidArgumentException ) 
throw ( InvalidArgumentException ) t ; 
throw new SLEEException ( "" , t ) ; 
public Collection < ProfileEntity > getProfilesByDynamicQuery ( 
String profileTable , QueryExpression expr ) 
QueryWrapper wQuery = JPAQueryBuilder . parseDynamicQuery ( expr ) ; 
Query dynamicQuery = em . createQuery ( wQuery 
for ( Object param : wQuery . getDynamicParameters ( ) ) { 
dynamicQuery . setParameter ( i ++ , param ) ; 
dynamicQuery . setMaxResults ( ( int ) wQuery . getMaxMatches ( ) ) ; 
return dynamicQuery . getResultList ( ) ; 
} public void persistProfile ( ProfileEntity profileEntity ) { 
EntityManager em = null ; 
em = getEntityManager ( ) ; 
em . persist ( profileEntity ) ; 
} public ProfileEntity retrieveProfile ( String profileTable , String profileName ) { 
profileName = DEFAULT_PROFILE_NAME ; 
final Query q = em . createQuery ( 
List < ? > resultList = q . getResultList ( ) ; 
if ( resultList . size ( ) > 0 ) { 
return AccessController . doPrivileged ( new PrivilegedAction < ProfileEntity > ( ) { 
public ProfileEntity run ( ) { 
} public void renameProfileTable ( String oldProfileTableName , String newProfileTableName ) { 
. setParameter ( 1 , newProfileTableName ) . setParameter ( 2 , oldProfileTableName ) ; 
q . executeUpdate ( ) ; 
} public void install ( ) { 
new ConcreteProfileEntityGenerator ( component , this ) 
. generateClasses ( ) ; 
profileEntityClassName = profileEntityClass . getName ( ) ; 
profileEntityFactoryClass = new ConcreteProfileEntityFactoryGenerator ( 
component , profileEntityClass , 
profileEntityArrayAttrValueClassMap ) . generateClass ( ) ; 
profileEntityFactory = ( ProfileEntityFactory ) profileEntityFactoryClass 
component . setProfileCmpConcreteClass ( new ConcreteProfileGenerator ( 
component ) . generateConcreteProfile ( ) ) ; 
createPersistenceUnit ( component ) ; 
new JPAQueryBuilder ( component ) . parseStaticQueries ( ) ; 
} public void uninstall ( ) { 
Transaction tx = null ; 
tx = sleeTransactionManager . suspend ( ) ; 
if ( entityManagerFactory != null ) { 
entityManagerFactory . close ( ) ; 
sleeTransactionManager . resume ( tx ) ; 
private EntityManager getEntityManager ( ) { 
if ( txDataKey == null ) { 
txDataKey = new StringBuilder ( "jpapef.em." ) . append ( component . getProfileSpecificationID ( ) ) . toString ( ) ; 
Map transactionContextData = txContext . getData ( ) ; 
EntityManager result = ( EntityManager ) transactionContextData 
. get ( txDataKey ) ; 
result = entityManagerFactory . createEntityManager ( ) ; 
transactionContextData . put ( txDataKey , result ) ; 
} public void start ( ) throws InvalidStateException , ManagementException { 
final SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { 
public void stateChanged ( SleeState oldState ) { 
logger . debug ( generateMessageWithLogo ( "starting" ) ) ; 
notifyStateChange ( oldState , getNewState ( ) ) ; 
public void requestCompleted ( ) { 
final SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { 
private SleeState oldState ; 
logger . info ( generateMessageWithLogo ( "started" ) ) ; 
this . oldState = oldState ; 
public boolean isBlockingRequest ( ) { 
public SleeState getNewState ( ) { 
return SleeState . RUNNING ; 
sleeContainer . setSleeState ( runningRequest ) ; 
stop ( false ) ; 
return SleeState . STARTING ; 
sleeContainer . setSleeState ( startingRequest ) ; 
} public void shutdown ( ) throws InvalidStateException , ManagementException { 
logger . info ( generateMessageWithLogo ( "shutdown" ) ) ; 
sleeContainer . shutdownSlee ( ) ; 
throw new ManagementException ( ex . getMessage ( ) ) ; 
} public void addNotificationListener ( NotificationListener listener , 
NotificationFilter filter , Object handback ) 
notificationBroadcaster . addNotificationListener ( listener , filter , 
handback ) ; 
ServiceComponent specComponent = this . repository . getComponentByID ( this . component . getServiceID ( ) ) ; 
String sopts = ":bu:a:d:cr:plg" ; 
new LongOpt ( "bind" , LongOpt . NO_ARGUMENT , null , 'b' ) , 
new LongOpt ( "link-name" , LongOpt . REQUIRED_ARGUMENT , null , BindOperation . ra_link_name ) , 
new LongOpt ( "entity-name" , LongOpt . REQUIRED_ARGUMENT , null , BindOperation . ra_entity_name ) , 
new LongOpt ( "unbind" , LongOpt . REQUIRED_ARGUMENT , null , 'u' ) , 
new LongOpt ( "activate" , LongOpt . REQUIRED_ARGUMENT , null , 'a' ) , 
new LongOpt ( "deactivate" , LongOpt . REQUIRED_ARGUMENT , null , 'd' ) , 
new LongOpt ( "ra-id" , LongOpt . REQUIRED_ARGUMENT , null , CreateOperation . ra_id ) , 
new LongOpt ( "config" , LongOpt . REQUIRED_ARGUMENT , null , CreateOperation . config ) , 
new LongOpt ( "remove" , LongOpt . REQUIRED_ARGUMENT , null , 'r' ) , 
new LongOpt ( "update-config" , LongOpt . NO_ARGUMENT , null , 'p' ) , 
new LongOpt ( "ra-entities" , LongOpt . OPTIONAL_ARGUMENT , null , ListOperation . ra_entities ) , 
new LongOpt ( "ra-entities-in-state" , LongOpt . REQUIRED_ARGUMENT , null , ListOperation . ra_entities_in_state ) , 
new LongOpt ( "ra-entities-by-link" , LongOpt . REQUIRED_ARGUMENT , null , ListOperation . ra_entities_by_link ) , 
new LongOpt ( "links" , LongOpt . OPTIONAL_ARGUMENT , null , ListOperation . links ) , 
new LongOpt ( "sbbs" , LongOpt . REQUIRED_ARGUMENT , null , ListOperation . sbbs ) , 
new LongOpt ( "state" , LongOpt . REQUIRED_ARGUMENT , null , GetOperation . state ) , 
new LongOpt ( "config-by-id" , LongOpt . REQUIRED_ARGUMENT , null , GetOperation . config_by_id ) , 
new LongOpt ( "config-by-name" , LongOpt . REQUIRED_ARGUMENT , null , GetOperation . config_by_name ) , 
case 'b' : 
super . operation = new BindOperation ( super . context , super . log , this ) ; 
super . operation = new UnBindOperation ( super . context , super . log , this ) ; 
super . operation = new ActivateOperation ( super . context , super . log , this ) ; 
super . operation = new DeactivateOperation ( super . context , super . log , this ) ; 
case 'p' : 
super . operation = new UpdateConfigOperation ( super . context , super . log , this ) ; 
} public static ClassLoader switchSafelyClassLoader ( final ClassLoader cl , final ProfileObject po ) 
ClassLoader _cl = null ; 
_cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
return _switchSafelyClassLoader ( cl , po ) ; 
_cl = _switchSafelyClassLoader ( cl , po ) ; 
return _cl ; 
} public static Object makeSafeProxyCall ( final Object proxy , final String methodToCallname , final Class [ ] signature , final Object [ ] values ) throws PrivilegedActionException 
return AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { 
public Object run ( ) throws Exception { 
final Method m = proxy . getClass ( ) . getMethod ( methodToCallname , signature ) ; 
return m . invoke ( proxy , values ) ; 
} catch ( PrivilegedActionException e ) 
} public boolean isIdentical ( javax . slee . profile . ProfileLocalObject other ) throws SLEEException { 
if ( ! ( other instanceof ProfileLocalObjectImpl ) ) { 
return this . _equals ( other ) ; 
} public void remove ( ) throws TransactionRequiredLocalException , TransactionRolledbackLocalException , SLEEException { 
ProfileEntity profileEntity = profileObject . getProfileEntity ( ) ; 
if ( profileEntity != null ) { 
profileEntity . remove ( ) ; 
if ( getProfileTable ( ) . find ( getProfileName ( ) ) == null ) { 
} catch ( SystemException e1 ) { 
throw new SLEEException ( e1 . getMessage ( ) , e1 ) ; 
} protected void checkTransaction ( ) throws IllegalStateException { 
if ( ! sleeContainer . getTransactionManager ( ) . getTransaction ( ) . equals ( this . transaction ) ) { 
} protected void processRuntimeException ( RuntimeException e ) throws SLEEException , TransactionRolledbackLocalException { 
} protected void processPrivilegedActionException ( PrivilegedActionException e ) throws Exception , TransactionRolledbackLocalException { 
if ( e . getCause ( ) instanceof RuntimeException ) { 
processRuntimeException ( ( RuntimeException ) e . getCause ( ) ) ; 
else if ( e . getCause ( ) instanceof Exception ) { 
throw ( Exception ) e . getCause ( ) ; 
} private static String toTTL ( String lastAccess , long timeout ) { 
Long ttl = timeout - ( ( System . currentTimeMillis ( ) - Long . parseLong ( lastAccess ) ) / 1000 ) ; 
return ttl . toString ( ) ; 
} boolean isProfileClassVisible ( ) { 
Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileAfterAction . getClass ( ) . getName ( ) ) ; 
} ProfileObjectImpl getProfileObjectValidInCurrentTransaction ( ProfileEntity profileEntity ) throws TransactionRequiredLocalException { 
final SleeTransactionManager txManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; 
if ( txData == null ) { 
txData = new HashMap < ProfileEntity , ProfileObjectImpl > ( ) ; 
ProfileObjectImpl profileObject = ( ProfileObjectImpl ) txData . get ( profileEntity ) ; 
if ( profileObject == null ) { 
profileEntity . setReadOnly ( true ) ; 
profileEntity . setDirty ( false ) ; 
ProfileObjectPool pool = profileManagement . getObjectPoolManagement ( ) . getObjectPool ( profileEntity . getTableName ( ) ) ; 
profileObject = pool . borrowObject ( ) ; 
profileObject . profileActivate ( profileEntity ) ; 
ProfileTableTransactionView . passivateProfileObjectOnTxEnd ( txManager , profileObject , pool ) ; 
txData . put ( profileEntity , profileObject ) ; 
} public List < String > getLoggerNames ( String regex ) throws ManagementConsoleException { 
return ( List < String > ) this . mbeanServer . invoke ( logMgmtMBeanName , "getLoggerNames" , new Object [ ] { regex } , new String [ ] { "java.lang.String" } ) ; 
} public void resetLoggerLevels ( ) throws ManagementConsoleException { 
this . mbeanServer . invoke ( logMgmtMBeanName , "resetLoggerLevels" , null , null ) ; 
} public void clearLoggers ( String name ) throws ManagementConsoleException { 
this . mbeanServer . invoke ( logMgmtMBeanName , "clearLoggers" , new Object [ ] { name } , new String [ ] { "java.lang.String" } ) ; 
} public boolean addLogger ( String name , Level level ) throws NullPointerException , ManagementConsoleException { 
return ( ( Boolean ) this . mbeanServer . invoke ( logMgmtMBeanName , "addLogger" , new Object [ ] { name , level } , new String [ ] { "java.lang.String" , 
"java.util.logging.Level" } ) ) . booleanValue ( ) ; 
} public void addSocketHandler ( String loggerName , Level handlerLevel , String handlerName , String formaterClassName , String filterClassName , String host , 
int port ) throws ManagementConsoleException { 
this . mbeanServer . invoke ( logMgmtMBeanName , "addSocketHandler" , new Object [ ] { loggerName , handlerLevel , handlerName , formaterClassName , filterClassName , 
host , port } , new String [ ] { "java.lang.String" , "java.util.logging.Level" , "java.lang.String" , "java.lang.String" , "java.lang.String" , 
"java.lang.String" , "int" } ) ; 
} public boolean removeHandler ( String loggerName , String handlerName ) throws ManagementConsoleException { 
return ( ( Boolean ) this . mbeanServer . invoke ( logMgmtMBeanName , "removeHandler" , new Object [ ] { loggerName , handlerName } , new String [ ] { "java.lang.String" , 
"java.lang.String" } ) ) . booleanValue ( ) ; 
} public void addNotificationHandler ( String loggerName , int numberOfEntries , Level level , String formaterClassName , String filterClassName ) 
throws IllegalArgumentException , IllegalStateException , NullPointerException , ManagementConsoleException { 
this . mbeanServer . invoke ( logMgmtMBeanName , "addNotificationHandler" , 
new Object [ ] { loggerName , numberOfEntries , level , formaterClassName , filterClassName } , new String [ ] { "java.lang.String" , "int" , 
"java.util.logging.Logger" , "java.lang.String" , "java.lang.String" } ) ; 
} public void onShow ( ) { 
ListPanel operations = new ListPanel ( ) ; 
operations . setWidth ( "100%" ) ; 
this . display . setHorizontalAlignment ( DockPanel . ALIGN_CENTER ) ; 
this . display . setVerticalAlignment ( DockPanel . ALIGN_TOP ) ; 
this . display . add ( operations , DockPanel . CENTER ) ; 
this . display . setCellHeight ( operations , "100%" ) ; 
this . display . setCellWidth ( operations , "100%" ) ; 
operations . setHeader ( 1 , "Parameters" ) ; 
operations . setColumnWidth ( 0 , "33%" ) ; 
operations . setColumnWidth ( 1 , "33%" ) ; 
operations . setColumnWidth ( 2 , "33%" ) ; 
operations . setCell ( 1 , 1 , null ) ; 
operations . setCell ( 1 , 2 , _defaultLoggerLevel ) ; 
_defaultLoggerLevel . setTitle ( _ll_Explanation ) ; 
operations . setCell ( 2 , 1 , null ) ; 
operations . setCell ( 2 , 2 , _defaultHandlerLevel ) ; 
_defaultHandlerLevel . setTitle ( _hl_Explanation ) ; 
Hyperlink readLink = new Hyperlink ( "Trigger" , null ) ; 
operations . setCell ( 3 , 1 , _readUri ) ; 
operations . setCell ( 3 , 2 , readLink ) ; 
readLink . setTitle ( _cfg_Explanation ) ; 
Hyperlink resetLink = new Hyperlink ( "Trigger" , null ) ; 
operations . setCell ( 4 , 1 , _resetLoggerList ) ; 
operations . setCell ( 4 , 2 , resetLink ) ; 
resetLink . setTitle ( _reset_Explanation ) ; 
Hyperlink clearLink = new Hyperlink ( "Trigger" , null ) ; 
operations . setCell ( 5 , 1 , _clearLoggerList ) ; 
operations . setCell ( 5 , 2 , clearLink ) ; 
clearLink . setTitle ( _cclear_Explanation ) ; 
Hyperlink addLogger = new Hyperlink ( "Trigger" , null ) ; 
operations . setCell ( 6 , 1 , _newLoggerName ) ; 
operations . setCell ( 6 , 2 , addLogger ) ; 
addLogger . setTitle ( _add_Logger_Explanation ) ; 
Hyperlink setInterval = new Hyperlink ( "Trigger" , null ) ; 
operations . setCell ( 7 , 1 , _defaultNotificationInterval ) ; 
operations . setCell ( 7 , 2 , setInterval ) ; 
_defaultLoggerLevel . addClickListener ( new ClickListener ( ) { 
public void onClick ( Widget arg0 ) { 
ServerConnection . logServiceAsync . setDefaultLoggerLevel ( _defaultLoggerLevel . getItemText ( _defaultLoggerLevel . getSelectedIndex ( ) ) , new AsyncCallback ( ) { 
public void onFailure ( Throwable t ) { 
public void onSuccess ( Object arg0 ) { 
_defaultHandlerLevel . addClickListener ( new ClickListener ( ) { 
ServerConnection . logServiceAsync . setDefaultHandlerLevel ( _defaultHandlerLevel . getItemText ( _defaultHandlerLevel . getSelectedIndex ( ) ) , new AsyncCallback ( ) { 
readLink . addClickListener ( new ClickListener ( ) { 
ServerConnection . logServiceAsync . reReadConf ( _readUri . getText ( ) , new AsyncCallback ( ) { 
logStructureTreePanel . refreshData ( ) ; 
resetLink . addClickListener ( new ClickListener ( ) { 
ServerConnection . logServiceAsync . resetLoggerLevel ( _resetLoggerList . getText ( ) , new AsyncCallback ( ) { 
clearLink . addClickListener ( new ClickListener ( ) { 
ServerConnection . logServiceAsync . clearLoggers ( _clearLoggerList . getText ( ) , new AsyncCallback ( ) { 
addLogger . addClickListener ( new ClickListener ( ) { 
ServerConnection . logServiceAsync . addLogger ( _newLoggerName . getText ( ) , _defaultLoggerLevel . getItemText ( _defaultLoggerLevel . getSelectedIndex ( ) ) , 
new AsyncCallback ( ) { 
setInterval . addClickListener ( new ClickListener ( ) { 
int di = - 1 ; 
di = Integer . valueOf ( _defaultNotificationInterval . getText ( ) ) . intValue ( ) ; 
ServerConnection . logServiceAsync . setDefaultNotificationInterval ( di , new AsyncCallback ( ) { 
ServerConnection . logServiceAsync . getDefaultNotificationInterval ( new AsyncCallback ( ) { 
public void onSuccess ( Object o ) { 
_defaultNotificationInterval . setText ( o + "" ) ; 
ServerConnection . logServiceAsync . getDefaultHandlerLevel ( new AsyncCallback ( ) { 
setValue ( ( String ) arg0 , _defaultHandlerLevel ) ; 
ServerConnection . logServiceAsync . getDefaultLoggerLevel ( new AsyncCallback ( ) { 
setValue ( ( String ) arg0 , _defaultLoggerLevel ) ; 
} public static AddressScreening fromInt ( int value ) throws IllegalArgumentException { 
case ADDRESS_SCREENING_UNDEFINED : return UNDEFINED ; 
case ADDRESS_SCREENING_USER_NOT_VERIFIED : return USER_NOT_VERIFIED ; 
case ADDRESS_SCREENING_USER_VERIFIED_PASSED : return USER_VERIFIED_PASSED ; 
case ADDRESS_SCREENING_USER_VERIFIED_FAILED : return USER_VERIFIED_FAILED ; 
case ADDRESS_SCREENING_NETWORK : return NETWORK ; 
} public AddressScreening fromString ( String value ) throws NullPointerException , IllegalArgumentException { 
if ( value . equalsIgnoreCase ( USER_NOT_VERIFIED_STRING ) ) return USER_NOT_VERIFIED ; 
if ( value . equalsIgnoreCase ( USER_VERIFIED_PASSED_STRING ) ) return USER_VERIFIED_PASSED ; 
if ( value . equalsIgnoreCase ( USER_VERIFIED_FAILED_STRING ) ) return USER_VERIFIED_FAILED ; 
if ( value . equalsIgnoreCase ( NETWORK_STRING ) ) return NETWORK ; 
} public List < ResourceAdaptorTypeDescriptorImpl > parse ( InputStream inputStream ) throws DeploymentException 
List < ResourceAdaptorTypeDescriptorImpl > result = new ArrayList < ResourceAdaptorTypeDescriptorImpl > ( ) ; 
MResourceAdaptorTypeJar mResourceAdaptorTypeJar = null ; 
if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee . ratype . ResourceAdaptorTypeJar ) 
mResourceAdaptorTypeJar = new MResourceAdaptorTypeJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee . ratype . ResourceAdaptorTypeJar ) jaxbPojo ) ; 
else if ( jaxbPojo instanceof org . mobicents . slee . container . component . deployment . jaxb . slee11 . ratype . ResourceAdaptorTypeJar ) 
mResourceAdaptorTypeJar = new MResourceAdaptorTypeJar ( ( org . mobicents . slee . container . component . deployment . jaxb . slee11 . ratype . ResourceAdaptorTypeJar ) jaxbPojo ) ; 
for ( MResourceAdaptorType mResourceAdaptorType : mResourceAdaptorTypeJar . getResourceAdaptorType ( ) ) 
result . add ( new ResourceAdaptorTypeDescriptorImpl ( mResourceAdaptorType , isSlee11 ) ) ; 
} public Object getCMPField ( String cmpFieldName ) { 
return cacheData . getCmpField ( cmpFieldName ) ; 
} public void setCMPField ( String cmpFieldName , Object cmpFieldValue ) { 
cacheData . setCmpField ( cmpFieldName , cmpFieldValue ) ; 
} public void afterACAttach ( ActivityContextHandle ach ) { 
cacheData . attachActivityContext ( ach ) ; 
Set < EventTypeID > maskedEvents = getSbbComponent ( ) . getDescriptor ( ) . getDefaultEventMask ( ) ; 
if ( maskedEvents != null && ! maskedEvents . isEmpty ( ) ) { 
cacheData . updateEventMask ( ach , new HashSet < EventTypeID > ( maskedEvents ) ) ; 
} public void afterACDetach ( ActivityContextHandle ach ) { 
cacheData . detachActivityContext ( ach ) ; 
} public byte getPriority ( ) { 
if ( priority == null ) { 
priority = cacheData . getPriority ( ) ; 
return priority . byteValue ( ) ; 
} public void setPriority ( byte value ) { 
priority = Byte . valueOf ( value ) ; 
cacheData . setPriority ( priority ) ; 
log . trace ( "remove()" ) ; 
for ( Iterator < ActivityContextHandle > i = this . getActivityContexts ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
ActivityContextHandle ach = i . next ( ) ; 
if ( ac != null && ! ac . isEnding ( ) ) { 
ac . detachSbbEntity ( this . sbbeId ) ; 
boolean invokingServiceSet = SleeThreadLocals 
. getInvokingService ( ) != null ; 
if ( ! invokingServiceSet ) { 
SleeThreadLocals . setInvokingService ( getServiceId ( ) ) ; 
if ( this . sbbObject == null ) { 
this . assignSbbObject ( ) ; 
removeAndReleaseSbbObject ( ) ; 
this . trashObject ( ) ; 
for ( SbbEntityID childSbbEntityId : cacheData . getAllChildSbbEntities ( ) ) { 
SbbEntity childSbbEntity = sbbEntityFactory . getSbbEntity ( childSbbEntityId , false ) ; 
if ( childSbbEntity != null ) { 
sbbEntityFactory . removeSbbEntity ( childSbbEntity , false ) ; 
cacheData . remove ( ) ; 
} public void trashObject ( ) { 
getObjectPool ( ) . returnObject ( sbbObject ) ; 
this . sbbObject = null ; 
} public void sbbRolledBack ( Object event , 
ActivityContextInterface activityContextInterface , 
boolean removeRollback ) { 
if ( sbbObject != null ) { 
sbbObject . sbbRolledBack ( event , activityContextInterface , removeRollback ) ; 
passivateAndReleaseSbbObject ( ) ; 
} public SbbID getSbbId ( ) { 
if ( _sbbID == null ) { 
ServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getServiceId ( ) ) ; 
SbbComponent sbbComponent = null ; 
if ( sbbeId . isRootSbbEntity ( ) ) { 
_sbbID = serviceComponent . getRootSbbComponent ( ) . getSbbID ( ) ; 
final LinkedList < SbbEntityID > stack = new LinkedList < SbbEntityID > ( ) ; 
SbbEntityID sbbEntityID = sbbeId . getParentSBBEntityID ( ) ; 
while ( ! sbbEntityID . isRootSbbEntity ( ) ) { 
stack . push ( sbbEntityID ) ; 
sbbEntityID = sbbEntityID . getParentSBBEntityID ( ) ; 
sbbComponent = serviceComponent . getRootSbbComponent ( ) ; 
GetChildRelationMethodDescriptor getChildRelationMethodDescriptor = null ; 
sbbEntityID = stack . pop ( ) ; 
getChildRelationMethodDescriptor = sbbComponent . getDescriptor ( ) . getGetChildRelationMethodsMap ( ) . get ( sbbEntityID . getParentChildRelation ( ) ) ; 
sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getChildRelationMethodDescriptor . getSbbID ( ) ) ; 
getChildRelationMethodDescriptor = sbbComponent . getDescriptor ( ) . getGetChildRelationMethodsMap ( ) . get ( sbbeId . getParentChildRelation ( ) ) ; 
_sbbID = getChildRelationMethodDescriptor . getSbbID ( ) ; 
return _sbbID ; 
} public void invokeEventHandler ( EventContext sleeEvent , ActivityContext ac , 
EventContext eventContextImpl ) throws Exception { 
final SbbComponent sbbComponent = getSbbComponent ( ) ; 
final EventHandlerMethod eventHandlerMethod = sbbComponent 
. getEventHandlerMethods ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; 
ActivityContextInterface aci = asSbbActivityContextInterface ( ac . getActivityContextInterface ( ) ) ; 
final Object [ ] parameters ; 
if ( eventHandlerMethod . getHasEventContextParam ( ) ) { 
parameters = new Object [ ] { sleeEvent . getEvent ( ) , 
aci , eventContextImpl } ; 
aci } ; 
final EventRoutingTransactionData data = new EventRoutingTransactionDataImpl ( 
sleeEvent , aci ) ; 
txContext . setEventRoutingTransactionData ( data ) ; 
Set < SbbEntityID > invokedSbbentities = null ; 
if ( ! isReentrant ( ) ) { 
invokedSbbentities = txContext . getInvokedNonReentrantSbbEntities ( ) ; 
invokedSbbentities . add ( sbbeId ) ; 
AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { 
public Object run ( ) throws IllegalAccessException , InvocationTargetException { 
eventHandlerMethod . getEventHandlerMethod ( ) . invoke ( 
sbbObject . getSbbConcrete ( ) , parameters ) ; 
} catch ( PrivilegedActionException pae ) { 
Throwable cause = pae . getException ( ) ; 
if ( cause instanceof IllegalAccessException ) 
} else if ( cause instanceof InvocationTargetException ) { 
Throwable realException = cause . getCause ( ) ; 
if ( realException instanceof RuntimeException ) { 
throw ( RuntimeException ) realException ; 
} else if ( realException instanceof Error ) { 
throw ( Error ) realException ; 
} else if ( realException instanceof Exception ) { 
throw ( Exception ) realException ; 
pae . printStackTrace ( ) ; 
} catch ( IllegalAccessException iae ) { 
throw new RuntimeException ( iae ) ; 
} catch ( InvocationTargetException ite ) { 
Throwable realException = ite . getCause ( ) ; 
log . error ( e . getMessage ( ) , e ) ; 
if ( invokedSbbentities != null ) { 
invokedSbbentities . remove ( sbbeId ) ; 
txContext . setEventRoutingTransactionData ( null ) ; 
} public void passivateAndReleaseSbbObject ( ) { 
this . sbbObject . sbbStore ( ) ; 
this . sbbObject . sbbPassivate ( ) ; 
this . sbbObject . setState ( SbbObjectState . POOLED ) ; 
this . sbbObject . setSbbEntity ( null ) ; 
getObjectPool ( ) . returnObject ( this . sbbObject ) ; 
if ( childsWithSbbObjects != null ) { 
for ( Iterator < SbbEntity > i = childsWithSbbObjects . iterator ( ) ; i 
SbbEntity childSbbEntity = i . next ( ) ; 
if ( childSbbEntity . getSbbObject ( ) != null ) { 
Thread t = Thread . currentThread ( ) ; 
ClassLoader cl = t . getContextClassLoader ( ) ; 
t . setContextClassLoader ( childSbbEntity . getSbbComponent ( ) . getClassLoader ( ) ) ; 
childSbbEntity . passivateAndReleaseSbbObject ( ) ; 
t . setContextClassLoader ( cl ) ; 
} public SbbObjectPool getObjectPool ( ) { 
if ( _pool == null ) { 
_pool = sleeContainer . getSbbManagement ( ) . getObjectPool ( getServiceId ( ) , getSbbId ( ) ) ; 
return this . _pool ; 
} public ChildRelationImpl getChildRelation ( String accessorName ) { 
return new ChildRelationImpl ( this . getSbbComponent ( ) . getDescriptor ( ) 
. getGetChildRelationMethodsMap ( ) . get ( accessorName ) , this ) ; 
} public SbbLocalObjectImpl getSbbLocalObject ( ) { 
if ( doTraceLogs ) 
log . trace ( "getSbbLocalObject()" ) ; 
final Class < ? > sbbLocalClass = getSbbComponent ( ) . getSbbLocalInterfaceConcreteClass ( ) ; 
if ( sbbLocalClass != null ) { 
Object [ ] objs = { this } ; 
Constructor < ? > constructor = getSbbComponent ( ) . getSbbLocalObjectClassConstructor ( ) ; 
if ( constructor == null ) { 
final Class < ? > [ ] types = { SbbEntityImpl . class } ; 
constructor = sbbLocalClass . getConstructor ( types ) ; 
getSbbComponent ( ) . setSbbLocalObjectClassConstructor ( constructor ) ; 
return ( SbbLocalObjectImpl ) constructor . newInstance ( objs ) ; 
return new SbbLocalObjectImpl ( this ) ; 
} public void assignSbbObject ( ) throws Exception { 
this . sbbObject = getObjectPool ( ) . borrowObject ( ) ; 
this . sbbObject . setSbbEntity ( this ) ; 
if ( created ) { 
this . sbbObject . sbbCreate ( ) ; 
this . sbbObject . setState ( SbbObjectState . READY ) ; 
this . sbbObject . sbbPostCreate ( ) ; 
this . sbbObject . sbbActivate ( ) ; 
this . sbbObject . sbbLoad ( ) ; 
removeFromCache ( ) ; 
} private int getNextIndex ( ) { 
int current = index . get ( ) ; 
int next = ( current == executors . length ? 1 : current + 1 ) ; 
if ( index . compareAndSet ( current , next ) ) 
return next - 1 ; 
protected void addExamples ( PrintWriter out ) { 
} private String tracerNameToLog4JLoggerName ( String tracerName , NotificationSource notificationSource ) { 
final StringBuilder sb = new StringBuilder ( "javax.slee." ) . append ( notificationSource . toString ( ) ) ; 
if ( ! tracerName . equals ( ROOT_TRACER_NAME ) ) { 
sb . append ( '.' ) . append ( tracerName ) ; 
} void syncLevelWithLog4j ( ) { 
Level log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; 
assignLog4JLevel ( log4jLevel ) ; 
if ( tracerToLog4JLevel ( level ) != log4jLevel ) { 
if ( parent == null && level == null ) { 
logger . setLevel ( Level . INFO ) ; 
level = TraceLevel . INFO ; 
resetCacheFlags ( false ) ; 
} private void assignLog4JLevel ( Level log4jLevel ) { 
if ( log4jLevel == null ) { 
if ( log4jLevel == Level . DEBUG ) { 
level = TraceLevel . FINE ; 
else if ( log4jLevel == Level . INFO ) { 
else if ( log4jLevel == Level . WARN ) { 
level = TraceLevel . WARNING ; 
else if ( log4jLevel == Level . ERROR ) { 
level = TraceLevel . SEVERE ; 
else if ( log4jLevel == Level . TRACE ) { 
level = TraceLevel . FINEST ; 
else if ( log4jLevel == Level . OFF ) { 
level = TraceLevel . OFF ; 
} void resetCacheFlags ( boolean resetChilds ) { 
if ( isTraceable ( TraceLevel . FINEST ) ) { 
finestEnabled = true ; 
finerEnabled = true ; 
fineEnabled = true ; 
configEnabled = true ; 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
finestEnabled = false ; 
if ( isTraceable ( TraceLevel . FINER ) ) { 
finerEnabled = false ; 
if ( isTraceable ( TraceLevel . FINE ) ) { 
fineEnabled = false ; 
if ( isTraceable ( TraceLevel . CONFIG ) ) { 
if ( isTraceable ( TraceLevel . INFO ) ) { 
infoEnabled = false ; 
if ( isTraceable ( TraceLevel . WARNING ) ) { 
warningEnabled = false ; 
if ( isTraceable ( TraceLevel . SEVERE ) ) { 
severeEnabled = false ; 
if ( resetChilds ) { 
for ( TracerImpl child : childs ) { 
if ( child . level == null ) { 
child . resetCacheFlags ( true ) ; 
} public void config ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . CONFIG , message , null ) ; 
logger . info ( message ) ; 
} public void config ( String message , Throwable t ) 
throws NullPointerException , FacilityException { 
sendNotification ( TraceLevel . CONFIG , message , t ) ; 
logger . info ( message , t ) ; 
} public void fine ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . FINE , message , null ) ; 
logger . debug ( message ) ; 
} public void fine ( String message , Throwable t ) throws NullPointerException , 
sendNotification ( TraceLevel . FINE , message , t ) ; 
logger . debug ( message , t ) ; 
} public void finer ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . FINER , message , null ) ; 
} public void finer ( String message , Throwable t ) throws NullPointerException , 
sendNotification ( TraceLevel . FINER , message , t ) ; 
} public void finest ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . FINEST , message , null ) ; 
logger . trace ( message ) ; 
} public void finest ( String message , Throwable t ) 
sendNotification ( TraceLevel . FINEST , message , t ) ; 
logger . trace ( message , t ) ; 
} public void info ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . INFO , message , null ) ; 
} public void info ( String message , Throwable t ) throws NullPointerException , 
sendNotification ( TraceLevel . INFO , message , t ) ; 
} public void severe ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . SEVERE , message , null ) ; 
logger . error ( message ) ; 
} public void severe ( String message , Throwable t ) 
sendNotification ( TraceLevel . SEVERE , message , t ) ; 
logger . error ( message , t ) ; 
} public void trace ( TraceLevel traceLevel , String message , Throwable t ) 
sendNotification ( traceLevel , message , t ) ; 
logger . log ( tracerToLog4JLevel ( traceLevel ) , message , t ) ; 
} public void warning ( String message ) throws NullPointerException , 
sendNotification ( TraceLevel . WARNING , message , null ) ; 
logger . warn ( message ) ; 
} public void warning ( String message , Throwable t ) 
sendNotification ( TraceLevel . WARNING , message , t ) ; 
logger . warn ( message , t ) ; 
} void sendNotification ( javax . slee . facilities . TraceLevel level , String message , Throwable t ) { 
if ( ! isTraceable ( level ) ) { 
traceMBean . sendNotification ( new TraceNotification ( notificationSource . getNotificationSource ( ) . getTraceNotificationType ( ) , traceMBean , notificationSource . getNotificationSource ( ) , getTracerName ( ) , level , message , t , notificationSource . getNextSequence ( ) , System . currentTimeMillis ( ) ) ) ; 
} public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { 
if ( tracerName . equals ( "" ) ) { 
if ( lastToken . equals ( token ) && token . equals ( "." ) ) { 
if ( lastToken . equals ( "." ) ) { 
} public static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { 
out . defaultWriteObject ( ) ; 
if ( vendorData != null ) { 
out . writeObject ( new MarshalledObject ( vendorData ) ) ; 
else out . writeBoolean ( false ) ; 
} public static Object readObject ( ObjectInputStream in , boolean vendorDataDeserializationEnabled ) throws IOException , ClassNotFoundException { 
in . defaultReadObject ( ) ; 
MarshalledObject vendorData = in . readBoolean ( ) 
? ( MarshalledObject ) in . readObject ( ) 
return ( vendorData != null && vendorDataDeserializationEnabled ) ? vendorData . get ( ) : null ; 
} public void addDirectDependency ( URLClassLoaderDomainImpl domain ) { 
directDependencies . add ( domain ) ; 
} public List < URLClassLoaderDomainImpl > getAllDependencies ( ) { 
List < URLClassLoaderDomainImpl > result = new ArrayList < URLClassLoaderDomainImpl > ( ) ; 
this . getAllDependencies ( result ) ; 
} protected Class < ? > findClassLocally ( String name ) 
final boolean acquiredLock = acquireGlobalLock ( ) ; 
return findClassLocallyLocked ( name ) ; 
if ( acquiredLock ) { 
releaseGlobalLock ( ) ; 
} protected URL findResourceLocally ( String name ) { 
return super . findResource ( name ) ; 
} protected Enumeration < URL > findResourcesLocally ( String name ) 
return super . findResources ( name ) ; 
} public ObjectName createProfile ( java . lang . String profileTableName , java . lang . String profileName ) throws java . lang . NullPointerException , UnrecognizedProfileTableNameException , 
InvalidArgumentException , ProfileAlreadyExistsException , ManagementException { 
ProfileTableImpl . validateProfileName ( profileName ) ; 
ProfileTableImpl . validateProfileTableName ( profileTableName ) ; 
catch ( IllegalArgumentException e ) { 
throw new InvalidArgumentException ( e . getMessage ( ) ) ; 
Transaction transaction = null ; 
sleeTransactionManagement . begin ( ) ; 
transaction = sleeTransactionManagement . getTransaction ( ) ; 
final ProfileTableImpl profileTable = this . sleeProfileManagement . getProfileTable ( profileTableName ) ; 
profileTable . createProfile ( profileName ) ; 
if ( sleeTransactionManagement . getRollbackOnly ( ) ) { 
final AbstractProfileMBeanImpl profileMBean = createAndRegisterProfileMBean ( profileName , profileTable ) ; 
profileTable . addUncommittedProfileMBean ( profileMBean ) ; 
profileTable . removeUncommittedProfileMBean ( profileMBean ) ; 
final TransactionContext txContext = sleeTransactionManagement . getTransactionContext ( ) ; 
profileMBean . createProfile ( ) ; 
return profileMBean . getObjectName ( ) ; 
} catch ( TransactionRequiredLocalException e ) { 
} catch ( SLEEException e ) { 
} catch ( CreateException e ) { 
if ( sleeTransactionManagement . getTransaction ( ) == null ) { 
sleeTransactionManagement . resume ( transaction ) ; 
sleeTransactionManagement . rollback ( ) ; 
} private AbstractProfileMBeanImpl createAndRegisterProfileMBean ( String profileName , ProfileTableImpl profileTable ) throws ManagementException { 
ProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; 
Constructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; 
final AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileName , profileTable ) ; 
profileMBean . register ( ) ; 
TransactionalAction rollbackAction = new TransactionalAction ( ) { 
profileMBean . unregister ( ) ; 
sleeTransactionManagement . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( rollbackAction ) ; 
return profileMBean ; 
} public void createProfileTable ( ProfileSpecificationID specificationID , 
String profileTableName ) throws NullPointerException , 
UnrecognizedProfileSpecificationException , 
InvalidArgumentException , ProfileTableAlreadyExistsException , 
ProfileSpecificationComponent component = sleeContainer . getComponentRepository ( ) . getComponentByID ( specificationID ) ; 
if ( component == null ) 
throw new UnrecognizedProfileSpecificationException ( ) ; 
ClassLoader currentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
boolean terminateTx = sleeTransactionManagement . requireTransaction ( ) ; 
Thread . currentThread ( ) . setContextClassLoader ( component . getClassLoader ( ) ) ; 
sleeProfileManagement . addProfileTable ( profileTableName , component ) ; 
} catch ( ProfileTableAlreadyExistsException e ) { 
Thread . currentThread ( ) . setContextClassLoader ( currentClassLoader ) ; 
sleeTransactionManagement . requireTransactionEnd ( terminateTx , doRollback ) ; 
} public ObjectName getDefaultProfile ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , ManagementException { 
return _getProfile ( profileTableName , null ) ; 
} public ObjectName getProfile ( java . lang . String profileTableName , java . lang . String profileName ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedProfileNameException , 
ObjectName objectName = _getProfile ( profileTableName , profileName ) ; 
return objectName ; 
} public ProfileSpecificationID getProfileSpecification ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , ManagementException { 
if ( profileTableName == null ) 
b = this . sleeTransactionManagement . requireTransaction ( ) ; 
ProfileTableImpl profileTable = this . sleeProfileManagement . getProfileTable ( profileTableName ) ; 
return profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ; 
sleeTransactionManagement . requireTransactionEnd ( b , false ) ; 
} public ObjectName getProfileTableUsageMBean ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , InvalidArgumentException , ManagementException { 
boolean b = this . sleeTransactionManagement . requireTransaction ( ) ; 
ProfileTableUsageMBean usageMBeanImpl = this . sleeProfileManagement . getProfileTable ( profileTableName ) . getProfileTableUsageMBean ( ) ; 
if ( usageMBeanImpl == null ) { 
throw new InvalidArgumentException ( ) ; 
usageMBeanImpl . open ( ) ; 
return usageMBeanImpl . getObjectName ( ) ; 
} public Collection < String > getProfileTables ( ) throws ManagementException { 
logger . debug ( "getProfileTables()" ) ; 
boolean b = sleeTransactionManagement . requireTransaction ( ) ; 
return sleeProfileManagement . getDeclaredProfileTableNames ( ) ; 
} catch ( Exception x ) { 
if ( x instanceof ManagementException ) 
throw ( ManagementException ) x ; 
} public Collection < String > getProfileTables ( ProfileSpecificationID id ) throws java . lang . NullPointerException , UnrecognizedProfileSpecificationException , ManagementException { 
if ( id == null ) { 
return sleeProfileManagement . getDeclaredProfileTableNames ( id ) ; 
} catch ( UnrecognizedProfileSpecificationException x ) { 
throw x ; 
} catch ( Throwable x ) { 
} public Collection < ProfileID > getProfiles ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , ManagementException { 
return sleeProfileManagement . getProfileTable ( profileTableName ) . getProfiles ( ) ; 
} public Collection < ProfileID > getProfilesByAttribute ( String profileTableName , 
String attributeName , Object attributeValue ) 
UnrecognizedAttributeException , AttributeTypeMismatchException , 
ProfileTableImpl profileTable = sleeProfileManagement . getProfileTable ( profileTableName ) ; 
if ( ! profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) { 
return profileTable . getProfilesByAttribute ( attributeName , attributeValue , true ) ; 
} public Collection < ProfileID > getProfilesByDynamicQuery ( String profileTableName , 
QueryExpression queryExpression ) throws NullPointerException , 
if ( queryExpression == null ) { 
for ( ProfileEntity profileEntity : profileTable . getProfileSpecificationComponent ( ) . getProfileEntityFramework ( ) . getProfilesByDynamicQuery ( profileTableName , queryExpression ) ) { 
return profileIDs ; 
} public Collection < ProfileID > getProfilesByStaticQuery ( String profileTableName , String queryName , Object [ ] parameters ) throws NullPointerException , 
UnrecognizedQueryNameException , InvalidArgumentException , 
AttributeTypeMismatchException , ManagementException { 
if ( queryName == null ) { 
for ( ProfileEntity profileEntity : profileTable . getProfileSpecificationComponent ( ) . getProfileEntityFramework ( ) . getProfilesByStaticQuery ( profileTableName , queryName , parameters ) ) { 
} catch ( UnrecognizedQueryNameException e ) { 
} public void removeProfile ( java . lang . String profileTableName , java . lang . String profileName ) throws java . lang . NullPointerException , UnrecognizedProfileTableNameException , 
UnrecognizedProfileNameException , ManagementException { 
if ( profileName == null ) 
boolean rb = true ; 
if ( ! profileTable . profileExists ( profileName ) ) { 
profileTable . removeProfile ( profileName , true , false ) ; 
if ( ! sleeTransactionManagement . getRollbackOnly ( ) ) { 
rb = false ; 
sleeTransactionManagement . requireTransactionEnd ( b , rb ) ; 
} public void removeProfileTable ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , ManagementException { 
boolean rb = false ; 
this . sleeProfileManagement . removeProfileTable ( profileTableName ) ; 
rb = true ; 
} public void renameProfileTable ( java . lang . String oldProfileTableName , java . lang . String newProfileTableName ) throws java . lang . NullPointerException , UnrecognizedProfileTableNameException , 
InvalidArgumentException , ProfileTableAlreadyExistsException , ManagementException { 
if ( oldProfileTableName == null ) 
if ( newProfileTableName == null ) 
ProfileTableImpl . validateProfileTableName ( newProfileTableName ) ; 
this . sleeProfileManagement . renameProfileTable ( oldProfileTableName , newProfileTableName ) ; 
} public static final AbstractUsageParameterSet newInstance ( Class < ? > concreteClass , NotificationSource notificationSource , String parameterSetName , SleeContainer sleeContainer ) 
throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException { 
Constructor < ? > constructor = concreteClass . getConstructor ( NotificationSource . class , String . class , SleeContainer . class ) ; 
return ( AbstractUsageParameterSet ) constructor . newInstance ( notificationSource , parameterSetName , sleeContainer ) ; 
} SleeTransaction suspendTransaction ( ) throws SLEEException { 
final SleeTransaction tx = txManager . getTransaction ( ) ; 
} void resumeTransaction ( SleeTransaction transaction ) throws SLEEException { 
if ( transaction != null ) { 
txManager . resume ( transaction ) ; 
} public ComponentClassLoaderImpl newComponentClassLoader ( 
ComponentID componentID , URLClassLoaderDomain parent ) { 
return new ComponentClassLoaderImpl ( componentID , ( URLClassLoaderDomainImpl ) parent ) ; 
} public javax . slee . management . ServiceDescriptor getSpecsDescriptor ( ) { 
specsDescriptor = new javax . slee . management . ServiceDescriptor ( getServiceID ( ) , 
getDeployableUnit ( ) . getDeployableUnitID ( ) , 
getDeploymentUnitSource ( ) , descriptor . getRootSbbID ( ) , 
descriptor . getAddressProfileTable ( ) , 
descriptor . getResourceInfoProfileTable ( ) ) ; 
} public Set < SbbID > getSbbIDs ( ComponentRepository componentRepository ) { 
Set < SbbID > result = new HashSet < SbbID > ( ) ; 
buildSbbTree ( descriptor . getRootSbbID ( ) , result , 
componentRepository ) ; 
} public Set < String > getResourceAdaptorEntityLinks ( ComponentRepository componentRepository ) { 
for ( SbbID sbbID : getSbbIDs ( componentRepository ) ) { 
SbbComponent sbbComponent = componentRepository . getComponentByID ( sbbID ) ; 
for ( ResourceAdaptorTypeBindingDescriptor raTypeBinding : sbbComponent . getDescriptor ( ) . getResourceAdaptorTypeBindings ( ) ) { 
for ( ResourceAdaptorEntityBindingDescriptor raEntityBinding : raTypeBinding . getResourceAdaptorEntityBinding ( ) ) { 
result . add ( raEntityBinding . getResourceAdaptorEntityLink ( ) ) ; 
} private void registerResource ( String publicID , String resourceName ) 
URL url = this . getClass ( ) . getClassLoader ( ) . getResource ( resourceName ) ; 
resources . put ( publicID , url ) ; 
} public String dumpState ( ) { 
return componentManagement + "\n" + resourceManagement + "\n" 
+ timerFacility + "\n" + traceMBeanImpl + "\n" 
+ sleeProfileTableManager + "\n" + activityContextFactory 
+ "\n" + activityContextNamingFacility + "\n" 
+ nullActivityFactory + "\n" 
+ getEventRouter ( ) + "\n" 
+ getEventContextFactory ( ) + "\n" 
+ getTransactionManager ( ) + "\n" ; 
} public void initSlee ( ) throws InvalidStateException { 
if ( sleeState != null ) { 
beforeModulesInitialization ( ) ; 
for ( Iterator < SleeContainerModule > i = modules . iterator ( ) ; i 
i . next ( ) . sleeInitialization ( ) ; 
afterModulesInitialization ( ) ; 
sleeState = SleeState . STOPPED ; 
} public void shutdownSlee ( ) throws InvalidStateException { 
if ( sleeState != SleeState . STOPPED ) { 
beforeModulesShutdown ( ) ; 
for ( Iterator < SleeContainerModule > i = modules 
. descendingIterator ( ) ; i . hasNext ( ) ; ) { 
i . next ( ) . sleeShutdown ( ) ; 
afterModulesShutdown ( ) ; 
sleeState = null ; 
} private void validateStateTransition ( SleeState oldState , SleeState newState ) 
if ( oldState == SleeState . STOPPED ) { 
if ( newState == SleeState . STARTING ) { 
} else if ( oldState == SleeState . STARTING ) { 
if ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) { 
} else if ( oldState == SleeState . RUNNING ) { 
if ( newState == SleeState . STOPPING ) { 
} else if ( oldState == SleeState . STOPPING ) { 
if ( newState == SleeState . STOPPED ) { 
} public void setExecutorMapperClassName ( String className ) 
Class . forName ( className ) ; 
if ( this . executorMapperClassName != null ) { 
+ className 
this . executorMapperClassName = className ; 
} public ProfileLocalObject getProfileLocalObject ( ) 
throws IllegalStateException , SLEEException { 
if ( profileObject == null 
|| profileObject . getState ( ) == ProfileObjectState . PROFILE_INITIALIZATION 
|| profileObject . getProfileEntity ( ) == null ) { 
if ( profileObject . getProfileEntity ( ) . getProfileName ( ) == null ) { 
} public String getProfileName ( ) throws IllegalStateException , SLEEException { 
doGeneralChecks ( ) ; 
return this . profileObject . getProfileEntity ( ) . getProfileName ( ) ; 
} public ProfileTable getProfileTable ( String profileTableName ) 
return this . profileTable . getSleeContainer ( ) 
. getSleeProfileTableManager ( ) . getProfileTable ( profileTableName ) ; 
} public String getProfileTableName ( ) throws SLEEException { 
return this . profileTable . getProfileTableName ( ) ; 
final SleeTransactionManager txMgr = profileTable . getSleeContainer ( ) 
} public Tracer getTracer ( String tracerName ) throws NullPointerException , 
IllegalArgumentException , SLEEException { 
TracerImpl . checkTracerName ( tracerName , this . profileTable 
. getProfileTableNotification ( ) . getNotificationSource ( ) ) ; 
} catch ( InvalidArgumentException e1 ) { 
throw new IllegalArgumentException ( e1 ) ; 
return profileTable . getSleeContainer ( ) . getTraceManagement ( ) 
. createTracer ( 
this . profileTable . getProfileTableNotification ( ) 
. getNotificationSource ( ) , tracerName , true ) ; 
} public EventTypeComponent getComponentByID ( EventTypeID id ) { 
EventTypeComponent component = componentRepository . getComponentByID ( id ) ; 
if ( component == null ) { 
component = deployableUnit . getEventTypeComponents ( ) . get ( id ) ; 
return component ; 
} public ProfileSpecificationComponent getComponentByID ( 
ProfileSpecificationID id ) { 
ProfileSpecificationComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getProfileSpecificationComponents ( ) . get ( id ) ; 
} public LibraryComponent getComponentByID ( LibraryID id ) { 
LibraryComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getLibraryComponents ( ) . get ( id ) ; 
} public ResourceAdaptorComponent getComponentByID ( ResourceAdaptorID id ) { 
ResourceAdaptorComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getResourceAdaptorComponents ( ) . get ( id ) ; 
} public ResourceAdaptorTypeComponent getComponentByID ( 
ResourceAdaptorTypeID id ) { 
ResourceAdaptorTypeComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getResourceAdaptorTypeComponents ( ) . get ( id ) ; 
} public SbbComponent getComponentByID ( SbbID id ) { 
SbbComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getSbbComponents ( ) . get ( id ) ; 
} public ServiceComponent getComponentByID ( ServiceID id ) { 
ServiceComponent component = componentRepository . getComponentByID ( id ) ; 
component = deployableUnit . getServiceComponents ( ) . get ( id ) ; 
} private void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { 
String methodName = "getUsageParameterSet" ; 
for ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { 
if ( ctMethod . getName ( ) . equals ( methodName ) ) { 
CtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; 
+ ClassGeneratorUtils . MANAGEMENT_HANDLER 
ctMethodCopy . setBody ( methodBody ) ; 
profileConcreteClass . addMethod ( ctMethodCopy ) ; 
} private void generateProfileConcreteClassInfo ( CtClass profileConcreteClass ) { 
final ClassPool pool = profileComponent . getClassPool ( ) ; 
CtClass profileClass = null ; 
profileClass = pool . get ( Profile . class . getName ( ) ) ; 
ProfileConcreteClassInfo profileConcreteClassInfo = profileComponent . getProfileConcreteClassInfo ( ) ; 
for ( CtMethod method : profileClass . getDeclaredMethods ( ) ) { 
for ( CtMethod profileConcreteMethod : profileConcreteClass 
if ( profileConcreteMethod . getName ( ) . equals ( 
method . getName ( ) ) 
&& profileConcreteMethod . getSignature ( ) . equals ( 
method . getSignature ( ) ) ) { 
profileConcreteClassInfo . setInvokeInfo ( profileConcreteMethod 
. getMethodInfo ( ) . getName ( ) , ! profileConcreteMethod 
NullActivity nullActivity ) throws NullPointerException , 
if ( nullActivity == null ) 
if ( ! ( nullActivity instanceof NullActivityImpl ) ) 
NullActivityImpl nullActivityImpl = ( NullActivityImpl ) nullActivity ; 
ActivityContextHandle ach = new NullActivityContextHandle ( nullActivityImpl . getHandle ( ) ) ; 
throw new UnrecognizedActivityException ( nullActivity ) ; 
} public < T > T queryUnique ( final SelectQuery query , final ObjectMapper < T > mapper ) { 
return runner . run ( new TransactionWrapper < T > ( ) { 
public T perform ( QueryRunner queryRunner ) { 
return queryRunner . queryUnique ( query , mapper ) ; 
} public < T > List < T > queryList ( final SelectQuery query , final ObjectMapper < T > mapper ) { 
return runner . run ( new TransactionWrapper < List < T > > ( ) { 
public List < T > perform ( QueryRunner queryRunner ) { 
return queryRunner . queryList ( query , mapper ) ; 
} public < T > Set < T > querySet ( final SelectQuery query , final ObjectMapper < T > mapper ) { 
return runner . run ( new TransactionWrapper < Set < T > > ( ) { 
public Set < T > perform ( QueryRunner queryRunner ) { 
return queryRunner . querySet ( query , mapper ) ; 
} public boolean queryExistence ( final SelectQuery query ) { 
return runner . run ( new TransactionWrapper < Boolean > ( ) { 
public Boolean perform ( QueryRunner queryRunner ) { 
return queryRunner . queryExistence ( query ) ; 
} public long insert ( final InsertQuery query ) { 
return runner . run ( new TransactionWrapper < Long > ( ) { 
public Long perform ( QueryRunner queryRunner ) { 
return queryRunner . insert ( query ) ; 
} public int update ( final UpdateQuery query ) { 
return runner . run ( new TransactionWrapper < Integer > ( ) { 
public Integer perform ( QueryRunner queryRunner ) { 
return queryRunner . update ( query ) ; 
} public UpdateQuery set ( String fieldName , Object value ) { 
String updatedFieldName = "update_" + fieldName ; 
query . setArgument ( updatedFieldName , value ) ; 
} public UpdateQuery withArgument ( String argumentName , Object object ) { 
query . setArgument ( argumentName , object ) ; 
} public DeleteQuery withArgument ( String argumentName , Object object ) { 
} public PolyJDBC build ( ) { 
TransactionManager manager ; 
if ( dataSource != null ) { 
manager = new DataSourceTransactionManager ( dataSource ) ; 
manager = new ExternalTransactionManager ( connectionProvider ) ; 
return new DefaultPolyJDBC ( dialect , schemaName , new ColumnTypeMapper ( customMappings ) , manager ) ; 
} public PolyJDBCBuilder withCustomMapping ( Class < ? > clazz , SqlType sqlType ) { 
this . customMappings . put ( clazz , sqlType ) ; 
} public SelectQuery orderBy ( String name , Order order ) { 
if ( orderBy == null ) { 
orderBy = new StringBuilder ( ORDER_BY_LENGTH ) ; 
} public SelectQuery withArgument ( String argumentName , Object object ) { 
} public InsertQuery value ( String fieldName , Object value ) { 
setArgument ( fieldName , value ) ; 
} public < T > T run ( TransactionWrapper < T > operation ) { 
QueryRunner runner = null ; 
runner = queryRunnerFactory . create ( ) ; 
T result = operation . perform ( runner ) ; 
runner . commit ( ) ; 
} catch ( Throwable throwable ) { 
TheCloser . rollback ( runner ) ; 
throw new TransactionInterruptedException ( throwable ) ; 
TheCloser . close ( runner ) ; 
} @ JsonDeserialize ( contentAs = SearchLayer . class ) 
public void setWithin ( List < Resource > within ) throws IllegalArgumentException { 
if ( within . stream ( ) . anyMatch ( r -> ! ( r instanceof SearchLayer ) ) ) { 
super . setWithin ( within ) ; 
public SearchResult addWithin ( Resource first , Resource ... rest ) throws IllegalArgumentException { 
if ( ! ( first instanceof SearchLayer ) || Arrays . stream ( rest ) . anyMatch ( r -> ! ( r instanceof SearchLayer ) ) ) { 
super . addWithin ( first , rest ) ; 
} @ JsonCreator 
public static RegionRequest fromString ( String str ) throws ResolvingException { 
if ( str . equals ( "full" ) ) { 
return new RegionRequest ( ) ; 
if ( str . equals ( "square" ) ) { 
return new RegionRequest ( true ) ; 
Matcher matcher = PARSE_PAT . matcher ( str ) ; 
if ( matcher . group ( 1 ) == null ) { 
return new RegionRequest ( 
Integer . valueOf ( matcher . group ( 2 ) ) , 
Integer . valueOf ( matcher . group ( 3 ) ) , 
Integer . valueOf ( matcher . group ( 4 ) ) , 
Integer . valueOf ( matcher . group ( 5 ) ) ) ; 
new BigDecimal ( matcher . group ( 2 ) ) , 
new BigDecimal ( matcher . group ( 3 ) ) , 
new BigDecimal ( matcher . group ( 4 ) ) , 
new BigDecimal ( matcher . group ( 5 ) ) ) ; 
} public Rectangle2D getRegion ( ) { 
if ( isRelative ( ) ) { 
return new Rectangle2D . Double ( 
relativeBox . x . doubleValue ( ) , relativeBox . y . doubleValue ( ) , 
relativeBox . w . doubleValue ( ) , relativeBox . h . doubleValue ( ) ) ; 
return absoluteBox ; 
} public Rectangle resolve ( Dimension imageDims ) throws ResolvingException { 
if ( square ) { 
if ( imageDims . width > imageDims . height ) { 
( imageDims . width - imageDims . height ) / 2 , 
imageDims . height , imageDims . height ) ; 
} else if ( imageDims . height > imageDims . width ) { 
( imageDims . height - imageDims . width ) / 2 , 
imageDims . width , imageDims . width ) ; 
if ( absoluteBox == null && relativeBox == null ) { 
return new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; 
Rectangle rect ; 
rect = new Rectangle ( 
( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , 
( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , 
( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , 
( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; 
rect = absoluteBox ; 
if ( rect . x >= imageDims . width || rect . y >= imageDims . height ) { 
if ( rect . x + rect . width > imageDims . width ) { 
rect . width = imageDims . width - rect . x ; 
if ( rect . y + rect . height > imageDims . height ) { 
rect . height = imageDims . height - rect . y ; 
} private static String urlEncode ( String str ) { 
Set < String > excluded = ImmutableSet . of ( 
":" , "!" , "$" , "&" , "'" , "(" , ")" , "*" , "+" , "," , ";" , "=" ) ; 
String encoded = new Encoded ( str ) . toString ( ) ; 
for ( String ex : excluded ) { 
encoded = encoded . replaceAll ( new Encoded ( ex ) . toString ( ) , ex ) ; 
return encoded ; 
} public String getCanonicalForm ( Dimension nativeSize , ImageApiProfile profile , Quality defaultQuality ) throws ResolvingException { 
Dimension scaleReference = nativeSize ; 
Rectangle2D canonicalRegion = RegionRequest . fromString ( region . getCanonicalForm ( nativeSize ) ) . getRegion ( ) ; 
if ( canonicalRegion != null ) { 
scaleReference = new Dimension ( ( int ) canonicalRegion . getWidth ( ) , ( int ) canonicalRegion . getHeight ( ) ) ; 
return String . format ( 
"%s%s/%s/%s/%s.%s" , 
identifier != null ? urlEncode ( identifier ) + "/" : "" , 
region . getCanonicalForm ( nativeSize ) , 
size . getCanonicalForm ( scaleReference , profile ) , 
rotation . toString ( ) , 
quality . equals ( defaultQuality ) ? "default" : quality . toString ( ) , 
format . toString ( ) ) ; 
} private String getOnType ( DeserializationContext ctxt ) { 
Object curVal = ctxt . getParser ( ) . getCurrentValue ( ) ; 
boolean isPaintingAnno = ( curVal != null && curVal instanceof Annotation 
&& ( ( Annotation ) curVal ) . getMotivation ( ) != null 
&& ( ( Annotation ) curVal ) . getMotivation ( ) . equals ( Motivation . PAINTING ) ) ; 
if ( isPaintingAnno ) { 
return "sc:Canvas" ; 
JsonStreamContext parent = ctxt . getParser ( ) . getParsingContext ( ) . getParent ( ) ; 
while ( parent != null && ( parent . getCurrentValue ( ) == null || ! ( parent . getCurrentValue ( ) instanceof Resource ) ) ) { 
Resource parentObj = ( Resource ) parent . getCurrentValue ( ) ; 
return parentObj . getType ( ) ; 
} public static Completeness getCompleteness ( Object res , Class < ? > type ) { 
Set < Method > getters = ReflectionUtils . getAllMethods ( 
type , 
ReflectionUtils . withModifier ( Modifier . PUBLIC ) , 
ReflectionUtils . withPrefix ( "get" ) ) ; 
Set < String > gettersWithValues = getters . stream ( ) 
. filter ( g -> g . getAnnotation ( JsonIgnore . class ) == null ) 
. filter ( g -> returnsValue ( g , res ) ) 
. map ( Method :: getName ) 
boolean hasOnlyTypeAndId = ( gettersWithValues . size ( ) == 2 
&& Stream . of ( "getType" , "getIdentifier" ) . allMatch ( gettersWithValues :: contains ) ) ; 
if ( gettersWithValues . isEmpty ( ) ) { 
return Completeness . EMPTY ; 
} else if ( containsOnly ( gettersWithValues , "getType" , "getIdentifier" ) ) { 
return Completeness . ID_AND_TYPE ; 
} else if ( containsOnly ( gettersWithValues , "getType" , "getIdentifier" , "getLabels" ) ) { 
return Completeness . ID_AND_TYPE_AND_LABEL ; 
} else if ( containsOnly ( gettersWithValues , "getIdentifier" ) ) { 
return Completeness . ID_ONLY ; 
return Completeness . COMPLEX ; 
} public void setViewingHints ( List < ViewingHint > viewingHints ) throws IllegalArgumentException { 
for ( ViewingHint hint : viewingHints ) { 
boolean supportsHint = ( hint . getType ( ) == ViewingHint . Type . OTHER 
|| this . getSupportedViewingHintTypes ( ) . contains ( hint . getType ( ) ) ) ; 
if ( ! supportsHint ) { 
this . getType ( ) , hint . toString ( ) ) ) ; 
this . viewingHints = viewingHints ; 
} public Resource addViewingHint ( ViewingHint first , ViewingHint ... rest ) throws IllegalArgumentException { 
List < ViewingHint > hints = this . viewingHints ; 
if ( hints == null ) { 
hints = new ArrayList < > ( ) ; 
hints . addAll ( Lists . asList ( first , rest ) ) ; 
this . setViewingHints ( hints ) ; 
} public void setRenderings ( List < OtherContent > renderings ) throws IllegalArgumentException { 
renderings . forEach ( this :: verifyRendering ) ; 
this . renderings = renderings ; 
} public Resource addRendering ( OtherContent first , OtherContent ... rest ) { 
if ( renderings == null ) { 
this . renderings = new ArrayList < > ( ) ; 
List < OtherContent > renderingsToAdd = Lists . asList ( first , rest ) ; 
renderingsToAdd . forEach ( this :: verifyRendering ) ; 
this . renderings . addAll ( renderingsToAdd ) ; 
} public static ImageApiProfile merge ( List < Profile > profiles ) { 
return profiles . stream ( ) 
. filter ( ImageApiProfile . class :: isInstance ) 
. map ( ImageApiProfile . class :: cast ) 
. reduce ( new ImageApiProfile ( ) , ImageApiProfile :: merge ) ; 
} public ImageApiProfile merge ( ImageApiProfile other ) { 
ImageApiProfile merged = new ImageApiProfile ( ) ; 
streamNotNull ( this . features ) . forEach ( merged :: addFeature ) ; 
streamNotNull ( other . features ) . forEach ( merged :: addFeature ) ; 
streamNotNull ( this . formats ) . forEach ( merged :: addFormat ) ; 
streamNotNull ( other . formats ) . forEach ( merged :: addFormat ) ; 
streamNotNull ( this . qualities ) . forEach ( merged :: addQuality ) ; 
streamNotNull ( other . qualities ) . forEach ( merged :: addQuality ) ; 
if ( this . maxWidth != null && other . maxWidth == null ) { 
merged . maxWidth = this . maxWidth ; 
} else if ( this . maxWidth == null && other . maxWidth != null ) { 
merged . maxWidth = other . maxWidth ; 
} else if ( this . maxWidth != null ) { 
merged . maxWidth = Math . min ( this . maxWidth , other . maxWidth ) ; 
if ( this . maxHeight != null && other . maxHeight == null ) { 
merged . maxHeight = this . maxHeight ; 
} else if ( this . maxHeight == null && other . maxHeight != null ) { 
merged . maxHeight = other . maxHeight ; 
} else if ( this . maxHeight != null ) { 
merged . maxHeight = Math . min ( this . maxHeight , other . maxHeight ) ; 
if ( this . maxArea != null && other . maxArea == null ) { 
merged . maxArea = this . maxArea ; 
} else if ( this . maxArea == null && other . maxArea != null ) { 
merged . maxArea = other . maxArea ; 
} else if ( this . maxArea != null ) { 
merged . maxArea = Math . min ( this . maxArea , other . maxArea ) ; 
public static RotationRequest fromString ( String str ) throws ResolvingException { 
Matcher matcher = PATTERN . matcher ( str ) ; 
return new RotationRequest ( 
! ( matcher . group ( 1 ) == null ) ) ; 
} private < T > Converter < String , T > fromString ( Function < String , ? extends T > fun ) { 
return new StdConverter < String , T > ( ) { 
public T convert ( String value ) { 
return fun . apply ( value ) ; 
} public Collection addMember ( Resource first , Resource ... rest ) { 
if ( this . members == null ) { 
this . members = new ArrayList < > ( ) ; 
checkMember ( first ) ; 
stream ( rest ) . forEach ( this :: checkMember ) ; 
this . members . addAll ( Lists . asList ( first , rest ) ) ; 
} public Range addMember ( Resource first , Resource ... rest ) throws IllegalArgumentException { 
List < Resource > membersToAdd = Lists . asList ( first , rest ) ; 
membersToAdd . forEach ( this :: checkMember ) ; 
this . members . addAll ( membersToAdd ) ; 
} public String getFirstValue ( Locale locale ) { 
List < String > values = getValues ( locale ) ; 
return getFirstValue ( ) ; 
return values . get ( 0 ) ; 
public static SizeRequest fromString ( String str ) throws ResolvingException { 
return new SizeRequest ( ) ; 
if ( str . equals ( "max" ) ) { 
return new SizeRequest ( true ) ; 
if ( matcher . group ( 1 ) != null ) { 
if ( matcher . group ( 1 ) . equals ( "!" ) ) { 
return new SizeRequest ( 
} else if ( matcher . group ( 1 ) . equals ( "pct:" ) ) { 
return new SizeRequest ( new BigDecimal ( matcher . group ( 4 ) ) ) ; 
Integer width = null ; 
Integer height = null ; 
if ( matcher . group ( 2 ) != null ) { 
width = Integer . parseInt ( matcher . group ( 2 ) ) ; 
if ( matcher . group ( 3 ) != null ) { 
height = Integer . parseInt ( matcher . group ( 3 ) ) ; 
return new SizeRequest ( width , height ) ; 
} public String getCanonicalForm ( Dimension nativeSize , ImageApiProfile profile ) throws ResolvingException { 
Dimension resolved = this . resolve ( nativeSize , profile ) ; 
double nativeRatio = nativeSize . getWidth ( ) / nativeSize . getHeight ( ) ; 
double resolvedRatio = resolved . getWidth ( ) / resolved . getHeight ( ) ; 
if ( resolved . equals ( nativeSize ) ) { 
return "full" ; 
} else if ( this . width != null && this . height == null ) { 
return this . toString ( ) ; 
} else if ( Math . floor ( resolvedRatio * nativeSize . getHeight ( ) ) == nativeSize . getWidth ( ) 
|| Math . ceil ( resolvedRatio * nativeSize . getHeight ( ) ) == nativeSize . getWidth ( ) ) { 
return String . format ( "%d," , resolved . width ) ; 
return String . format ( "%d,%d" , resolved . width , resolved . height ) ; 
} public Dimension resolve ( Dimension nativeSize , List < Dimension > availableSizes , ImageApiProfile profile ) throws ResolvingException { 
double aspect = ( double ) nativeSize . width / ( double ) nativeSize . height ; 
if ( max ) { 
Dimension dim = availableSizes . stream ( ) 
. filter ( s -> s . width <= nativeSize . width && s . height <= nativeSize . height ) 
. max ( Comparator . comparing ( Dimension :: getWidth ) . thenComparing ( Dimension :: getHeight ) ) 
. orElse ( new Dimension ( nativeSize . width , nativeSize . height ) ) ; 
if ( profile != null && profile . maxWidth != null ) { 
if ( dim . width > profile . maxWidth ) { 
dim . width = profile . maxWidth ; 
dim . height = ( int ) ( profile . maxWidth / aspect ) ; 
int maxHeight = profile . maxHeight != null ? profile . maxHeight : profile . maxWidth ; 
if ( dim . height > maxHeight ) { 
dim . height = maxHeight ; 
dim . width = ( int ) ( aspect * dim . height ) ; 
if ( profile != null && profile . maxArea != null ) { 
long currentArea = ( long ) dim . width * ( long ) dim . height ; 
if ( currentArea > profile . maxArea ) { 
dim . width = ( int ) Math . sqrt ( aspect * ( double ) profile . maxArea ) ; 
dim . height = ( int ) ( dim . width / aspect ) ; 
if ( dim . width <= 0 || dim . height <= 0 ) { 
throw new ResolvingException ( String . format ( 
nativeSize . width , nativeSize . height , profile . maxArea ) ) ; 
Dimension out ; 
if ( percentage != null || bestFit ) { 
double ratio ; 
if ( percentage != null ) { 
ratio = percentage . doubleValue ( ) / 100.0 ; 
ratio = Math . min ( width / nativeSize . getWidth ( ) , height / nativeSize . getHeight ( ) ) ; 
out = new Dimension ( ( int ) ( ratio * nativeSize . width ) , ( int ) ( ratio * nativeSize . height ) ) ; 
} else if ( width == null && height == null ) { 
out = nativeSize ; 
out = new Dimension ( ) ; 
if ( width != null ) { 
out . width = width ; 
if ( height != null ) { 
out . height = height ; 
if ( width == null ) { 
out . width = ( int ) ( out . height * aspect ) ; 
if ( height == null ) { 
out . height = ( int ) ( out . width / aspect ) ; 
Integer maxHeight = profile . maxHeight != null ? profile . maxHeight : profile . maxWidth ; 
if ( profile . maxWidth != null && out . width > profile . maxWidth ) { 
} else if ( maxHeight != null && out . height > maxHeight ) { 
} else if ( profile . maxArea != null && out . height * out . width > profile . maxArea ) { 
out . width , out . height , out . width * out . height , profile . maxArea ) ) ; 
} else if ( ( profile . features == null || ! profile . features . contains ( ImageApiProfile . Feature . SIZE_ABOVE_FULL ) ) 
&& ( out . width > nativeSize . width || out . height > nativeSize . height ) ) { 
out . width , out . height , nativeSize . width , nativeSize . height ) ) ; 
} public Dimension resolve ( Rectangle region , ImageApiProfile profile ) throws ResolvingException { 
return resolve ( 
new Dimension ( region . width , region . height ) , 
profile ) ; 
} public TextEditor replaceAll ( String regex , String replacement ) { 
final String r = replacement ; 
Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; 
Matcher m = p . matcher ( text ) ; 
StringBuffer sb = new StringBuffer ( ) ; 
m . appendReplacement ( sb , r ) ; 
text = new StringBuilder ( sb . toString ( ) ) ; 
} public TextEditor replaceAllLiteral ( String regex , final String replacement ) { 
return replaceAll ( Pattern . compile ( regex , Pattern . MULTILINE ) , new Replacement ( ) { 
public String replacement ( Matcher m ) { 
return replacement ; 
} public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { 
Matcher m = pattern . matcher ( text ) ; 
int lastIndex = 0 ; 
sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; 
sb . append ( replacement . replacement ( m ) ) ; 
lastIndex = m . end ( ) ; 
sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; 
text = sb ; 
} public TextEditor detabify ( final int tabWidth ) { 
replaceAll ( Pattern . compile ( "(.*?)\\t" ) , new Replacement ( ) { 
String lineSoFar = m . group ( 1 ) ; 
int width = lineSoFar . length ( ) ; 
StringBuilder replacement = new StringBuilder ( lineSoFar ) ; 
++ width ; 
} while ( width % tabWidth != 0 ) ; 
return replacement . toString ( ) ; 
} public TextEditor indent ( int spaces ) { 
StringBuilder sb = new StringBuilder ( spaces ) ; 
for ( int i = 0 ; i < spaces ; i ++ ) { 
return replaceAll ( "^" , sb . toString ( ) ) ; 
} public Collection < HTMLToken > tokenizeHTML ( ) { 
List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; 
String nestedTags = nestedTagsRegex ( 6 ) ; 
Pattern p = Pattern . compile ( "" + 
"(?s:<!(--.*?--\\s*)+>)" + 
"|" + 
"(?s:<\\?.*?\\?>)" + 
nestedTags + 
"" , Pattern . CASE_INSENSITIVE ) ; 
int lastPos = 0 ; 
if ( lastPos < m . start ( ) ) { 
tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; 
tokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; 
lastPos = m . end ( ) ; 
if ( lastPos < text . length ( ) ) { 
tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; 
return tokens ; 
} public String markdown ( String txt ) { 
txt = "" ; 
TextEditor text = new TextEditor ( txt ) ; 
text . replaceAll ( "\\r\\n" , "\n" ) ; 
text . replaceAll ( "\\r" , "\n" ) ; 
text . append ( "\n\n" ) ; 
text . detabify ( ) ; 
hashHTMLBlocks ( text ) ; 
stripLinkDefinitions ( text ) ; 
text = runBlockGamut ( text ) ; 
unEscapeSpecialChars ( text ) ; 
text . append ( "\n" ) ; 
return text . toString ( ) ; 
} private TextEditor escapeSpecialCharsWithinTagAttributes ( TextEditor text ) { 
Collection < HTMLToken > tokens = text . tokenizeHTML ( ) ; 
TextEditor newText = new TextEditor ( "" ) ; 
for ( HTMLToken token : tokens ) { 
String value = token . getText ( ) ; 
if ( token . isTag ( ) ) { 
value = value . replaceAll ( "\\\\" , CHAR_PROTECTOR . encode ( "\\" ) ) ; 
value = value . replaceAll ( "`" , CHAR_PROTECTOR . encode ( "`" ) ) ; 
value = value . replaceAll ( "\\*" , CHAR_PROTECTOR . encode ( "*" ) ) ; 
value = value . replaceAll ( "_" , CHAR_PROTECTOR . encode ( "_" ) ) ; 
newText . append ( value ) ; 
return newText ; 
WeakElement wv = null ; 
while ( ( wv = ( WeakElement ) this . queue . poll ( ) ) != null ) { 
super . remove ( wv ) ; 
} private String findParentFqcn ( TypeElement typeElement , Set < String > parents ) { 
TypeMirror type ; 
type = typeElement . getSuperclass ( ) ; 
if ( type . getKind ( ) == TypeKind . NONE ) { 
typeElement = ( TypeElement ) ( ( DeclaredType ) type ) . asElement ( ) ; 
if ( parents . contains ( typeElement . toString ( ) ) ) { 
String packageName = getPackageName ( typeElement ) ; 
return packageName + "." + getClassName ( typeElement , packageName ) ; 
} private static IBarbershop < Object > findBarbershopForClass ( Class < ? > cls ) { 
IBarbershop < Object > barbershop = BARBERSHOPS . get ( cls ) ; 
if ( barbershop != null ) { 
return barbershop ; 
String clsName = cls . getName ( ) ; 
if ( clsName . startsWith ( ANDROID_PREFIX ) || clsName . startsWith ( JAVA_PREFIX ) ) { 
return NO_OP ; 
Class < ? > barbershopClass = Class . forName ( clsName + SUFFIX ) ; 
barbershop = ( IBarbershop < Object > ) barbershopClass . newInstance ( ) ; 
barbershop = findBarbershopForClass ( cls . getSuperclass ( ) ) ; 
Log . e ( TAG , e . getMessage ( ) ) ; 
BARBERSHOPS . put ( cls , barbershop ) ; 
} void writeToFiler ( Filer filer ) throws IOException { 
ClassName targetClassName = ClassName . get ( classPackage , targetClass ) ; 
TypeSpec . Builder barberShop = TypeSpec . classBuilder ( className ) 
. addModifiers ( Modifier . PUBLIC ) 
. addTypeVariable ( TypeVariableName . get ( "T" , targetClassName ) ) 
. addMethod ( generateStyleMethod ( ) ) 
. addMethod ( generateCheckParentMethod ( ) ) ; 
if ( parentBarbershop == null ) { 
barberShop . addSuperinterface ( ParameterizedTypeName . get ( ClassName . get ( Barber . IBarbershop . class ) , TypeVariableName . get ( "T" ) ) ) ; 
barberShop . superclass ( ParameterizedTypeName . get ( ClassName . bestGuess ( parentBarbershop ) , TypeVariableName . get ( "T" ) ) ) ; 
JavaFile javaFile = JavaFile . builder ( classPackage , barberShop . build ( ) ) . build ( ) ; 
javaFile . writeTo ( filer ) ; 
} private MethodSpec generateStyleMethod ( ) { 
MethodSpec . Builder builder = MethodSpec . methodBuilder ( "style" ) 
. addAnnotation ( Override . class ) 
. returns ( void . class ) 
. addParameter ( TypeVariableName . get ( "T" ) , "target" , Modifier . FINAL ) 
. addParameter ( AttributeSet . class , "set" , Modifier . FINAL ) 
. addParameter ( int [ ] . class , "attrs" , Modifier . FINAL ) 
. addParameter ( int . class , "defStyleAttr" , Modifier . FINAL ) 
. addParameter ( int . class , "defStyleRes" , Modifier . FINAL ) ; 
if ( parentBarbershop != null ) { 
. addStatement ( "return" ) 
. endControlFlow ( ) ; 
builder . addStatement ( "this.lastStyledTargets.add(target)" ) ; 
if ( ! styleableBindings . isEmpty ( ) ) { 
if ( hasDefaults ) { 
for ( StyleableBinding binding : styleableBindings . values ( ) ) { 
if ( binding . kind == RES_ID && binding . hasDefaultValue ( ) && ! binding . isRequired ) { 
builder . addStatement ( generateSetterStatement ( binding ) , binding . name , binding . getFormattedStatement ( "a." ) ) ; 
if ( binding . isRequired ) { 
builder . nextControlFlow ( "else" ) ; 
} else if ( binding . hasDefaultValue ( ) ) { 
if ( binding . kind != FRACTION && binding . kind != DIMEN && ( "float" . equals ( binding . type ) || "java.lang.Float" . equals ( binding . type ) ) ) { 
} else if ( "android.graphics.drawable.Drawable" . equals ( binding . type ) ) { 
builder . addStatement ( generateSetterStatement ( binding ) , binding . name , 
+ binding . defaultValue 
builder . addStatement ( generateSetterStatement ( binding ) , binding . name , generateResourceStatement ( binding , "res." , true ) ) ; 
builder . endControlFlow ( ) ; 
builder . addStatement ( "a.recycle()" ) ; 
if ( ! androidAttrBindings . isEmpty ( ) ) { 
for ( AndroidAttrBinding binding : androidAttrBindings . values ( ) ) { 
builder . addStatement ( generateSetterStatement ( binding ) , binding . name , binding . getFormattedStatement ( "set." ) ) ; 
} private static String chompLastParam ( String input ) { 
int lastCommaIndex = input . lastIndexOf ( ',' ) ; 
if ( lastCommaIndex == - 1 ) { 
return input . substring ( 0 , lastCommaIndex ) + ")" ; 
} public boolean sendMsg ( Message msg ) { 
SendResult sendResult = null ; 
sendResult = producer . send ( msg ) ; 
return sendResult != null && sendResult . getSendStatus ( ) == SendStatus . SEND_OK ; 
} public void sendOneWayMsg ( Message msg ) { 
producer . sendOneway ( msg ) ; 
} public boolean sendDelayMsg ( String topic , String tag , Message msg , int delayLevel ) { 
msg . setDelayTimeLevel ( delayLevel ) ; 
} public static String asciiCharactersEncoding ( String str ) throws QSException { 
if ( QSStringUtil . isEmpty ( str ) ) { 
String encoded = URLEncoder . encode ( str , QSConstant . ENCODING_UTF8 ) ; 
encoded = encoded . replace ( "%2F" , "/" ) ; 
encoded = encoded . replace ( "%3D" , "=" ) ; 
encoded = encoded . replace ( "+" , "%20" ) ; 
encoded = encoded . replace ( "%3A" , ":" ) ; 
throw new QSException ( "UnsupportedEncodingException:" , e ) ; 
} public static String generateAuthorization ( 
String accessKey , 
String secretKey , 
String method , 
String requestURI , 
Map < String , String > headers ) { 
String signature = generateSignature ( secretKey , method , requestURI , params , headers ) ; 
String strToSign ) { 
String signature = generateSignature ( secretKey , strToSign ) ; 
} public static String generateSignature ( 
String signature = "" ; 
String strToSign = getStringToSignature ( method , requestURI , params , headers ) ; 
signature = generateSignature ( secretKey , strToSign ) ; 
return signature ; 
return QSSignatureUtil . generateAuthorization ( accessKey , secretKey , strToSign ) ; 
} public static String generateSignature ( String secretKey , String strToSign ) { 
return QSSignatureUtil . generateSignature ( secretKey , strToSign ) ; 
} private void checkDownloadRequest ( ) { 
if ( outputClass == null ) return ; 
boolean isDownloadRequest = false ; 
Field [ ] declaredField = outputClass . getDeclaredFields ( ) ; 
for ( Field field : declaredField ) { 
String methodName = "get" + QSParamInvokeUtil . capitalize ( field . getName ( ) ) ; 
Method [ ] methods = outputClass . getDeclaredMethods ( ) ; 
for ( Method m : methods ) { 
if ( m . getName ( ) . equalsIgnoreCase ( methodName ) ) { 
ParamAnnotation annotation = m . getAnnotation ( ParamAnnotation . class ) ; 
if ( annotation == null ) continue ; 
if ( "BodyInputStream" . equals ( annotation . paramName ( ) ) ) { 
isDownloadRequest = true ; 
if ( isDownloadRequest ) { 
getBuilder ( ) . setHeader ( "Accept-Encoding" , "identity" ) ; 
} public void setSignature ( String accessKey , String signature , String gmtTime ) throws QSException { 
builder . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , gmtTime ) ; 
setSignature ( accessKey , signature ) ; 
} public static String encode ( byte [ ] binaryData ) { 
if ( binaryData == null ) { 
int lengthDataBits = binaryData . length * EIGHTBIT ; 
if ( lengthDataBits == 0 ) { 
int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; 
int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; 
int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets ; 
char encodedData [ ] = null ; 
encodedData = new char [ numberQuartet * 4 ] ; 
byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; 
int encodedIndex = 0 ; 
int dataIndex = 0 ; 
for ( int i = 0 ; i < numberTriplets ; i ++ ) { 
b1 = binaryData [ dataIndex ++ ] ; 
b2 = binaryData [ dataIndex ++ ] ; 
b3 = binaryData [ dataIndex ++ ] ; 
l = ( byte ) ( b2 & 0x0f ) ; 
k = ( byte ) ( b1 & 0x03 ) ; 
byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; 
byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; 
byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ val1 ] ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; 
if ( fewerThan24bits == EIGHTBIT ) { 
b1 = binaryData [ dataIndex ] ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ k << 4 ] ; 
encodedData [ encodedIndex ++ ] = PAD ; 
} else if ( fewerThan24bits == SIXTEENBIT ) { 
b2 = binaryData [ dataIndex + 1 ] ; 
encodedData [ encodedIndex ++ ] = lookUpBase64Alphabet [ l << 2 ] ; 
return new String ( encodedData ) ; 
} public static byte [ ] decode ( String encoded ) { 
if ( encoded == null ) { 
char [ ] base64Data = encoded . toCharArray ( ) ; 
int len = removeWhiteSpace ( base64Data ) ; 
if ( len % FOURBYTE != 0 ) { 
int numberQuadruple = ( len / FOURBYTE ) ; 
if ( numberQuadruple == 0 ) { 
return new byte [ 0 ] ; 
byte decodedData [ ] = null ; 
byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 ; 
char d1 = 0 , d2 = 0 , d3 = 0 , d4 = 0 ; 
decodedData = new byte [ ( numberQuadruple ) * 3 ] ; 
for ( ; i < numberQuadruple - 1 ; i ++ ) { 
if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) 
|| ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) 
|| ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) 
|| ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { 
b1 = base64Alphabet [ d1 ] ; 
b2 = base64Alphabet [ d2 ] ; 
b3 = base64Alphabet [ d3 ] ; 
b4 = base64Alphabet [ d4 ] ; 
decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; 
decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; 
decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << 6 | b4 ) ; 
if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { 
d3 = base64Data [ dataIndex ++ ] ; 
d4 = base64Data [ dataIndex ++ ] ; 
if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { 
if ( isPad ( d3 ) && isPad ( d4 ) ) { 
if ( ( b2 & 0xf ) != 0 ) 
byte [ ] tmp = new byte [ i * 3 + 1 ] ; 
System . arraycopy ( decodedData , 0 , tmp , 0 , i * 3 ) ; 
tmp [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; 
} else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { 
if ( ( b3 & 0x3 ) != 0 ) 
byte [ ] tmp = new byte [ i * 3 + 2 ] ; 
tmp [ encodedIndex ++ ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; 
tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; 
return decodedData ; 
} private static int removeWhiteSpace ( char [ ] data ) { 
int newSize = 0 ; 
int len = data . length ; 
if ( ! isWhiteSpace ( data [ i ] ) ) { 
data [ newSize ++ ] = data [ i ] ; 
return newSize ; 
} public void put ( File file ) throws QSException { 
if ( ! file . exists ( ) || file . isDirectory ( ) ) 
put ( file , file . getName ( ) , null , "" ) ; 
} public void put ( File file , String objectKey , String fileName , String eTag ) throws QSException { 
long length = file . length ( ) ; 
if ( length <= partSize ) { 
partCounts = 1 ; 
putFile ( file , objectKey , fileName , length ) ; 
if ( length / partSize > MAX_PART_COUNTS ) { 
partSize = length / MAX_PART_COUNTS ; 
partCounts = MAX_PART_COUNTS ; 
if ( partSize > 5 * 1024 * 1024 * 1024L ) 
partCounts = ( int ) ( length / partSize ) ; 
if ( length % partSize > 0 ) partCounts += 1 ; 
putFileMulti ( file , objectKey , fileName , eTag , length ) ; 
} public void putFileMulti ( File file , final String objectKey , String fileName , String eTag , final long length ) throws QSException { 
if ( partSize < 4 * 1024 * 1024 ) { 
if ( recorder == null || recorder . get ( objectKey ) == null ) { 
Bucket . InitiateMultipartUploadInput inputInit = new Bucket . InitiateMultipartUploadInput ( ) ; 
Bucket . InitiateMultipartUploadOutput initOutput = bucket . initiateMultipartUpload ( objectKey , inputInit ) ; 
int code = initOutput . getStatueCode ( ) ; 
if ( code < 200 || code >= 300 ) { 
if ( callBack != null ) { 
OutputModel outputModel = new OutputModel ( ) ; 
outputModel . setStatueCode ( code ) ; 
outputModel . setMessage ( initOutput . getMessage ( ) ) ; 
callBack . onAPIResponse ( objectKey , outputModel ) ; 
uploadModel = new UploadModel ( ) ; 
uploadModel . setTotalSize ( length ) ; 
uploadModel . setUploadID ( initOutput . getUploadID ( ) ) ; 
byte [ ] bytes = recorder . get ( objectKey ) ; 
String json = new String ( bytes ) ; 
uploadModel = new Gson ( ) . fromJson ( json , UploadModel . class ) ; 
if ( uploadModel . isUploadComplete ( ) ) { 
outputModel . setStatueCode ( 201 ) ; 
if ( uploadModel . isFileComplete ( ) ) { 
completeMultiUpload ( objectKey , fileName , eTag , uploadModel . getUploadID ( ) , length ) ; 
for ( int i = uploadModel . getCurrentPart ( ) ; i < partCounts ; i ++ ) { 
uploadModel . setCurrentPart ( i ) ; 
uploadModel . setBytesWritten ( i * partSize ) ; 
setData ( objectKey , recorder ) ; 
if ( cancellationHandler != null && cancellationHandler . isCancelled ( ) ) { 
long contentLength = Math . min ( partSize , ( file . length ( ) - uploadModel . getCurrentPart ( ) * partSize ) ) ; 
Bucket . UploadMultipartInput input = new Bucket . UploadMultipartInput ( ) ; 
input . setBodyInputFilePart ( file ) ; 
input . setFileOffset ( i * partSize ) ; 
input . setContentLength ( contentLength ) ; 
input . setPartNumber ( i ) ; 
input . setUploadID ( uploadModel . getUploadID ( ) ) ; 
RequestHandler requestHandler = bucket . uploadMultipartRequest ( objectKey , input ) ; 
if ( progressListener != null ) { 
requestHandler . setProgressListener ( new BodyProgressListener ( ) { 
public void onProgress ( long len , long size ) { 
long bytesWritten = uploadModel . getCurrentPart ( ) * partSize + len ; 
progressListener . onProgress ( objectKey , bytesWritten , length ) ; 
requestHandler . setCancellationHandler ( cancellationHandler ) ; 
sign ( requestHandler ) ; 
OutputModel send = requestHandler . send ( ) ; 
if ( send . getStatueCode ( ) != 200 && send . getStatueCode ( ) != 201 ) { 
if ( callBack != null ) 
callBack . onAPIResponse ( objectKey , send ) ; 
} else if ( i == partCounts - 1 ) { 
uploadModel . setBytesWritten ( length ) ; 
uploadModel . setFileComplete ( true ) ; 
} private void sign ( RequestHandler requestHandler ) throws QSException { 
String signed = callBack . onSignature ( requestHandler . getStringToSignature ( ) ) ; 
if ( ! QSStringUtil . isEmpty ( signed ) ) 
requestHandler . setSignature ( callBack . onAccessKey ( ) , signed ) ; 
String correctTime = callBack . onCorrectTime ( requestHandler . getStringToSignature ( ) ) ; 
if ( correctTime != null && correctTime . trim ( ) . length ( ) > 0 ) 
requestHandler . getBuilder ( ) . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , correctTime ) ; 
} private void setData ( String objectKey , Recorder recorder ) { 
if ( recorder == null ) return ; 
String upload = new Gson ( ) . toJson ( uploadModel ) ; 
recorder . set ( objectKey , upload . getBytes ( ) ) ; 
} private void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { 
CompleteMultipartUploadInput completeMultipartUploadInput = 
new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; 
completeMultipartUploadInput . setContentLength ( length ) ; 
if ( ! QSStringUtil . isEmpty ( fileName ) ) { 
String keyName = QSStringUtil . percentEncode ( fileName , "UTF-8" ) ; 
completeMultipartUploadInput . setContentDisposition ( String . format ( 
if ( ! QSStringUtil . isEmpty ( eTag ) ) { 
completeMultipartUploadInput . setETag ( eTag ) ; 
RequestHandler requestHandler = 
bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; 
Bucket . CompleteMultipartUploadOutput send = 
( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; 
if ( send . getStatueCode ( ) == 200 || send . getStatueCode ( ) == 201 ) { 
uploadModel . setUploadComplete ( true ) ; 
} public void putFile ( File file , final String objectKey , 
String fileName , long length ) throws QSException { 
PutObjectInput input = new PutObjectInput ( ) ; 
input . setContentLength ( length ) ; 
input . setBodyInputFile ( file ) ; 
input . setContentDisposition ( String . format ( 
RequestHandler requestHandler = bucket . putObjectRequest ( objectKey , input ) ; 
progressListener . onProgress ( objectKey , len , size ) ; 
OutputModel outputModel = requestHandler . send ( ) ; 
} public static void normalize ( GeoTuple3D_F64 p ) { 
double n = p . norm ( ) ; 
p . x /= n ; 
p . y /= n ; 
p . z /= n ; 
} public static boolean contained ( Box3D_I32 box , Point3D_I32 point ) { 
return ( box . p0 . x <= point . x && point . x < box . p1 . x && 
box . p0 . y <= point . y && point . y < box . p1 . y && 
box . p0 . z <= point . z && point . z < box . p1 . z ) ; 
} public static boolean contained ( Box3D_I32 boxA , Box3D_I32 boxB ) { 
return ( boxA . p0 . x <= boxB . p0 . x && boxA . p1 . x >= boxB . p1 . x && 
boxA . p0 . y <= boxB . p0 . y && boxA . p1 . y >= boxB . p1 . y && 
boxA . p0 . z <= boxB . p0 . z && boxA . p1 . z >= boxB . p1 . z ) ; 
} public void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { 
GeometryMath_F64 . sub ( B , P , D ) ; 
a = E0 . dot ( E0 ) ; 
b = E0 . dot ( E1 ) ; 
c = E1 . dot ( E1 ) ; 
d = E0 . dot ( D ) ; 
e = E1 . dot ( D ) ; 
double det = a * c - b * b ; 
s = b * e - c * d ; 
t = b * d - a * e ; 
if ( s + t <= det ) { 
if ( s < 0 ) { 
if ( t < 0 ) { 
region4 ( ) ; 
region3 ( ) ; 
} else if ( t < 0 ) { 
region5 ( ) ; 
region0 ( det ) ; 
region2 ( ) ; 
region6 ( ) ; 
region1 ( ) ; 
closestPt . x = B . x + s * E0 . x + t * E1 . x ; 
closestPt . y = B . y + s * E0 . y + t * E1 . y ; 
closestPt . z = B . z + s * E0 . z + t * E1 . z ; 
} public double sign ( Point3D_F64 P ) { 
GeometryMath_F64 . cross ( E1 , E0 , N ) ; 
double d = N . x * ( P . x - B . x ) + N . y * ( P . y - B . y ) + N . z * ( P . z - B . z ) ; 
return Math . signum ( d ) ; 
} public void set ( Se3_F64 se ) { 
R . set ( se . getR ( ) ) ; 
T . set ( se . getT ( ) ) ; 
} public void set ( double x , double y , double z , EulerType type , double rotA , double rotB , double rotC ) { 
T . set ( x , y , z ) ; 
ConvertRotation3D_F64 . eulerToMatrix ( type , rotA , rotB , rotC , R ) ; 
} public void set ( double x , double y , double z , RotationType type , double A , double B , double C , double D ) { 
case RODRIGUES : 
ConvertRotation3D_F64 . rodriguesToMatrix ( A , B , C , D , R ) ; 
case QUATERNION : 
ConvertRotation3D_F64 . quaternionToMatrix ( A , B , C , D , R ) ; 
} public Point3D_F64 transform ( Point3D_F64 src , @ Nullable Point3D_F64 dst ) { 
return SePointOps_F64 . transform ( this , src , dst ) ; 
} public Point3D_F64 transformReverse ( Point3D_F64 src , @ Nullable Point3D_F64 dst ) { 
return SePointOps_F64 . transformReverse ( this , src , dst ) ; 
} public Vector3D_F64 transform ( Vector3D_F64 src , @ Nullable Vector3D_F64 dst ) { 
return GeometryMath_F64 . mult ( R , src , dst ) ; 
} public Vector3D_F64 transformReverse ( Vector3D_F64 src , @ Nullable Vector3D_F64 dst ) { 
return GeometryMath_F64 . multTran ( R , src , dst ) ; 
} public static void convert ( Rectangle2D_F64 input , Quadrilateral_F64 output ) { 
output . a . x = input . p0 . x ; 
output . a . y = input . p0 . y ; 
output . b . x = input . p1 . x ; 
output . b . y = input . p0 . y ; 
output . c . x = input . p1 . x ; 
output . c . y = input . p1 . y ; 
output . d . x = input . p0 . x ; 
output . d . y = input . p1 . y ; 
} public static void convert ( Rectangle2D_F64 input , Polygon2D_F64 output ) { 
if ( output . size ( ) != 4 ) 
output . get ( 0 ) . set ( input . p0 . x , input . p0 . y ) ; 
output . get ( 1 ) . set ( input . p1 . x , input . p0 . y ) ; 
output . get ( 2 ) . set ( input . p1 . x , input . p1 . y ) ; 
output . get ( 3 ) . set ( input . p0 . x , input . p1 . y ) ; 
} public static void convert ( Polygon2D_F64 input , Quadrilateral_F64 output ) { 
if ( input . size ( ) != 4 ) 
output . a . set ( input . get ( 0 ) ) ; 
output . b . set ( input . get ( 1 ) ) ; 
output . c . set ( input . get ( 2 ) ) ; 
output . d . set ( input . get ( 3 ) ) ; 
} public static void convert ( RectangleLength2D_I32 input , Quadrilateral_F64 output ) { 
output . a . x = input . x0 ; 
output . a . y = input . y0 ; 
output . b . x = input . x0 + input . width - 1 ; 
output . b . y = input . y0 ; 
output . c . x = input . x0 + input . width - 1 ; 
output . c . y = input . y0 + input . height - 1 ; 
output . d . x = input . x0 ; 
output . d . y = input . y0 + input . height - 1 ; 
} public static void bounding ( Quadrilateral_F64 quad , Rectangle2D_F64 rectangle ) { 
rectangle . p0 . x = Math . min ( quad . a . x , quad . b . x ) ; 
rectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . c . x ) ; 
rectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . d . x ) ; 
rectangle . p0 . y = Math . min ( quad . a . y , quad . b . y ) ; 
rectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . c . y ) ; 
rectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . d . y ) ; 
rectangle . p1 . x = Math . max ( quad . a . x , quad . b . x ) ; 
rectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . c . x ) ; 
rectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . d . x ) ; 
rectangle . p1 . y = Math . max ( quad . a . y , quad . b . y ) ; 
rectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . c . y ) ; 
rectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . d . y ) ; 
} public static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { 
rectangle . p0 . set ( polygon . get ( 0 ) ) ; 
rectangle . p1 . set ( polygon . get ( 0 ) ) ; 
for ( int i = 0 ; i < polygon . size ( ) ; i ++ ) { 
Point2D_F64 p = polygon . get ( i ) ; 
if ( p . x < rectangle . p0 . x ) { 
rectangle . p0 . x = p . x ; 
} else if ( p . x > rectangle . p1 . x ) { 
rectangle . p1 . x = p . x ; 
if ( p . y < rectangle . p0 . y ) { 
rectangle . p0 . y = p . y ; 
} else if ( p . y > rectangle . p1 . y ) { 
rectangle . p1 . y = p . y ; 
} public static Point2D_F64 center ( Quadrilateral_F64 quad , Point2D_F64 center ) { 
if ( center == null ) 
center = new Point2D_F64 ( ) ; 
center . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; 
center . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; 
center . x /= 4.0 ; 
center . y /= 4.0 ; 
return center ; 
} public static boolean isCCW ( List < Point2D_F64 > polygon ) { 
final int N = polygon . size ( ) ; 
int sign = 0 ; 
for ( int i = 0 ; i < N ; i ++ ) { 
int j = ( i + 1 ) % N ; 
int k = ( i + 2 ) % N ; 
Point2D_F64 a = polygon . get ( i ) ; 
Point2D_F64 b = polygon . get ( j ) ; 
Point2D_F64 c = polygon . get ( k ) ; 
double dx0 = a . x - b . x ; 
double dy0 = a . y - b . y ; 
double dx1 = c . x - b . x ; 
double dy1 = c . y - b . y ; 
double z = dx0 * dy1 - dy0 * dx1 ; 
if ( z > 0 ) 
sign ++ ; 
sign -- ; 
return sign < 0 ; 
} public static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { 
average . setIdx ( 0 , 0 ) ; 
for ( int i = 0 ; i < input . size ( ) ; i ++ ) { 
Point2D_F64 v = input . vertexes . data [ i ] ; 
average . x += v . x ; 
average . y += v . y ; 
average . x /= input . size ( ) ; 
average . y /= input . size ( ) ; 
} public static boolean isIdentical ( Polygon2D_F64 a , Polygon2D_F64 b , double tol ) { 
if ( a . size ( ) != b . size ( ) ) 
double tol2 = tol * tol ; 
for ( int i = 0 ; i < a . size ( ) ; i ++ ) { 
if ( a . get ( i ) . distance2 ( b . get ( i ) ) > tol2 ) 
} public static boolean isEquivalent ( Polygon2D_F64 a , Polygon2D_F64 b , double tol ) { 
Point2D_F64 a0 = a . get ( 0 ) ; 
int match = - 1 ; 
for ( int i = 0 ; i < b . size ( ) ; i ++ ) { 
if ( a0 . distance2 ( b . get ( i ) ) <= tol2 ) { 
match = i ; 
if ( match < 0 ) 
for ( int i = 1 ; i < b . size ( ) ; i ++ ) { 
Point2D_F64 ai = a . get ( i ) ; 
Point2D_F64 bi = b . get ( ( match + i ) % b . size ( ) ) ; 
if ( ai . distance2 ( bi ) > tol2 ) { 
} public static void flip ( Polygon2D_F64 a ) { 
int N = a . size ( ) ; 
int H = N / 2 ; 
for ( int i = 1 ; i <= H ; i ++ ) { 
int j = N - i ; 
Point2D_F64 tmp = a . vertexes . data [ i ] ; 
a . vertexes . data [ i ] = a . vertexes . data [ j ] ; 
a . vertexes . data [ j ] = tmp ; 
} public static void shiftUp ( Polygon2D_F64 a ) { 
final int N = a . size ( ) ; 
Point2D_F64 first = a . get ( 0 ) ; 
for ( int i = 0 ; i < N - 1 ; i ++ ) { 
a . vertexes . data [ i ] = a . vertexes . data [ i + 1 ] ; 
a . vertexes . data [ N - 1 ] = first ; 
} public static void shiftDown ( Polygon2D_F64 a ) { 
Point2D_F64 last = a . get ( N - 1 ) ; 
for ( int i = N - 1 ; i > 0 ; i -- ) { 
a . vertexes . data [ i ] = a . vertexes . data [ i - 1 ] ; 
a . vertexes . data [ 0 ] = last ; 
} public static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { 
Point2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; 
for ( int i = 0 ; i < points . size ( ) ; i ++ ) { 
array [ i ] = points . get ( i ) ; 
AndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; 
andrew . process ( array , array . length , hull ) ; 
} public static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { 
for ( int i = 0 ; i < polygon . vertexes . size ( ) ; ) { 
int j = ( i + 1 ) % polygon . vertexes . size ( ) ; 
int k = ( i + 2 ) % polygon . vertexes . size ( ) ; 
Point2D_F64 p0 = polygon . vertexes . get ( i ) ; 
Point2D_F64 p1 = polygon . vertexes . get ( j ) ; 
Point2D_F64 p2 = polygon . vertexes . get ( k ) ; 
double angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; 
if ( angle <= tol ) { 
polygon . vertexes . remove ( j ) ; 
if ( j < i ) 
i = polygon . vertexes . size ( ) - 1 ; 
} public static void removeAdjacentDuplicates ( Polygon2D_F64 polygon , double tol ) { 
for ( int i = polygon . vertexes . size ( ) - 1 , j = 0 ; i >= 0 && polygon . size ( ) > 1 ; j = i , i -- ) { 
if ( polygon . get ( i ) . isIdentical ( polygon . get ( j ) , tol ) ) { 
polygon . vertexes . remove ( i ) ; 
} public static boolean hasAdjacentDuplicates ( Polygon2D_F64 polygon , double tol ) { 
} public static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { 
LineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; 
double cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; 
double totalLength = 0 ; 
for ( int i = 0 ; i < target . size ( ) ; i ++ ) { 
Point2D_F64 b0 = target . get ( i % target . size ( ) ) ; 
Point2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; 
cornerLocationsB [ i ] = totalLength ; 
totalLength += b0 . distance ( b1 ) ; 
cornerLocationsB [ target . size ( ) ] = totalLength ; 
Point2D_F64 pointOnB = new Point2D_F64 ( ) ; 
double error = 0 ; 
int cornerB = 0 ; 
for ( int k = 0 ; k < numberOfSamples ; k ++ ) { 
double location = totalLength * k / numberOfSamples ; 
while ( location > cornerLocationsB [ cornerB + 1 ] ) { 
cornerB ++ ; 
Point2D_F64 b0 = target . get ( cornerB ) ; 
Point2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; 
double locationCornerB = cornerLocationsB [ cornerB ] ; 
double fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; 
pointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; 
pointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; 
double best = Double . MAX_VALUE ; 
for ( int i = 0 ; i < model . size ( ) + 1 ; i ++ ) { 
line . a = model . get ( i % model . size ( ) ) ; 
line . b = model . get ( ( i + 1 ) % model . size ( ) ) ; 
double d = Distance2D_F64 . distance ( line , pointOnB ) ; 
if ( d < best ) { 
best = d ; 
error += best ; 
return error / numberOfSamples ; 
} public static Homography2D_F64 convert ( DMatrixRMaj m , Homography2D_F64 ret ) { 
if ( m . numCols != 3 || m . numRows != 3 ) 
if ( ret == null ) 
ret = new Homography2D_F64 ( ) ; 
ret . a11 = m . unsafe_get ( 0 , 0 ) ; 
ret . a12 = m . unsafe_get ( 0 , 1 ) ; 
ret . a13 = m . unsafe_get ( 0 , 2 ) ; 
ret . a21 = m . unsafe_get ( 1 , 0 ) ; 
ret . a22 = m . unsafe_get ( 1 , 1 ) ; 
ret . a23 = m . unsafe_get ( 1 , 2 ) ; 
ret . a31 = m . unsafe_get ( 2 , 0 ) ; 
ret . a32 = m . unsafe_get ( 2 , 1 ) ; 
ret . a33 = m . unsafe_get ( 2 , 2 ) ; 
} public static DMatrixRMaj convert ( Homography2D_F64 m , DMatrixRMaj ret ) { 
if ( ret == null ) { 
ret = new DMatrixRMaj ( 3 , 3 ) ; 
} else if ( ret . numCols != 3 || ret . numRows != 3 ) 
ret . unsafe_set ( 0 , 0 , m . a11 ) ; 
ret . unsafe_set ( 0 , 1 , m . a12 ) ; 
ret . unsafe_set ( 0 , 2 , m . a13 ) ; 
ret . unsafe_set ( 1 , 0 , m . a21 ) ; 
ret . unsafe_set ( 1 , 1 , m . a22 ) ; 
ret . unsafe_set ( 1 , 2 , m . a23 ) ; 
ret . unsafe_set ( 2 , 0 , m . a31 ) ; 
ret . unsafe_set ( 2 , 1 , m . a32 ) ; 
ret . unsafe_set ( 2 , 2 , m . a33 ) ; 
} public double computeArea ( Polygon2D_F64 a , Polygon2D_F64 b ) { 
ssss = 0 ; 
sclx = 0 ; 
scly = 0 ; 
return inter ( a , b ) ; 
} private double inter ( Polygon2D_F64 a , Polygon2D_F64 b ) 
if ( a . size ( ) < 3 || b . size ( ) < 3 ) 
Vertex [ ] ipa = new Vertex [ a . size ( ) + 1 ] ; 
Vertex [ ] ipb = new Vertex [ b . size ( ) + 1 ] ; 
Rectangle2D_F64 bbox = new Rectangle2D_F64 ( 
Double . MAX_VALUE , Double . MAX_VALUE , 
- Double . MAX_VALUE , - Double . MAX_VALUE ) ; 
range ( a , bbox ) ; 
range ( b , bbox ) ; 
double rngx = bbox . p1 . x - bbox . p0 . x ; 
sclx = gamut / rngx ; 
double rngy = bbox . p1 . y - bbox . p0 . y ; 
scly = gamut / rngy ; 
double ascale = sclx * scly ; 
fit ( a , ipa , 0 , bbox ) ; 
fit ( b , ipb , 2 , bbox ) ; 
for ( int j = 0 ; j < a . size ( ) ; ++ j ) { 
for ( int k = 0 ; k < b . size ( ) ; ++ k ) { 
if ( ovl ( ipa [ j ] . rx , ipb [ k ] . rx ) && ovl ( ipa [ j ] . ry , ipb [ k ] . ry ) ) { 
long a1 = - area ( ipa [ j ] . ip , ipb [ k ] . ip , ipb [ k + 1 ] . ip ) ; 
long a2 = area ( ipa [ j + 1 ] . ip , ipb [ k ] . ip , ipb [ k + 1 ] . ip ) ; 
boolean o = a1 < 0 ; 
if ( o == a2 < 0 ) { 
long a3 = area ( ipb [ k ] . ip , ipa [ j ] . ip , ipa [ j + 1 ] . ip ) ; 
long a4 = - area ( ipb [ k + 1 ] . ip , ipa [ j ] . ip , 
ipa [ j + 1 ] . ip ) ; 
if ( a3 < 0 == a4 < 0 ) { 
if ( o ) 
cross ( ipa [ j ] , ipa [ j + 1 ] , ipb [ k ] , ipb [ k + 1 ] , 
a1 , a2 , a3 , a4 ) ; 
cross ( ipb [ k ] , ipb [ k + 1 ] , ipa [ j ] , ipa [ j + 1 ] , 
a3 , a4 , a1 , a2 ) ; 
inness ( ipa , a . size ( ) , ipb , b . size ( ) ) ; 
inness ( ipb , b . size ( ) , ipa , a . size ( ) ) ; 
return ssss / ascale ; 
} public Point2D_F64 getPointOnLine ( double t ) { 
return new Point2D_F64 ( slopeX * t + p . x , slopeY * t + p . y ) ; 
} public static boolean containConvex ( Polygon2D_F64 polygon , Point2D_F64 pt ) 
boolean c = false ; 
for ( int i = 0 , j = N - 1 ; i < N ; j = i ++ ) { 
Point2D_F64 a = polygon . vertexes . data [ i ] ; 
Point2D_F64 b = polygon . vertexes . data [ j ] ; 
if ( ( ( a . y > pt . y ) != ( b . y > pt . y ) ) && ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ) 
c = ! c ; 
} public static boolean containConcave ( Polygon2D_F64 polygon , Point2D_F64 pt ) 
int left = 0 ; 
int right = 0 ; 
Point2D_F64 b = polygon . vertexes . data [ i + 1 ] ; 
if ( ( pt . y >= a . y && pt . y < b . y ) || ( pt . y >= b . y && pt . y < a . y ) ) { 
double x = b . y == a . y ? pt . x : ( pt . y - a . y ) * ( b . x - a . x ) / ( b . y - a . y ) + a . x ; 
if ( x <= pt . x ) 
left ++ ; 
else if ( x > pt . x ) 
right ++ ; 
Point2D_F64 a = polygon . vertexes . data [ N - 1 ] ; 
Point2D_F64 b = polygon . vertexes . data [ 0 ] ; 
double x = b . y == a . y ? pt . x : ( pt . y - pt . y ) * ( b . x - a . x ) / ( b . y - a . y ) + a . x ; 
return ( left % 2 == 1 && right % 2 == 1 ) ; 
} public static boolean contains ( Quadrilateral_F64 quad , Point2D_F64 pt ) { 
return containTriangle ( quad . a , quad . b , quad . d , pt ) || 
containTriangle ( quad . b , quad . c , quad . d , pt ) ; 
} public static boolean containTriangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c , Point2D_F64 pt ) 
boolean ret = false ; 
ret = true ; 
if ( ( ( b . y > pt . y ) != ( c . y > pt . y ) ) && ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ) 
ret = ! ret ; 
if ( ( ( c . y > pt . y ) != ( a . y > pt . y ) ) && ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ) 
} public static Point2D_F64 intersection ( LineParametric2D_F64 a , LineParametric2D_F64 b , Point2D_F64 ret ) { 
double t_b = a . getSlopeX ( ) * ( b . getY ( ) - a . getY ( ) ) - a . getSlopeY ( ) * ( b . getX ( ) - a . getX ( ) ) ; 
double bottom = a . getSlopeY ( ) * b . getSlopeX ( ) - b . getSlopeY ( ) * a . getSlopeX ( ) ; 
if ( bottom == 0 ) 
t_b /= bottom ; 
double x = b . getSlopeX ( ) * t_b + b . getX ( ) ; 
double y = b . getSlopeY ( ) * t_b + b . getY ( ) ; 
ret = new Point2D_F64 ( ) ; 
ret . set ( x , y ) ; 
} public static double intersection ( LineParametric2D_F64 a , LineParametric2D_F64 b ) { 
double t_a = b . getSlopeX ( ) * ( a . getY ( ) - b . getY ( ) ) - b . getSlopeY ( ) * ( a . getX ( ) - b . getX ( ) ) ; 
double bottom = b . getSlopeY ( ) * a . getSlopeX ( ) - a . getSlopeY ( ) * b . getSlopeX ( ) ; 
return t_a / bottom ; 
} public static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , 
Point2D_F64 ret ) { 
double a0 = l_0 . b . x - l_0 . a . x ; 
double b0 = l_0 . b . y - l_0 . a . y ; 
double a1 = l_1 . b . x - l_1 . a . x ; 
double b1 = l_1 . b . y - l_1 . a . y ; 
double top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; 
double bottom = a0 * b1 - b0 * a1 ; 
double t_1 = top / bottom ; 
if ( t_1 < 0 || t_1 > 1 ) 
top = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; 
bottom = a1 * b0 - b1 * a0 ; 
double t_0 = top / bottom ; 
if ( t_0 < 0 || t_0 > 1 ) 
ret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; 
} public static Point3D_F64 intersection ( LineGeneral2D_F64 a , LineGeneral2D_F64 b , Point3D_F64 ret ) 
ret = new Point3D_F64 ( ) ; 
ret . x = a . B * b . C - a . C * b . B ; 
ret . y = a . C * b . A - a . A * b . C ; 
ret . z = a . A * b . B - a . B * b . A ; 
} public static Point2D_F64 intersection ( Point2D_F64 lineA0 , Point2D_F64 lineA1 , 
Point2D_F64 lineB0 , Point2D_F64 lineB1 , 
Point2D_F64 output ) 
if ( output == null ) 
output = new Point2D_F64 ( ) ; 
double slopeAx = lineA1 . x - lineA0 . x ; 
double slopeAy = lineA1 . y - lineA0 . y ; 
double slopeBx = lineB1 . x - lineB0 . x ; 
double slopeBy = lineB1 . y - lineB0 . y ; 
double top = slopeAy * ( lineB0 . x - lineA0 . x ) + slopeAx * ( lineA0 . y - lineB0 . y ) ; 
double bottom = slopeAx * slopeBy - slopeAy * slopeBx ; 
double t = top / bottom ; 
output . x = lineB0 . x + t * slopeBx ; 
output . y = lineB0 . y + t * slopeBy ; 
} public static double intersection ( LineParametric2D_F64 target , LineSegment2D_F64 l ) { 
double a1 = l . b . x - l . a . x ; 
double b1 = l . b . y - l . a . y ; 
double top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; 
double bottom = target . slope . x * b1 - target . slope . y * a1 ; 
top = b1 * ( target . p . x - l . a . x ) + a1 * ( l . a . y - target . p . y ) ; 
bottom = a1 * target . slope . y - b1 * target . slope . x ; 
return top / bottom ; 
} public static double intersection ( Polygon2D_F64 a , Polygon2D_F64 b ) { 
AreaIntersectionPolygon2D_F64 alg = new AreaIntersectionPolygon2D_F64 ( ) ; 
return Math . abs ( alg . computeArea ( a , b ) ) ; 
} public static boolean contains ( Rectangle2D_F64 a , double x , double y ) { 
return ( a . p0 . x <= x && a . p1 . x > x && a . p0 . y <= y && a . p1 . y > y ) ; 
} public static boolean contains2 ( Rectangle2D_F64 a , double x , double y ) { 
return ( a . p0 . x <= x && a . p1 . x >= x && a . p0 . y <= y && a . p1 . y >= y ) ; 
} public static boolean contains ( EllipseRotated_F64 ellipse , double x , double y ) { 
return ( UtilEllipse_F64 . evaluate ( x , y , ellipse ) <= 1.0 ) ; 
} public static boolean intersects ( Rectangle2D_F64 a , Rectangle2D_F64 b ) { 
return ( a . p0 . x < b . p1 . x && a . p1 . x > b . p0 . x && a . p0 . y < b . p1 . y && a . p1 . y > b . p0 . y ) ; 
} public static boolean intersection ( Rectangle2D_F64 a , Rectangle2D_F64 b , Rectangle2D_F64 result ) { 
if ( ! intersects ( a , b ) ) 
result . p0 . x = Math . max ( a . p0 . x , b . p0 . x ) ; 
result . p1 . x = Math . min ( a . p1 . x , b . p1 . x ) ; 
result . p0 . y = Math . max ( a . p0 . y , b . p0 . y ) ; 
result . p1 . y = Math . min ( a . p1 . y , b . p1 . y ) ; 
} public static double intersectionArea ( Rectangle2D_F64 a , Rectangle2D_F64 b ) { 
double x0 = Math . max ( a . p0 . x , b . p0 . x ) ; 
double x1 = Math . min ( a . p1 . x , b . p1 . x ) ; 
double y0 = Math . max ( a . p0 . y , b . p0 . y ) ; 
double y1 = Math . min ( a . p1 . y , b . p1 . y ) ; 
return ( x1 - x0 ) * ( y1 - y0 ) ; 
} public static int intersection ( LineGeneral2D_F64 line , EllipseRotated_F64 ellipse , 
Point2D_F64 intersection0 , Point2D_F64 intersection1 , double EPS ) { 
if ( EPS < 0 ) { 
EPS = GrlConstants . EPS ; 
double C = line . C + ( line . A * ellipse . center . x + line . B * ellipse . center . y ) ; 
double cphi = Math . cos ( ellipse . phi ) ; 
double sphi = Math . sin ( ellipse . phi ) ; 
double A = line . A * cphi + line . B * sphi ; 
double B = - line . A * sphi + line . B * cphi ; 
double a2 = ellipse . a * ellipse . a ; 
double b2 = ellipse . b * ellipse . b ; 
double x0 , y0 ; 
double x1 , y1 ; 
int totalIntersections ; 
if ( Math . abs ( A ) > Math . abs ( B ) ) { 
double alpha = - C / A ; 
double beta = - B / A ; 
double aa = beta * beta / a2 + 1.0 / b2 ; 
double bb = 2.0 * alpha * beta / a2 ; 
double cc = alpha * alpha / a2 - 1.0 ; 
double inner = bb * bb - 4.0 * aa * cc ; 
if ( Math . abs ( inner / aa ) < EPS ) { 
totalIntersections = 1 ; 
inner = inner < 0 ? 0 : inner ; 
} else if ( inner < 0 ) { 
totalIntersections = 2 ; 
double right = Math . sqrt ( inner ) ; 
y0 = ( - bb + right ) / ( 2.0 * aa ) ; 
y1 = ( - bb - right ) / ( 2.0 * aa ) ; 
x0 = - ( C + B * y0 ) / A ; 
x1 = - ( C + B * y1 ) / A ; 
double alpha = - C / B ; 
double beta = - A / B ; 
double aa = beta * beta / b2 + 1.0 / a2 ; 
double bb = 2.0 * alpha * beta / b2 ; 
double cc = alpha * alpha / b2 - 1.0 ; 
x0 = ( - bb + right ) / ( 2.0 * aa ) ; 
x1 = ( - bb - right ) / ( 2.0 * aa ) ; 
y0 = - ( A * x0 + C ) / B ; 
y1 = - ( A * x1 + C ) / B ; 
intersection0 . x = x0 * cphi - y0 * sphi + ellipse . center . x ; 
intersection0 . y = x0 * sphi + y0 * cphi + ellipse . center . y ; 
intersection1 . x = x1 * cphi - y1 * sphi + ellipse . center . x ; 
intersection1 . y = x1 * sphi + y1 * cphi + ellipse . center . y ; 
return totalIntersections ; 
} public static DMatrixRMaj rodriguesToMatrix ( Rodrigues_F64 rodrigues , DMatrixRMaj R ) { 
return rodriguesToMatrix ( 
rodrigues . unitAxisRotation . x , 
rodrigues . unitAxisRotation . y , 
rodrigues . unitAxisRotation . z , 
rodrigues . theta , R ) ; 
} public static DMatrixRMaj rodriguesToMatrix ( double axisX , double axisY , double axisZ , double theta , 
DMatrixRMaj R ) { 
R = checkDeclare3x3 ( R ) ; 
double x = axisX , y = axisY , z = axisZ ; 
double c = Math . cos ( theta ) ; 
double s = Math . sin ( theta ) ; 
double oc = 1.0 - c ; 
R . data [ 0 ] = c + x * x * oc ; 
R . data [ 1 ] = x * y * oc - z * s ; 
R . data [ 2 ] = x * z * oc + y * s ; 
R . data [ 3 ] = y * x * oc + z * s ; 
R . data [ 4 ] = c + y * y * oc ; 
R . data [ 5 ] = y * z * oc - x * s ; 
R . data [ 6 ] = z * x * oc - y * s ; 
R . data [ 7 ] = z * y * oc + x * s ; 
R . data [ 8 ] = c + z * z * oc ; 
return R ; 
} public static double [ ] rodriguesToEuler ( Rodrigues_F64 rodrigues , EulerType type , double [ ] euler ) 
DMatrixRMaj R = rodriguesToMatrix ( rodrigues , null ) ; 
return matrixToEuler ( R , type , euler ) ; 
} public static Quaternion_F64 rodriguesToQuaternion ( Rodrigues_F64 rodrigues , 
Quaternion_F64 quat ) { 
if ( quat == null ) 
quat = new Quaternion_F64 ( ) ; 
quat . w = Math . cos ( rodrigues . theta / 2.0 ) ; 
double s = Math . sin ( rodrigues . theta / 2.0 ) ; 
quat . x = rodrigues . unitAxisRotation . x * s ; 
quat . y = rodrigues . unitAxisRotation . y * s ; 
quat . z = rodrigues . unitAxisRotation . z * s ; 
return quat ; 
} public static Rodrigues_F64 quaternionToRodrigues ( Quaternion_F64 quat , 
Rodrigues_F64 rodrigues ) { 
if ( rodrigues == null ) 
rodrigues = new Rodrigues_F64 ( ) ; 
rodrigues . unitAxisRotation . set ( quat . x , quat . y , quat . z ) ; 
rodrigues . unitAxisRotation . normalize ( ) ; 
rodrigues . theta = 2.0 * Math . acos ( quat . w ) ; 
return rodrigues ; 
} public static double [ ] quaternionToEuler ( Quaternion_F64 q , EulerType type , double [ ] euler ) 
DMatrixRMaj R = quaternionToMatrix ( q , null ) ; 
} public static double [ ] matrixToEuler ( DMatrixRMaj R , EulerType type , double [ ] euler ) { 
if ( euler == null ) 
euler = new double [ 3 ] ; 
case ZYX : 
TanSinTan ( - 2 , 1 , 3 , - 6 , 9 , 5 , - 7 , 4 , 8 , R , euler ) ; 
case ZYZ : 
TanCosTan ( 8 , - 7 , 9 , 6 , 3 , 5 , - 7 , 4 , 8 , R , euler ) ; 
case ZXY : 
TanSinTan ( 4 , 5 , - 6 , 3 , 9 , 1 , 8 , - 2 , 7 , R , euler ) ; 
case ZXZ : 
TanCosTan ( 7 , 8 , 9 , 3 , - 6 , 1 , 8 , - 2 , 7 , R , euler ) ; 
case YXZ : 
TanSinTan ( - 7 , 9 , 8 , - 2 , 5 , 1 , - 6 , 3 , 4 , R , euler ) ; 
case YXY : 
TanCosTan ( 4 , - 6 , 5 , 2 , 8 , 1 , - 6 , 3 , 4 , R , euler ) ; 
case YZX : 
TanSinTan ( 3 , 1 , - 2 , 8 , 5 , 9 , 4 , - 7 , 6 , R , euler ) ; 
case YZY : 
TanCosTan ( 6 , 4 , 5 , 8 , - 2 , 9 , 4 , - 7 , 6 , R , euler ) ; 
case XYZ : 
TanSinTan ( 8 , 9 , - 7 , 4 , 1 , 5 , 3 , - 6 , 2 , R , euler ) ; 
case XYX : 
TanCosTan ( 2 , 3 , 1 , 4 , - 7 , 5 , 3 , - 6 , 2 , R , euler ) ; 
case XZY : 
TanSinTan ( - 6 , 5 , 4 , - 7 , 1 , 9 , - 2 , 8 , 3 , R , euler ) ; 
case XZX : 
TanCosTan ( 3 , - 2 , 1 , 7 , 4 , 9 , - 2 , 8 , 3 , R , euler ) ; 
return euler ; 
} private static double get ( DMatrixRMaj M , int index ) { 
return - M . data [ - index - 1 ] ; 
return M . data [ index - 1 ] ; 
} public static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { 
double m00 = R . unsafe_get ( 0 , 0 ) ; 
double m01 = R . unsafe_get ( 0 , 1 ) ; 
double m02 = R . unsafe_get ( 0 , 2 ) ; 
double m10 = R . unsafe_get ( 1 , 0 ) ; 
double m11 = R . unsafe_get ( 1 , 1 ) ; 
double m12 = R . unsafe_get ( 1 , 2 ) ; 
double m20 = R . unsafe_get ( 2 , 0 ) ; 
double m21 = R . unsafe_get ( 2 , 1 ) ; 
double m22 = R . unsafe_get ( 2 , 2 ) ; 
double trace = m00 + m11 + m22 ; 
if ( trace > 0 ) { 
double S = Math . sqrt ( trace + 1.0 ) * 2 ; 
quat . w = 0.25 * S ; 
quat . x = ( m21 - m12 ) / S ; 
quat . y = ( m02 - m20 ) / S ; 
quat . z = ( m10 - m01 ) / S ; 
} else if ( ( m00 > m11 ) & ( m00 > m22 ) ) { 
double S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; 
quat . w = ( m21 - m12 ) / S ; 
quat . x = 0.25 * S ; 
quat . y = ( m01 + m10 ) / S ; 
quat . z = ( m02 + m20 ) / S ; 
} else if ( m11 > m22 ) { 
double S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; 
quat . w = ( m02 - m20 ) / S ; 
quat . x = ( m01 + m10 ) / S ; 
quat . y = 0.25 * S ; 
quat . z = ( m12 + m21 ) / S ; 
double S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; 
quat . w = ( m10 - m01 ) / S ; 
quat . x = ( m02 + m20 ) / S ; 
quat . y = ( m12 + m21 ) / S ; 
quat . z = 0.25 * S ; 
} public static Rodrigues_F64 matrixToRodrigues ( DMatrixRMaj R , Rodrigues_F64 rodrigues ) { 
if ( rodrigues == null ) { 
double diagSum = ( ( R . unsafe_get ( 0 , 0 ) + R . unsafe_get ( 1 , 1 ) + R . unsafe_get ( 2 , 2 ) ) - 1.0 ) / 2.0 ; 
double absDiagSum = Math . abs ( diagSum ) ; 
if ( absDiagSum <= 1.0 && 1.0 - absDiagSum > 10.0 * GrlConstants . EPS ) { 
rodrigues . theta = Math . acos ( diagSum ) ; 
double bottom = 2.0 * Math . sin ( rodrigues . theta ) ; 
rodrigues . unitAxisRotation . x = ( R . unsafe_get ( 2 , 1 ) - R . unsafe_get ( 1 , 2 ) ) / bottom ; 
rodrigues . unitAxisRotation . y = ( R . unsafe_get ( 0 , 2 ) - R . unsafe_get ( 2 , 0 ) ) / bottom ; 
rodrigues . unitAxisRotation . z = ( R . unsafe_get ( 1 , 0 ) - R . unsafe_get ( 0 , 1 ) ) / bottom ; 
if ( diagSum >= 1.0 ) 
rodrigues . theta = 0 ; 
else if ( diagSum <= - 1.0 ) 
rodrigues . theta = Math . PI ; 
rodrigues . unitAxisRotation . x = Math . sqrt ( ( R . get ( 0 , 0 ) + 1 ) / 2 ) ; 
rodrigues . unitAxisRotation . y = Math . sqrt ( ( R . get ( 1 , 1 ) + 1 ) / 2 ) ; 
rodrigues . unitAxisRotation . z = Math . sqrt ( ( R . get ( 2 , 2 ) + 1 ) / 2 ) ; 
double x = rodrigues . unitAxisRotation . x ; 
double y = rodrigues . unitAxisRotation . y ; 
double z = rodrigues . unitAxisRotation . z ; 
if ( Math . abs ( R . get ( 1 , 0 ) - 2 * x * y ) > GrlConstants . EPS ) { 
x *= - 1 ; 
if ( Math . abs ( R . get ( 2 , 0 ) - 2 * x * z ) > GrlConstants . EPS ) { 
z *= - 1 ; 
if ( Math . abs ( R . get ( 2 , 1 ) - 2 * z * y ) > GrlConstants . EPS ) { 
y *= - 1 ; 
rodrigues . unitAxisRotation . x = x ; 
rodrigues . unitAxisRotation . y = y ; 
rodrigues . unitAxisRotation . z = z ; 
} public static DMatrixRMaj rotX ( double ang , DMatrixRMaj R ) { 
if ( R == null ) 
R = new DMatrixRMaj ( 3 , 3 ) ; 
setRotX ( ang , R ) ; 
} public static void setRotX ( double ang , DMatrixRMaj R ) { 
double c = Math . cos ( ang ) ; 
double s = Math . sin ( ang ) ; 
R . set ( 0 , 0 , 1 ) ; 
R . set ( 1 , 1 , c ) ; 
R . set ( 1 , 2 , - s ) ; 
R . set ( 2 , 1 , s ) ; 
R . set ( 2 , 2 , c ) ; 
} public static DMatrixRMaj rotY ( double ang , DMatrixRMaj R ) { 
setRotY ( ang , R ) ; 
} public static DMatrixRMaj rotZ ( double ang , DMatrixRMaj R ) { 
setRotZ ( ang , R ) ; 
} public static void setRotZ ( double ang , DMatrixRMaj r ) { 
r . set ( 0 , 0 , c ) ; 
r . set ( 0 , 1 , - s ) ; 
r . set ( 1 , 0 , s ) ; 
r . set ( 1 , 1 , c ) ; 
r . set ( 2 , 2 , 1 ) ; 
} public static DMatrixRMaj eulerToMatrix ( EulerType type , 
double rotA , double rotB , double rotC , 
DMatrixRMaj R_a = rotationAboutAxis ( type . getAxisA ( ) , rotA , null ) ; 
DMatrixRMaj R_b = rotationAboutAxis ( type . getAxisB ( ) , rotB , null ) ; 
DMatrixRMaj R_c = rotationAboutAxis ( type . getAxisC ( ) , rotC , null ) ; 
DMatrixRMaj A = new DMatrixRMaj ( 3 , 3 ) ; 
CommonOps_DDRM . mult ( R_b , R_a , A ) ; 
CommonOps_DDRM . mult ( R_c , A , R ) ; 
} private static DMatrixRMaj rotationAboutAxis ( int axis , double angle , DMatrixRMaj R ) { 
switch ( axis ) { 
return ConvertRotation3D_F64 . rotX ( angle , R ) ; 
return ConvertRotation3D_F64 . rotY ( angle , R ) ; 
return ConvertRotation3D_F64 . rotZ ( angle , R ) ; 
} public static DMatrixRMaj approximateRotationMatrix ( DMatrixRMaj orig , DMatrixRMaj R ) { 
SingularValueDecomposition < DMatrixRMaj > svd = 
DecompositionFactory_DDRM . svd ( orig . numRows , orig . numCols , true , true , false ) ; 
if ( ! svd . decompose ( orig ) ) 
CommonOps_DDRM . mult ( svd . getU ( null , false ) , svd . getV ( null , true ) , R ) ; 
double det = CommonOps_DDRM . det ( R ) ; 
if ( det < 0 ) 
CommonOps_DDRM . scale ( - 1 , R ) ; 
} public static DMatrixRMaj quaternionToMatrix ( Quaternion_F64 quat , DMatrixRMaj R ) { 
return quaternionToMatrix ( quat . w , quat . x , quat . y , quat . z , R ) ; 
} public void setAngle ( double angle ) { 
slope . set ( Math . cos ( angle ) , Math . sin ( angle ) ) ; 
return new Point2D_F64 ( slope . x * t + p . x , slope . y * t + p . y ) ; 
} public static DMatrixRMaj homogenous ( Se3_F64 transform , DMatrixRMaj H ) { 
if ( H == null ) { 
H = new DMatrixRMaj ( 4 , 4 ) ; 
H . reshape ( 4 , 4 ) ; 
CommonOps_DDRM . insert ( transform . R , H , 0 , 0 ) ; 
H . data [ 3 ] = transform . T . x ; 
H . data [ 7 ] = transform . T . y ; 
H . data [ 11 ] = transform . T . z ; 
H . data [ 12 ] = 0 ; H . data [ 13 ] = 0 ; H . data [ 14 ] = 0 ; H . data [ 15 ] = 1 ; 
return H ; 
} public static DMatrixRMaj homogenous ( TwistCoordinate_F64 twist , DMatrixRMaj H ) { 
H . data [ 12 ] = 0 ; H . data [ 13 ] = 0 ; H . data [ 14 ] = 0 ; H . data [ 15 ] = 0 ; 
H . data [ 0 ] = 0 ; H . data [ 1 ] = - twist . w . z ; H . data [ 2 ] = twist . w . y ; H . data [ 3 ] = twist . v . x ; 
H . data [ 4 ] = twist . w . z ; H . data [ 5 ] = 0 ; H . data [ 6 ] = - twist . w . x ; H . data [ 7 ] = twist . v . y ; 
H . data [ 8 ] = - twist . w . y ; H . data [ 9 ] = twist . w . x ; H . data [ 10 ] = 0 ; H . data [ 11 ] = twist . v . z ; 
} public static Se3_F64 exponential ( TwistCoordinate_F64 twist , double theta , Se3_F64 motion ) { 
if ( motion == null ) { 
motion = new Se3_F64 ( ) ; 
double w_norm = twist . w . norm ( ) ; 
if ( w_norm == 0.0 ) { 
CommonOps_DDRM . setIdentity ( motion . R ) ; 
motion . T . x = twist . v . x * theta ; 
motion . T . y = twist . v . y * theta ; 
motion . T . z = twist . v . z * theta ; 
return motion ; 
DMatrixRMaj R = motion . getR ( ) ; 
double wx = twist . w . x / w_norm , wy = twist . w . y / w_norm , wz = twist . w . z / w_norm ; 
ConvertRotation3D_F64 . rodriguesToMatrix ( wx , wy , wz , theta * w_norm , R ) ; 
theta *= w_norm ; 
double vx = twist . v . x , vy = twist . v . y , vz = twist . v . z ; 
double wv_x = wy * vz - wz * vy ; 
double wv_y = wz * vx - wx * vz ; 
double wv_z = wx * vy - wy * vx ; 
double left_x = ( 1 - R . data [ 0 ] ) * wv_x - R . data [ 1 ] * wv_y - R . data [ 2 ] * wv_z ; 
double left_y = - R . data [ 3 ] * wv_x + ( 1 - R . data [ 4 ] ) * wv_y - R . data [ 5 ] * wv_z ; 
double left_z = - R . data [ 6 ] * wv_x - R . data [ 7 ] * wv_y + ( 1 - R . data [ 8 ] ) * wv_z ; 
double right_x = ( wx * wx * vx + wx * wy * vy + wx * wz * vz ) * theta ; 
double right_y = ( wy * wx * vx + wy * wy * vy + wy * wz * vz ) * theta ; 
double right_z = ( wz * wx * vx + wz * wy * vy + wz * wz * vz ) * theta ; 
motion . T . x = ( double ) left_x + right_x ; 
motion . T . y = ( double ) left_y + right_y ; 
motion . T . z = ( double ) left_z + right_z ; 
motion . T . divide ( w_norm ) ; 
} public static TwistCoordinate_F64 twist ( Se3_F64 motion , TwistCoordinate_F64 twist ) { 
if ( twist == null ) 
twist = new TwistCoordinate_F64 ( ) ; 
if ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) { 
twist . w . set ( 0 , 0 , 0 ) ; 
twist . v . set ( motion . T ) ; 
Rodrigues_F64 rod = new Rodrigues_F64 ( ) ; 
ConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; 
twist . w . set ( rod . unitAxisRotation ) ; 
double theta = rod . theta ; 
DMatrixRMaj A = CommonOps_DDRM . identity ( 3 ) ; 
CommonOps_DDRM . subtract ( A , motion . R , A ) ; 
DMatrixRMaj w_hat = GeometryMath_F64 . crossMatrix ( twist . w , null ) ; 
DMatrixRMaj tmp = A . copy ( ) ; 
CommonOps_DDRM . mult ( tmp , w_hat , A ) ; 
Vector3D_F64 w = twist . w ; 
A . data [ 0 ] += w . x * w . x * theta ; A . data [ 1 ] += w . x * w . y * theta ; A . data [ 2 ] += w . x * w . z * theta ; 
A . data [ 3 ] += w . y * w . x * theta ; A . data [ 4 ] += w . y * w . y * theta ; A . data [ 5 ] += w . y * w . z * theta ; 
A . data [ 6 ] += w . z * w . x * theta ; A . data [ 7 ] += w . z * w . y * theta ; A . data [ 8 ] += w . z * w . z * theta ; 
DMatrixRMaj y = new DMatrixRMaj ( 3 , 1 ) ; 
y . data [ 0 ] = motion . T . x ; 
y . data [ 1 ] = motion . T . y ; 
y . data [ 2 ] = motion . T . z ; 
DMatrixRMaj x = new DMatrixRMaj ( 3 , 1 ) ; 
CommonOps_DDRM . solve ( A , y , x ) ; 
twist . w . scale ( rod . theta ) ; 
twist . v . x = ( double ) x . data [ 0 ] ; 
twist . v . y = ( double ) x . data [ 1 ] ; 
twist . v . z = ( double ) x . data [ 2 ] ; 
twist . v . scale ( rod . theta ) ; 
return twist ; 
} public void setTransforms ( Se3_F64 initial , Se3_F64 end ) { 
this . initial . set ( initial ) ; 
translation . x = end . T . x - initial . T . x ; 
translation . y = end . T . y - initial . T . y ; 
translation . z = end . T . z - initial . T . z ; 
CommonOps_DDRM . multTransA ( initial . getR ( ) , end . getR ( ) , R ) ; 
ConvertRotation3D_F64 . matrixToRodrigues ( R , rotation ) ; 
rotMagnitude = rotation . theta ; 
} public void interpolate ( double where , Se3_F64 output ) { 
rotation . setTheta ( where * rotMagnitude ) ; 
ConvertRotation3D_F64 . rodriguesToMatrix ( rotation , R ) ; 
output . T . x = initial . T . x + where * translation . x ; 
output . T . y = initial . T . y + where * translation . y ; 
output . T . z = initial . T . z + where * translation . z ; 
CommonOps_DDRM . mult ( initial . R , R , output . R ) ; 
} public void enforceExtents ( ) { 
if ( p1 . x < p0 . x ) { 
double tmp = p1 . x ; 
p1 . x = p0 . x ; 
p0 . x = tmp ; 
if ( p1 . y < p0 . y ) { 
double tmp = p1 . y ; 
p1 . y = p0 . y ; 
p0 . y = tmp ; 
} public static void polygon2Dto3D ( Polygon2D_F64 polygon2D , Se3_F64 polyToWorld , FastQueue < Point3D_F64 > output ) 
output . resize ( polygon2D . size ( ) ) ; 
for ( int i = 0 ; i < polygon2D . size ( ) ; i ++ ) { 
Point2D_F64 p2 = polygon2D . get ( i ) ; 
Point3D_F64 p3 = output . get ( i ) ; 
p3 . set ( p2 . x , p2 . y , 0 ) ; 
SePointOps_F64 . transform ( polyToWorld , p3 , p3 ) ; 
} public static LinePolar2D_F64 polar ( List < Point2D_F64 > points , double weights [ ] , LinePolar2D_F64 ret ) { 
final int N = points . size ( ) ; 
double totalWeight = 0 ; 
totalWeight += weights [ i ] ; 
if ( totalWeight == 0 ) 
ret = new LinePolar2D_F64 ( ) ; 
double meanX = 0 ; 
double meanY = 0 ; 
Point2D_F64 p = points . get ( i ) ; 
double w = weights [ i ] ; 
meanX += w * p . x ; 
meanY += w * p . y ; 
meanX /= totalWeight ; 
meanY /= totalWeight ; 
double top = 0 ; 
double bottom = 0 ; 
double dx = meanX - p . x ; 
double dy = meanY - p . y ; 
top += w * dx * dy ; 
bottom += w * ( dy * dy - dx * dx ) ; 
top /= totalWeight ; 
bottom /= totalWeight ; 
ret . angle = Math . atan2 ( - 2.0 * top , bottom ) / 2.0 ; 
ret . distance = ( double ) ( meanX * Math . cos ( ret . angle ) + meanY * Math . sin ( ret . angle ) ) ; 
} public boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { 
outputCenter . set ( 0 , 0 , 0 ) ; 
Point3D_F64 p = points . get ( i ) ; 
outputCenter . x += p . x ; 
outputCenter . y += p . y ; 
outputCenter . z += p . z ; 
outputCenter . x /= N ; 
outputCenter . y /= N ; 
outputCenter . z /= N ; 
return solvePoint ( points , outputCenter , outputNormal ) ; 
} public boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { 
A . reshape ( N , 3 ) ; 
A . data [ index ++ ] = p . x - pointOnPlane . x ; 
A . data [ index ++ ] = p . y - pointOnPlane . y ; 
A . data [ index ++ ] = p . z - pointOnPlane . z ; 
if ( ! solverNull . process ( A , 1 , nullspace ) ) 
outputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; 
outputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; 
outputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; 
} public double getSideLength ( int index ) { 
Point2D_F64 a = vertexes . get ( index ) ; 
Point2D_F64 b = vertexes . get ( ( index + 1 ) % vertexes . size ) ; 
return ( double ) a . distance ( b ) ; 
} public boolean isInside ( Point2D_F64 p ) { 
if ( isConvex ( ) ) { 
return Intersection2D_F64 . containConvex ( this , p ) ; 
return Intersection2D_F64 . containConcave ( this , p ) ; 
} public LineSegment2D_F64 getLine ( int index , LineSegment2D_F64 storage ) { 
if ( storage == null ) 
storage = new LineSegment2D_F64 ( ) ; 
int j = ( index + 1 ) % vertexes . size ; 
storage . a . set ( get ( index ) ) ; 
storage . b . set ( get ( j ) ) ; 
return storage ; 
} public List < Point2D_F64 > convert ( @ Nullable List < Point2D_F64 > storage , boolean copy ) { 
if ( copy ) { 
for ( int i = 0 ; i < vertexes . size ; i ++ ) { 
storage . add ( vertexes . get ( i ) . copy ( ) ) ; 
storage . addAll ( vertexes . toList ( ) ) ; 
} public void set ( List < Point2D_F64 > list ) { 
vertexes . resize ( list . size ( ) ) ; 
for ( int i = 0 ; i < list . size ( ) ; i ++ ) { 
vertexes . data [ i ] . set ( list . get ( i ) ) ; 
} public static DMatrixRMaj convert ( ConicGeneral_F64 src , DMatrixRMaj dst ) 
if ( dst == null ) 
dst = new DMatrixRMaj ( 3 , 3 ) ; 
dst . reshape ( 3 , 3 ) ; 
double B = src . B / 2.0 ; 
double D = src . D / 2.0 ; 
double E = src . E / 2.0 ; 
dst . data [ 0 ] = src . A ; dst . data [ 1 ] = B ; dst . data [ 2 ] = D ; 
dst . data [ 3 ] = B ; dst . data [ 4 ] = src . C ; dst . data [ 5 ] = E ; 
dst . data [ 6 ] = D ; dst . data [ 7 ] = E ; dst . data [ 8 ] = src . F ; 
return dst ; 
} public static ConicGeneral_F64 convert ( DMatrix3x3 src , ConicGeneral_F64 dst ) { 
dst = new ConicGeneral_F64 ( ) ; 
dst . A = src . a11 ; dst . B = 2 * src . a12 ; dst . D = 2 * src . a13 ; 
dst . C = src . a22 ; dst . E = 2 * src . a23 ; 
dst . F = src . a33 ; 
} public static DMatrix3x3 convert ( ConicGeneral_F64 src , DMatrix3x3 dst ) 
dst = new DMatrix3x3 ( ) ; 
dst . a11 = src . A ; dst . a12 = B ; dst . a13 = D ; 
dst . a21 = B ; dst . a22 = src . C ; dst . a23 = E ; 
dst . a31 = D ; dst . a32 = E ; dst . a33 = src . F ; 
} public static ConicGeneral_F64 convert ( DMatrixRMaj src , ConicGeneral_F64 dst ) { 
dst . A = src . data [ 0 ] ; dst . B = 2 * src . data [ 1 ] ; dst . D = 2 * src . data [ 2 ] ; 
dst . C = src . data [ 4 ] ; dst . E = 2 * src . data [ 5 ] ; 
dst . F = src . data [ 8 ] ; 
} public static ParabolaGeneral_F64 convert ( ConicGeneral_F64 src , ParabolaGeneral_F64 dst ) { 
dst = new ParabolaGeneral_F64 ( ) ; 
dst . A = Math . signum ( src . A ) * Math . sqrt ( Math . abs ( src . A ) ) ; 
dst . C = Math . signum ( src . C ) * Math . sqrt ( Math . abs ( src . C ) ) ; 
dst . D = src . D ; 
dst . E = src . E ; 
dst . F = src . F ; 
} public static ConicGeneral_F64 convert ( ParabolaGeneral_F64 src , ConicGeneral_F64 dst ) { 
dst . A = src . A * src . A ; 
dst . B = src . A * src . C * 2.0 ; 
dst . C = src . C * src . C ; 
} public static ParabolaParametric_F64 convert ( ParabolaGeneral_F64 src , ParabolaParametric_F64 dst ) { 
dst = new ParabolaParametric_F64 ( ) ; 
double A = src . A ; 
double C = src . C ; 
double D = src . D ; 
double E = src . E ; 
double F = src . F ; 
double bottom = C * D - A * E ; 
if ( bottom == 0 ) { 
dst . A = - C / bottom ; 
dst . B = E / bottom ; 
dst . C = - C * F / bottom ; 
dst . D = A / bottom ; 
dst . E = - D / bottom ; 
dst . F = A * F / bottom ; 
} public static DMatrixRMaj crossMatrix ( double x0 , double x1 , double x2 , DMatrixRMaj ret ) { 
ret . zero ( ) ; 
ret . set ( 0 , 1 , - x2 ) ; 
ret . set ( 0 , 2 , x1 ) ; 
ret . set ( 1 , 0 , x2 ) ; 
ret . set ( 1 , 2 , - x0 ) ; 
ret . set ( 2 , 0 , - x1 ) ; 
ret . set ( 2 , 1 , x0 ) ; 
} public static DMatrixRMaj crossMatrix ( GeoTuple3D_F64 v , DMatrixRMaj ret ) { 
double x = v . getX ( ) ; 
double y = v . getY ( ) ; 
double z = v . getZ ( ) ; 
ret . set ( 0 , 1 , - z ) ; 
ret . set ( 0 , 2 , y ) ; 
ret . set ( 1 , 0 , z ) ; 
ret . set ( 1 , 2 , - x ) ; 
ret . set ( 2 , 0 , - y ) ; 
ret . set ( 2 , 1 , x ) ; 
} public static void cross ( double a_x , double a_y , double a_z , 
double b_x , double b_y , double b_z , 
GeoTuple3D_F64 c ) { 
c . x = a_y * b_z - a_z * b_y ; 
c . y = a_z * b_x - a_x * b_z ; 
c . z = a_x * b_y - a_y * b_x ; 
} public static void cross ( GeoTuple2D_F64 a , GeoTuple3D_F64 b , GeoTuple3D_F64 c ) { 
c . x = a . y * b . z - b . y ; 
c . y = b . x - a . x * b . z ; 
c . z = a . x * b . y - a . y * b . x ; 
} public static void add ( GeoTuple3D_F64 a , GeoTuple3D_F64 b , GeoTuple3D_F64 c ) { 
c . x = a . x + b . x ; 
c . y = a . y + b . y ; 
c . z = a . z + b . z ; 
} public static void add ( double a0 , GeoTuple3D_F64 pt0 , double a1 , GeoTuple3D_F64 pt1 , GeoTuple3D_F64 pt2 ) { 
pt2 . x = a0 * pt0 . x + a1 * pt1 . x ; 
pt2 . y = a0 * pt0 . y + a1 * pt1 . y ; 
pt2 . z = a0 * pt0 . z + a1 * pt1 . z ; 
} public static < T extends GeoTuple3D_F64 > T addMult ( T p0 , DMatrixRMaj M , T p1 , T result ) { 
if ( M . numRows != 3 || M . numCols != 3 ) 
result = ( T ) p0 . createNewInstance ( ) ; 
double x = p1 . x ; 
double y = p1 . y ; 
double z = p1 . z ; 
result . x = p0 . x + ( double ) ( M . data [ 0 ] * x + M . data [ 1 ] * y + M . data [ 2 ] * z ) ; 
result . y = p0 . y + ( double ) ( M . data [ 3 ] * x + M . data [ 4 ] * y + M . data [ 5 ] * z ) ; 
result . z = p0 . z + ( double ) ( M . data [ 6 ] * x + M . data [ 7 ] * y + M . data [ 8 ] * z ) ; 
} public static void sub ( GeoTuple3D_F64 a , GeoTuple3D_F64 b , GeoTuple3D_F64 c ) { 
c . x = a . x - b . x ; 
c . y = a . y - b . y ; 
c . z = a . z - b . z ; 
} public static void rotate ( double theta , GeoTuple2D_F64 pt , GeoTuple2D_F64 solution ) { 
double x = pt . x ; 
double y = pt . y ; 
solution . x = c * x - s * y ; 
solution . y = s * x + c * y ; 
} public static void rotate ( double c , double s , GeoTuple2D_F64 pt , GeoTuple2D_F64 solution ) { 
} public static < T extends GeoTuple3D_F64 > T mult ( DMatrixRMaj M , T pt , T result ) { 
result = ( T ) pt . createNewInstance ( ) ; 
double z = pt . z ; 
result . x = ( double ) ( M . data [ 0 ] * x + M . data [ 1 ] * y + M . data [ 2 ] * z ) ; 
result . y = ( double ) ( M . data [ 3 ] * x + M . data [ 4 ] * y + M . data [ 5 ] * z ) ; 
result . z = ( double ) ( M . data [ 6 ] * x + M . data [ 7 ] * y + M . data [ 8 ] * z ) ; 
} public static < T extends GeoTuple2D_F64 > T mult ( DMatrixRMaj M , T pt , T mod ) { 
if ( mod == null ) { 
double modz = ( double ) ( M . unsafe_get ( 2 , 0 ) * x + M . unsafe_get ( 2 , 1 ) * y + M . unsafe_get ( 2 , 2 ) ) ; 
mod . x = ( double ) ( ( M . unsafe_get ( 0 , 0 ) * x + M . unsafe_get ( 0 , 1 ) * y + M . unsafe_get ( 0 , 2 ) ) / modz ) ; 
mod . y = ( double ) ( ( M . unsafe_get ( 1 , 0 ) * x + M . unsafe_get ( 1 , 1 ) * y + M . unsafe_get ( 1 , 2 ) ) / modz ) ; 
return mod ; 
} public static void mult ( DMatrixRMaj P , GeoTuple4D_F64 X , GeoTuple3D_F64 mod ) { 
if ( P . numRows != 3 || P . numCols != 4 ) 
mod . x = P . data [ 0 ] * X . x + P . data [ 1 ] * X . y + P . data [ 2 ] * X . z + P . data [ 3 ] * X . w ; 
mod . y = P . data [ 4 ] * X . x + P . data [ 5 ] * X . y + P . data [ 6 ] * X . z + P . data [ 7 ] * X . w ; 
mod . z = P . data [ 8 ] * X . x + P . data [ 9 ] * X . y + P . data [ 10 ] * X . z + P . data [ 11 ] * X . w ; 
} public static DMatrixRMaj multCrossATransA ( GeoTuple2D_F64 A , DMatrixRMaj M , DMatrixRMaj result ) { 
result = new DMatrixRMaj ( 3 , 3 ) ; 
double x = A . x ; 
double y = A . y ; 
double a11 = M . data [ 0 ] ; double a12 = M . data [ 1 ] ; double a13 = M . data [ 2 ] ; 
double a21 = M . data [ 3 ] ; double a22 = M . data [ 4 ] ; double a23 = M . data [ 5 ] ; 
double a31 = M . data [ 6 ] ; double a32 = M . data [ 7 ] ; double a33 = M . data [ 8 ] ; 
result . data [ 0 ] = a21 - a31 * y ; 
result . data [ 1 ] = a22 - a32 * y ; 
result . data [ 2 ] = a23 - a33 * y ; 
result . data [ 3 ] = - a11 + a31 * x ; 
result . data [ 4 ] = - a12 + a32 * x ; 
result . data [ 5 ] = - a13 + a33 * x ; 
result . data [ 6 ] = a11 * y - a21 * x ; 
result . data [ 7 ] = a12 * y - a22 * x ; 
result . data [ 8 ] = a13 * y - a23 * x ; 
} public static < T extends GeoTuple3D_F64 > T multTran ( DMatrixRMaj M , T pt , T mod ) { 
mod = ( T ) pt . createNewInstance ( ) ; 
mod . x = ( double ) ( M . unsafe_get ( 0 , 0 ) * x + M . unsafe_get ( 1 , 0 ) * y + M . unsafe_get ( 2 , 0 ) * z ) ; 
mod . y = ( double ) ( M . unsafe_get ( 0 , 1 ) * x + M . unsafe_get ( 1 , 1 ) * y + M . unsafe_get ( 2 , 1 ) * z ) ; 
mod . z = ( double ) ( M . unsafe_get ( 0 , 2 ) * x + M . unsafe_get ( 1 , 2 ) * y + M . unsafe_get ( 2 , 2 ) * z ) ; 
return ( T ) mod ; 
} public static double innerProdTranM ( GeoTuple3D_F64 a , DMatrixRMaj M , GeoTuple3D_F64 b ) { 
DMatrixRMaj m1 = new DMatrixRMaj ( 3 , 1 , true , a . x , a . y , a . z ) ; 
DMatrixRMaj m2 = new DMatrixRMaj ( 3 , 1 , true , b . x , b . y , b . z ) ; 
return ( double ) ( VectorVectorMult_DDRM . innerProdTranA ( m1 , M , m2 ) ) ; 
} public static DMatrixRMaj outerProd ( GeoTuple3D_F64 a , GeoTuple3D_F64 b , DMatrixRMaj ret ) { 
ret . data [ 0 ] = a . x * b . x ; 
ret . data [ 1 ] = a . x * b . y ; 
ret . data [ 2 ] = a . x * b . z ; 
ret . data [ 3 ] = a . y * b . x ; 
ret . data [ 4 ] = a . y * b . y ; 
ret . data [ 5 ] = a . y * b . z ; 
ret . data [ 6 ] = a . z * b . x ; 
ret . data [ 7 ] = a . z * b . y ; 
ret . data [ 8 ] = a . z * b . z ; 
} public static DMatrixRMaj addOuterProd ( DMatrixRMaj A , double scalar , GeoTuple3D_F64 b , GeoTuple3D_F64 c , DMatrixRMaj ret ) { 
ret . data [ 0 ] = A . data [ 0 ] + scalar * b . x * c . x ; 
ret . data [ 1 ] = A . data [ 1 ] + scalar * b . x * c . y ; 
ret . data [ 2 ] = A . data [ 2 ] + scalar * b . x * c . z ; 
ret . data [ 3 ] = A . data [ 3 ] + scalar * b . y * c . x ; 
ret . data [ 4 ] = A . data [ 4 ] + scalar * b . y * c . y ; 
ret . data [ 5 ] = A . data [ 5 ] + scalar * b . y * c . z ; 
ret . data [ 6 ] = A . data [ 6 ] + scalar * b . z * c . x ; 
ret . data [ 7 ] = A . data [ 7 ] + scalar * b . z * c . y ; 
ret . data [ 8 ] = A . data [ 8 ] + scalar * b . z * c . z ; 
} public static double innerProd ( GeoTuple2D_F64 a , DMatrixRMaj M , GeoTuple2D_F64 b ) { 
DMatrixRMaj m1 = new DMatrixRMaj ( 3 , 1 , true , a . x , a . y , 1 ) ; 
DMatrixRMaj m2 = new DMatrixRMaj ( 3 , 1 , true , b . x , b . y , 1 ) ; 
return ( double ) ( VectorVectorMult_DDRM . innerProdA ( m1 , M , m2 ) ) ; 
} public static void scale ( GeoTuple3D_F64 p , double v ) { 
p . x *= v ; 
p . y *= v ; 
p . z *= v ; 
} public static void divide ( GeoTuple3D_F64 p , double v ) { 
p . x /= v ; 
p . y /= v ; 
p . z /= v ; 
} public static void changeSign ( GeoTuple3D_F64 t ) { 
t . x = - t . x ; 
t . y = - t . y ; 
t . z = - t . z ; 
} public static DMatrixRMaj toMatrix ( GeoTuple3D_F64 in , DMatrixRMaj out ) { 
out = new DMatrixRMaj ( 3 , 1 ) ; 
else if ( out . getNumElements ( ) != 3 ) 
out . data [ 0 ] = in . x ; 
out . data [ 1 ] = in . y ; 
out . data [ 2 ] = in . z ; 
} public static void toTuple3D ( DMatrixRMaj in , GeoTuple3D_F64 out ) { 
out . x = ( double ) in . get ( 0 ) ; 
out . y = ( double ) in . get ( 1 ) ; 
out . z = ( double ) in . get ( 2 ) ; 
} public void setParamVector ( double x , double y , double z ) { 
double ax = Math . abs ( x ) ; 
double ay = Math . abs ( y ) ; 
double az = Math . abs ( z ) ; 
double max = Math . max ( ax , ay ) ; 
max = Math . max ( max , az ) ; 
if ( max == 0 ) { 
theta = 0 ; 
unitAxisRotation . set ( 1 , 0 , 0 ) ; 
x /= max ; 
y /= max ; 
z /= max ; 
theta = Math . sqrt ( x * x + y * y + z * z ) ; 
unitAxisRotation . x = x / theta ; 
unitAxisRotation . y = y / theta ; 
unitAxisRotation . z = z / theta ; 
theta *= max ; 
} public static double toHalfCircle ( double angle ) { 
if ( angle < 0 ) 
angle += Math . PI ; 
if ( angle > Math . PI / 2.0 ) 
angle -= Math . PI ; 
return angle ; 
} public static double bound ( double ang ) { 
ang %= GrlConstants . PI2 ; 
if ( ang > PI ) { 
return ang - GrlConstants . PI2 ; 
} else if ( ang < - PI ) { 
return ang + GrlConstants . PI2 ; 
return ang ; 
} public static float bound ( float ang ) { 
ang %= GrlConstants . F_PI2 ; 
if ( ang > GrlConstants . F_PI ) { 
return ang - GrlConstants . F_PI2 ; 
} else if ( ang < - GrlConstants . F_PI ) { 
return ang + GrlConstants . F_PI2 ; 
} public static double boundHalf ( double angle ) { 
angle = bound ( angle ) ; 
if ( angle > GrlConstants . PId2 ) { 
} else if ( angle < - GrlConstants . PId2 ) { 
} public static float boundHalf ( float angle ) { 
if ( angle > GrlConstants . F_PId2 ) { 
angle -= GrlConstants . F_PI ; 
} else if ( angle < - GrlConstants . F_PId2 ) { 
angle += GrlConstants . F_PI ; 
} public static double distanceCCW ( double angA , double angB ) { 
if ( angB >= angA ) 
return angB - angA ; 
return GrlConstants . PI2 - ( angA - angB ) ; 
} public static float distanceCCW ( float angA , float angB ) { 
return GrlConstants . F_PI2 - ( angA - angB ) ; 
} public static double distanceCW ( double angA , double angB ) { 
if ( angA >= angB ) 
return angA - angB ; 
return GrlConstants . PI2 - ( angB - angA ) ; 
} public static float distanceCW ( float angA , float angB ) { 
return GrlConstants . F_PI2 - ( angB - angA ) ; 
} public static double minus ( double angA , double angB ) { 
double diff = angA - angB ; 
if ( diff > Math . PI ) { 
return GrlConstants . PI2 - diff ; 
} else if ( diff < - Math . PI ) 
return - GrlConstants . PI2 - diff ; 
} public static float minus ( float angA , float angB ) { 
float diff = angA - angB ; 
if ( diff > GrlConstants . F_PI ) { 
return GrlConstants . F_PI2 - diff ; 
} else if ( diff < - GrlConstants . F_PI ) 
return - GrlConstants . F_PI2 - diff ; 
} public static double distHalf ( double angA , double angB ) { 
double a = Math . abs ( angA - angB ) ; 
if ( a <= Math . PI / 2 ) 
return Math . PI - a ; 
} public static double reflectZeroToOne ( double value ) { 
if ( value < 0 ) 
value = - value ; 
value = value % 2.0 ; 
if ( value > 1.0 ) 
return 2.0 - value ; 
} public static boolean intersect ( PlaneNormal3D_F64 plane , LineParametric3D_F64 line , Point3D_F64 intersection ) { 
double dx = plane . p . x - line . p . x ; 
double dy = plane . p . y - line . p . y ; 
double dz = plane . p . z - line . p . z ; 
double top = dx * plane . n . x + dy * plane . n . y + dz * plane . n . z ; 
double bottom = line . slope . dot ( plane . n ) ; 
double d = top / bottom ; 
intersection . x = line . p . x + d * line . slope . x ; 
intersection . y = line . p . y + d * line . slope . y ; 
intersection . z = line . p . z + d * line . slope . z ; 
} public static boolean intersect ( PlaneGeneral3D_F64 plane , LineParametric3D_F64 line , Point3D_F64 intersection ) { 
double top = plane . D - plane . A * line . p . x - plane . B * line . p . y - plane . C * line . p . z ; 
double bottom = plane . A * line . slope . x + plane . B * line . slope . y + plane . C * line . slope . z ; 
} public static boolean intersect ( PlaneGeneral3D_F64 a , PlaneGeneral3D_F64 b , LineParametric3D_F64 line ) { 
GeometryMath_F64 . cross ( a . A , a . B , a . C , b . A , b . B , b . C , line . slope ) ; 
if ( line . slope . normSq ( ) == 0 ) 
double n2 = a . A * a . A + a . B * a . B + a . C * a . C ; 
double closestX = a . A * a . D / n2 ; 
double closestY = a . B * a . D / n2 ; 
double closestZ = a . C * a . D / n2 ; 
double slopeX = a . B * line . slope . z - a . C * line . slope . y ; 
double slopeY = a . C * line . slope . x - a . A * line . slope . z ; 
double slopeZ = a . A * line . slope . y - a . B * line . slope . x ; 
double top = b . D - b . A * closestX - b . B * closestY - b . C * closestZ ; 
double bottom = b . A * slopeX + b . B * slopeY + b . C * slopeZ ; 
line . p . x = closestX + d * slopeX ; 
line . p . y = closestY + d * slopeY ; 
line . p . z = closestZ + d * slopeZ ; 
} public static int intersect ( Triangle3D_F64 T , LineSegment3D_F64 R , Point3D_F64 output ) { 
return intersect ( T , R , output , 
new Vector3D_F64 ( ) , new Vector3D_F64 ( ) , new Vector3D_F64 ( ) , new Vector3D_F64 ( ) , new Vector3D_F64 ( ) ) ; 
} public static int intersect ( Triangle3D_F64 T , LineSegment3D_F64 R , Point3D_F64 output , 
Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 n , 
Vector3D_F64 dir , Vector3D_F64 w0 ) { 
double r , a , b ; 
u . minus ( T . v1 , T . v0 ) ; 
v . minus ( T . v2 , T . v0 ) ; 
n . cross ( u , v ) ; 
if ( n . normSq ( ) == 0 ) 
dir . minus ( R . b , R . a ) ; 
w0 . minus ( R . a , T . v0 ) ; 
a = - n . dot ( w0 ) ; 
b = n . dot ( dir ) ; 
if ( Math . abs ( b ) < GrlConstants . EPS ) { 
if ( a == 0 ) 
else return 0 ; 
r = a / b ; 
if ( r < 0.0 ) 
else if ( r > 1.0 ) 
output . x = R . a . x + r * dir . x ; 
output . y = R . a . y + r * dir . y ; 
output . z = R . a . z + r * dir . z ; 
if ( containedPlane ( T . v0 , output , u , v , w0 ) ) { 
} public static int intersect ( Triangle3D_F64 T , LineParametric3D_F64 R , Point3D_F64 output ) { 
new Vector3D_F64 ( ) , new Vector3D_F64 ( ) , new Vector3D_F64 ( ) , new Vector3D_F64 ( ) ) ; 
} public static int intersectConvex ( FastQueue < Point3D_F64 > polygon , 
LineParametric3D_F64 line , Point3D_F64 output , 
Vector3D_F64 n , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { 
if ( polygon . size < 3 ) 
Point3D_F64 v0 = polygon . get ( 0 ) ; 
Point3D_F64 v1 = polygon . get ( 1 ) ; 
Point3D_F64 v2 = polygon . get ( 2 ) ; 
u . minus ( v1 , v0 ) ; 
v . minus ( v2 , v0 ) ; 
Vector3D_F64 dir = line . slope ; 
w0 . minus ( line . p , v0 ) ; 
output . x = line . p . x + r * dir . x ; 
output . y = line . p . y + r * dir . y ; 
output . z = line . p . z + r * dir . z ; 
for ( int i = 2 ; i < polygon . size ; i ++ ) { 
if ( containedPlane ( v0 , output , u , v , w0 ) ) { 
if ( r >= 0 ) 
if ( i < polygon . size - 1 ) { 
u . minus ( polygon . get ( i ) , v0 ) ; 
v . minus ( polygon . get ( i + 1 ) , v0 ) ; 
} private static boolean containedPlane ( Point3D_F64 T_v0 , 
Point3D_F64 output , 
Vector3D_F64 u , Vector3D_F64 v , 
Vector3D_F64 w0 ) { 
double uu , uv , vv , wu , wv , D ; 
uu = u . dot ( u ) ; 
uv = u . dot ( v ) ; 
vv = v . dot ( v ) ; 
w0 . minus ( output , T_v0 ) ; 
wu = w0 . dot ( u ) ; 
wv = w0 . dot ( v ) ; 
D = uv * uv - uu * vv ; 
double s , t ; 
s = ( uv * wv - vv * wu ) / D ; 
if ( s < 0.0 || s > 1.0 ) 
t = ( uv * wu - uu * wv ) / D ; 
return ! ( t < 0.0 ) && ! ( ( s + t ) > 1.0 ) ; 
} public static boolean contained ( BoxLength3D_F64 box , Point3D_F64 point ) { 
return ( box . p . x <= point . x && point . x < box . p . x + box . lengthX && 
box . p . y <= point . y && point . y < box . p . y + box . lengthY && 
box . p . z <= point . z && point . z < box . p . z + box . lengthZ ) ; 
} public static boolean contained ( Box3D_F64 box , Point3D_F64 point ) { 
} public static boolean intersect ( LineParametric3D_F64 line , Sphere3D_F64 sphere , 
Point3D_F64 a , Point3D_F64 b ) { 
double r2 = sphere . radius * sphere . radius ; 
double PP = GeometryMath_F64 . dot ( line . p , line . p ) ; 
double PV = GeometryMath_F64 . dot ( line . p , line . slope ) ; 
double PX = GeometryMath_F64 . dot ( line . p , sphere . center ) ; 
double VV = GeometryMath_F64 . dot ( line . slope , line . slope ) ; 
double VX = GeometryMath_F64 . dot ( line . slope , sphere . center ) ; 
double XX = GeometryMath_F64 . dot ( sphere . center , sphere . center ) ; 
double A = VV ; 
double B = 2.0 * ( PV - VX ) ; 
double C = PP + XX - 2.0 * PX - r2 ; 
double inner = B * B - 4.0 * A * C ; 
if ( inner < 0 ) 
double sqrt = Math . sqrt ( inner ) ; 
double t0 = ( - B + sqrt ) / ( 2.0 * A ) ; 
double t1 = ( - B - sqrt ) / ( 2.0 * A ) ; 
line . setPointOnLine ( t0 , a ) ; 
line . setPointOnLine ( t1 , b ) ; 
} public static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { 
double w0 = 1.0 - where ; 
output . T . x = a . T . x * w0 + b . T . x * where ; 
output . T . y = a . T . y * w0 + b . T . y * where ; 
double yaw0 = a . getYaw ( ) ; 
double yaw1 = b . getYaw ( ) ; 
double cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; 
double ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; 
double yaw ; 
if ( cw > ccw ) { 
yaw = yaw0 + ccw * where ; 
yaw = yaw0 - cw * where ; 
output . setYaw ( yaw ) ; 
} private void extractQuaternionFromQ ( SimpleMatrix q ) { 
SimpleEVD < SimpleMatrix > evd = q . eig ( ) ; 
int indexMax = evd . getIndexMax ( ) ; 
SimpleMatrix v_max = evd . getEigenVector ( indexMax ) ; 
quat . w = ( double ) v_max . get ( 0 ) ; 
quat . x = ( double ) v_max . get ( 1 ) ; 
quat . y = ( double ) v_max . get ( 2 ) ; 
quat . z = ( double ) v_max . get ( 3 ) ; 
quat . normalize ( ) ; 
ConvertRotation3D_F64 . quaternionToMatrix ( quat , motion . getR ( ) ) ; 
} public void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) 
if ( length == 2 ) { 
hull . vertexes . resize ( length ) ; 
hull . get ( i ) . set ( input [ i ] ) ; 
sorter . sort ( input , length ) ; 
work . reset ( ) ; 
Point2D_F64 p = input [ i ] ; 
while ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { 
work . removeTail ( ) ; 
work . add ( p ) ; 
int minSize = work . size + 2 ; 
for ( int i = length - 1 ; i >= 0 ; i -- ) 
while ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { 
hull . vertexes . resize ( work . size ) ; 
for ( int i = 0 ; i < work . size ( ) ; i ++ ) { 
hull . vertexes . data [ i ] . set ( work . get ( i ) ) ; 
} private static double subtractThenCross ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c ) { 
double x0 = b . x - a . x ; 
double y0 = b . y - a . y ; 
double x1 = c . x - a . x ; 
double y1 = c . y - a . y ; 
return x0 * y1 - y0 * x1 ; 
} public boolean setCovariance ( double a11 , double a12 , double a22 ) { 
Q . data [ 0 ] = a11 ; 
Q . data [ 1 ] = a12 ; 
Q . data [ 2 ] = a12 ; 
Q . data [ 3 ] = a22 ; 
if ( ! eigen . decompose ( Q ) ) { 
Complex_F64 v0 = eigen . getEigenvalue ( 0 ) ; 
Complex_F64 v1 = eigen . getEigenvalue ( 1 ) ; 
DMatrixRMaj a0 , a1 ; 
if ( v0 . getMagnitude2 ( ) > v1 . getMagnitude2 ( ) ) { 
a0 = eigen . getEigenVector ( 0 ) ; 
a1 = eigen . getEigenVector ( 1 ) ; 
lengthX = ( double ) v0 . getMagnitude ( ) ; 
lengthY = ( double ) v1 . getMagnitude ( ) ; 
a0 = eigen . getEigenVector ( 1 ) ; 
a1 = eigen . getEigenVector ( 0 ) ; 
lengthX = ( double ) v1 . getMagnitude ( ) ; 
lengthY = ( double ) v0 . getMagnitude ( ) ; 
if ( a0 == null || a1 == null ) { 
lengthX = Math . sqrt ( lengthX ) ; 
lengthY = Math . sqrt ( lengthY ) ; 
x . set ( ( double ) a0 . get ( 0 ) , ( double ) a0 . get ( 1 ) ) ; 
y . set ( ( double ) a1 . get ( 0 ) , ( double ) a1 . get ( 1 ) ) ; 
} public static void setToNoMotion ( Se3_F64 se ) { 
CommonOps_DDRM . setIdentity ( se . getR ( ) ) ; 
se . getT ( ) . set ( 0 , 0 , 0 ) ; 
} public static Affine2D_F64 toAffine ( Se2_F64 se , Affine2D_F64 affine ) { 
if ( affine == null ) 
affine = new Affine2D_F64 ( ) ; 
affine . a11 = se . c ; 
affine . a12 = - se . s ; 
affine . a21 = se . s ; 
affine . a22 = se . c ; 
affine . tx = se . T . x ; 
affine . ty = se . T . y ; 
return affine ; 
} public static DMatrixRMaj toHomogeneous ( Se3_F64 se , DMatrixRMaj ret ) { 
ret = new DMatrixRMaj ( 4 , 4 ) ; 
ret . set ( 3 , 0 , 0 ) ; 
ret . set ( 3 , 1 , 0 ) ; 
ret . set ( 3 , 2 , 0 ) ; 
CommonOps_DDRM . insert ( se . getR ( ) , ret , 0 , 0 ) ; 
Vector3D_F64 T = se . getT ( ) ; 
ret . set ( 0 , 3 , T . x ) ; 
ret . set ( 1 , 3 , T . y ) ; 
ret . set ( 2 , 3 , T . z ) ; 
ret . set ( 3 , 3 , 1 ) ; 
} public static Se3_F64 toSe3 ( DMatrixRMaj H , Se3_F64 ret ) { 
if ( H . numCols != 4 || H . numRows != 4 ) 
ret = new Se3_F64 ( ) ; 
ret . setTranslation ( ( double ) H . get ( 0 , 3 ) , ( double ) H . get ( 1 , 3 ) , ( double ) H . get ( 2 , 3 ) ) ; 
CommonOps_DDRM . extract ( H , 0 , 3 , 0 , 3 , ret . getR ( ) , 0 , 0 ) ; 
} public static DMatrixRMaj toHomogeneous ( Se2_F64 se , DMatrixRMaj ret ) { 
ret . set ( 2 , 0 , 0 ) ; 
ret . set ( 2 , 1 , 0 ) ; 
final double c = se . getCosineYaw ( ) ; 
final double s = se . getSineYaw ( ) ; 
ret . set ( 0 , 0 , c ) ; 
ret . set ( 0 , 1 , - s ) ; 
ret . set ( 1 , 0 , s ) ; 
ret . set ( 1 , 1 , c ) ; 
ret . set ( 0 , 2 , se . getX ( ) ) ; 
ret . set ( 1 , 2 , se . getY ( ) ) ; 
ret . set ( 2 , 2 , 1 ) ; 
} public static Se2_F64 toSe2 ( DMatrixRMaj H , Se2_F64 ret ) { 
if ( H . numCols != 3 || H . numRows != 3 ) 
ret = new Se2_F64 ( ) ; 
ret . setTranslation ( ( double ) H . get ( 0 , 2 ) , ( double ) H . get ( 1 , 2 ) ) ; 
double c = ( double ) H . get ( 0 , 0 ) ; 
double s = ( double ) H . get ( 1 , 0 ) ; 
ret . setYaw ( Math . atan2 ( s , c ) ) ; 
} public static Se3_F64 eulerXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , 
Se3_F64 se ) { 
return eulerXyz ( dx , dy , dz , EulerType . XYZ , rotX , rotY , rotZ , se ) ; 
} public static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , 
if ( se == null ) 
se = new Se3_F64 ( ) ; 
double theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; 
if ( theta == 0 ) { 
CommonOps_DDRM . setIdentity ( se . R ) ; 
ConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; 
T . x = dx ; 
T . y = dy ; 
T . z = dz ; 
return se ; 
} public static boolean isIdentical ( Se3_F64 a , Se3_F64 b , double tolT , double tolR ) { 
if ( Math . abs ( a . T . x - b . T . x ) > tolT ) 
if ( Math . abs ( a . T . y - b . T . y ) > tolT ) 
if ( Math . abs ( a . T . z - b . T . z ) > tolT ) 
DMatrixRMaj D = new DMatrixRMaj ( 3 , 3 ) ; 
CommonOps_DDRM . multTransA ( a . R , b . R , D ) ; 
ConvertRotation3D_F64 . matrixToRodrigues ( D , rod ) ; 
return rod . theta <= tolR ; 
} public static boolean bestFit ( Se3_F64 a ) { 
SingularValueDecomposition_F64 < DMatrixRMaj > svd = DecompositionFactory_DDRM . svd ( true , true , true ) ; 
if ( ! svd . decompose ( a . R ) ) 
CommonOps_DDRM . multTransB ( svd . getU ( null , false ) , svd . getV ( null , false ) , a . R ) ; 
double det = CommonOps_DDRM . det ( a . R ) ; 
if ( det < 0 ) { 
CommonOps_DDRM . scale ( - 1 , a . R ) ; 
double b = 1.0 ; 
double s [ ] = svd . getSingularValues ( ) ; 
for ( int i = 0 ; i < svd . numberOfSingularValues ( ) ; i ++ ) { 
b *= s [ i ] ; 
b = Math . signum ( det ) / Math . pow ( b , 1.0 / 3.0 ) ; 
GeometryMath_F64 . scale ( a . T , b ) ; 
} public static double distance ( LineSegment2D_I32 line , 
Point2D_I32 p ) { 
int a = line . b . x - line . a . x ; 
int b = line . b . y - line . a . y ; 
double t = a * ( p . x - line . a . x ) + b * ( p . y - line . a . y ) ; 
t /= ( a * a + b * b ) ; 
return UtilPoint2D_I32 . distance ( line . a . x , line . a . y , p . x , p . y ) ; 
} else if ( t > 1.0 ) 
return UtilPoint2D_I32 . distance ( line . b . x , line . b . y , p . x , p . y ) ; 
return UtilPoint2D_F64 . distance ( line . a . x + t * a , line . a . y + t * b , p . x , p . y ) ; 
} public static double distance ( LineParametric2D_I32 line , Point2D_I32 p ) { 
int a = line . slopeX ; 
int b = line . slopeY ; 
double t = a * ( p . x - line . p . x ) + b * ( p . y - line . p . y ) ; 
return UtilPoint2D_F64 . distance ( line . p . x + t * a , line . p . y + t * b , p . x , p . y ) ; 
} public static < T extends GeoTuple3D_F64 < T > > T latlonToUnitVector ( double lat , double lon , T vector ) { 
if ( vector == null ) 
vector = ( T ) new Vector3D_F64 ( ) ; 
vector . x = Math . cos ( lat ) * Math . cos ( lon ) ; 
vector . y = Math . cos ( lat ) * Math . sin ( lon ) ; 
vector . z = - Math . sin ( lat ) ; 
return vector ; 
} public static double evaluate ( double x , double y , Circle2D_F64 circle ) { 
x -= circle . center . x ; 
y -= circle . center . y ; 
return x * x + y * y - circle . radius * circle . radius ; 
} public static boolean circle ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 , Circle2D_F64 circle ) { 
double xa = ( x0 . x + x1 . x ) / 2.0 ; 
double ya = ( x0 . y + x1 . y ) / 2.0 ; 
double xb = ( x1 . x + x2 . x ) / 2.0 ; 
double yb = ( x1 . y + x2 . y ) / 2.0 ; 
double m2 = x0 . x - x1 . x ; 
double m1 = x1 . y - x0 . y ; 
double n2 = x2 . x - x1 . x ; 
double n1 = x1 . y - x2 . y ; 
double bottom = m2 * n1 - n2 * m1 ; 
double alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; 
circle . center . x = xb + n1 * alpha ; 
circle . center . y = yb + n2 * alpha ; 
circle . radius = circle . center . distance ( x0 ) ; 
} public static double circleRadiusSq ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 ) { 
double dx = xb + n1 * alpha - x0 . x ; 
double dy = yb + n2 * alpha - x0 . y ; 
return dx * dx + dy * dy ; 
} public static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , 
LineParametric3D_F64 l1 , 
Point3D_F64 ret ) { 
ret . x = l0 . p . x - l1 . p . x ; 
ret . y = l0 . p . y - l1 . p . y ; 
ret . z = l0 . p . z - l1 . p . z ; 
double dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; 
double dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; 
double dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; 
double t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; 
double bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; 
t0 /= bottom ; 
double t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; 
ret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; 
ret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; 
ret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; 
} public static boolean closestPoints ( LineParametric3D_F64 l0 , 
double param [ ] ) 
double dX = l0 . p . x - l1 . p . x ; 
double dY = l0 . p . y - l1 . p . y ; 
double dZ = l0 . p . z - l1 . p . z ; 
double dv01v1 = MiscOps . dot ( dX , dY , dZ , l1 . slope ) ; 
double t0 = dv01v1 * dv1v0 - MiscOps . dot ( dX , dY , dZ , l0 . slope ) * dv1v1 ; 
param [ 0 ] = t0 ; 
param [ 1 ] = t1 ; 
} public static Point3D_F64 closestPoint ( LineParametric3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) 
double dx = pt . x - line . p . x ; 
double dy = pt . y - line . p . y ; 
double dz = pt . z - line . p . z ; 
double n2 = line . slope . normSq ( ) ; 
double d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; 
ret . x = line . p . x + d * line . slope . x / n2 ; 
ret . y = line . p . y + d * line . slope . y / n2 ; 
ret . z = line . p . z + d * line . slope . z / n2 ; 
} public static double closestPoint ( LineParametric3D_F64 line , Point3D_F64 pt ) 
return ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) / line . slope . normSq ( ) ; 
} public static Point3D_F64 closestPoint ( PlaneNormal3D_F64 plane , Point3D_F64 point , Point3D_F64 found ) { 
if ( found == null ) 
found = new Point3D_F64 ( ) ; 
double A = plane . n . x ; 
double B = plane . n . y ; 
double C = plane . n . z ; 
double D = plane . n . x * plane . p . x + plane . n . y * plane . p . y + plane . n . z * plane . p . z ; 
double top = A * point . x + B * point . y + C * point . z - D ; 
double n2 = A * A + B * B + C * C ; 
found . x = point . x - A * top / n2 ; 
found . y = point . y - B * top / n2 ; 
found . z = point . z - C * top / n2 ; 
} public static Point3D_F64 closestPoint ( PlaneGeneral3D_F64 plane , Point3D_F64 point , Point3D_F64 found ) { 
double top = plane . A * point . x + plane . B * point . y + plane . C * point . z - plane . D ; 
double n2 = plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ; 
found . x = point . x - plane . A * top / n2 ; 
found . y = point . y - plane . B * top / n2 ; 
found . z = point . z - plane . C * top / n2 ; 
} public static Point3D_F64 closestPointOrigin ( PlaneGeneral3D_F64 plane , Point3D_F64 found ) { 
found . x = plane . A * plane . D / n2 ; 
found . y = plane . B * plane . D / n2 ; 
found . z = plane . C * plane . D / n2 ; 
} public static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { 
double dx = pt . x - line . a . x ; 
double dy = pt . y - line . a . y ; 
double dz = pt . z - line . a . z ; 
double slope_x = line . b . x - line . a . x ; 
double slope_y = line . b . y - line . a . y ; 
double slope_z = line . b . z - line . a . z ; 
double n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; 
double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; 
if ( d <= 0 ) { 
ret . set ( line . a ) ; 
} else if ( d >= n ) { 
ret . set ( line . b ) ; 
ret . x = line . a . x + d * slope_x / n ; 
ret . y = line . a . y + d * slope_y / n ; 
ret . z = line . a . z + d * slope_z / n ; 
} public static Point3D_F64 closestPoint ( LineSegment3D_F64 l0 , LineSegment3D_F64 l1 , Point3D_F64 ret ) { 
ret . x = l0 . a . x - l1 . a . x ; 
ret . y = l0 . a . y - l1 . a . y ; 
ret . z = l0 . a . z - l1 . a . z ; 
double slope0_x = l0 . b . x - l0 . a . x ; 
double slope0_y = l0 . b . y - l0 . a . y ; 
double slope0_z = l0 . b . z - l0 . a . z ; 
double slope1_x = l1 . b . x - l1 . a . x ; 
double slope1_y = l1 . b . y - l1 . a . y ; 
double slope1_z = l1 . b . z - l1 . a . z ; 
double n0 = ( double ) Math . sqrt ( slope0_x * slope0_x + slope0_y * slope0_y + slope0_z * slope0_z ) ; 
double n1 = ( double ) Math . sqrt ( slope1_x * slope1_x + slope1_y * slope1_y + slope1_z * slope1_z ) ; 
slope0_x /= n0 ; slope0_y /= n0 ; slope0_z /= n0 ; 
slope1_x /= n1 ; slope1_y /= n1 ; slope1_z /= n1 ; 
double dv01v1 = ret . x * slope1_x + ret . y * slope1_y + ret . z * slope1_z ; 
double dv01v0 = ret . x * slope0_x + ret . y * slope0_y + ret . z * slope0_z ; 
double dv1v0 = slope1_x * slope0_x + slope1_y * slope0_y + slope1_z * slope0_z ; 
double t0 = dv01v1 * dv1v0 - dv01v0 ; 
double bottom = 1 - dv1v0 * dv1v0 ; 
if ( t0 < 0 ) 
return closestPoint ( l1 , l0 . a , ret ) ; 
if ( t0 > 1 ) 
return closestPoint ( l1 , l0 . b , ret ) ; 
double t1 = ( dv01v1 + t0 * dv1v0 ) ; 
if ( t1 < 0 ) 
return closestPoint ( l0 , l1 . a , ret ) ; 
if ( t1 > 1 ) 
return closestPoint ( l0 , l1 . b , ret ) ; 
ret . x = ( double ) 0.5 * ( ( l0 . a . x + t0 * slope0_x ) + ( l1 . a . x + t1 * slope1_x ) ) ; 
ret . y = ( double ) 0.5 * ( ( l0 . a . y + t0 * slope0_y ) + ( l1 . a . y + t1 * slope1_y ) ) ; 
ret . z = ( double ) 0.5 * ( ( l0 . a . z + t0 * slope0_z ) + ( l1 . a . z + t1 * slope1_z ) ) ; 
} public static Point3D_F64 closestPoint ( Point3D_F64 vertexA , Point3D_F64 vertexB , Point3D_F64 vertexC , 
Point3D_F64 point , Point3D_F64 ret ) { 
DistancePointTriangle3D_F64 alg = new DistancePointTriangle3D_F64 ( ) ; 
alg . setTriangle ( vertexA , vertexB , vertexC ) ; 
alg . closestPoint ( point , ret ) ; 
} public static double closestPointT ( LineParametric3D_F64 line , PlaneNormal3D_F64 plane ) { 
} public static Point2D_F64 transform ( Homography2D_F64 H , Point2D_F64 orig , Point2D_F64 result ) { 
result = new Point2D_F64 ( ) ; 
double x = orig . x ; 
double y = orig . y ; 
double z = H . a31 * x + H . a32 * y + H . a33 ; 
result . x = ( H . a11 * x + H . a12 * y + H . a13 ) / z ; 
result . y = ( H . a21 * x + H . a22 * y + H . a23 ) / z ; 
} public static Point2D_F64 transform ( Se2_F64 se , Point2D_F64 orig , Point2D_F64 result ) { 
result . x = se . getX ( ) + x * c - y * s ; 
result . y = se . getY ( ) + x * s + y * c ; 
} public static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { 
double tranX = se . getX ( ) ; 
double tranY = se . getY ( ) ; 
Point2D_F64 pt = points [ i ] ; 
pt . x = tranX + x * c - y * s ; 
pt . y = tranY + x * s + y * c ; 
} public static void transform ( Se3_F64 se , Point3D_F64 [ ] points , int start , int length ) { 
Point3D_F64 p = points [ i + start ] ; 
transform ( se , p , p ) ; 
} public static void transform ( Se3_F64 se , List < Point3D_F64 > points ) { 
for ( Point3D_F64 p : points ) { 
} public static Point3D_F64 transform ( Se3_F64 se , Point3D_F64 origPt , Point3D_F64 tranPt ) { 
if ( tranPt == null ) 
tranPt = new Point3D_F64 ( ) ; 
DMatrixRMaj R = se . getR ( ) ; 
GeometryMath_F64 . mult ( R , origPt , tranPt ) ; 
GeometryMath_F64 . add ( tranPt , T , tranPt ) ; 
return tranPt ; 
} public static Point3D_F64 transform ( Se3_F64 se , Point4D_F64 origPt , Point3D_F64 tranPt ) { 
double P11 = R . data [ 0 ] , P12 = R . data [ 1 ] , P13 = R . data [ 2 ] , P14 = T . x ; 
double P21 = R . data [ 3 ] , P22 = R . data [ 4 ] , P23 = R . data [ 5 ] , P24 = T . y ; 
double P31 = R . data [ 6 ] , P32 = R . data [ 7 ] , P33 = R . data [ 8 ] , P34 = T . z ; 
tranPt . x = P11 * origPt . x + P12 * origPt . y + P13 * origPt . z + P14 * origPt . w ; 
tranPt . y = P21 * origPt . x + P22 * origPt . y + P23 * origPt . z + P24 * origPt . w ; 
tranPt . z = P31 * origPt . x + P32 * origPt . y + P33 * origPt . z + P34 * origPt . w ; 
} public static Point3D_F64 transformReverse ( Se3_F64 se , Point3D_F64 origPt , Point3D_F64 tranPt ) { 
GeometryMath_F64 . sub ( origPt , T , tranPt ) ; 
GeometryMath_F64 . multTran ( R , tranPt , tranPt ) ; 
storage . add ( get ( i ) . copy ( ) ) ; 
storage . add ( get ( i ) ) ; 
if ( list . size ( ) != 4 ) 
a . set ( list . get ( 0 ) ) ; 
b . set ( list . get ( 1 ) ) ; 
c . set ( list . get ( 2 ) ) ; 
d . set ( list . get ( 3 ) ) ; 
} public boolean isEquals ( Quadrilateral_F64 quad , double tol ) { 
tol *= tol ; 
if ( a . distance2 ( quad . a ) > tol ) 
if ( b . distance2 ( quad . b ) > tol ) 
if ( c . distance2 ( quad . c ) > tol ) 
return d . distance2 ( quad . d ) <= tol ; 
} public static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { 
double la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; 
double lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; 
double value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; 
if ( value < - 1.0 ) value = - 1.0 ; 
else if ( value > 1.0 ) value = 1.0 ; 
return Math . acos ( value ) ; 
} public static double acuteAngleN ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { 
double value = a . A * b . A + a . B * b . B ; 
} public static LineParametric2D_F64 convert ( LinePolar2D_F64 src , LineParametric2D_F64 ret ) 
ret = new LineParametric2D_F64 ( ) ; 
double c = ( double ) Math . cos ( src . angle ) ; 
double s = ( double ) Math . sin ( src . angle ) ; 
ret . p . set ( c * src . distance , s * src . distance ) ; 
ret . slope . set ( - s , c ) ; 
} public static LineGeneral2D_F64 convert ( LinePolar2D_F64 src , LineGeneral2D_F64 ret ) 
ret = new LineGeneral2D_F64 ( ) ; 
ret . A = c ; 
ret . B = s ; 
ret . C = - src . distance ; 
} public static LinePolar2D_F64 convert ( LineGeneral2D_F64 src , LinePolar2D_F64 ret ) 
double r = Math . sqrt ( src . A * src . A + src . B * src . B ) ; 
double sign = src . C < 0 ? - 1 : 1 ; 
ret . angle = Math . atan2 ( - sign * src . B / r , - sign * src . A / r ) ; 
ret . distance = sign * src . C / r ; 
} public static LineParametric2D_F64 convert ( LineSegment2D_F64 src , LineParametric2D_F64 ret ) 
ret . p . set ( src . a ) ; 
ret . slope . set ( src . slopeX ( ) , src . slopeY ( ) ) ; 
} public static LineGeneral2D_F64 convert ( LineSegment2D_F64 src , LineGeneral2D_F64 ret ) 
return convert ( src . a , src . b , ret ) ; 
} public static LineGeneral2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineGeneral2D_F64 ret ) 
ret . A = a . y - b . y ; 
ret . B = b . x - a . x ; 
ret . C = - ( ret . A * a . x + ret . B * a . y ) ; 
} public static LineParametric2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineParametric2D_F64 ret ) 
ret . p . set ( a ) ; 
ret . slope . x = b . x - a . x ; 
ret . slope . y = b . y - a . y ; 
} public static LinePolar2D_F64 convert ( LineParametric2D_F64 src , LinePolar2D_F64 ret ) 
double top = src . slope . y * src . p . x - src . slope . x * src . p . y ; 
ret . distance = top / src . slope . norm ( ) ; 
ret . angle = Math . atan2 ( - src . slope . x , src . slope . y ) ; 
if ( ret . distance < 0 ) { 
ret . distance = - ret . distance ; 
ret . angle = UtilAngle . bound ( ret . angle + Math . PI ) ; 
} public static LineGeneral2D_F64 convert ( LineParametric2D_F64 src , LineGeneral2D_F64 ret ) { 
ret . A = - src . slope . y ; 
ret . B = src . slope . x ; 
ret . C = - ret . A * src . p . x - ret . B * src . p . y ; 
} public static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { 
ret . slope . x = src . B ; 
ret . slope . y = - src . A ; 
if ( Math . abs ( src . B ) > Math . abs ( src . A ) ) { 
ret . p . y = - src . C / src . B ; 
ret . p . x = 0 ; 
ret . p . x = - src . C / src . A ; 
ret . p . y = 0 ; 
} public static PlaneGeneral3D_F64 convert ( PlaneNormal3D_F64 input , PlaneGeneral3D_F64 output ) { 
output = new PlaneGeneral3D_F64 ( ) ; 
Vector3D_F64 n = input . n ; 
Point3D_F64 p = input . p ; 
output . A = n . x ; 
output . B = n . y ; 
output . C = n . z ; 
output . D = n . x * p . x + n . y * p . y + n . z * p . z ; 
} public static PlaneNormal3D_F64 convert ( PlaneGeneral3D_F64 input , PlaneNormal3D_F64 output ) { 
output = new PlaneNormal3D_F64 ( ) ; 
double top = - input . D ; 
double n2 = input . A * input . A + input . B * input . B + input . C * input . C ; 
output . p . x = - input . A * top / n2 ; 
output . p . y = - input . B * top / n2 ; 
output . p . z = - input . C * top / n2 ; 
output . n . set ( input . A , input . B , input . C ) ; 
} public static PlaneNormal3D_F64 convert ( PlaneTangent3D_F64 input , PlaneNormal3D_F64 output ) { 
output . n . x = input . x ; 
output . n . y = input . y ; 
output . n . z = input . z ; 
output . p . set ( input ) ; 
} public static PlaneNormal3D_F64 convert ( Se3_F64 planeToWorld , PlaneNormal3D_F64 output ) { 
output . n . x = planeToWorld . R . unsafe_get ( 0 , 2 ) ; 
output . n . y = planeToWorld . R . unsafe_get ( 1 , 2 ) ; 
output . n . z = planeToWorld . R . unsafe_get ( 2 , 2 ) ; 
output . p . set ( planeToWorld . T . x , planeToWorld . T . y , planeToWorld . T . z ) ; 
} public static void hessianNormalForm ( PlaneGeneral3D_F64 plane ) { 
double n = Math . sqrt ( plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ) ; 
plane . A /= n ; 
plane . B /= n ; 
plane . C /= n ; 
plane . D /= n ; 
} public static double evaluate ( PlaneGeneral3D_F64 plane , Point3D_F64 point ) { 
return plane . A * point . x + plane . B * point . y + plane . C * point . z - plane . D ; 
} public static double evaluate ( PlaneNormal3D_F64 plane , Point3D_F64 point ) { 
double dx = point . x - plane . p . x ; 
double dy = point . y - plane . p . y ; 
double dz = point . z - plane . p . z ; 
return plane . n . x * dx + plane . n . y * dy + plane . n . z * dz ; 
} public static void selectAxis2D ( Vector3D_F64 normal , Vector3D_F64 axisX , Vector3D_F64 axisY ) { 
UtilVector3D_F64 . perpendicularCanonical ( normal , axisX ) ; 
axisX . normalize ( ) ; 
axisY . cross ( normal , axisX ) ; 
axisY . normalize ( ) ; 
} public static void point3Dto2D ( Point3D_F64 pointOnPlane , 
Vector3D_F64 axisX , Vector3D_F64 axisY , 
Point3D_F64 A , Point2D_F64 output ) { 
double x = A . x - pointOnPlane . x ; 
double y = A . y - pointOnPlane . y ; 
double z = A . z - pointOnPlane . z ; 
output . x = x * axisX . x + y * axisX . y + z * axisX . z ; 
output . y = x * axisY . x + y * axisY . y + z * axisY . z ; 
} public static void point2Dto3D ( Point3D_F64 origin , 
Point2D_F64 A , Point3D_F64 output ) { 
output . x = origin . x + axisX . x * A . x + axisY . y * A . y ; 
output . y = origin . y + axisX . y * A . x + axisY . y * A . y ; 
output . z = origin . z + axisX . z * A . x + axisY . y * A . y ; 
} public static Se3_F64 planeToWorld ( PlaneGeneral3D_F64 plane , Se3_F64 planeToWorld ) { 
if ( planeToWorld == null ) 
planeToWorld = new Se3_F64 ( ) ; 
Vector3D_F64 axisZ = new Vector3D_F64 ( plane . A , plane . B , plane . C ) ; 
axisZ . normalize ( ) ; 
Vector3D_F64 axisX = new Vector3D_F64 ( ) ; 
Vector3D_F64 axisY = new Vector3D_F64 ( ) ; 
UtilPlane3D_F64 . selectAxis2D ( axisZ , axisX , axisY ) ; 
return planeToWorld ( plane , axisX , axisY , axisZ , planeToWorld ) ; 
} public boolean isIdentical ( T t , double tol ) { 
if ( t . getDimension ( ) != getDimension ( ) ) 
int N = getDimension ( ) ; 
double diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; 
if ( diff > tol ) 
public T copy ( ) { 
T ret = createNewInstance ( ) ; 
ret . setIdx ( i , getIdx ( i ) ) ; 
} public double normSq ( ) { 
double total = 0 ; 
double a = getIdx ( i ) ; 
total += a * a ; 
} public static LineParametric3D_F64 convert ( LineSegment3D_F64 line , LineParametric3D_F64 output ) { 
output = new LineParametric3D_F64 ( ) ; 
output . p . set ( line . a ) ; 
output . slope . x = line . b . x - line . a . x ; 
output . slope . y = line . b . y - line . a . y ; 
output . slope . z = line . b . z - line . a . z ; 
} public static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { 
double dx = pointOnLine . x - line . p . x ; 
double dy = pointOnLine . y - line . p . y ; 
double dz = pointOnLine . z - line . p . z ; 
double adx = Math . abs ( dx ) ; 
double ady = Math . abs ( dy ) ; 
double adz = Math . abs ( dz ) ; 
double t ; 
if ( adx > ady ) { 
if ( adx > adz ) { 
t = dx / line . slope . x ; 
t = dz / line . slope . z ; 
} else if ( ady > adz ) { 
t = dy / line . slope . y ; 
} public boolean hasUncountable ( ) { 
return UtilEjml . isUncountable ( A ) || UtilEjml . isUncountable ( C ) 
|| UtilEjml . isUncountable ( D ) || UtilEjml . isUncountable ( E ) || 
UtilEjml . isUncountable ( F ) ; 
} public boolean isEquivalent ( ParabolaGeneral_F64 parabola , double tol ) { 
double scale = relativeScale ( parabola ) ; 
if ( Math . abs ( A * scale - parabola . A ) > tol ) 
if ( Math . abs ( C * scale - parabola . C ) > tol ) 
if ( Math . abs ( D * scale - parabola . D ) > tol ) 
if ( Math . abs ( E * scale - parabola . E ) > tol ) 
if ( Math . abs ( F * scale - parabola . F ) > tol ) 
} public static LinePolar2D_F32 polar ( List < Point2D_I32 > points , int start , int length , LinePolar2D_F32 ret ) { 
ret = new LinePolar2D_F32 ( ) ; 
int sumX = 0 ; 
int sumY = 0 ; 
final int N = length ; 
Point2D_I32 p = points . get ( start + i ) ; 
sumX += p . x ; 
sumY += p . y ; 
float meanX = sumX / ( float ) N ; 
float meanY = sumY / ( float ) N ; 
float top = 0 ; 
float bottom = 0 ; 
float dx = meanX - p . x ; 
float dy = meanY - p . y ; 
top += dx * dy ; 
bottom += dy * dy - dx * dx ; 
ret . angle = ( float ) Math . atan2 ( - 2.0f * top , bottom ) / 2.0f ; 
ret . distance = ( float ) ( meanX * Math . cos ( ret . angle ) + meanY * Math . sin ( ret . angle ) ) ; 
} public double area ( ) { 
return ( p1 . x - p0 . x ) * ( p1 . y - p0 . y ) * ( p1 . z - p0 . z ) ; 
} public Point3D_F64 center ( Point3D_F64 storage ) { 
storage = new Point3D_F64 ( ) ; 
storage . x = ( p0 . x + p1 . x ) / 2.0 ; 
storage . y = ( p0 . y + p1 . y ) / 2.0 ; 
storage . z = ( p0 . z + p1 . z ) / 2.0 ; 
} public static double acuteAngle ( LineSegment2D_I32 line0 , LineSegment2D_I32 line1 ) { 
int dx0 = line0 . b . x - line0 . a . x ; 
int dy0 = line0 . b . y - line0 . a . y ; 
int dx1 = line1 . b . x - line1 . a . x ; 
int dy1 = line1 . b . y - line1 . a . y ; 
double bottom = Math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; 
return Math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; 
} public static Se2_F64 fitPoints2D ( List < Point2D_F64 > from , List < Point2D_F64 > to ) { 
MotionTransformPoint < Se2_F64 , Point2D_F64 > alg = fitPoints2D ( ) ; 
alg . process ( from , to ) ; 
return alg . getTransformSrcToDst ( ) ; 
} public static Se3_F64 fitPoints3D ( List < Point3D_F64 > from , List < Point3D_F64 > to ) { 
MotionTransformPoint < Se3_F64 , Point3D_F64 > alg = fitPoints3D ( ) ; 
} public static boolean isInfiniteH ( Point4D_F64 p , double tol ) { 
double n = Math . sqrt ( p . x * p . x + p . y * p . y + p . z * p . z ) ; 
return Math . abs ( p . w ) <= n * tol ; 
} public static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { 
List < Point4D_F64 > ret = new ArrayList < > ( ) ; 
Point4D_F64 p = new Point4D_F64 ( ) ; 
p . x = center . x + rand . nextGaussian ( ) * stdev ; 
p . y = center . y + rand . nextGaussian ( ) * stdev ; 
p . z = center . z + rand . nextGaussian ( ) * stdev ; 
p . w = w ; 
ret . add ( p ) ; 
} public static Point3D_F64 h_to_e ( Point4D_F64 p ) { 
Point3D_F64 out = new Point3D_F64 ( ) ; 
h_to_e ( p , out ) ; 
} public static Vector2D_F64 transform ( Affine2D_F64 se , Vector2D_F64 orig , Vector2D_F64 result ) { 
result = new Vector2D_F64 ( ) ; 
result . x = se . a11 * x + se . a12 * y ; 
result . y = se . a21 * x + se . a22 * y ; 
} public static Point2D_F64 transform ( Affine2D_F64 se , Point2D_F64 orig , Point2D_F64 result ) { 
result . x = se . tx + se . a11 * x + se . a12 * y ; 
result . y = se . ty + se . a21 * x + se . a22 * y ; 
} public static double acute ( Vector2D_F64 a , Vector2D_F64 b ) { 
double dot = a . dot ( b ) ; 
double value = dot / ( a . norm ( ) * b . norm ( ) ) ; 
value = 1.0 ; 
else if ( value < - 1.0 ) 
value = - 1.0 ; 
} public static Vector2D_F64 minus ( Point2D_F64 a , Point2D_F64 b , Vector2D_F64 output ) { 
output = new Vector2D_F64 ( ) ; 
output . x = a . x - b . x ; 
output . y = a . y - b . y ; 
} public static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { 
double dx0 = xb - xa ; 
double dy0 = yb - ya ; 
double dx1 = xb + xa ; 
double dy1 = yb + ya ; 
double error0 = dx0 * dx0 + dy0 * dy0 ; 
double error1 = dx1 * dx1 + dy1 * dy1 ; 
if ( error0 < error1 ) { 
return error0 <= tol * tol ; 
return error1 <= tol * tol ; 
} public void set ( RectangleLength2D_I32 r ) { 
this . x0 = r . x0 ; 
this . y0 = r . y0 ; 
this . width = r . width ; 
this . height = r . height ; 
} public void minus ( Point3D_F64 a , Point3D_F64 b ) { 
x = a . x - b . x ; 
y = a . y - b . y ; 
z = a . z - b . z ; 
} public double dot ( Vector3D_F64 a ) { 
return x * a . x + y * a . y + z * a . z ; 
} public static EllipseRotated_F64 convert ( EllipseQuadratic_F64 input , EllipseRotated_F64 output ) { 
output = new EllipseRotated_F64 ( ) ; 
double a11 = input . A ; 
double a12 = input . B ; 
double a22 = input . C ; 
double b1 = 2 * input . D ; 
double b2 = 2 * input . E ; 
double c = input . F ; 
output . center . x = ( a22 * b1 - a12 * b2 ) / ( 2 * ( a12 * a12 - a11 * a22 ) ) ; 
output . center . y = ( a11 * b2 - a12 * b1 ) / ( 2 * ( a12 * a12 - a11 * a22 ) ) ; 
double k1 = output . center . x ; 
double k2 = output . center . y ; 
double mu = 1.0 / ( a11 * k1 * k1 + 2 * a12 * k1 * k2 + a22 * k2 * k2 - c ) ; 
double m11 = mu * a11 ; 
double m12 = mu * a12 ; 
double m22 = mu * a22 ; 
double inner = Math . sqrt ( ( m11 - m22 ) * ( m11 - m22 ) + 4 * m12 * m12 ) ; 
double l1 = ( ( m11 + m22 ) + inner ) / 2.0 ; 
double l2 = ( ( m11 + m22 ) - inner ) / 2.0 ; 
output . b = 1 / ( double ) Math . sqrt ( l1 ) ; 
output . a = 1 / ( double ) Math . sqrt ( l2 ) ; 
if ( m11 >= m22 ) { 
dx = l1 - m22 ; 
dy = m12 ; 
dx = m12 ; 
dy = l1 - m11 ; 
output . phi = Math . atan2 ( - dx , dy ) ; 
if ( output . phi < - GrlConstants . PId2 ) { 
output . phi += ( double ) Math . PI ; 
} else if ( output . phi > GrlConstants . PId2 ) { 
output . phi -= ( double ) Math . PI ; 
} public static EllipseQuadratic_F64 convert ( EllipseRotated_F64 input , EllipseQuadratic_F64 output ) { 
output = new EllipseQuadratic_F64 ( ) ; 
double x0 = input . center . x ; 
double y0 = input . center . y ; 
double a = input . a ; 
double b = input . b ; 
double phi = input . phi ; 
double cphi = Math . cos ( phi ) ; 
double sphi = Math . sin ( phi ) ; 
double cphi2 = cphi * cphi ; 
double sphi2 = sphi * sphi ; 
double a2 = a * a ; 
double b2 = b * b ; 
double x02 = x0 * x0 ; 
double y02 = y0 * y0 ; 
output . A = cphi2 / a2 + sphi2 / b2 ; 
output . B = sphi * cphi / a2 - sphi * cphi / b2 ; 
output . C = sphi2 / a2 + cphi2 / b2 ; 
output . D = - x0 * cphi2 / a2 - y0 * sphi * cphi / a2 - x0 * sphi2 / b2 + y0 * sphi * cphi / b2 ; 
output . E = - x0 * sphi * cphi / a2 - y0 * sphi2 / a2 + x0 * sphi * cphi / b2 - y0 * cphi2 / b2 ; 
output . F = x02 * cphi2 / a2 + 2 * x0 * y0 * sphi * cphi / a2 + y02 * sphi2 / a2 + 
x02 * sphi2 / b2 - 2 * x0 * y0 * sphi * cphi / b2 + y02 * cphi2 / b2 - 1 ; 
} public static double evaluate ( double x , double y , EllipseQuadratic_F64 ellipse ) { 
return ellipse . A * x * x + 2 * ellipse . B * x * y + ellipse . C * y * y + 2 * ellipse . D * x + 2 * ellipse . E * y + ellipse . F ; 
} public static double evaluate ( double x , double y , EllipseRotated_F64 ellipse ) { 
x -= ellipse . center . x ; 
y -= ellipse . center . y ; 
double left = ( x * cphi + y * sphi ) ; 
double right = ( - x * sphi + y * cphi ) ; 
double ll = left / ellipse . a ; 
double rr = right / ellipse . b ; 
return ll * ll + rr * rr ; 
} public static Point2D_F64 computePoint ( double t , EllipseRotated_F64 ellipse , Point2D_F64 output ) { 
double ct = Math . cos ( t ) ; 
double st = Math . sin ( t ) ; 
double x = ellipse . a * ct ; 
double y = ellipse . b * st ; 
output . x = ellipse . center . x + x * cphi - y * sphi ; 
output . y = ellipse . center . y + x * sphi + y * cphi ; 
} public static double computeAngle ( Point2D_F64 p , EllipseRotated_F64 ellipse ) { 
double ce = Math . cos ( ellipse . phi ) ; 
double se = Math . sin ( ellipse . phi ) ; 
double xc = p . x - ellipse . center . x ; 
double yc = p . y - ellipse . center . y ; 
double x = ce * xc + se * yc ; 
double y = - se * xc + ce * yc ; 
return Math . atan2 ( y / ellipse . b , x / ellipse . a ) ; 
} public static Vector2D_F64 computeTangent ( double t , 
EllipseRotated_F64 ellipse , 
Vector2D_F64 output ) { 
double x = ellipse . a * ct * ellipse . b * ellipse . b ; 
double y = ellipse . b * st * ellipse . a * ellipse . a ; 
double rx = x * cphi - y * sphi ; 
double ry = x * sphi + y * cphi ; 
double r = Math . sqrt ( rx * rx + ry * ry ) ; 
output . x = - ry / r ; 
output . y = rx / r ; 
} public static boolean tangentLines ( Point2D_F64 pt , EllipseRotated_F64 ellipse , 
Point2D_F64 tangentA , Point2D_F64 tangentB ) 
double tmpx = pt . x - ellipse . center . x ; 
double tmpy = pt . y - ellipse . center . y ; 
double xt = tmpx * cphi + tmpy * sphi ; 
double yt = - tmpx * sphi + tmpy * cphi ; 
double aa0 = yt * yt / b2 + xt * xt / a2 ; 
double bb0 = - 2.0 * xt ; 
double cc0 = a2 * ( 1.0 - yt * yt / b2 ) ; 
double descriminant0 = bb0 * bb0 - 4.0 * aa0 * cc0 ; 
double aa1 = xt * xt / a2 + yt * yt / b2 ; 
double bb1 = - 2.0 * yt ; 
double cc1 = b2 * ( 1.0 - xt * xt / a2 ) ; 
double descriminant1 = bb1 * bb1 - 4.0 * aa1 * cc1 ; 
double x0 , y0 , x1 , y1 ; 
if ( descriminant0 < 0 && descriminant1 < 0 ) { 
} else if ( descriminant0 > descriminant1 ) { 
if ( yt == 0 ) 
double right = Math . sqrt ( descriminant0 ) ; 
x0 = ( - bb0 + right ) / ( 2.0 * aa0 ) ; 
x1 = ( - bb0 - right ) / ( 2.0 * aa0 ) ; 
y0 = b2 / yt - xt * x0 * b2 / ( yt * a2 ) ; 
y1 = b2 / yt - xt * x1 * b2 / ( yt * a2 ) ; 
if ( xt == 0 ) 
double right = Math . sqrt ( descriminant1 ) ; 
y0 = ( - bb1 + right ) / ( 2.0 * aa1 ) ; 
y1 = ( - bb1 - right ) / ( 2.0 * aa1 ) ; 
x0 = a2 / xt - yt * y0 * a2 / ( xt * b2 ) ; 
x1 = a2 / xt - yt * y1 * a2 / ( xt * b2 ) ; 
tangentA . x = x0 * cphi - y0 * sphi + ellipse . center . x ; 
tangentA . y = x0 * sphi + y0 * cphi + ellipse . center . y ; 
tangentB . x = x1 * cphi - y1 * sphi + ellipse . center . x ; 
tangentB . y = x1 * sphi + y1 * cphi + ellipse . center . y ; 
} public static boolean tangentLines ( EllipseRotated_F64 ellipseA , EllipseRotated_F64 ellipseB , 
Point2D_F64 tangentA0 , Point2D_F64 tangentA1 , 
Point2D_F64 tangentA2 , Point2D_F64 tangentA3 , 
Point2D_F64 tangentB0 , Point2D_F64 tangentB1 , 
Point2D_F64 tangentB2 , Point2D_F64 tangentB3 ) 
TangentLinesTwoEllipses_F64 alg = new TangentLinesTwoEllipses_F64 ( GrlConstants . TEST_F64 , 10 ) ; 
return alg . process ( ellipseA , ellipseB , 
tangentA0 , tangentA1 , tangentA2 , tangentA3 , 
tangentB0 , tangentB1 , tangentB2 , tangentB3 ) ; 
} public boolean process ( EllipseRotated_F64 ellipseA , EllipseRotated_F64 ellipseB , 
converged = false ; 
if ( ! initialize ( ellipseA , ellipseB , 
tangentB0 , tangentB1 , tangentB2 , tangentB3 ) ) 
int iteration = 0 ; 
for ( ; iteration < maxIterations ; iteration ++ ) { 
boolean allGood = false ; 
sumDifference = 0 ; 
if ( ! selectTangent ( tangentA0 , tangentB0 , ellipseB , tangentB0 , false ) ) 
if ( ! selectTangent ( tangentA1 , tangentB1 , ellipseB , tangentB1 , true ) ) 
if ( ! selectTangent ( tangentA2 , tangentB2 , ellipseB , tangentB2 , true ) ) 
if ( ! selectTangent ( tangentA3 , tangentB3 , ellipseB , tangentB3 , false ) ) 
if ( Math . sqrt ( sumDifference ) / 4.0 <= convergenceTol ) { 
allGood = true ; 
if ( ! selectTangent ( tangentB0 , tangentA0 , ellipseA , tangentA0 , false ) ) 
if ( ! selectTangent ( tangentB1 , tangentA1 , ellipseA , tangentA1 , true ) ) 
if ( ! selectTangent ( tangentB2 , tangentA2 , ellipseA , tangentA2 , true ) ) 
if ( ! selectTangent ( tangentB3 , tangentA3 , ellipseA , tangentA3 , false ) ) 
if ( allGood && Math . sqrt ( sumDifference ) / 4.0 <= convergenceTol ) { 
converged = iteration < maxIterations ; 
} boolean initialize ( EllipseRotated_F64 ellipseA , EllipseRotated_F64 ellipseB , 
Point2D_F64 tangentB2 , Point2D_F64 tangentB3 ) { 
centerLine . set ( ellipseA . center , ellipseB . center ) ; 
UtilLine2D_F64 . convert ( centerLine , lineGeneral ) ; 
Intersection2D_F64 . intersection ( lineGeneral , ellipseA , temp0 , temp1 , - 1 ) ; 
if ( temp0 . distance2 ( ellipseB . center ) < temp1 . distance2 ( ellipseB . center ) ) { 
tangentA0 . set ( temp0 ) ; 
tangentA0 . set ( temp1 ) ; 
if ( ! tangentLines ( tangentA0 , ellipseB , tangentB0 , tangentB1 ) ) 
if ( ! selectTangent ( tangentB0 , tangentA0 , ellipseA , tangentA1 , true ) ) 
if ( ! selectTangent ( tangentB1 , tangentA0 , ellipseA , tangentA2 , true ) ) 
if ( ! selectTangent ( tangentB1 , tangentA0 , ellipseA , tangentA3 , false ) ) 
} boolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , 
EllipseRotated_F64 ellipse , Point2D_F64 tangent , 
boolean cross ) 
if ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) 
tempLine . a = a ; 
tempLine . b = temp0 ; 
boolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; 
tempLine . b = temp1 ; 
boolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; 
if ( crossed0 == crossed1 ) 
if ( cross == crossed0 ) { 
sumDifference += previousTangent . distance2 ( temp0 ) ; 
tangent . set ( temp0 ) ; 
sumDifference += previousTangent . distance2 ( temp1 ) ; 
tangent . set ( temp1 ) ; 
if ( x1 < x0 ) { 
int tmp = x1 ; 
x1 = x0 ; 
x0 = tmp ; 
if ( y1 < y0 ) { 
int tmp = y1 ; 
y1 = y0 ; 
y0 = tmp ; 
} public int distance2 ( Point2D_I32 a ) { 
int dx = x - a . x ; 
int dy = y - a . y ; 
} public static void bestFit ( DMatrixRMaj A ) { 
if ( ! svd . decompose ( A ) ) 
CommonOps_DDRM . multTransB ( svd . getU ( null , false ) , svd . getV ( null , false ) , A ) ; 
double det = CommonOps_DDRM . det ( A ) ; 
CommonOps_DDRM . scale ( - 1 , A ) ; 
} public Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { 
if ( corner == null ) 
corner = new Point3D_F64 ( ) ; 
corner . set ( p ) ; 
if ( ( index & 0x01 ) != 0 ) { 
corner . x += lengthX ; 
if ( ( index & 0x02 ) != 0 ) { 
corner . y += lengthY ; 
if ( ( index & 0x04 ) != 0 ) { 
corner . z += lengthZ ; 
return corner ; 
} public static double distance ( LineParametric3D_F64 l0 , 
LineParametric3D_F64 l1 ) { 
double x = l0 . p . x - l1 . p . x ; 
double y = l0 . p . y - l1 . p . y ; 
double z = l0 . p . z - l1 . p . z ; 
double dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; 
double t0 ; 
t0 = 0 ; 
t0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; 
double dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; 
double dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; 
double dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; 
double distanceSq = dx * dx + dy * dy + dz * dz ; 
if ( distanceSq < 0 ) 
return Math . sqrt ( distanceSq ) ; 
} public static double distance ( LineParametric3D_F64 l , 
Point3D_F64 p ) { 
double x = l . p . x - p . x ; 
double y = l . p . y - p . y ; 
double z = l . p . z - p . z ; 
double cc = x * x + y * y + z * z ; 
double b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; 
double distanceSq = cc - b * b ; 
if ( distanceSq < 0 ) { 
} public static double distance ( LineSegment3D_F64 l , 
double dx = p . x - l . a . x ; 
double dy = p . y - l . a . y ; 
double dz = p . z - l . a . z ; 
double cc = dx * dx + dy * dy + dz * dz ; 
double slope_x = l . b . x - l . a . x ; 
double slope_y = l . b . y - l . a . y ; 
double slope_z = l . b . z - l . a . z ; 
if ( d <= 0 ) 
return p . distance ( l . a ) ; 
else if ( d >= n ) 
return p . distance ( l . b ) ; 
double distanceSq = cc - d * d ; 
} public static double distance ( PlaneGeneral3D_F64 plane , Point3D_F64 point ) { 
return top / Math . sqrt ( plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ) ; 
} public static double distance ( Sphere3D_F64 sphere , Point3D_F64 point ) { 
double r = point . distance ( sphere . center ) ; 
return r - sphere . radius ; 
} public static double distance ( Cylinder3D_F64 cylinder , Point3D_F64 point ) { 
double r = Distance3D_F64 . distance ( cylinder . line , point ) ; 
return r - cylinder . radius ; 
} public static double distance ( Triangle3D_F64 triangle , Point3D_F64 point ) { 
alg . setTriangle ( triangle . v0 , triangle . v1 , triangle . v2 ) ; 
Point3D_F64 cp = new Point3D_F64 ( ) ; 
alg . closestPoint ( point , cp ) ; 
double d = point . distance ( cp ) ; 
return alg . sign ( point ) * d ; 
} public void setPointOnLine ( double t , Point3D_F64 where ) { 
where . x = p . x + t * slope . x ; 
where . y = p . y + t * slope . y ; 
where . z = p . z + t * slope . z ; 
} public Point3D_F64 getPointOnLine ( double t ) { 
return new Point3D_F64 ( slope . x * t + p . x , slope . y * t + p . y , slope . z * t + p . z ) ; 
} public static double distance ( LineParametric2D_F64 line , Point2D_F64 p ) { 
return Math . sqrt ( distanceSq ( line , p ) ) ; 
} public static double distance ( LineParametric2D_F64 line , double x , double y ) { 
return Math . sqrt ( distanceSq ( line , x , y ) ) ; 
} public static double distanceSq ( LineParametric2D_F64 line , Point2D_F64 p ) { 
double scale = Math . max ( Math . abs ( line . slope . x ) , Math . abs ( line . slope . y ) ) ; 
double t = ClosestPoint2D_F64 . closestPointT ( line , p , scale ) ; 
double a = ( line . slope . x / scale ) * t + line . p . x ; 
double b = ( line . slope . y / scale ) * t + line . p . y ; 
double dx = p . x - a ; 
double dy = p . y - b ; 
} public static double distance ( LineSegment2D_F64 line , Point2D_F64 p ) { 
} public static double distance ( LineSegment2D_F64 line , double x , double y ) { 
} public static double distanceSq ( LineSegment2D_F64 line , Point2D_F64 p ) { 
double a = line . b . x - line . a . x ; 
double b = line . b . y - line . a . y ; 
return UtilPoint2D_F64 . distanceSq ( line . a . x , line . a . y , p . x , p . y ) ; 
return UtilPoint2D_F64 . distanceSq ( line . b . x , line . b . y , p . x , p . y ) ; 
return UtilPoint2D_F64 . distanceSq ( line . a . x + t * a , line . a . y + t * b , p . x , p . y ) ; 
} public static double distance ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { 
return Math . sqrt ( distanceSq ( segmentA , segmentB ) ) ; 
} public static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { 
double slopeAX = segmentA . slopeX ( ) ; 
double slopeAY = segmentA . slopeY ( ) ; 
double slopeBX = segmentB . slopeX ( ) ; 
double slopeBY = segmentB . slopeY ( ) ; 
double ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; 
double bottom = slopeBY * slopeAX - slopeAY * slopeBX ; 
if ( bottom != 0 ) { 
ta /= bottom ; 
if ( ta >= 0 && ta <= 1.0 ) { 
double tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; 
tb /= slopeAY * slopeBX - slopeBY * slopeAX ; 
if ( tb >= 0 && tb <= 1.0 ) 
double closest = Double . MAX_VALUE ; 
closest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; 
closest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; 
closest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; 
closest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; 
return closest ; 
} public static double distance ( Quadrilateral_F64 quad , Point2D_F64 p ) { 
return Math . sqrt ( distanceSq ( quad , p ) ) ; 
} public static double distanceSq ( Quadrilateral_F64 quad , Point2D_F64 p ) { 
LineSegment2D_F64 seg = LineSegment2D_F64 . wrap ( quad . a , quad . b ) ; 
double a = distanceSq ( seg , p ) ; 
seg . a = quad . b ; seg . b = quad . c ; 
a = Math . min ( a , distanceSq ( seg , p ) ) ; 
seg . a = quad . c ; seg . b = quad . d ; 
seg . a = quad . d ; seg . b = quad . a ; 
return Math . min ( a , distanceSq ( seg , p ) ) ; 
} public static double distance ( Polygon2D_F64 poly , Point2D_F64 p ) { 
return Math . sqrt ( distanceSq ( poly , p , null ) ) ; 
} public static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { 
storage = LineSegment2D_F64 . wrap ( null , null ) ; 
double minimum = Double . MAX_VALUE ; 
for ( int i = 0 ; i < poly . size ( ) ; i ++ ) { 
int j = ( i + 1 ) % poly . size ( ) ; 
storage . a = poly . vertexes . data [ i ] ; 
storage . b = poly . vertexes . data [ j ] ; 
double d = distanceSq ( storage , p ) ; 
if ( d < minimum ) 
minimum = d ; 
return minimum ; 
} public static double distance ( LineGeneral2D_F64 line , Point2D_F64 p ) { 
return Math . abs ( line . A * p . x + line . B * p . y + line . C ) / Math . sqrt ( line . A * line . A + line . B * line . B ) ; 
} public static double distanceNorm ( LineGeneral2D_F64 line , Point2D_F64 p ) { 
return Math . abs ( line . A * p . x + line . B * p . y + line . C ) ; 
} public static double distanceOrigin ( LineParametric2D_F64 line ) { 
double top = line . slope . y * line . p . x - line . slope . x * line . p . y ; 
return Math . abs ( top ) / line . slope . norm ( ) ; 
} public static double distance ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { 
return Math . sqrt ( distance2 ( ellipse , p ) ) ; 
} public static double distance2 ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { 
double r = Math . sqrt ( xc * xc + yc * yc ) ; 
double x = cphi * xc + sphi * yc ; 
double y = - sphi * xc + cphi * yc ; 
double ct = x / r ; 
double st = y / r ; 
x = ellipse . center . x + ellipse . a * ct * cphi - ellipse . b * st * sphi ; 
y = ellipse . center . y + ellipse . a * ct * sphi + ellipse . b * st * cphi ; 
return p . distance2 ( x , y ) ; 
} public void addTransform ( boolean forward , T tran ) { 
path . add ( new Node < T > ( tran , forward ) ) ; 
} public static Point2D_F64 closestPoint ( LineGeneral2D_F64 line , 
Point2D_F64 p , 
Point2D_F64 output ) { 
double AA = line . A * line . A ; 
double AB = line . A * line . B ; 
double BB = line . B * line . B ; 
output . y = AA * p . y - AB * p . x - line . B * line . C ; 
output . y /= AA + BB ; 
output . x = BB * p . x - AB * p . y - line . A * line . C ; 
output . x /= AA + BB ; 
} public static Point2D_F64 closestPoint ( LineParametric2D_F64 line , 
double t = closestPointT ( line , p ) ; 
output . x = line . p . x + line . slope . x * t ; 
output . y = line . p . y + line . slope . y * t ; 
} public static double closestPointT ( LineParametric2D_F64 line , 
Point2D_F64 p ) { 
double t = line . slope . x * ( p . x - line . p . x ) + line . slope . y * ( p . y - line . p . y ) ; 
t /= line . slope . x * line . slope . x + line . slope . y * line . slope . y ; 
} public static double closestPointT ( LineParametric2D_F64 line , double x , double y , double scale ) { 
double sx = line . slope . x / scale ; 
double sy = line . slope . y / scale ; 
double t = sx * ( x - line . p . x ) + sy * ( y - line . p . y ) ; 
t /= sx * sx + sy * sy ; 
} public static Point2D_F64 closestPoint ( LineSegment2D_F64 line , 
double slopeX = line . b . x - line . a . x ; 
double slopeY = line . b . y - line . a . y ; 
double t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; 
t /= slopeX * slopeX + slopeY * slopeY ; 
if ( t < 0 ) 
t = 0 ; 
else if ( t > 1 ) 
t = 1 ; 
output . x = line . a . x + slopeX * t ; 
output . y = line . a . y + slopeY * t ; 
} public static Point2D_F64 closestPoint ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { 
ClosestPointEllipseAngle_F64 alg = new ClosestPointEllipseAngle_F64 ( GrlConstants . TEST_F64 , 30 ) ; 
alg . setEllipse ( ellipse ) ; 
alg . process ( p ) ; 
return alg . getClosest ( ) ; 
} public boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { 
int N = length / 2 ; 
int numCoefs = output . size ( ) ; 
A . reshape ( N , numCoefs ) ; 
b . reshape ( N , 1 ) ; 
x . reshape ( numCoefs , 1 ) ; 
int end = offset + length ; 
for ( int i = offset , idxA = 0 ; i < end ; i += 2 ) { 
double x = data [ i ] ; 
double y = data [ i + 1 ] ; 
double pow = 1.0 ; 
for ( int j = 0 ; j < numCoefs ; j ++ ) { 
A . data [ idxA ++ ] = pow ; 
pow *= x ; 
b . data [ i / 2 ] = y ; 
if ( ! solver . setA ( A ) ) 
solver . solve ( b , x ) ; 
for ( int i = 0 ; i < numCoefs ; i ++ ) { 
output . set ( i , x . data [ i ] ) ; 
public boolean process ( List < Point2D_F64 > points , ConicGeneral_F64 output ) { 
if ( N < 3 ) 
CommonOps_DDF6 . fill ( ATA , 0 ) ; 
double x = p . x ; 
double y = p . y ; 
double xx = x * x ; 
double xxx = xx * x ; 
double yy = y * y ; 
double yyy = yy * y ; 
ATA . a11 += xx * xx ; 
ATA . a12 += xxx * y ; 
ATA . a13 += xx * yy ; 
ATA . a14 += xxx ; 
ATA . a15 += xx * y ; 
ATA . a16 += xx ; 
ATA . a22 += xx * yy ; 
ATA . a23 += x * yyy ; 
ATA . a25 += x * yy ; 
ATA . a26 += x * y ; 
ATA . a33 += yyy * y ; 
ATA . a35 += yyy ; 
ATA . a36 += yy ; 
ATA . a45 += x * y ; 
ATA . a46 += x ; 
ATA . a56 += y ; 
ATA . a21 = ATA . a12 ; 
ATA . a24 = ATA . a15 ; 
ATA . a31 = ATA . a13 ; 
ATA . a32 = ATA . a23 ; 
ATA . a34 = ATA . a25 ; 
ATA . a41 = ATA . a14 ; 
ATA . a42 = ATA . a24 ; 
ATA . a43 = ATA . a34 ; 
ATA . a44 = ATA . a16 ; 
ATA . a51 = ATA . a15 ; 
ATA . a52 = ATA . a25 ; 
ATA . a53 = ATA . a35 ; 
ATA . a54 = ATA . a45 ; 
ATA . a55 = ATA . a36 ; 
ATA . a61 = ATA . a16 ; 
ATA . a62 = ATA . a26 ; 
ATA . a63 = ATA . a36 ; 
ATA . a64 = ATA . a56 ; 
ATA . a65 = ATA . a56 ; 
ATA . a66 = N ; 
ConvertDMatrixStruct . convert ( ATA , tmp ) ; 
if ( ! solver . process ( tmp , 1 , nullspace ) ) 
output . A = nullspace . data [ 0 ] ; 
output . B = nullspace . data [ 1 ] ; 
output . C = nullspace . data [ 2 ] ; 
output . D = nullspace . data [ 3 ] ; 
output . E = nullspace . data [ 4 ] ; 
output . F = nullspace . data [ 5 ] ; 
} public static Vector3D_F64 createRandom ( double min , double max , Random rand ) { 
double range = max - min ; 
Vector3D_F64 a = new Vector3D_F64 ( ) ; 
a . x = range * rand . nextDouble ( ) + min ; 
a . y = range * rand . nextDouble ( ) + min ; 
a . z = range * rand . nextDouble ( ) + min ; 
} public static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { 
output = new Vector3D_F64 ( ) ; 
double scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; 
if ( scale == 0 ) { 
output . set ( 0 , 0 , 0 ) ; 
double x = A . x / scale ; 
double y = A . y / scale ; 
double z = A . z / scale ; 
if ( Math . abs ( x ) > Math . abs ( y ) ) { 
output . set ( z , 0 , - x ) ; 
output . set ( 0 , z , - y ) ; 
} public static boolean isIdentical ( Vector3D_F64 a , Vector3D_F64 b , double tol ) { 
if ( Math . abs ( a . x - b . x ) > tol ) 
if ( Math . abs ( a . y - b . y ) > tol ) 
return Math . abs ( a . z - b . z ) <= tol ; 
} public static void normalize ( Vector3D_F64 v ) { 
double a = v . norm ( ) ; 
v . x /= a ; 
v . y /= a ; 
v . z /= a ; 
} public static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { 
if ( R == null ) { 
R = new DMatrixRMaj ( 3 , v . length ) ; 
for ( int i = 0 ; i < v . length ; i ++ ) { 
R . set ( 0 , i , v [ i ] . x ) ; 
R . set ( 1 , i , v [ i ] . y ) ; 
R . set ( 2 , i , v [ i ] . z ) ; 
} public static Vector3D_F64 convert ( DMatrixRMaj m ) { 
Vector3D_F64 v = new Vector3D_F64 ( ) ; 
v . x = ( double ) m . data [ 0 ] ; 
v . y = ( double ) m . data [ 1 ] ; 
v . z = ( double ) m . data [ 2 ] ; 
} public static double acute ( GeoTuple3D_F64 a , GeoTuple3D_F64 b ) { 
double dot = a . x * b . x + a . y * b . y + a . z * b . z ; 
} public void plusIP ( GeoTuple3D_F64 a ) { 
x += a . x ; 
y += a . y ; 
z += a . z ; 
} public T plus ( GeoTuple3D_F64 a ) { 
ret . x = x + a . x ; 
ret . y = y + a . y ; 
ret . z = z + a . z ; 
} public T times ( double scalar ) { 
ret . x = x * scalar ; 
ret . y = y * scalar ; 
ret . z = z * scalar ; 
} public static boolean intersects ( Rectangle2D_I32 a , Rectangle2D_I32 b ) { 
return ( a . x0 < b . x1 && a . x1 > b . x0 && a . y0 < b . y1 && a . y1 > b . y0 ) ; 
} public static boolean intersection ( Rectangle2D_I32 a , Rectangle2D_I32 b , Rectangle2D_I32 result ) { 
result . x0 = Math . max ( a . x0 , b . x0 ) ; 
result . x1 = Math . min ( a . x1 , b . x1 ) ; 
result . y0 = Math . max ( a . y0 , b . y0 ) ; 
result . y1 = Math . min ( a . y1 , b . y1 ) ; 
} public static boolean containConvex ( Polygon2D_I32 polygon , Point2D_I32 pt ) 
Point2D_I32 a = polygon . vertexes . data [ i ] ; 
Point2D_I32 b = polygon . vertexes . data [ j ] ; 
} public static boolean containConcave ( Polygon2D_I32 polygon , Point2D_I32 pt ) 
Point2D_I32 b = polygon . vertexes . data [ i + 1 ] ; 
double x = b . y == a . y ? pt . x : ( pt . y - a . y ) * ( b . x - a . x ) / ( double ) ( b . y - a . y ) + a . x ; 
Point2D_I32 a = polygon . vertexes . data [ N - 1 ] ; 
Point2D_I32 b = polygon . vertexes . data [ 0 ] ; 
double x = b . y == a . y ? pt . x : ( pt . y - pt . y ) * ( b . x - a . x ) / ( double ) ( b . y - a . y ) + a . x ; 
} public static boolean contains ( RectangleLength2D_I32 a , int x , int y ) { 
if ( a . getX ( ) <= x && a . getX ( ) + a . getWidth ( ) > x ) { 
return a . getY ( ) <= y && a . getY ( ) + a . getHeight ( ) > y ; 
} public static boolean contains ( Rectangle2D_I32 a , int x , int y ) { 
return ( x >= a . x0 && y >= a . y0 && x < a . x1 && y < a . y1 ) ; 
} public T plus ( GeoTuple2D_F64 a ) { 
} public double distance ( double x , double y ) { 
double dx = x - this . x ; 
double dy = y - this . y ; 
return Math . sqrt ( dx * dx + dy * dy ) ; 
} public void setEllipse ( EllipseRotated_F64 ellipse ) { 
this . ellipse = ellipse ; 
ce = Math . cos ( ellipse . phi ) ; 
se = Math . sin ( ellipse . phi ) ; 
} public void process ( Point2D_F64 point ) { 
double xc = point . x - ellipse . center . x ; 
double yc = point . y - ellipse . center . y ; 
theta = Math . atan2 ( ellipse . a * y , ellipse . b * x ) ; 
double a2_m_b2 = ellipse . a * ellipse . a - ellipse . b * ellipse . b ; 
for ( ; i < maxIterations ; i ++ ) { 
double f = a2_m_b2 * c * s - x * ellipse . a * s + y * ellipse . b * c ; 
if ( Math . abs ( f ) < tol ) 
double d = a2_m_b2 * ( c * c - s * s ) - x * ellipse . a * c - y * ellipse . b * s ; 
theta = theta - f / d ; 
x = ellipse . a * ( double ) Math . cos ( theta ) ; 
y = ellipse . b * ( double ) Math . sin ( theta ) ; 
closest . x = ce * x - se * y + ellipse . center . x ; 
closest . y = se * x + ce * y + ellipse . center . y ; 
double n = Math . sqrt ( w * w + x * x + y * y + z * z ) ; 
w /= n ; 
x /= n ; 
y /= n ; 
z /= n ; 
A . reshape ( N , 6 ) ; 
for ( int i = 0 , index = 0 ; i < N ; i ++ ) { 
A . data [ index ++ ] = x * x ; 
A . data [ index ++ ] = x * y ; 
A . data [ index ++ ] = y * y ; 
A . data [ index ++ ] = x ; 
A . data [ index ++ ] = y ; 
A . data [ index ++ ] = 1 ; 
if ( ! solver . process ( A , 1 , nullspace ) ) 
} public static double triangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c ) { 
double inner = a . x * ( b . y - c . y ) + b . x * ( c . y - a . y ) + c . x * ( a . y - b . y ) ; 
return Math . abs ( inner / 2.0 ) ; 
} public static double quadrilateral ( Quadrilateral_F64 quad ) { 
double bx = quad . b . x - quad . a . x ; 
double by = quad . b . y - quad . a . y ; 
double cx = quad . c . x - quad . a . x ; 
double cy = quad . c . y - quad . a . y ; 
double dx = quad . d . x - quad . a . x ; 
double dy = quad . d . y - quad . a . y ; 
if ( ( bx * cy - by * cx >= 0 ) == ( cx * dy - cy * dx >= 0 ) ) { 
return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; 
return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; 
} public static double polygonSimple ( Polygon2D_F64 poly ) { 
Point2D_F64 v0 = poly . get ( 0 ) ; 
Point2D_F64 v1 = poly . get ( 1 ) ; 
for ( int i = 2 ; i < poly . size ( ) ; i ++ ) { 
Point2D_F64 v2 = poly . get ( i ) ; 
total += v1 . x * ( v2 . y - v0 . y ) ; 
v0 = v1 ; v1 = v2 ; 
Point2D_F64 v2 = poly . get ( 0 ) ; 
v2 = poly . get ( 1 ) ; 
return Math . abs ( total / 2.0 ) ; 
} public static Point2D_F64 mean ( List < Point2D_F64 > list , Point2D_F64 mean ) { 
if ( mean == null ) 
mean = new Point2D_F64 ( ) ; 
double x = 0 ; 
double y = 0 ; 
for ( Point2D_F64 p : list ) { 
x += p . getX ( ) ; 
y += p . getY ( ) ; 
x /= list . size ( ) ; 
y /= list . size ( ) ; 
mean . set ( x , y ) ; 
return mean ; 
} public static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { 
Point2D_F64 p = list [ offset + i ] ; 
x /= length ; 
y /= length ; 
} public static Point2D_F64 mean ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 mean ) { 
mean . x = ( a . x + b . x ) / 2.0 ; 
mean . y = ( a . y + b . y ) / 2.0 ; 
} public static RectangleLength2D_F64 bounding ( List < Point2D_F64 > points , RectangleLength2D_F64 bounding ) { 
if ( bounding == null ) 
bounding = new RectangleLength2D_F64 ( ) ; 
double minX = Double . MAX_VALUE , maxX = - Double . MAX_VALUE ; 
double minY = Double . MAX_VALUE , maxY = - Double . MAX_VALUE ; 
if ( p . x < minX ) 
minX = p . x ; 
if ( p . x > maxX ) 
maxX = p . x ; 
if ( p . y < minY ) 
minY = p . y ; 
if ( p . y > maxY ) 
maxY = p . y ; 
bounding . x0 = minX ; 
bounding . y0 = minY ; 
bounding . width = maxX - minX ; 
bounding . height = maxY - minY ; 
bounding . width += Math . max ( 0 , ( maxX - ( bounding . x0 + bounding . width ) ) * 10.0 ) ; 
bounding . height += Math . max ( 0 , ( maxY - ( bounding . y0 + bounding . height ) ) * 10.0 ) ; 
return bounding ; 
} public static Rectangle2D_F64 bounding ( List < Point2D_F64 > points , Rectangle2D_F64 bounding ) { 
bounding = new Rectangle2D_F64 ( ) ; 
bounding . set ( minX , minY , maxX , maxY ) ; 
} public static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { 
Point2D_F64 center = mean ( points , null ) ; 
double angles [ ] = new double [ points . size ( ) ] ; 
for ( int i = 0 ; i < angles . length ; i ++ ) { 
double dx = p . x - center . x ; 
double dy = p . y - center . y ; 
angles [ i ] = Math . atan2 ( dy , dx ) ; 
int order [ ] = new int [ points . size ( ) ] ; 
QuickSort_F64 sorter = new QuickSort_F64 ( ) ; 
sorter . sort ( angles , 0 , points . size ( ) , order ) ; 
List < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; 
out . add ( points . get ( order [ i ] ) ) ; 
} public static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { 
if ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { 
if ( covariance instanceof ReshapeMatrix ) { 
( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; 
mean ( points , mean ) ; 
double xx = 0 , xy = 0 , yy = 0 ; 
double dx = p . x - mean . x ; 
double dy = p . y - mean . y ; 
xx += dx * dx ; 
xy += dx * dy ; 
yy += dy * dy ; 
xx /= points . size ( ) ; 
xy /= points . size ( ) ; 
yy /= points . size ( ) ; 
covariance . unsafe_set ( 0 , 0 , xx ) ; 
covariance . unsafe_set ( 0 , 1 , xy ) ; 
covariance . unsafe_set ( 1 , 0 , xy ) ; 
covariance . unsafe_set ( 1 , 1 , yy ) ; 
} public static List < Point2D_F64 > randomNorm ( Point2D_F64 mean , DMatrix covariance , int count , 
Random rand , 
@ Nullable List < Point2D_F64 > output ) 
output = new ArrayList < > ( ) ; 
double cxx = covariance . get ( 0 , 0 ) ; 
double cxy = covariance . get ( 0 , 1 ) ; 
double cyy = covariance . get ( 1 , 1 ) ; 
double sxx = Math . sqrt ( cxx ) ; 
double sxy = cxy / cxx ; 
double syy = Math . sqrt ( cyy - sxy * sxy ) ; 
Point2D_F64 p = new Point2D_F64 ( ) ; 
double x = rand . nextGaussian ( ) ; 
double y = rand . nextGaussian ( ) ; 
p . x = mean . x + sxx * x + sxy * y ; 
p . y = mean . y + sxy * x + syy * y ; 
output . add ( p ) ; 
} public void set ( double a , double b , double c ) { 
this . A = a ; 
this . B = b ; 
this . C = c ; 
double d = Math . sqrt ( A * A + B * B ) ; 
A /= d ; 
B /= d ; 
C /= d ; 
} public void minus ( Point2D_F64 a , Point2D_F64 b ) { 
} public static void bounding ( List < Point2D_I32 > points , Rectangle2D_I32 rectangle ) { 
rectangle . x0 = Integer . MAX_VALUE ; 
rectangle . y0 = Integer . MAX_VALUE ; 
rectangle . x1 = Integer . MIN_VALUE ; 
rectangle . y1 = Integer . MIN_VALUE ; 
Point2D_I32 p = points . get ( i ) ; 
if ( p . x < rectangle . x0 ) 
rectangle . x0 = p . x ; 
if ( p . x > rectangle . x1 ) 
rectangle . x1 = p . x ; 
if ( p . y < rectangle . y0 ) 
rectangle . y0 = p . y ; 
if ( p . y > rectangle . y1 ) 
rectangle . y1 = p . y ; 
rectangle . x1 ++ ; 
rectangle . y1 ++ ; 
} public static void bounding ( Polygon2D_I32 quad , Rectangle2D_I32 rectangle ) { 
UtilPolygons2D_I32 . bounding ( quad . vertexes . toList ( ) , rectangle ) ; 
} public static boolean isCCW ( List < Point2D_I32 > polygon ) { 
if ( isPositiveZ ( polygon . get ( i ) , polygon . get ( j ) , polygon . get ( k ) ) ) { 
} public static void flip ( Polygon2D_I32 a ) { 
Point2D_I32 tmp = a . vertexes . data [ i ] ; 
} public static boolean isConvex ( Polygon2D_I32 poly ) { 
final int N = poly . size ( ) ; 
int numPositive = 0 ; 
Point2D_I32 a = poly . vertexes . data [ i ] ; 
Point2D_I32 b = poly . vertexes . data [ j ] ; 
Point2D_I32 c = poly . vertexes . data [ k ] ; 
int dx0 = a . x - b . x ; 
int dy0 = a . y - b . y ; 
int dx1 = c . x - b . x ; 
int dy1 = c . y - b . y ; 
int z = dx0 * dy1 - dy0 * dx1 ; 
numPositive ++ ; 
return ( numPositive == 0 || numPositive == N ) ; 
} public static boolean isPositiveZ ( Point2D_I32 a , Point2D_I32 b , Point2D_I32 c ) { 
return z > 0 ; 
} public static boolean isIdentical ( Polygon2D_I32 a , Polygon2D_I32 b ) { 
if ( ! a . get ( i ) . equals ( b . get ( i ) ) ) 
} public static boolean isEquivalent ( Polygon2D_I32 a , Polygon2D_I32 b ) { 
Point2D_I32 a0 = a . get ( 0 ) ; 
if ( a0 . equals ( b . get ( i ) ) ) { 
Point2D_I32 ai = a . get ( i ) ; 
Point2D_I32 bi = b . get ( ( match + i ) % b . size ( ) ) ; 
if ( ! ai . equals ( bi ) ) { 
} public static Point2D_I32 mean ( List < Point2D_I32 > list , Point2D_I32 mean ) { 
mean = new Point2D_I32 ( ) ; 
int sumX = 0 , sumY = 0 ; 
int N = list . size ( ) ; 
Point2D_I32 p = list . get ( i ) ; 
mean . x = sumX / N ; 
mean . y = sumY / N ; 
} public void plusIP ( GeoTuple4D_F64 a ) { 
w += a . w ; 
} public void timesIP ( double scalar ) { 
x *= scalar ; 
y *= scalar ; 
z *= scalar ; 
w *= scalar ; 
} public double maxAbs ( ) { 
double absX = Math . abs ( x ) ; 
double absY = Math . abs ( y ) ; 
double absZ = Math . abs ( z ) ; 
double absW = Math . abs ( w ) ; 
double found = Math . max ( absX , absY ) ; 
if ( found < absZ ) 
found = absZ ; 
if ( found < absW ) 
found = absW ; 
} public static boolean fitMM ( double [ ] data , int offset , int length , 
PolynomialQuadratic1D_F64 output , @ Nullable DMatrix3x3 work ) { 
if ( work == null ) 
work = new DMatrix3x3 ( ) ; 
final int N = length / 2 ; 
double sx0 = N , sx1 = 0 , sx2 = 0 ; 
double sx3 = 0 ; 
double sx4 = 0 ; 
double b0 = 0 , b1 = 0 , b2 = 0 ; 
for ( int i = offset ; i < end ; i += 2 ) { 
double x2 = x * x ; 
sx1 += x ; 
sx2 += x2 ; 
sx3 += x2 * x ; 
sx4 += x2 * x2 ; 
b0 += y ; 
b1 += x * y ; 
b2 += x2 * y ; 
DMatrix3x3 A = work ; 
A . set ( sx0 , sx1 , sx2 , 
sx1 , sx2 , sx3 , 
sx2 , sx3 , sx4 ) ; 
if ( ! CommonOps_DDF3 . invert ( A , A ) ) 
output . a = A . a11 * b0 + A . a12 * b1 + A . a13 * b2 ; 
output . b = A . a21 * b0 + A . a22 * b1 + A . a23 * b2 ; 
output . c = A . a31 * b0 + A . a32 * b1 + A . a33 * b2 ; 
} public static boolean fitQRP ( double [ ] data , int offset , int length , 
PolynomialQuadratic1D_F64 output ) { 
FitPolynomialSolverTall_F64 solver = new FitPolynomialSolverTall_F64 ( ) ; 
return solver . process ( data , offset , length , output ) ; 
} public static boolean fitMM ( double [ ] data , int offset , int length , PolynomialCubic1D_F64 output , @ Nullable DMatrix4x4 A ) { 
if ( A == null ) 
A = new DMatrix4x4 ( ) ; 
if ( N < 4 ) 
double sx1 = 0 , sx2 = 0 , sx3 = 0 , sx4 = 0 , sx5 = 0 , sx6 = 0 ; 
double b0 = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; 
double x3 = x2 * x ; 
double x4 = x2 * x2 ; 
sx1 += x ; sx2 += x2 ; sx3 += x3 ; 
sx4 += x4 ; sx5 += x4 * x ; 
sx6 += x4 * x2 ; 
b3 += x3 * y ; 
A . set ( N , sx1 , sx2 , sx3 , 
sx1 , sx2 , sx3 , sx4 , 
sx2 , sx3 , sx4 , sx5 , 
sx3 , sx4 , sx5 , sx6 ) ; 
if ( ! CommonOps_DDF4 . invert ( A , A ) ) 
output . a = A . a11 * b0 + A . a12 * b1 + A . a13 * b2 + A . a14 * b3 ; 
output . b = A . a21 * b0 + A . a22 * b1 + A . a23 * b2 + A . a24 * b3 ; 
output . c = A . a31 * b0 + A . a32 * b1 + A . a33 * b2 + A . a34 * b3 ; 
output . d = A . a41 * b0 + A . a42 * b1 + A . a43 * b2 + A . a44 * b3 ; 
} public static boolean fit ( double [ ] data , int offset , int length , PolynomialQuadratic2D_F64 output ) { 
final int N = length / 3 ; 
if ( N < 6 ) 
double sx1 = 0 , sy1 = 0 , sx1y1 = 0 , sx2 = 0 , sy2 = 0 , sx2y1 = 0 , sx1y2 = 0 , sx2y2 = 0 , sx3 = 0 , sy3 = 0 , sx3y1 = 0 , sx1y3 = 0 , sx4 = 0 , sy4 = 0 ; 
double b0 = 0 , b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , b5 = 0 ; 
for ( int i = offset ; i < end ; i += 3 ) { 
double z = data [ i + 2 ] ; 
double y2 = y * y ; 
double y3 = y2 * y ; 
double y4 = y2 * y2 ; 
sx1 += x ; sx2 += x2 ; sx3 += x3 ; sx4 += x4 ; 
sy1 += y ; sy2 += y2 ; sy3 += y3 ; sy4 += y4 ; 
sx1y1 += x * y ; sx2y1 += x2 * y ; sx1y2 += x * y2 ; sx2y2 += x2 * y2 ; 
sx3y1 += x3 * y ; sx1y3 += x * y3 ; 
b0 += z ; 
b1 += x * z ; 
b2 += y * z ; 
b3 += x * y * z ; 
b4 += x2 * z ; 
b5 += y2 * z ; 
DMatrix6x6 A = new DMatrix6x6 ( ) ; 
A . set ( N , sx1 , sy1 , sx1y1 , sx2 , sy2 , 
sx1 , sx2 , sx1y1 , sx2y1 , sx3 , sx1y2 , 
sy1 , sx1y1 , sy2 , sx1y2 , sx2y1 , sy3 , 
sx1y1 , sx2y1 , sx1y2 , sx2y2 , sx3y1 , sx1y3 , 
sx2 , sx3 , sx2y1 , sx3y1 , sx4 , sx2y2 , 
sy2 , sx1y2 , sy3 , sx1y3 , sx2y2 , sy4 ) ; 
DMatrixRMaj _A = new DMatrixRMaj ( 6 , 6 ) ; 
ConvertDMatrixStruct . convert ( A , _A ) ; 
LinearSolverDense < DMatrixRMaj > solver = LinearSolverFactory_DDRM . pseudoInverse ( true ) ; 
if ( ! solver . setA ( _A ) ) 
solver . invert ( _A ) ; 
DMatrixRMaj B = new DMatrixRMaj ( 6 , 1 , true , b0 , b1 , b2 , b3 , b4 , b5 ) ; 
DMatrixRMaj Y = new DMatrixRMaj ( 6 , 1 ) ; 
CommonOps_DDRM . mult ( _A , B , Y ) ; 
output . a = Y . data [ 0 ] ; 
output . b = Y . data [ 1 ] ; 
output . c = Y . data [ 2 ] ; 
output . d = Y . data [ 3 ] ; 
output . e = Y . data [ 4 ] ; 
output . f = Y . data [ 5 ] ; 
} public static double distance ( double x0 , double y0 , double z0 , 
double x1 , double y1 , double z1 ) { 
return norm ( x1 - x0 , y1 - y0 , z1 - z0 ) ; 
} public static double distanceSq ( double x0 , double y0 , double z0 , 
double dx = x1 - x0 ; 
double dy = y1 - y0 ; 
double dz = z1 - z0 ; 
return dx * dx + dy * dy + dz * dz ; 
} public static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { 
List < Point3D_F64 > ret = new ArrayList < > ( ) ; 
UtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; 
double x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; 
double y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; 
Point3D_F64 p = new Point3D_F64 ( ) ; 
p . x = plane . p . x + axisX . x * x + axisY . x * y ; 
p . y = plane . p . y + axisX . y * x + axisY . y * y ; 
p . z = plane . p . z + axisX . z * x + axisY . z * y ; 
} public static List < Point3D_F64 > random ( Point3D_F64 mean , 
double minX , double maxX , 
double minY , double maxY , 
double minZ , double maxZ , 
int num , Random rand ) 
p . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; 
p . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; 
p . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; 
} public static List < Point3D_F64 > randomN ( Point3D_F64 mean , 
double stdX , double stdY , double stdZ , 
p . x = mean . x + rand . nextGaussian ( ) * stdX ; 
p . y = mean . y + rand . nextGaussian ( ) * stdY ; 
p . z = mean . z + rand . nextGaussian ( ) * stdZ ; 
} public static Point3D_F64 mean ( List < Point3D_F64 > points , Point3D_F64 mean ) { 
mean = new Point3D_F64 ( ) ; 
double x = 0 , y = 0 , z = 0 ; 
x += p . x ; 
y += p . y ; 
z += p . z ; 
mean . x = x / points . size ( ) ; 
mean . y = y / points . size ( ) ; 
mean . z = z / points . size ( ) ; 
} public static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { 
mean . x = x / num ; 
mean . y = y / num ; 
mean . z = z / num ; 
} public static void boundingBox ( List < Point3D_F64 > points , Box3D_F64 bounding ) { 
double minZ = Double . MAX_VALUE , maxZ = - Double . MAX_VALUE ; 
if ( p . z < minZ ) 
minZ = p . z ; 
if ( p . z > maxZ ) 
maxZ = p . z ; 
bounding . p0 . set ( minX , minY , minZ ) ; 
bounding . p1 . set ( maxX , maxY , maxZ ) ; 
public static Set < String > combineToSet ( Collection < String > ... collections ) { 
Set < String > lowercaseSet = new HashSet < String > ( ) ; 
for ( Collection < String > collection : collections ) { 
for ( String value : collection ) { 
if ( ! lowercaseSet . contains ( value . toLowerCase ( ) ) ) { 
lowercaseSet . add ( value . toLowerCase ( ) ) ; 
result . add ( value ) ; 
} public Set < String > getServerFeatures ( File serverDirectory ) { 
Set < String > result = getConfigDropinsFeatures ( null , serverDirectory , "defaults" ) ; 
result = getServerXmlFeatures ( result , new File ( serverDirectory , "server.xml" ) , null ) ; 
return getConfigDropinsFeatures ( result , serverDirectory , "overrides" ) ; 
} private Set < String > getConfigDropinsFeatures ( Set < String > origResult , File serverDirectory , String folderName ) { 
Set < String > result = origResult ; 
File configDropinsFolder ; 
configDropinsFolder = new File ( new File ( serverDirectory , "configDropins" ) , folderName ) . getCanonicalFile ( ) ; 
debug ( e ) ; 
File [ ] configDropinsXmls = configDropinsFolder . listFiles ( new FilenameFilter ( ) { 
return name . endsWith ( ".xml" ) ; 
if ( configDropinsXmls == null || configDropinsXmls . length == 0 ) { 
Comparator < File > comparator = new Comparator < File > ( ) { 
public int compare ( File left , File right ) { 
return left . getAbsolutePath ( ) . toLowerCase ( ) . compareTo ( right . getAbsolutePath ( ) . toLowerCase ( ) ) ; 
Collections . sort ( Arrays . asList ( configDropinsXmls ) , comparator ) ; 
for ( File xml : configDropinsXmls ) { 
Set < String > features = getServerXmlFeatures ( result , xml , null ) ; 
if ( features != null ) { 
result = features ; 
} private Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { 
List < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; 
File canonicalServerFile ; 
canonicalServerFile = serverFile . getCanonicalFile ( ) ; 
updatedParsedXmls . add ( canonicalServerFile ) ; 
if ( canonicalServerFile . exists ( ) ) { 
Document doc = new XmlDocument ( ) { 
public Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { 
createDocument ( file ) ; 
} . getDocument ( canonicalServerFile ) ; 
Element root = doc . getDocumentElement ( ) ; 
NodeList nodes = root . getChildNodes ( ) ; 
if ( nodes . item ( i ) instanceof Element ) { 
Element child = ( Element ) nodes . item ( i ) ; 
if ( "featureManager" . equals ( child . getNodeName ( ) ) ) { 
result = new HashSet < String > ( ) ; 
result . addAll ( parseFeatureManagerNode ( child ) ) ; 
} else if ( "include" . equals ( child . getNodeName ( ) ) ) { 
result = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; 
} catch ( IOException | ParserConfigurationException | SAXException e ) { 
} private Set < String > parseIncludeNode ( Set < String > origResult , File serverFile , Element node , 
List < File > updatedParsedXmls ) { 
String includeFileName = node . getAttribute ( "location" ) ; 
if ( includeFileName == null || includeFileName . trim ( ) . isEmpty ( ) ) { 
File includeFile = null ; 
if ( isURL ( includeFileName ) ) { 
File tempFile = File . createTempFile ( "serverFromURL" , ".xml" ) ; 
FileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; 
includeFile = tempFile ; 
includeFile = new File ( includeFileName ) ; 
if ( ! includeFile . isAbsolute ( ) ) { 
includeFile = new File ( serverFile . getParentFile ( ) . getAbsolutePath ( ) , includeFileName ) 
. getCanonicalFile ( ) ; 
includeFile = includeFile . getCanonicalFile ( ) ; 
if ( ! updatedParsedXmls . contains ( includeFile ) ) { 
String onConflict = node . getAttribute ( "onConflict" ) ; 
Set < String > features = getServerXmlFeatures ( null , includeFile , updatedParsedXmls ) ; 
result = handleOnConflict ( result , onConflict , features ) ; 
} private static Set < String > parseFeatureManagerNode ( Element node ) { 
NodeList features = node . getElementsByTagName ( "feature" ) ; 
for ( int j = 0 ; j < features . getLength ( ) ; j ++ ) { 
String content = features . item ( j ) . getTextContent ( ) ; 
if ( content . contains ( ":" ) ) { 
String [ ] split = content . split ( ":" , 2 ) ; 
result . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; 
result . add ( content . trim ( ) . toLowerCase ( ) ) ; 
} private Set < File > downloadProductJsons ( ) throws PluginExecutionException { 
Set < File > downloadedJsons = new HashSet < File > ( ) ; 
for ( ProductProperties properties : propertiesList ) { 
File json = downloadJsons ( properties . getId ( ) , properties . getVersion ( ) ) ; 
if ( json != null ) { 
downloadedJsons . add ( json ) ; 
return downloadedJsons ; 
} private File downloadJsons ( String productId , String productVersion ) { 
String jsonGroupId = productId + ".features" ; 
return downloadArtifact ( jsonGroupId , "features" , "json" , productVersion ) ; 
} catch ( PluginExecutionException e ) { 
} private boolean hasUnsupportedParameters ( String from , Set < String > pluginListedEsas ) { 
boolean hasFrom = from != null ; 
boolean hasPluginListedEsas = ! pluginListedEsas . isEmpty ( ) ; 
return hasFrom || hasPluginListedEsas ; 
} public static Set < String > getOpenLibertyFeatureSet ( Set < File > jsons ) throws PluginExecutionException { 
Set < String > libertyFeatures = new HashSet < String > ( ) ; 
for ( File file : jsons ) { 
Scanner s = null ; 
s = new Scanner ( file ) ; 
while ( s . findWithinHorizon ( OPEN_LIBERTY_GROUP_ID + ":([^:]*):" , 0 ) != null ) { 
MatchResult match = s . match ( ) ; 
if ( match . groupCount ( ) >= 1 ) { 
libertyFeatures . add ( match . group ( 1 ) ) ; 
s . close ( ) ; 
return libertyFeatures ; 
} private boolean isOnlyOpenLibertyFeatures ( List < String > featuresToInstall ) throws PluginExecutionException { 
boolean result = containsIgnoreCase ( getOpenLibertyFeatureSet ( downloadedJsons ) , featuresToInstall ) ; 
} public static boolean containsIgnoreCase ( Collection < String > reference , Collection < String > target ) { 
return toLowerCase ( reference ) . containsAll ( toLowerCase ( target ) ) ; 
public void installFeatures ( boolean isAcceptLicense , List < String > featuresToInstall ) throws PluginExecutionException { 
List < File > jsonRepos = new ArrayList < File > ( downloadedJsons ) ; 
boolean acceptLicenseMapValue = isOnlyOpenLibertyFeatures ( featuresToInstall ) ? true : isAcceptLicense ; 
Map < String , Object > mapBasedInstallKernel = createMapBasedInstallKernelInstance ( installDirectory ) ; 
mapBasedInstallKernel . put ( "install.local.esa" , true ) ; 
mapBasedInstallKernel . put ( "single.json.file" , jsonRepos ) ; 
mapBasedInstallKernel . put ( "features.to.resolve" , featuresToInstall ) ; 
mapBasedInstallKernel . put ( "license.accept" , acceptLicenseMapValue ) ; 
if ( isDebugEnabled ( ) ) { 
mapBasedInstallKernel . put ( "debug" , Level . FINEST ) ; 
Collection < ? > resolvedFeatures = ( Collection < ? > ) mapBasedInstallKernel . get ( "action.result" ) ; 
if ( resolvedFeatures == null ) { 
String exceptionMessage = ( String ) mapBasedInstallKernel . get ( "action.error.message" ) ; 
throw new PluginExecutionException ( exceptionMessage ) ; 
} else if ( resolvedFeatures . isEmpty ( ) ) { 
if ( exceptionMessage == null ) { 
} else if ( exceptionMessage . contains ( "CWWKF1250I" ) ) { 
info ( exceptionMessage ) ; 
Collection < File > artifacts = downloadEsas ( resolvedFeatures ) ; 
StringBuilder installedFeaturesBuilder = new StringBuilder ( ) ; 
Collection < String > actionReturnResult = new ArrayList < String > ( ) ; 
for ( File esaFile : artifacts ) { 
mapBasedInstallKernel . put ( "action.install" , esaFile ) ; 
if ( to != null ) { 
mapBasedInstallKernel . put ( "to.extension" , to ) ; 
Integer ac = ( Integer ) mapBasedInstallKernel . get ( "action.result" ) ; 
if ( mapBasedInstallKernel . get ( "action.error.message" ) != null ) { 
debug ( exceptionMessage ) ; 
} else if ( mapBasedInstallKernel . get ( "action.install.result" ) != null ) { 
actionReturnResult . addAll ( ( Collection < String > ) mapBasedInstallKernel . get ( "action.install.result" ) ) ; 
for ( String installResult : actionReturnResult ) { 
productInfoValidate ( ) ; 
} public String getOverrideBundleDescriptor ( String groupId , String artifactId ) throws PluginExecutionException { 
File overrideJar = downloadOverrideJar ( groupId , artifactId ) ; 
if ( overrideJar != null && overrideJar . exists ( ) ) { 
String symbolicName = extractSymbolicName ( overrideJar ) ; 
if ( symbolicName != null ) { 
return overrideJar . getAbsolutePath ( ) + ";" + symbolicName ; 
} public static String getNextProductVersion ( String version ) throws PluginExecutionException { 
int versionSplittingIndex = version . lastIndexOf ( "." ) + 1 ; 
if ( versionSplittingIndex == 0 ) { 
String quarterVersion = version . substring ( versionSplittingIndex ) ; 
int nextQuarterSpecifier ; 
nextQuarterSpecifier = Integer . parseInt ( quarterVersion ) + 1 ; 
result = version . substring ( 0 , versionSplittingIndex ) + nextQuarterSpecifier ; 
} public static String extractSymbolicName ( File jar ) throws PluginExecutionException { 
jarFile = new JarFile ( jar ) ; 
return jarFile . getManifest ( ) . getMainAttributes ( ) . getValue ( "Bundle-SymbolicName" ) ; 
if ( jarFile != null ) { 
jarFile . close ( ) ; 
} public static File getMapBasedInstallKernelJar ( File dir ) { 
File [ ] installMapJars = dir . listFiles ( new FilenameFilter ( ) { 
return name . startsWith ( INSTALL_MAP_PREFIX ) && name . endsWith ( INSTALL_MAP_SUFFIX ) ; 
File result = null ; 
if ( installMapJars != null ) { 
for ( File jar : installMapJars ) { 
if ( isReplacementJar ( result , jar ) ) { 
result = jar ; 
} private static boolean isReplacementJar ( File file1 , File file2 ) { 
if ( file1 == null ) { 
} else if ( file2 == null ) { 
String version1 = extractVersion ( file1 . getName ( ) ) ; 
String version2 = extractVersion ( file2 . getName ( ) ) ; 
return compare ( version1 , version2 ) < 0 ; 
} private static String extractVersion ( String fileName ) { 
int startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; 
int endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; 
if ( startIndex < endIndex ) { 
return fileName . substring ( startIndex , endIndex ) ; 
} private static int compare ( String version1 , String version2 ) { 
if ( version1 == null && version2 == null ) { 
} else if ( version1 == null && version2 != null ) { 
} else if ( version1 != null && version2 == null ) { 
String [ ] components1 = version1 . split ( "\\." ) ; 
String [ ] components2 = version2 . split ( "\\." ) ; 
for ( int i = 0 ; i < components1 . length && i < components2 . length ; i ++ ) { 
int comparison ; 
comparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; 
comparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; 
if ( comparison != 0 ) { 
return comparison ; 
return components1 . length - components2 . length ; 
} private void productInfoValidate ( ) throws PluginExecutionException { 
String output = productInfo ( installDirectory , "validate" ) ; 
throw new PluginExecutionException ( 
} else if ( output . contains ( "[ERROR]" ) ) { 
throw new PluginExecutionException ( output ) ; 
} public static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { 
Process pr = null ; 
Worker worker = null ; 
String command ; 
if ( OSUtil . isWindows ( ) ) { 
pr = Runtime . getRuntime ( ) . exec ( command ) ; 
worker = new Worker ( pr ) ; 
worker . start ( ) ; 
worker . join ( 300000 ) ; 
if ( worker . exit == null ) { 
int exitValue = pr . exitValue ( ) ; 
if ( exitValue != 0 ) { 
is = pr . getInputStream ( ) ; 
s = new Scanner ( is ) ; 
s . useDelimiter ( "\\A" ) ; 
if ( s . hasNext ( ) ) { 
return s . next ( ) ; 
worker . interrupt ( ) ; 
if ( pr != null ) { 
pr . destroy ( ) ; 
} public static boolean isSpringBootUberJar ( File artifact ) { 
if ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) { 
try ( JarFile jarFile = new JarFile ( artifact ) ) { 
Manifest manifest = jarFile . getManifest ( ) ; 
if ( manifest != null ) { 
Attributes attributes = manifest . getMainAttributes ( ) ; 
if ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null 
&& attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) { 
Enumeration < JarEntry > entries = jarFile . entries ( ) ; 
while ( entries . hasMoreElements ( ) ) { 
JarEntry entry = entries . nextElement ( ) ; 
String entryName = entry . getName ( ) ; 
if ( ! entryName . startsWith ( "org" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) { 
} catch ( IOException e ) { } 
} public static Map < LibertyPropertyI , String > getArquillianProperties ( Map < String , String > arquillianProperties , 
Class < ? > cls ) throws ArquillianConfigurationException { 
Map < LibertyPropertyI , String > props = new HashMap < LibertyPropertyI , String > ( ) ; 
if ( arquillianProperties != null && ! arquillianProperties . isEmpty ( ) ) { 
for ( Entry < String , String > entry : arquillianProperties . entrySet ( ) ) { 
LibertyPropertyI p = getArquillianProperty ( key , cls ) ; 
props . put ( p , value ) ; 
} private static LibertyPropertyI getArquillianProperty ( String key , Class < ? > cls ) 
throws ArquillianConfigurationException { 
if ( cls == LibertyManagedObject . LibertyManagedProperty . class ) { 
return LibertyManagedObject . LibertyManagedProperty . valueOf ( key ) ; 
} else if ( cls == LibertyRemoteObject . LibertyRemoteProperty . class ) { 
return LibertyRemoteObject . LibertyRemoteProperty . valueOf ( key ) ; 
throw new ArquillianConfigurationException ( 
} public NamespaceManager withNamespace ( String namespace , String href ) { 
if ( namespaces . containsKey ( namespace ) ) { 
throw new RepresentationException ( 
if ( ! href . contains ( "{rel}" ) ) { 
return new NamespaceManager ( namespaces . put ( namespace , href ) ) ; 
} public ResourceRepresentation < V > withContent ( ByteString content ) { 
return new ResourceRepresentation < > ( 
Option . of ( content ) , links , rels , namespaceManager , value , resources ) ; 
} public ResourceRepresentation < V > withRel ( Rel rel ) { 
if ( rels . containsKey ( rel . rel ( ) ) ) { 
final TreeMap < String , Rel > updatedRels = rels . put ( rel . rel ( ) , rel ) ; 
content , links , updatedRels , namespaceManager , value , resources ) ; 
} public ResourceRepresentation < V > withLink ( String rel , URI uri ) { 
return withLink ( rel , uri . toASCIIString ( ) ) ; 
} public ResourceRepresentation < V > withLink ( 
String rel , String href , Map < String , String > properties ) { 
return withLink ( Links . create ( rel , href , properties ) ) ; 
String rel , String href , java . util . Map < String , String > properties ) { 
return withLink ( Links . create ( rel , href , HashMap . ofAll ( properties ) ) ) ; 
} public ResourceRepresentation < V > withLink ( Link link ) { 
String rel = Links . getRel ( link ) ; 
Support . checkRelType ( rel ) ; 
validateSingletonRel ( rel ) ; 
final TreeMap < String , Rel > updatedRels = 
! rels . containsKey ( rel ) ? rels . put ( rel , Rels . natural ( rel ) ) : rels ; 
final List < Link > updatedLinks = links . append ( link ) ; 
content , updatedLinks , updatedRels , namespaceManager , value , resources ) ; 
} public ResourceRepresentation < V > withLinks ( List < Link > links ) { 
links . forEach ( 
link -> { 
links 
. map ( Links :: getRel ) 
. foldLeft ( 
rels , 
( accum , rel ) -> 
! accum . containsKey ( rel ) ? accum . put ( rel , Rels . natural ( rel ) ) : accum ) ; 
final List < Link > updatedLinks = this . links . appendAll ( links ) ; 
} public < R > ResourceRepresentation < R > withValue ( R newValue ) { 
Option . none ( ) , links , rels , namespaceManager , newValue , resources ) ; 
} public ResourceRepresentation < V > withNamespace ( String namespace , String href ) { 
if ( ! rels . containsKey ( "curies" ) ) { 
rels = rels . put ( "curies" , Rels . collection ( "curies" ) ) ; 
final NamespaceManager updatedNamespaceManager = 
namespaceManager . withNamespace ( namespace , href ) ; 
content , links , rels , updatedNamespaceManager , value , resources ) ; 
} private static String [ ] getFileExtensions ( final Decoder decoder ) 
final Class < ? extends Decoder > decoderClass = decoder . getClass ( ) ; 
final FileExtensions fileExtensionsAnnotation = decoderClass . getAnnotation ( FileExtensions . class ) ; 
return ( fileExtensionsAnnotation == null ) 
? new String [ ] { "" } 
: fileExtensionsAnnotation . value ( ) ; 
} private String nameToFile ( final Class configClass , final Name servicePath , final String fileNameDelimiter , final String extension ) 
StringBuilder builder = new StringBuilder ( "cfg" ) ; 
for ( final String component : servicePath ) { 
builder . append ( fileNameDelimiter ) . append ( component ) ; 
builder . append ( fileNameDelimiter ) . append ( configClass . getSimpleName ( ) ) ; 
if ( ! extension . isEmpty ( ) ) { 
builder . append ( '.' ) . append ( extension ) ; 
} private void updateDB ( ) throws SQLException , LiquibaseException 
try ( BasicDataSource dataSource = new BasicDataSource ( ) ) { 
dataSource . setUrl ( fullConnectionString ) ; 
dataSource . setUsername ( username ) ; 
dataSource . setPassword ( password ) ; 
try ( java . sql . Connection c = dataSource . getConnection ( ) ) { 
Database database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; 
Liquibase liquibase = null ; 
ClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; 
if ( accessor . getResourcesAsStream ( "changelog-master.xml" ) != null ) { 
liquibase = new Liquibase ( "changelog-master.xml" , new ClassLoaderResourceAccessor ( ) , database ) ; 
} else if ( accessor . getResourcesAsStream ( "changelog.xml" ) != null ) { 
liquibase = new Liquibase ( "changelog.xml" , new ClassLoaderResourceAccessor ( ) , database ) ; 
Logger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; 
throw new RuntimeException ( errorMessage ) ; 
Logger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; 
liquibase . getLog ( ) . setLogLevel ( logLevel ) ; 
liquibase . update ( new Contexts ( ) ) ; 
} private static Object evaluateScript ( final ScriptEngine scriptEngine , final InputStream stream ) throws IOException , ScriptException 
try ( final InputStreamReader reader = new InputStreamReader ( stream , StandardCharsets . UTF_8 ) ) { 
return scriptEngine . eval ( reader ) ; 
} private static String invokeStringMethod ( final ScriptEngine jsEngine , final Object thiz , final String name , final Object ... args ) 
throws NoSuchMethodException , ScriptException 
return ( String ) ( ( Invocable ) jsEngine ) . invokeMethod ( thiz , name , args ) ; 
} public synchronized T acquire ( final DataSource source ) 
throws DataSourceException 
if ( getReference ( ) == null ) { 
object = source . getObject ( getReference ( ) , objectClass ) ; 
} public static < T > ReferencedObject < T > getReferencedObject ( final Class < T > clazz , final String ref ) 
return new ReferencedObject < > ( clazz , ref , null ) ; 
} public static < T > ReferencedObject < T > getWrappedObject ( final Class < T > clazz , final T obj ) 
return new ReferencedObject < > ( clazz , null , obj ) ; 
protected InputStream getConfigurationStream ( final Class configClass , final Name relativePath ) 
throws ConfigurationException 
return remoteCall ( relativePath . toString ( ) , configClass . getSimpleName ( ) ) . getBody ( ) . in ( ) ; 
} catch ( final HttpConfigurationException e ) { 
} catch ( final IOException | InterruptedException e ) { 
} private Response remoteCall ( final String path , final String configName ) 
throws ConfigurationException , InterruptedException 
return remote . getRemoteConfiguration ( path , configName ) ; 
} catch ( final HttpConfigurationException nfe ) { 
throw nfe ; 
} catch ( final ConfigurationException e ) { 
if ( i == retries ) { 
Thread . sleep ( ( long ) Math . pow ( 2 , i ) * 1000L ) ; 
public final < T > T getConfiguration ( final Class < T > configClass ) 
Objects . requireNonNull ( configClass ) ; 
incrementRequests ( ) ; 
T config = getCompleteConfig ( configClass ) ; 
Set < ConstraintViolation < T > > violations = getValidator ( ) . validate ( config ) ; 
if ( violations . isEmpty ( ) ) { 
incrementErrors ( ) ; 
} private < T > T getCompleteConfig ( final Class < T > configClass ) 
T config = getConfig ( configClass ) ; 
for ( final Field f : configClass . getDeclaredFields ( ) ) { 
if ( f . isAnnotationPresent ( Configuration . class ) ) { 
Method setter = getMethod ( f . getName ( ) , configClass , PropertyDescriptor :: getWriteMethod ) ; 
setter . invoke ( config , getCompleteConfig ( f . getType ( ) ) ) ; 
} catch ( final InvocationTargetException | IllegalAccessException e ) { 
} else if ( f . getType ( ) . equals ( String . class ) && f . isAnnotationPresent ( Encrypted . class ) ) { 
Method getter = getMethod ( f . getName ( ) , config . getClass ( ) , PropertyDescriptor :: getReadMethod ) ; 
Method setter = getMethod ( f . getName ( ) , config . getClass ( ) , PropertyDescriptor :: getWriteMethod ) ; 
if ( getter != null && setter != null ) { 
final String configValue = ( String ) getter . invoke ( config ) ; 
final String encryptedValue = isSubstitutorEnabled ? tokenSubstitutor ( configValue ) : configValue ; 
setter . invoke ( config , getCipher ( ) . decrypt ( encryptedValue ) ) ; 
} catch ( final CipherException | InvocationTargetException | IllegalAccessException e ) { 
} else if ( isSubstitutorEnabled && f . getType ( ) . equals ( String . class ) ) { 
String propertyName = f . getName ( ) ; 
Method getter = getMethod ( propertyName , config . getClass ( ) , PropertyDescriptor :: getReadMethod ) ; 
Method setter = getMethod ( propertyName , config . getClass ( ) , PropertyDescriptor :: getWriteMethod ) ; 
String propertyValueByToken = tokenSubstitutor ( ( String ) getter . invoke ( config ) ) ; 
setter . invoke ( config , propertyValueByToken ) ; 
} private < T > T getConfig ( final Class < T > configClass ) 
Iterator < Name > it = getServicePath ( ) . descendingPathIterator ( ) ; 
try ( InputStream in = getConfigurationStream ( configClass , it . next ( ) ) ) { 
return decoder . deserialise ( in , configClass ) ; 
} catch ( final CodecException | IOException e ) { 
} private static boolean getIsSubstitutorEnabled ( final BootstrapConfiguration bootstrapConfig ) 
final String ENABLE_SUBSTITUTOR_CONFIG_KEY = "CAF_CONFIG_ENABLE_SUBSTITUTOR" ; 
final boolean ENABLE_SUBSTITUTOR_CONFIG_DEFAULT = true ; 
if ( ! bootstrapConfig . isConfigurationPresent ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ) { 
return ENABLE_SUBSTITUTOR_CONFIG_DEFAULT ; 
return bootstrapConfig . getConfigurationBoolean ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ; 
} catch ( final ConfigurationException ex ) { 
public < T > Iterator < Class < T > > createClassIterator ( 
final Class < T > service , 
final String serviceName , 
final ClassLoader loader , 
final boolean ignoreOnClassNotFound 
final Iterator < Class < T > > delegateClassIterator = delegate . createClassIterator ( 
service , serviceName , loader , ignoreOnClassNotFound ) ; 
Stream < Class < T > > stream = StreamSupport . stream ( 
Spliterators . spliteratorUnknownSize ( delegateClassIterator , Spliterator . ORDERED ) , false ) ; 
return stream . filter ( t -> ! t . getPackage ( ) . getName ( ) . startsWith ( "com.sun.jersey" ) ) . collect ( Collectors . toList ( ) ) . iterator ( ) ; 
public Decoder getDecoder ( final BootstrapConfiguration bootstrap , final Decoder defaultDecoder ) 
final String DECODER_CONFIG_KEY = "CAF_CONFIG_DECODER" ; 
final String decoder ; 
if ( ! bootstrap . isConfigurationPresent ( DECODER_CONFIG_KEY ) ) { 
return defaultDecoder ; 
decoder = bootstrap . getConfiguration ( DECODER_CONFIG_KEY ) ; 
return ModuleProvider . getInstance ( ) . getModule ( Decoder . class , decoder ) ; 
} catch ( final NullPointerException ex ) { 
} public static < T > T getService ( final Class < T > intf ) 
throws ModuleLoaderException 
return getService ( intf , null ) ; 
} public static < T > T getService ( final Class < T > intf , final Class < ? extends T > defaultImpl ) 
final T implementation = getServiceOrElse ( intf , null ) ; 
if ( implementation != null ) { 
return implementation ; 
if ( defaultImpl == null ) { 
return defaultImpl . getConstructor ( ) . newInstance ( ) ; 
} catch ( final InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e ) { 
} public static < T > T getServiceOrElse ( final Class < T > intf , final T defaultObj ) 
Objects . requireNonNull ( intf ) ; 
final T ret ; 
List < T > implementations = getServices ( intf ) ; 
if ( implementations . isEmpty ( ) ) { 
return defaultObj ; 
ret = implementations . get ( 0 ) ; 
if ( implementations . size ( ) > 1 ) { 
} public static < T > List < T > getServices ( final Class < T > intf ) 
List < T > ret = new LinkedList < > ( ) ; 
for ( final T t : ServiceLoader . load ( intf ) ) { 
ret . add ( t ) ; 
} public < T > T getModule ( final Class < T > interfaceImplemented , final String moduleType ) throws NullPointerException 
Map < String , Object > computedValue = loadedModules . computeIfAbsent ( interfaceImplemented , ModuleProvider :: loadModules ) ; 
Object moduleInstance = computedValue . get ( moduleType ) ; 
Objects . requireNonNull ( 
return ( T ) moduleInstance ; 
} public synchronized InputStream acquire ( final DataSource source ) 
InputStream ret ; 
ret = source . getStream ( getReference ( ) ) ; 
ret = new ByteArrayInputStream ( data ) ; 
} public synchronized long size ( final DataSource source ) 
return source . getDataSize ( getReference ( ) ) ; 
return data . length ; 
} public static ReferencedData getWrappedData ( final String ref , final byte [ ] data ) 
return new ReferencedData ( Objects . requireNonNull ( ref ) , data ) ; 
} public String getIndex ( final int index ) 
if ( index < 0 || index >= components . size ( ) ) { 
return components . get ( index ) ; 
} public Name getPrefix ( final int upperIndex ) 
if ( upperIndex < 0 || upperIndex > components . size ( ) ) { 
return new Name ( components . subList ( 0 , upperIndex ) ) ; 
} public String write ( Geometry geometry ) 
JSONStringer b = new JSONStringer ( ) ; 
if ( geometry . getClass ( ) . equals ( GeometryCollection . class ) ) 
writeFeatureCollection ( b , ( GeometryCollection ) geometry ) ; 
writeFeature ( b , geometry ) ; 
catch ( JSONException e ) 
throw new GeoJsonException ( e ) ; 
} private static Polygon createReversed ( Polygon geometry ) 
Polygon r = ( Polygon ) geometry . clone ( ) ; 
r . normalize ( ) ; 
return ( Polygon ) r . reverse ( ) ; 
} public Set < String > getContainingIds ( 
double minLongitude , double minLatitude , double maxLongitude , double maxLatitude ) 
Set < String > ids = new HashSet < > ( ) ; 
forCellsIn ( minLongitude , minLatitude , maxLongitude , maxLatitude , cell -> 
if ( ids . isEmpty ( ) ) 
ids . addAll ( cell . getContainingIds ( ) ) ; 
ids . retainAll ( cell . getContainingIds ( ) ) ; 
return ids ; 
} public Set < String > getIntersectingIds ( 
ids . addAll ( cell . getAllIds ( ) ) ; 
} private static boolean isPointInPolygon ( Point p , Point [ ] v ) 
int wn = 0 ; 
for ( int j = 0 , i = v . length - 1 ; j < v . length ; i = j ++ ) { 
if ( v [ i ] . y <= p . y ) { 
if ( v [ j ] . y > p . y ) { 
if ( isLeft ( v [ i ] , v [ j ] , p ) > 0 ) 
++ wn ; 
if ( v [ j ] . y <= p . y ) { 
if ( isLeft ( v [ i ] , v [ j ] , p ) < 0 ) 
-- wn ; 
return wn != 0 ; 
} public static PnSignalingParams defaultInstance ( ) { 
MediaConstraints pcConstraints = PnSignalingParams . defaultPcConstraints ( ) ; 
MediaConstraints videoConstraints = PnSignalingParams . defaultVideoConstraints ( ) ; 
MediaConstraints audioConstraints = PnSignalingParams . defaultAudioConstraints ( ) ; 
List < PeerConnection . IceServer > iceServers = PnSignalingParams . defaultIceServers ( ) ; 
return new PnSignalingParams ( iceServers , pcConstraints , videoConstraints , audioConstraints ) ; 
} public void addIceServers ( List < PeerConnection . IceServer > iceServers ) { 
if ( this . iceServers != null ) { 
iceServers . addAll ( this . iceServers ) ; 
this . iceServers = iceServers ; 
} public void addIceServers ( PeerConnection . IceServer iceServers ) { 
if ( this . iceServers == null ) { 
this . iceServers = new ArrayList < PeerConnection . IceServer > ( ) ; 
this . iceServers . add ( 0 , iceServers ) ; 
} boolean connect ( String userId ) { 
if ( ! peers . containsKey ( userId ) ) { 
if ( peers . size ( ) < MAX_CONNECTIONS ) { 
PnPeer peer = addPeer ( userId ) ; 
peer . pc . addStream ( this . localMediaStream ) ; 
actionMap . get ( CreateOfferAction . TRIGGER ) . execute ( userId , new JSONObject ( ) ) ; 
} catch ( JSONException e ) { 
} public void closeConnection ( String id ) { 
JSONObject packet = new JSONObject ( ) ; 
if ( ! this . peers . containsKey ( id ) ) return ; 
PnPeer peer = this . peers . get ( id ) ; 
peer . hangup ( ) ; 
packet . put ( PnRTCMessage . JSON_HANGUP , true ) ; 
transmitMessage ( id , packet ) ; 
mRtcListener . onPeerConnectionClosed ( peer ) ; 
} public void closeAllConnections ( ) { 
Iterator < String > peerIds = this . peers . keySet ( ) . iterator ( ) ; 
while ( peerIds . hasNext ( ) ) { 
closeConnection ( peerIds . next ( ) ) ; 
} void transmitMessage ( String toID , JSONObject packet ) { 
if ( this . id == null ) { 
JSONObject message = new JSONObject ( ) ; 
message . put ( PnRTCMessage . JSON_PACKET , packet ) ; 
message . put ( PnRTCMessage . JSON_ID , "" ) ; 
message . put ( PnRTCMessage . JSON_NUMBER , this . id ) ; 
this . mPubNub . publish ( toID , message , new Callback ( ) { 
public void successCallback ( String channel , Object message , String timetoken ) { 
mRtcListener . onDebug ( new PnRTCMessage ( ( JSONObject ) message ) ) ; 
public void errorCallback ( String channel , PubnubError error ) { 
mRtcListener . onDebug ( new PnRTCMessage ( error . errorObject ) ) ; 
} public static JSONObject generateUserMessage ( String userId , JSONObject message ) { 
JSONObject json = new JSONObject ( ) ; 
packet . put ( PnRTCMessage . JSON_USERMSG , message ) ; 
json . put ( PnRTCMessage . JSON_PACKET , packet ) ; 
json . put ( PnRTCMessage . JSON_ID , "" ) ; 
json . put ( PnRTCMessage . JSON_NUMBER , userId ) ; 
} public void transmit ( String userId , JSONObject message ) { 
JSONObject usrMsgJson = new JSONObject ( ) ; 
usrMsgJson . put ( PnRTCMessage . JSON_USERMSG , message ) ; 
this . pcClient . transmitMessage ( userId , usrMsgJson ) ; 
} public void transmitAll ( JSONObject message ) { 
List < PnPeer > peerList = this . pcClient . getPeers ( ) ; 
for ( PnPeer p : peerList ) { 
transmit ( p . getId ( ) , message ) ; 
} public Response setnx ( Object key , Object val ) { 
return req ( Cmd . setnx , bytes ( key ) , bytes ( val ) ) ; 
} public static final SSDB simple ( String host , int port , int timeout ) { 
return new SimpleClient ( host , port , timeout ) ; 
} public static final SSDB pool ( String host , int port , int timeout , Object config ) { 
return pool ( host , port , timeout , config , null ) ; 
} public static final SSDB pool ( String host , int port , int timeout , Object config , byte [ ] auth ) { 
return new SimpleClient ( _pool ( host , port , timeout , config , auth ) ) ; 
} public static final SSDB replication ( String masterHost , int masterPort , String slaveHost , int slavePort , int timeout , Object config ) { 
return replication ( masterHost , masterPort , slaveHost , slavePort , timeout , config , null , null ) ; 
} public static final SSDB replication ( String masterHost , int masterPort , String slaveHost , int slavePort , int timeout , Object config , byte [ ] masterAuth , byte [ ] slaveAuth ) { 
PoolSSDBStream master = _pool ( masterHost , masterPort , timeout , config , masterAuth ) ; 
PoolSSDBStream slave = _pool ( slaveHost , slavePort , timeout , config , slaveAuth ) ; 
return new SimpleClient ( new ReplicationSSDMStream ( master , slave ) ) ; 
} public static void writeBlock ( OutputStream out , byte [ ] data ) throws IOException { 
data = EMPTY_ARG ; 
out . write ( Integer . toString ( data . length ) . getBytes ( ) ) ; 
} public static void sendCmd ( OutputStream out , Cmd cmd , byte [ ] ... vals ) throws IOException { 
SSDBs . writeBlock ( out , cmd . bytes ( ) ) ; 
for ( byte [ ] bs : vals ) { 
SSDBs . writeBlock ( out , bs ) ; 
} public static Response readResp ( InputStream in ) throws IOException { 
Response resp = respFactory . make ( ) ; 
byte [ ] data = SSDBs . readBlock ( in ) ; 
resp . stat = new String ( data ) ; 
data = SSDBs . readBlock ( in ) ; 
resp . datas . add ( data ) ; 
return resp ; 
} @ PluginFactory 
@ SuppressWarnings ( "unused" ) 
public static GelfAppender createGelfAppender ( @ PluginElement ( "Filter" ) Filter filter , 
@ PluginElement ( "Layout" ) Layout < ? extends Serializable > layout , 
@ PluginElement ( value = "AdditionalFields" ) final KeyValuePair [ ] additionalFields , 
@ PluginAttribute ( value = "name" ) String name , 
@ PluginAttribute ( value = "ignoreExceptions" , defaultBoolean = true ) Boolean ignoreExceptions , 
@ PluginAttribute ( value = "server" , defaultString = "localhost" ) String server , 
@ PluginAttribute ( value = "port" , defaultInt = 12201 ) Integer port , 
@ PluginAttribute ( value = "protocol" , defaultString = "UDP" ) String protocol , 
@ PluginAttribute ( value = "hostName" ) String hostName , 
@ PluginAttribute ( value = "queueSize" , defaultInt = 512 ) Integer queueSize , 
@ PluginAttribute ( value = "connectTimeout" , defaultInt = 1000 ) Integer connectTimeout , 
@ PluginAttribute ( value = "reconnectDelay" , defaultInt = 500 ) Integer reconnectDelay , 
@ PluginAttribute ( value = "sendBufferSize" , defaultInt = - 1 ) Integer sendBufferSize , 
@ PluginAttribute ( value = "tcpNoDelay" , defaultBoolean = false ) Boolean tcpNoDelay , 
@ PluginAttribute ( value = "tcpKeepAlive" , defaultBoolean = false ) Boolean tcpKeepAlive , 
@ PluginAttribute ( value = "includeSource" , defaultBoolean = true ) Boolean includeSource , 
@ PluginAttribute ( value = "includeThreadContext" , defaultBoolean = true ) Boolean includeThreadContext , 
@ PluginAttribute ( value = "includeStackTrace" , defaultBoolean = true ) Boolean includeStackTrace , 
@ PluginAttribute ( value = "includeExceptionCause" , defaultBoolean = false ) Boolean includeExceptionCause , 
@ PluginAttribute ( value = "tlsEnabled" , defaultBoolean = false ) Boolean tlsEnabled , 
@ PluginAttribute ( value = "tlsEnableCertificateVerification" , defaultBoolean = true ) Boolean tlsEnableCertificateVerification , 
@ PluginAttribute ( value = "tlsTrustCertChainFilename" ) String tlsTrustCertChainFilename ) { 
if ( ! "UDP" . equalsIgnoreCase ( protocol ) && ! "TCP" . equalsIgnoreCase ( protocol ) ) { 
protocol = "UDP" ; 
if ( hostName == null || hostName . trim ( ) . isEmpty ( ) ) { 
final String canonicalHostName = InetAddress . getLocalHost ( ) . getCanonicalHostName ( ) ; 
if ( isFQDN ( canonicalHostName ) ) { 
hostName = canonicalHostName ; 
hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; 
} catch ( UnknownHostException e ) { 
hostName = "localhost" ; 
final InetSocketAddress serverAddress = new InetSocketAddress ( server , port ) ; 
final GelfTransports gelfProtocol = GelfTransports . valueOf ( protocol . toUpperCase ( ) ) ; 
final GelfConfiguration gelfConfiguration = new GelfConfiguration ( serverAddress ) 
. transport ( gelfProtocol ) 
. queueSize ( queueSize ) 
. connectTimeout ( connectTimeout ) 
. reconnectDelay ( reconnectDelay ) 
. sendBufferSize ( sendBufferSize ) 
. tcpNoDelay ( tcpNoDelay ) 
. tcpKeepAlive ( tcpKeepAlive ) ; 
if ( tlsEnabled ) { 
if ( gelfProtocol . equals ( GelfTransports . TCP ) ) { 
gelfConfiguration . enableTls ( ) ; 
if ( ! tlsEnableCertificateVerification ) { 
gelfConfiguration . disableTlsCertVerification ( ) ; 
if ( tlsEnableCertificateVerification && tlsTrustCertChainFilename != null ) { 
gelfConfiguration . tlsTrustCertChainFile ( new File ( tlsTrustCertChainFilename ) ) ; 
return new GelfAppender ( name , layout , filter , ignoreExceptions , gelfConfiguration , hostName , includeSource , 
includeThreadContext , includeStackTrace , additionalFields , includeExceptionCause ) ; 
} private boolean isRtl ( CharSequence text ) { 
if ( textDir == null ) { 
textDir = getTextDirectionHeuristic ( ) ; 
return textDir . isRtl ( text , 0 , text . length ( ) ) ; 
} private int getTextColor ( int item ) { 
int scrollX = getScrollX ( ) ; 
int color = textColor . getDefaultColor ( ) ; 
int itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; 
if ( scrollX > itemWithPadding * item - itemWithPadding / 2 && 
scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { 
int position = scrollX - itemWithPadding / 2 ; 
color = getColor ( position , item ) ; 
} else if ( item == pressedItem ) { 
color = textColor . getColorForState ( new int [ ] { android . R . attr . state_pressed } , color ) ; 
return color ; 
} public void setValues ( CharSequence [ ] values ) { 
if ( this . values != values ) { 
if ( this . values != null ) { 
layouts = new BoringLayout [ this . values . length ] ; 
for ( int i = 0 ; i < layouts . length ; i ++ ) { 
layouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 
1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; 
layouts = new BoringLayout [ 0 ] ; 
if ( getWidth ( ) > 0 ) { 
startMarqueeIfNeeded ( ) ; 
requestLayout ( ) ; 
invalidate ( ) ; 
} private int getColor ( int scrollX , int position ) { 
float proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; 
if ( proportion > .5 ) { 
proportion = ( proportion - .5f ) ; 
proportion = .5f - proportion ; 
proportion *= 2 ; 
int defaultColor ; 
int selectedColor ; 
if ( pressedItem == position ) { 
defaultColor = textColor . getColorForState ( new int [ ] { android . R . attr . state_pressed } , textColor . getDefaultColor ( ) ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { android . R . attr . state_pressed , android . R . attr . state_selected } , defaultColor ) ; 
defaultColor = textColor . getDefaultColor ( ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { android . R . attr . state_selected } , defaultColor ) ; 
return ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; 
} private void setTextSize ( float size ) { 
if ( size != textPaint . getTextSize ( ) ) { 
textPaint . setTextSize ( size ) ; 
} private int getInBoundsX ( int x ) { 
if ( x < 0 ) { 
x = 0 ; 
} else if ( x > ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ) { 
x = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; 
} private static String cleanPath ( String path ) { 
path = path == null ? "/" : path ; 
if ( ! path . startsWith ( "/" ) ) { 
path = path . replaceAll ( "/+" , "/" ) ; 
if ( path . length ( ) > 1 && path . endsWith ( "/" ) ) { 
RemoteServer . configureLogging ( ) ; 
RemoteServer server = new RemoteServer ( ) ; 
server . addLibrary ( MyRemoteLibrary . class , 8270 ) ; 
server . start ( ) ; 
} private String getIntro ( ) { 
InputStream introStream = MyRemoteLibrary . class . getResourceAsStream ( "__intro__.txt" ) ; 
StringWriter writer = new StringWriter ( ) ; 
IOUtils . copy ( introStream , writer , Charset . defaultCharset ( ) ) ; 
} public String [ ] get_keyword_names ( ) { 
String [ ] names = servlet . getLibrary ( ) . getKeywordNames ( ) ; 
if ( names == null || names . length == 0 ) 
String [ ] newNames = Arrays . copyOf ( names , names . length + 1 ) ; 
newNames [ names . length ] = "stop_remote_server" ; 
return newNames ; 
log . warn ( "" , e ) ; 
} public Map < String , Object > run_keyword ( String keyword , Object [ ] args , Map < String , Object > kwargs ) { 
StdStreamRedirecter redirector = new StdStreamRedirecter ( ) ; 
redirector . redirectStdStreams ( ) ; 
result . put ( "status" , "PASS" ) ; 
Object retObj = "" ; 
if ( keyword . equalsIgnoreCase ( "stop_remote_server" ) ) { 
retObj = stopRemoteServer ( ) ; 
retObj = servlet . getLibrary ( ) . runKeyword ( keyword , args , kwargs ) ; 
if ( illegalArgumentIn ( e ) ) { 
for ( int i = 0 ; i < args . length ; i ++ ) 
args [ i ] = arraysToLists ( args [ i ] ) ; 
throw ( e ) ; 
if ( retObj != null && ! retObj . equals ( "" ) ) { 
result . put ( "return" , retObj ) ; 
result . put ( "status" , "FAIL" ) ; 
Throwable thrown = e . getCause ( ) == null ? e : e . getCause ( ) ; 
result . put ( "error" , getError ( thrown ) ) ; 
result . put ( "traceback" , ExceptionUtils . getStackTrace ( thrown ) ) ; 
boolean continuable = isFlagSet ( "ROBOT_CONTINUE_ON_FAILURE" , thrown ) ; 
if ( continuable ) { 
result . put ( "continuable" , true ) ; 
boolean fatal = isFlagSet ( "ROBOT_EXIT_ON_FAILURE" , thrown ) ; 
if ( fatal ) { 
result . put ( "fatal" , true ) ; 
String stdOut = StringUtils . defaultString ( redirector . getStdOutAsString ( ) ) ; 
String stdErr = StringUtils . defaultString ( redirector . getStdErrAsString ( ) ) ; 
if ( ! stdOut . isEmpty ( ) || ! stdErr . isEmpty ( ) ) { 
StringBuilder output = new StringBuilder ( stdOut ) ; 
if ( ! stdOut . isEmpty ( ) && ! stdErr . isEmpty ( ) ) { 
if ( ! stdOut . endsWith ( "\n" ) ) { 
output . append ( "\n" ) ; 
boolean addLevel = true ; 
for ( String prefix : logLevelPrefixes ) { 
if ( stdErr . startsWith ( prefix ) ) { 
addLevel = false ; 
if ( addLevel ) { 
output . append ( "*INFO*" ) ; 
result . put ( "output" , output . append ( stdErr ) . toString ( ) ) ; 
redirector . resetStdStreams ( ) ; 
} public Map < String , Object > run_keyword ( String keyword , Object [ ] args ) { 
return run_keyword ( keyword , args , null ) ; 
} public String [ ] get_keyword_arguments ( String keyword ) { 
String [ ] args = servlet . getLibrary ( ) . getKeywordArguments ( keyword ) ; 
return args == null ? new String [ 0 ] : args ; 
} public String get_keyword_documentation ( String keyword ) { 
String doc = servlet . getLibrary ( ) . getKeywordDocumentation ( keyword ) ; 
return doc == null ? "" : doc ; 
configureLogging ( ) ; 
CommandLineHelper helper = new CommandLineHelper ( args ) ; 
if ( helper . getHelpRequested ( ) ) { 
System . out . print ( helper . getUsage ( ) ) ; 
RemoteServer remoteServer = new RemoteServer ( ) ; 
String error = helper . getError ( ) ; 
for ( String path : helper . getLibraryMap ( ) . keySet ( ) ) 
remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; 
} catch ( IllegalPathException e ) { 
error = e . getMessage ( ) ; 
if ( error != null ) { 
System . out . println ( helper . getUsage ( ) ) ; 
remoteServer . setPort ( helper . getPort ( ) ) ; 
remoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; 
remoteServer . setHost ( helper . getHost ( ) ) ; 
remoteServer . start ( ) ; 
} public RemoteLibrary putLibrary ( String path , Object library ) { 
RemoteLibrary oldLibrary = servlet . putLibrary ( path , library ) ; 
String name = servlet . getLibraryMap ( ) . get ( path ) . getName ( ) ; 
return oldLibrary ; 
public void addLibrary ( String className , int port ) { 
Class < ? > clazz ; 
addLibrary ( clazz , port ) ; 
public void addLibrary ( Class < ? > clazz , int port ) { 
if ( ! server . isStopped ( ) ) 
if ( connector . getPort ( ) != 0 && connector . getPort ( ) != port ) { 
if ( servlet . getLibraryMap ( ) . keySet ( ) . contains ( "/" ) ) { 
Object library ; 
library = clazz . newInstance ( ) ; 
setPort ( port ) ; 
putLibrary ( "/" , library ) ; 
} public void stop ( int timeoutMS ) throws Exception { 
if ( timeoutMS > 0 ) { 
server . setGracefulShutdown ( timeoutMS ) ; 
Thread stopper = new Thread ( ) { 
server . stop ( ) ; 
stopper . start ( ) ; 
} public void start ( ) throws Exception { 
} public static void configureLogging ( ) { 
Logger root = Logger . getRootLogger ( ) ; 
root . removeAllAppenders ( ) ; 
BasicConfigurator . configure ( ) ; 
root . setLevel ( Level . INFO ) ; 
org . eclipse . jetty . util . log . Log . setLog ( new Jetty2Log4J ( ) ) ; 
LogFactory . releaseAll ( ) ; 
LogFactory . getFactory ( ) . setAttribute ( "org.apache.commons.logging.Log" , 
"org.apache.commons.logging.impl.Log4JLogger" ) ; 
log = LogFactory . getLog ( RemoteServer . class ) ; 
public void removePrefixes ( ) { 
Map < String , Object > newHandlerMap = new HashMap < String , Object > ( ) ; 
for ( Entry < String , Object > entry : ( Set < Entry < String , Object > > ) this . handlerMap . entrySet ( ) ) { 
String newKey = ( String ) entry . getKey ( ) ; 
if ( entry . getKey ( ) instanceof String ) { 
String key = ( String ) entry . getKey ( ) ; 
if ( key . contains ( "." ) ) { 
newKey = key . substring ( key . lastIndexOf ( "." ) + 1 ) ; 
newHandlerMap . put ( newKey , entry . getValue ( ) ) ; 
this . handlerMap = newHandlerMap ; 
} public String convertPropertiesFromFileToJson ( String pathToFile , String ... includeDomainKeys ) throws ReadInputException , ParsePropertiesException { 
return convertPropertiesFromFileToJson ( new File ( pathToFile ) , includeDomainKeys ) ; 
} public String convertPropertiesFromFileToJson ( File file , String ... includeDomainKeys ) throws ReadInputException , ParsePropertiesException { 
InputStream targetStream = new FileInputStream ( file ) ; 
return convertToJson ( targetStream , includeDomainKeys ) ; 
throw new ReadInputException ( e ) ; 
} public String convertToJson ( InputStream inputStream , String ... includeDomainKeys ) throws ReadInputException , ParsePropertiesException { 
return convertToJson ( inputStreamToProperties ( inputStream ) , includeDomainKeys ) ; 
} public String convertToJson ( Properties properties ) throws ParsePropertiesException { 
if ( ! ( entry . getKey ( ) instanceof String ) ) { 
throw new ParsePropertiesException ( format ( PROPERTY_KEY_NEEDS_TO_BE_STRING_TYPE , 
entry . getKey ( ) . getClass ( ) , 
entry . getKey ( ) == null ? "null" : entry . getKey ( ) ) ) ; 
return convertFromValuesAsObjectMap ( propertiesToMap ( properties ) ) ; 
} public String convertToJson ( Map < String , String > properties ) throws ParsePropertiesException { 
return convertFromValuesAsObjectMap ( stringValueMapToObjectValueMap ( properties ) ) ; 
} public String convertFromValuesAsObjectMap ( Map < String , Object > properties ) throws ParsePropertiesException { 
ObjectJsonType coreObjectJsonType = new ObjectJsonType ( ) ; 
for ( String propertiesKey : getAllKeysFromProperties ( properties ) ) { 
addFieldsToJsonObject ( properties , coreObjectJsonType , propertiesKey ) ; 
return prettifyOfJson ( coreObjectJsonType . toStringJson ( ) ) ; 
} public String convertFromValuesAsObjectMap ( Map < String , Object > properties , String ... includeDomainKeys ) throws ParsePropertiesException { 
Map < String , Object > filteredProperties = new HashMap < > ( ) ; 
for ( String key : properties . keySet ( ) ) { 
for ( String requiredKey : includeDomainKeys ) { 
checkKey ( properties , filteredProperties , key , requiredKey ) ; 
return convertFromValuesAsObjectMap ( filteredProperties ) ; 
} public String convertToJson ( Properties properties , String ... includeDomainKeys ) throws ParsePropertiesException { 
return convertFromValuesAsObjectMap ( propertiesToMap ( properties ) , includeDomainKeys ) ; 
} private View wrapSliderContent ( View child , int index ) { 
if ( index == 1 && child . getId ( ) != - 1 ) { 
mLargeView = ( ViewGroup ) child ; 
mContainer = new ScrimInsetsRelativeLayout ( getContext ( ) ) ; 
mContainer . setGravity ( Gravity . START ) ; 
mContainer . setLayoutParams ( child . getLayoutParams ( ) ) ; 
mContainer . addView ( mLargeView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; 
mSmallView = new LinearLayout ( getContext ( ) ) ; 
mContainer . addView ( mSmallView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; 
mLargeView . setAlpha ( 0 ) ; 
mLargeView . setVisibility ( View . GONE ) ; 
mContainer . setFitsSystemWindows ( true ) ; 
mSmallView . setFitsSystemWindows ( true ) ; 
return mContainer ; 
} public void fadeUp ( int duration ) { 
mContainer . clearAnimation ( ) ; 
ResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMaxWidth , new ApplyTransformationListener ( ) { 
public void applyTransformation ( int width ) { 
overlapViews ( width ) ; 
anim . setDuration ( duration ) ; 
mContainer . startAnimation ( anim ) ; 
} public void fadeDown ( int duration ) { 
ResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMinWidth , new ApplyTransformationListener ( ) { 
} private float calculatePercentage ( int width ) { 
int absolute = mMaxWidth - mMinWidth ; 
int current = width - mMinWidth ; 
float percentage = 100.0f * current / absolute ; 
mIsCrossfaded = percentage > 90 ; 
return percentage ; 
} private void overlapViews ( int width ) { 
if ( width == mWidth ) { 
mWidth = width ; 
float percentage = calculatePercentage ( width ) ; 
float alpha = percentage / 100 ; 
mSmallView . setAlpha ( 1 ) ; 
mSmallView . setClickable ( false ) ; 
mLargeView . bringToFront ( ) ; 
mLargeView . setAlpha ( alpha ) ; 
mLargeView . setClickable ( true ) ; 
mLargeView . setVisibility ( alpha > 0.01f ? View . VISIBLE : View . GONE ) ; 
if ( mCrossfadeListener != null ) { 
mCrossfadeListener . onCrossfade ( mContainer , calculatePercentage ( width ) , width ) ; 
} public static SPARQLQueryDefinition bindObject ( SPARQLQueryDefinition qdef , 
String variableName , Node objectNode ) { 
SPARQLBindings bindings = qdef . getBindings ( ) ; 
if ( objectNode . isURI ( ) ) { 
bindings . bind ( variableName , objectNode . getURI ( ) ) ; 
} else if ( objectNode . isLiteral ( ) ) { 
if ( ! "" . equals ( objectNode . getLiteralLanguage ( ) ) ) { 
String languageTag = objectNode . getLiteralLanguage ( ) ; 
bindings . bind ( variableName , objectNode . getLiteralLexicalForm ( ) , 
Locale . forLanguageTag ( languageTag ) ) ; 
} else if ( objectNode . getLiteralDatatype ( ) != null ) { 
String xsdType = objectNode . getLiteralDatatypeURI ( ) ; 
String fragment = new URI ( xsdType ) . getFragment ( ) ; 
bindings . bind ( variableName , 
objectNode . getLiteralLexicalForm ( ) , 
RDFTypes . valueOf ( fragment . toUpperCase ( ) ) ) ; 
throw new MarkLogicJenaException ( 
RDFTypes . STRING ) ; 
qdef . setBindings ( bindings ) ; 
return qdef ; 
protected void addToDftGraph ( Node s , Node p , Node o ) { 
checkIsOpen ( ) ; 
Node s1 = skolemize ( s ) ; 
Node p1 = skolemize ( p ) ; 
Node o1 = skolemize ( o ) ; 
client . sinkQuad ( null , s1 , p1 , o1 ) ; 
} public void mergeGraph ( Node graphName , Graph graph ) { 
sync ( ) ; 
client . mergeGraph ( graphName . getURI ( ) , graph ) ; 
} public void addPermissions ( Node graphName , GraphPermissions permissions ) { 
client . mergeGraphPermissions ( graphName . getURI ( ) , permissions ) ; 
} public void writePermissions ( Node graphName , GraphPermissions permissions ) { 
client . writeGraphPermissions ( graphName . getURI ( ) , permissions ) ; 
} public MarkLogicDatasetGraph withRulesets ( SPARQLRuleset ... rulesets ) { 
if ( this . rulesets == null ) { 
this . rulesets = rulesets ; 
Collection < SPARQLRuleset > collection = new ArrayList < SPARQLRuleset > ( ) ; 
collection . addAll ( Arrays . asList ( this . rulesets ) ) ; 
collection . addAll ( Arrays . asList ( rulesets ) ) ; 
this . rulesets = collection . toArray ( new SPARQLRuleset [ ] { } ) ; 
if ( writeBuffer != null ) { 
writeBuffer . cancel ( ) ; 
client = null ; 
} public synchronized InputStreamHandle executeSelect ( SPARQLQueryDefinition qdef , 
InputStreamHandle handle , Long offset , Long limit ) { 
if ( limit == null ) { 
this . sparqlQueryManager . clearPageLength ( ) ; 
this . sparqlQueryManager . setPageLength ( limit ) ; 
if ( offset != null ) { 
return this . sparqlQueryManager . executeSelect ( qdef , handle , offset , 
currentTransaction ) ; 
return this . sparqlQueryManager . executeSelect ( qdef , handle , 
} public void sinkQuad ( Node g , Node s , Node p , Node o ) { 
writeBuffer . add ( g , s , p , o ) ; 
Graph graph = GraphFactory . createDefaultGraph ( ) ; 
graph . add ( Triple . create ( s , p , o ) ) ; 
mergeGraph ( g . getURI ( ) , graph ) ; 
} public static MarkLogicDatasetGraph createDatasetGraph ( DatabaseClient client ) { 
JenaDatabaseClient jenaClient = new JenaDatabaseClient ( client ) ; 
MarkLogicDatasetGraph datasetGraph = new MarkLogicDatasetGraph ( 
jenaClient ) ; 
MarkLogicQueryEngine . unregister ( ) ; 
MarkLogicQueryEngine . register ( ) ; 
MarkLogicUpdateEngine . unregister ( ) ; 
MarkLogicUpdateEngine . register ( ) ; 
return datasetGraph ; 
} static public MarkLogicDatasetGraph createDatasetGraph ( String host , 
int port , String user , String password , Authentication type ) { 
DatabaseClient client = DatabaseClientFactory . newClient ( host , port , 
user , password , type ) ; 
return MarkLogicDatasetGraphFactory . createDatasetGraph ( client ) ; 
} public static String parseSaveAttr ( final Cell cell , final Map < String , String > saveCommentsMap ) { 
if ( cell != null ) { 
String key = cell . getSheet ( ) . getSheetName ( ) + "!" 
+ CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; 
String saveAttr = null ; 
if ( saveCommentsMap != null ) { 
saveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; 
if ( ( saveAttr == null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) { 
saveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; 
if ( ( saveAttr != null ) && ( ! saveAttr . isEmpty ( ) ) ) { 
return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + "=" + saveAttr + "," ; 
} public static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , 
final String strValue , final ExpressionEngine engine ) { 
int index = saveAttr . lastIndexOf ( '.' ) ; 
String strObject = saveAttr . substring ( 0 , index ) ; 
String strMethod = saveAttr . substring ( index + 1 ) ; 
strObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; 
Object object = CommandUtility . evaluate ( strObject , context , engine ) ; 
CellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; 
} public static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , 
final Row row , final ExpressionEngine engine ) { 
if ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { 
int ipos = fullSaveAttr . indexOf ( '=' ) ; 
if ( ipos > 0 ) { 
String columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; 
String saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; 
Cell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; 
if ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { 
CommandUtility . evaluateNormalCells ( cell , 
TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; 
} public static String parseSaveAttrString ( final String strValue ) { 
if ( strValue != null ) { 
int first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; 
int last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; 
int end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; 
if ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) { 
return strValue . substring ( first + 2 , end ) ; 
} public static String getSaveAttrListFromRow ( final Row row ) { 
if ( row != null ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; 
String str = cell . getStringCellValue ( ) ; 
if ( ( str != null ) && ( ! str . isEmpty ( ) ) ) { 
return str ; 
} public static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { 
if ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { 
String str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + "=" ; 
int istart = saveAttrs . indexOf ( str ) ; 
if ( istart >= 0 ) { 
int iend = saveAttrs . indexOf ( ',' , istart ) ; 
if ( iend > istart ) { 
return saveAttrs . substring ( istart + str . length ( ) , iend ) ; 
} public static String getColumnIndexFromSaveAttr ( final String saveAttr ) { 
int iend = saveAttr . indexOf ( '=' ) ; 
if ( iend > 0 ) { 
int istart = saveAttr . indexOf ( '$' ) ; 
return saveAttr . substring ( istart + 1 , iend ) ; 
} public static boolean isHasSaveAttr ( final Cell cell ) { 
Cell saveAttrCell = cell . getRow ( ) . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; 
if ( saveAttrCell != null ) { 
return isHasSaveAttr ( cell , saveAttrCell . getStringCellValue ( ) ) ; 
} public static boolean isHasSaveAttr ( final Cell cell , final String saveAttrs ) { 
int columnIndex = cell . getColumnIndex ( ) ; 
if ( ( saveAttrs != null ) && ( saveAttrs . indexOf ( str ) >= 0 ) ) { 
} public static void setSaveObjectsInHiddenColumn ( final Row row , final String saveAttr ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
cell . setCellValue ( saveAttr ) ; 
} public static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , 
final Map < String , String > saveCommentsMap ) { 
for ( Row row : sheet ) { 
int rowIndex = row . getRowNum ( ) ; 
if ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) { 
setSaveAttrsForRow ( row , saveCommentsMap ) ; 
} public static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { 
StringBuilder saveAttr = new StringBuilder ( ) ; 
for ( Cell cell : row ) { 
String sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; 
if ( ! sAttr . isEmpty ( ) ) { 
saveAttr . append ( sAttr ) ; 
if ( saveAttr . length ( ) > 0 ) { 
SaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; 
} public static String prepareContextAndAttrsForCell ( Cell poiCell , String fullName , CellHelper cellHelper ) { 
if ( fullName == null ) { 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( poiCell . getRow ( ) ) ; 
if ( saveAttrList != null ) { 
String saveAttr = SaveAttrsUtility . getSaveAttrFromList ( poiCell . getColumnIndex ( ) , saveAttrList ) ; 
if ( saveAttr != null ) { 
cellHelper . restoreDataContext ( fullName ) ; 
return saveAttr ; 
public List getSerListFromCtObjChart ( final Object ctObjChart ) { 
if ( ctObjChart instanceof CTPieChart ) { 
return ( ( CTPieChart ) ctObjChart ) . getSerList ( ) ; 
return this . getEmptySerlist ( ) ; 
public final CTShapeProperties getShapePropertiesFromCTSer ( 
final Object ctObjSer ) { 
if ( ctObjSer instanceof CTPieSer ) { 
return ( ( CTPieSer ) ctObjSer ) . getSpPr ( ) ; 
public final CTNumDataSource getCTNumDataSourceFromCTSer ( 
return ( ( CTPieSer ) ctObjSer ) . getVal ( ) ; 
public final List < CTDPt > getDPtListFromCTSer ( final Object ctObjSer ) { 
List < CTDPt > dptList = ( ( CTPieSer ) ctObjSer ) . getDPtList ( ) ; 
if ( dptList == null ) { 
dptList = new ArrayList < > ( ) ; 
return dptList ; 
return this . getEmptyDptlist ( ) ; 
} protected final int calcLength ( final String lengthStr ) { 
return Integer . parseInt ( lengthStr ) ; 
LOG . log ( Level . FINE , 
public final Object getAsObject ( final FacesContext context , 
final UIComponent component , final String value ) { 
Double doubleValue = 0.0 ; 
String symbol = "" ; 
String strValue = value ; 
symbol = ( String ) component . getAttributes ( ) 
. get ( TieConstants . CELL_DATA_SYMBOL ) ; 
if ( ( symbol != null ) && ( symbol 
. equals ( TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL ) 
&& strValue != null ) ) { 
strValue = strValue . trim ( ) ; 
if ( strValue . endsWith ( 
TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL ) ) { 
doubleValue = Double . valueOf ( 
strValue . substring ( 0 , strValue . length ( ) - 1 ) ) 
/ TieConstants . CELL_FORMAT_PERCENTAGE_VALUE ; 
strValue = doubleValue . toString ( ) ; 
LOG . log ( Level . SEVERE , 
+ ex . getLocalizedMessage ( ) , 
return strValue ; 
} private String fmtNumber ( final double d ) { 
if ( Double . compare ( d % 1 , 0 ) == 0 ) { 
return String . format ( "%d" , ( int ) d ) ; 
return String . format ( "%.2f" , d ) ; 
public final String getAsString ( final FacesContext context , 
final UIComponent component , final Object value ) { 
String strValue = null ; 
strValue = ( String ) value ; 
if ( ( symbol != null ) 
&& ( symbol 
. equals ( TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL ) ) 
&& ( value != null ) && ! ( ( String ) value ) . isEmpty ( ) ) { 
Double doubleValue = Double . valueOf ( ( String ) value ) 
* TieConstants . CELL_FORMAT_PERCENTAGE_VALUE ; 
strValue = fmtNumber ( doubleValue ) 
+ TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL ; 
} private void writeObject ( final java . io . ObjectOutputStream out ) 
saveList = new ArrayList < > ( ) ; 
for ( Map . Entry < Cell , String > entry : this . getMap ( ) . entrySet ( ) ) { 
saveList . add ( 
new SerialKey ( new SerialCellAddress ( entry . getKey ( ) ) , 
entry . getValue ( ) ) ) ; 
} public void recover ( final Sheet sheet ) { 
if ( ! this . getMap ( ) . isEmpty ( ) ) { 
for ( SerialKey entry : this . saveList ) { 
SerialCellAddress skey = entry . getKey ( ) ; 
map . put ( sheet . getRow ( skey . getRow ( ) ) . getCell ( skey . getColumn ( ) ) , 
} public final void putShiftAttrs ( final String fullName , 
final ConfigRangeAttrs attrs , 
final RowsMapping unitRowsMapping ) { 
attrs . setUnitRowsMapping ( unitRowsMapping ) ; 
this . shiftMap . put ( fullName , attrs ) ; 
} public void setWb ( final Workbook pWb ) { 
this . getSerialWb ( ) . setWb ( pWb ) ; 
this . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) pWb ) ; 
} public XSSFEvaluationWorkbook getWbWrapper ( ) { 
if ( ( this . wbWrapper == null ) && ( this . getWb ( ) != null ) ) { 
this . wbWrapper = XSSFEvaluationWorkbook 
. create ( ( XSSFWorkbook ) this . getWb ( ) ) ; 
return wbWrapper ; 
} public FormulaEvaluator getFormulaEvaluator ( ) { 
if ( ( this . formulaEvaluator == null ) && ( this . getWb ( ) != null ) ) { 
this . formulaEvaluator = this . getWb ( ) . getCreationHelper ( ) 
. createFormulaEvaluator ( ) ; 
return formulaEvaluator ; 
} public void reCalcMaxColCounts ( ) { 
if ( ( this . getSheetConfigMap ( ) == null ) 
|| ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { 
this . maxColCounts = 0 ; 
int maxColumns = 0 ; 
for ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) 
int counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) 
- sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; 
if ( maxColumns < counts ) { 
maxColumns = counts ; 
this . maxColCounts = maxColumns ; 
} public int loadWebSheet ( final InputStream inputStream , 
final Map < String , Object > pDataContext ) { 
return this . getHelper ( ) . getWebSheetLoader ( ) 
. loadWorkbook ( inputStream , pDataContext ) ; 
} public int loadWebSheet ( final Workbook pWb , 
return this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkbook ( pWb , 
pDataContext ) ; 
} public void onTabChange ( final TabChangeEvent event ) { 
String tabName = event . getTab ( ) . getTitle ( ) ; 
loadWorkSheetByTabName ( tabName ) ; 
} public int loadWorkSheetByTabName ( final String tabName ) { 
int sheetId = this . getHelper ( ) . getWebSheetLoader ( ) 
. findTabIndexWithName ( tabName ) ; 
if ( ( getSheetConfigMap ( ) != null ) 
&& ( sheetId < getSheetConfigMap ( ) . size ( ) ) ) { 
this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; 
setActiveTabIndex ( sheetId ) ; 
+ ex . getMessage ( ) , ex ) ; 
} public void doExport ( ) { 
String fileName = this . getExportFileName ( ) ; 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
this . getWb ( ) . write ( out ) ; 
InputStream stream = new BufferedInputStream ( 
new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; 
exportFile = new DefaultStreamedContent ( stream , 
"application/force-download" , fileName ) ; 
} public void doSave ( ) { 
this . setSubmitMde ( false ) ; 
if ( ! this . getHelper ( ) . getValidationHandler ( ) . preValidation ( ) ) { 
processSave ( ) ; 
this . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( 
RequestContext . getCurrentInstance ( ) , false ) ; 
} public void doSubmit ( ) { 
this . setSubmitMde ( true ) ; 
processSubmit ( ) ; 
} public void populateComponent ( final ComponentSystemEvent event ) { 
UIComponent component = event . getComponent ( ) ; 
int [ ] rowcol = CellUtility 
. getRowColFromComponentAttributes ( component ) ; 
int row = rowcol [ 0 ] ; 
int col = rowcol [ 1 ] ; 
FacesCell fcell = CellUtility . getFacesCellFromBodyRow ( row , col , 
this . getBodyRows ( ) , this . getCurrent ( ) . getCurrentTopRow ( ) , 
this . getCurrent ( ) . getCurrentLeftColumn ( ) ) ; 
CellControlsUtility . populateAttributes ( component , fcell , 
this . getCellDefaultControl ( ) ) ; 
} public SheetConfiguration getCurrentSheetConfig ( ) { 
String currentTabName = this . getCurrent ( ) . getCurrentTabName ( ) ; 
if ( currentTabName == null ) { 
return this . getSheetConfigMap ( ) . get ( currentTabName ) ; 
} private void readObject ( final java . io . ObjectInputStream in ) 
recover ( ) ; 
} catch ( EncryptedDocumentException | ClassNotFoundException e ) { 
+ e . getLocalizedMessage ( ) , 
String pattern = ( String ) component . getAttributes ( ) . get ( "pattern" ) ; 
SimpleDateFormat formatter = new SimpleDateFormat ( pattern , 
getLocale ( context , component ) ) ; 
return formatter . parse ( value ) ; 
throw new ConverterException ( 
return ( String ) value ; 
if ( context == null || component == null ) { 
String pattern = ( String ) component . getAttributes ( ) 
. get ( TieConstants . WIDGET_ATTR_PATTERN ) ; 
SimpleDateFormat dateFormat = new SimpleDateFormat ( pattern , 
return dateFormat . format ( value ) ; 
throw new ConverterException ( e ) ; 
} private Locale getLocale ( final FacesContext context , 
final UIComponent component ) { 
String localeStr = ( String ) component . getAttributes ( ) 
. get ( TieConstants . COMPONENT_ATTR_LOCALE ) ; 
if ( localeStr == null ) { 
return context . getViewRoot ( ) . getLocale ( ) ; 
return Locale . forLanguageTag ( localeStr ) ; 
} public StreamedContent getPicture ( ) { 
FacesContext context = FacesContext . getCurrentInstance ( ) ; 
if ( context . getCurrentPhaseId ( ) == PhaseId . RENDER_RESPONSE ) { 
return new DefaultStreamedContent ( ) ; 
String pictureId = context . getExternalContext ( ) 
. getRequestParameterMap ( ) . get ( "pictureViewId" ) ; 
PictureData picData = ( PictureData ) FacesContext 
. getCurrentInstance ( ) . getExternalContext ( ) 
. getSessionMap ( ) . get ( pictureId ) ; 
FacesContext . getCurrentInstance ( ) . getExternalContext ( ) 
. getSessionMap ( ) . remove ( pictureId ) ; 
return new DefaultStreamedContent ( new ByteArrayInputStream ( 
picData . getData ( ) ) ) ; 
} public final CellHelper getCellHelper ( ) { 
if ( ( this . cellHelper == null ) && ( this . parent != null ) ) { 
this . cellHelper = new CellHelper ( parent ) ; 
return cellHelper ; 
} public final PicturesHelper getPicHelper ( ) { 
if ( ( this . picHelper == null ) && ( this . parent != null ) ) { 
this . picHelper = new PicturesHelper ( parent ) ; 
return picHelper ; 
} public final ValidationHandler getValidationHandler ( ) { 
if ( ( this . validationHandler == null ) && ( this . parent != null ) ) { 
this . validationHandler = new ValidationHandler ( parent ) ; 
return validationHandler ; 
} public final ChartHelper getChartHelper ( ) { 
if ( ( this . chartHelper == null ) && ( this . parent != null ) ) { 
this . chartHelper = new ChartHelper ( parent ) ; 
return chartHelper ; 
} public static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , 
final ShiftFormulaRef shiftFormulaRef ) { 
List < Ptg > newPtgList = new ArrayList < > ( ) ; 
Object ptg ; 
for ( int k = 0 ; k < ptgs . length ; ++ k ) { 
ptg = ptgs [ k ] ; 
newPtgList . addAll ( Arrays 
. asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; 
return newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; 
} public static int getFirstSupportedRowNumFromPtg ( final Object ptg ) { 
int rCode = - 1 ; 
if ( ptg instanceof RefPtgBase ) { 
if ( ! ( ptg instanceof Ref3DPxg ) && ! ( ptg instanceof Ref3DPtg ) ) { 
rCode = ( ( RefPtgBase ) ptg ) . getRow ( ) ; 
} else if ( ptg instanceof AreaPtgBase && ! ( ptg instanceof Area3DPxg ) 
&& ! ( ptg instanceof Area3DPtg ) ) { 
rCode = ( ( AreaPtgBase ) ptg ) . getFirstRow ( ) ; 
return rCode ; 
} private static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , 
final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { 
byte originalOperandClass = - 1 ; 
if ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { 
originalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; 
int currentRow ; 
currentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( ( currentRow >= 0 ) 
&& shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { 
return convertPtgForWatchList ( ptgs , position , shiftFormulaRef , 
ptg , originalOperandClass , currentRow ) ; 
if ( ( ptg instanceof AttrPtg ) 
&& ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { 
AttrPtg newPtg = ( AttrPtg ) ptg ; 
if ( newPtg . isSum ( ) ) { 
FuncVarPtg fptg = FuncVarPtg . create ( "sum" , 
shiftFormulaRef . getFormulaChanged ( ) ) ; 
return singlePtg ( fptg , fptg . getPtgClass ( ) , 
return singlePtg ( ptg , originalOperandClass , 
} private static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , 
final int position , final ShiftFormulaRef shiftFormulaRef , 
final Object ptg , final byte originalOperandClass , 
final int currentRow ) { 
List < SerialRow > rowlist = getRowsList ( currentRow , 
shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; 
if ( ( rowlist == null ) || ( rowlist . isEmpty ( ) ) ) { 
return singlePtg ( ptg , originalOperandClass , - 1 ) ; 
shiftFormulaRef . setFormulaChanged ( 1 ) ; 
if ( ( rowlist . size ( ) == 1 ) || ( ( position + 1 ) >= ptgs . length ) 
|| ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) { 
return singlePtg ( 
fixupRefRelativeRowOneToOne ( ptg , 
rowlist . get ( 0 ) . getRow ( ) ) , 
originalOperandClass , - 1 ) ; 
shiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; 
return fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , 
rowlist , ptgs , position ) ; 
} private static Ptg [ ] singlePtg ( final Object ptg , 
final byte originalOperandClass , final int formulaChanged ) { 
Ptg [ ] newPtg = new Ptg [ 1 ] ; 
if ( originalOperandClass != ( - 1 ) ) { 
( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; 
Object ptgAfter = ptg ; 
if ( ptg instanceof FuncVarPtg ) { 
FuncVarPtg fptg = ( FuncVarPtg ) ptg ; 
if ( ( formulaChanged > 0 ) 
&& ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) { 
ptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , 
formulaChanged ) ; 
newPtg [ 0 ] = ( Ptg ) ptgAfter ; 
return newPtg ; 
} private static List < SerialRow > getRowsList ( final int currentRow , 
final List < RowsMapping > currentRowsMappingList ) { 
List < SerialRow > all = null ; 
int size = currentRowsMappingList . size ( ) ; 
for ( RowsMapping rowsmapping : currentRowsMappingList ) { 
List < SerialRow > current = rowsmapping . get ( currentRow ) ; 
if ( current != null ) { 
all = assembleRowsListFromRowsMapping ( all , current ) ; 
} private static List < SerialRow > assembleRowsListFromRowsMapping ( 
final List < SerialRow > all , final List < SerialRow > current ) { 
List < SerialRow > list ; 
if ( all == null ) { 
list . addAll ( current ) ; 
list = all ; 
for ( SerialRow row : current ) { 
if ( ! all . contains ( row ) ) { 
list . add ( row ) ; 
} protected static Object fixupRefRelativeRowOneToOne ( final Object ptg , 
final Row newRow ) { 
if ( ptg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; 
Ref3DPxg new3dpxg = new Ref3DPxg ( 
ref3dPxg . getExternalWorkbookNumber ( ) , 
new SheetIdentifier ( null , 
new NameIdentifier ( ref3dPxg . getSheetName ( ) , 
false ) ) , 
new CellReference ( newRow . getRowNum ( ) , 
ref3dPxg . getColumn ( ) ) ) ; 
new3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; 
new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; 
return new3dpxg ; 
RefPtgBase refPtgBase = ( RefPtgBase ) ptg ; 
return new RefPtg ( newRow . getRowNum ( ) , 
refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , 
refPtgBase . isColRelative ( ) ) ; 
if ( ptg instanceof Area3DPxg ) { 
Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; 
Area3DPxg new3dpxg = new Area3DPxg ( 
area3dPxg . getExternalWorkbookNumber ( ) , 
new NameIdentifier ( area3dPxg . getSheetName ( ) , 
area3dPxg . format2DRefAsString ( ) ) ; 
new3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setFirstColRelative ( 
area3dPxg . isFirstColRelative ( ) ) ; 
new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; 
int shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; 
new3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; 
new3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; 
new3dpxg . setFirstRowRelative ( 
area3dPxg . isFirstRowRelative ( ) ) ; 
new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; 
AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; 
int shiftRow = newRow . getRowNum ( ) 
- areaPtgBase . getFirstRow ( ) ; 
return new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , 
areaPtgBase . getLastRow ( ) + shiftRow , 
areaPtgBase . getFirstColumn ( ) , 
areaPtgBase . getLastColumn ( ) , 
areaPtgBase . isFirstRowRelative ( ) , 
areaPtgBase . isLastRowRelative ( ) , 
areaPtgBase . isFirstColRelative ( ) , 
areaPtgBase . isLastColRelative ( ) ) ; 
} protected static Ptg [ ] fixupRefRelativeRowOneToMany ( final Object ptg , 
final byte originalOperandClass , final List < SerialRow > rowList , 
final Ptg [ ] ptgs , final int position ) { 
int size = rowList . size ( ) ; 
Ptg [ ] newPtg = null ; 
if ( isFollowedByValueOperator ( ptgs , position ) ) { 
newPtg = new Ptg [ size + 1 ] ; 
buildDynamicRowForRefPtgBase ( ptg , originalOperandClass , 
rowList , newPtg , false ) ; 
newPtg [ rowList . size ( ) ] = AddPtg . instance ; 
newPtg = new Ptg [ ( size * 2 ) - 1 ] ; 
rowList , newPtg , true ) ; 
buildDynamicRowForAreaPtgBase ( ptg , originalOperandClass , 
rowList , newPtg ) ; 
} private static void buildDynamicRowForRefPtgBase ( final Object ptg , 
final Ptg [ ] newPtg , final boolean includeParenthesis ) { 
RefPtgBase refPtg = ( RefPtgBase ) ptg ; 
int unitSize = 1 ; 
if ( includeParenthesis ) { 
unitSize = 2 ; 
for ( int i = 0 ; i < rowList . size ( ) ; i ++ ) { 
Row row = rowList . get ( i ) . getRow ( ) ; 
if ( refPtg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; 
new CellReference ( row . getRowNum ( ) , 
new3dpxg . setClass ( originalOperandClass ) ; 
newPtg [ i * unitSize ] = new3dpxg ; 
RefPtgBase refPtgBase = refPtg ; 
newPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , 
if ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { 
newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; 
} private static void buildDynamicRowForAreaPtgBase ( final Object ptg , 
final Ptg [ ] newPtg ) { 
AreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; 
int originFirstRow = areaPtg . getFirstRow ( ) ; 
int originLastRow = areaPtg . getLastRow ( ) ; 
int unitSize = 2 ; 
int shiftRow = row . getRowNum ( ) - originFirstRow ; 
new3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; 
new3dpxg . setLastRow ( originLastRow + shiftRow ) ; 
newPtg [ i * unitSize ] = new AreaPtg ( 
originFirstRow + shiftRow , originLastRow + shiftRow , 
if ( i < ( rowList . size ( ) - 1 ) ) { 
} private static boolean isFollowedByValueOperator ( final Ptg [ ] ptgs , 
final int position ) { 
for ( int i = position ; i < ptgs . length ; i ++ ) { 
Object ptg = ptgs [ position ] ; 
if ( ptg instanceof OperationPtg ) { 
return ptg instanceof ValueOperatorPtg ; 
} else if ( ptg instanceof AttrPtg ) { 
} public static XColor getBgColor ( final CTPlotArea ctPlot , 
final ThemesTable themeTable ) { 
CTSolidColorFillProperties colorFill = null ; 
colorFill = ctPlot . getSpPr ( ) . getSolidFill ( ) ; 
XColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; 
if ( xcolor != null ) { 
return xcolor ; 
return new XColor ( new XSSFColor ( Color . WHITE ) ) ; 
} public static XColor geColorFromSpPr ( final int index , 
final CTShapeProperties ctSpPr , final ThemesTable themeTable , 
final boolean isLineColor ) { 
if ( isLineColor ) { 
colorFill = ctSpPr . getLn ( ) . getSolidFill ( ) ; 
colorFill = ctSpPr . getSolidFill ( ) ; 
return getXColorWithAutomaticFill ( index , themeTable ) ; 
} private static XColor findAutomaticFillColor ( final ThemesTable themeTable , 
final CTSolidColorFillProperties colorFill ) { 
if ( colorFill == null ) { 
CTSchemeColor ctsColor = colorFill . getSchemeClr ( ) ; 
if ( ctsColor != null ) { 
return getXColorFromSchemeClr ( ctsColor , themeTable ) ; 
CTSRgbColor ctrColor = colorFill . getSrgbClr ( ) ; 
if ( ctrColor != null ) { 
return getXColorFromRgbClr ( ctrColor ) ; 
} private static XColor assembleXcolor ( final XSSFColor bcolor , 
final double preTint , final int lumOff , final int lumMod , 
final int alphaInt ) { 
if ( bcolor == null ) { 
double tint = preTint ; 
if ( Double . compare ( tint , 0 ) == 0 ) { 
if ( lumOff > 0 ) { 
tint = lumOff / MILLION_NUMBERS ; 
if ( lumMod > 0 ) { 
tint = - 1 * ( lumMod / MILLION_NUMBERS ) ; 
bcolor . setTint ( tint ) ; 
double alpha = 0 ; 
if ( alphaInt > 0 ) { 
alpha = alphaInt / MILLION_NUMBERS ; 
return new XColor ( bcolor , alpha ) ; 
} private static XColor getXColorFromSchemeClr ( 
final CTSchemeColor ctsColor , final ThemesTable themeTable ) { 
if ( ctsColor . getVal ( ) != null ) { 
return getXColorWithSchema ( ctsColor . getVal ( ) . toString ( ) , 0 , 
ctsColor , themeTable ) ; 
} private static XColor getXColorWithSchema ( final String colorSchema , 
final double preTint , final CTSchemeColor ctsColor , 
int colorIndex = getThemeIndexFromName ( colorSchema ) ; 
if ( colorIndex < 0 ) { 
XSSFColor bcolor = themeTable . getThemeColor ( colorIndex ) ; 
int lumOff = 0 ; 
int lumMod = 0 ; 
int alphaInt = 0 ; 
lumOff = ctsColor . getLumOffArray ( 0 ) . getVal ( ) ; 
lumMod = ctsColor . getLumModArray ( 0 ) . getVal ( ) ; 
alphaInt = ctsColor . getAlphaArray ( 0 ) . getVal ( ) ; 
return assembleXcolor ( bcolor , preTint , lumOff , lumMod , alphaInt ) ; 
} private static XColor getXColorFromRgbClr ( final CTSRgbColor ctrColor ) { 
XSSFColor bcolor = null ; 
byte [ ] rgb = ctrColor . getVal ( ) ; 
bcolor = new XSSFColor ( rgb ) ; 
+ ex . getLocalizedMessage ( ) , ex ) ; 
int alphaStr = 0 ; 
lumOff = ctrColor . getLumOffArray ( 0 ) . getVal ( ) ; 
lumMod = ctrColor . getLumModArray ( 0 ) . getVal ( ) ; 
alphaStr = ctrColor . getAlphaArray ( 0 ) . getVal ( ) ; 
return assembleXcolor ( bcolor , 0 , lumOff , lumMod , alphaStr ) ; 
} private static XColor getXColorWithAutomaticFill ( final int index , 
int reminder = ( index + 1 ) % AUTOCOLORSIZE ; 
if ( reminder == 0 ) { 
reminder = AUTOCOLORSIZE ; 
String schema = AUTOCOLORNAME + reminder ; 
double tint = getAutomaticTint ( index ) ; 
return getXColorWithSchema ( schema , tint , null , themeTable ) ; 
} private static double getAutomaticTint ( final int index ) { 
final double [ ] idxArray = { 0 , 0.25 , 0.5 , - 0.25 , - 0.5 , 0.1 , 0.3 , 
- 0.1 , - 0.3 } ; 
int i = index / AUTOCOLORSIZE ; 
if ( i >= idxArray . length ) { 
return idxArray [ i ] ; 
} public static Color xssfClrToClr ( final XSSFColor xssfColor ) { 
short [ ] rgb = getTripletFromXSSFColor ( xssfColor ) ; 
return new Color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; 
} private static int getThemeIndexFromName ( final String idxName ) { 
final String [ ] idxArray = { "bg1" , "tx1" , "bg2" , "tx2" , "accent1" , 
"accent2" , "accent3" , "accent4" , "accent5" , "accent6" , 
"hlink" , "folHlink" } ; 
for ( int i = 0 ; i < idxArray . length ; i ++ ) { 
if ( idxArray [ i ] . equalsIgnoreCase ( idxName ) ) { 
} public static short [ ] getTripletFromXSSFColor ( 
final XSSFColor xssfColor ) { 
short [ ] rgbfix = { RGB8BITS , RGB8BITS , RGB8BITS } ; 
if ( xssfColor != null ) { 
byte [ ] rgb = xssfColor . getRGBWithTint ( ) ; 
if ( rgb == null ) { 
rgb = xssfColor . getRGB ( ) ; 
rgbfix [ 0 ] = ( short ) ( ( rgb [ 0 ] < 0 ) ? ( rgb [ 0 ] + RGB8BITS ) 
: rgb [ 0 ] ) ; 
rgbfix [ 1 ] = ( short ) ( ( rgb [ 1 ] < 0 ) ? ( rgb [ 1 ] + RGB8BITS ) 
: rgb [ 1 ] ) ; 
rgbfix [ 2 ] = ( short ) ( ( rgb [ 2 ] < 0 ) ? ( rgb [ 2 ] + RGB8BITS ) 
: rgb [ 2 ] ) ; 
return rgbfix ; 
} static String getBgColorFromCell ( final Workbook wb , final Cell poiCell , 
final CellStyle cellStyle ) { 
String style = "" ; 
if ( poiCell instanceof HSSFCell ) { 
int bkColorIndex = cellStyle . getFillForegroundColor ( ) ; 
HSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; 
if ( color != null ) { 
HSSFPalette palette = ( ( HSSFWorkbook ) wb ) 
. getCustomPalette ( ) ; 
HSSFColor color2 = palette . getColor ( bkColorIndex ) ; 
if ( ! color . getHexString ( ) 
. equalsIgnoreCase ( color2 . getHexString ( ) ) ) { 
color = color2 ; 
style = "background-color:rgb(" 
+ FacesUtility . strJoin ( color . getTriplet ( ) , "," ) 
} else if ( poiCell instanceof XSSFCell ) { 
XSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) 
. getFillForegroundColorColor ( ) ; 
style = "background-color:rgb(" + FacesUtility . strJoin ( 
getTripletFromXSSFColor ( color ) , "," ) + ");" ; 
return style ; 
} private static String findComponentNameFromClass ( 
String cname = component . getClass ( ) . getSimpleName ( ) ; 
if ( supportComponents . contains ( cname ) ) { 
return cname ; 
} public static void populateAttributes ( final UIComponent component , 
final FacesCell fcell , 
final Map < String , Map < String , String > > defaultControlMap ) { 
List < CellFormAttributes > inputAttrs = fcell . getInputAttrs ( ) ; 
String cname = findComponentNameFromClass ( component ) ; 
if ( cname == null ) { 
Map < String , String > defaultMap = defaultControlMap . get ( cname ) ; 
if ( defaultMap == null ) { 
defaultMap = new HashMap < > ( ) ; 
defaultControlMap . put ( cname , defaultMap ) ; 
for ( Map . Entry < String , String > entry : defaultMap . entrySet ( ) ) { 
setObjectProperty ( component , entry . getKey ( ) , entry . getValue ( ) , 
for ( CellFormAttributes attr : inputAttrs ) { 
String propertyName = attr . getType ( ) ; 
String propertyValue = attr . getValue ( ) ; 
if ( ! defaultMap . containsKey ( propertyName ) ) { 
String defaultValue = getObjectPropertyValue ( component , 
propertyName , true ) ; 
defaultMap . put ( propertyName , defaultValue ) ; 
setObjectProperty ( component , propertyName , propertyValue , true ) ; 
} private static AttributesType matchParaMeterOfMethod ( final Object obj , 
final String methodName ) { 
for ( AttributesType attr : AttributesType . values ( ) ) { 
obj . getClass ( ) . getMethod ( methodName , 
new Class [ ] { attr . clazz } ) ; 
} public static void setObjectProperty ( final Object obj , 
final String propertyName , final String propertyValue , 
final boolean ignoreNonExisting ) { 
String methodName = "set" 
+ Character . toUpperCase ( propertyName . charAt ( 0 ) ) 
+ propertyName . substring ( 1 ) ; 
AttributesType parameterType = matchParaMeterOfMethod ( obj , 
methodName ) ; 
if ( parameterType != null ) { 
Method method = obj . getClass ( ) . getMethod ( methodName , 
new Class [ ] { parameterType . clazz } ) ; 
method . invoke ( obj , 
convertToObject ( parameterType , propertyValue ) ) ; 
+ obj ; 
if ( ignoreNonExisting ) { 
LOG . log ( Level . FINE , msg , e ) ; 
LOG . warning ( msg ) ; 
} public static String getObjectPropertyValue ( final Object obj , 
final String propertyName , final boolean ignoreNonExisting ) { 
Method method = obj . getClass ( ) 
. getMethod ( "get" 
+ propertyName . substring ( 1 ) ) ; 
return ( String ) method . invoke ( obj ) ; 
} public static void setupControlAttributes ( final int originRowIndex , 
final FacesCell fcell , final Cell poiCell , 
final SheetConfiguration sheetConfig , 
final CellAttributesMap cellAttributesMap ) { 
int rowIndex = originRowIndex ; 
if ( rowIndex < 0 ) { 
rowIndex = poiCell . getRowIndex ( ) ; 
String skey = poiCell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility 
. getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; 
Map < String , String > commentMap = cellAttributesMap 
. getTemplateCommentMap ( ) . get ( "$$" ) ; 
if ( commentMap != null ) { 
String comment = commentMap . get ( skey ) ; 
if ( comment != null ) { 
CommandUtility . createCellComment ( poiCell , comment , 
sheetConfig . getFinalCommentMap ( ) ) ; 
String widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; 
if ( widgetType != null ) { 
fcell . setControl ( widgetType . toLowerCase ( ) ) ; 
fcell . setInputAttrs ( 
cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; 
fcell . setSelectItemAttrs ( cellAttributesMap 
. getCellSelectItemsAttributes ( ) . get ( skey ) ) ; 
fcell . setDatePattern ( 
cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; 
} public static List < CellFormAttributes > findCellValidateAttributes ( 
final Map < String , List < CellFormAttributes > > validateMaps , 
final int originRowIndex , 
final Cell cell ) { 
String key = cell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility 
. getCellIndexNumberKey ( cell . getColumnIndex ( ) , originRowIndex ) ; 
return validateMaps . get ( key ) ; 
} public final void setupFacesCellPictureCharts ( final Sheet sheet1 , 
final FacesCell fcell , final Cell cell , final String fId ) { 
if ( parent . getPicturesMap ( ) != null ) { 
setupFacesCellPicture ( sheet1 , fcell , cell , fId ) ; 
if ( parent . getCharsData ( ) . getChartsMap ( ) != null ) { 
setupFacesCellCharts ( sheet1 , fcell , cell , fId ) ; 
} private void setupFacesCellCharts ( final Sheet sheet1 , 
String chartId = parent . getCharsData ( ) . getChartPositionMap ( ) 
. get ( fId ) ; 
if ( chartId != null ) { 
BufferedImage img = parent . getCharsData ( ) . getChartsMap ( ) 
. get ( chartId ) ; 
if ( img != null ) { 
fcell . setContainChart ( true ) ; 
fcell . setChartId ( chartId ) ; 
fcell . setChartStyle ( PicturesUtility . generateChartStyle ( 
sheet1 , fcell , cell , chartId , 
parent . getCharsData ( ) . getChartAnchorsMap ( ) ) ) ; 
} private void setupFacesCellPicture ( final Sheet sheet1 , 
Picture pic = parent . getPicturesMap ( ) . get ( fId ) ; 
if ( pic != null ) { 
fcell . setContainPic ( true ) ; 
fcell . setPictureId ( fId ) ; 
fcell . setPictureStyle ( PicturesUtility 
. generatePictureStyle ( sheet1 , fcell , cell , pic ) ) ; 
} private void initChartsMap ( final Workbook wb ) { 
if ( wb instanceof XSSFWorkbook ) { 
initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; 
+ e . getLocalizedMessage ( ) , e ) ; 
} public final String getParsedCellValue ( final ParsedCell pCell ) { 
String result = "" ; 
Cell poiCell = parent . getWb ( ) . getSheet ( pCell . getSheetName ( ) ) 
. getRow ( pCell . getRow ( ) ) . getCell ( pCell . getCol ( ) ) ; 
result = CellUtility . getCellValueWithoutFormat ( poiCell ) ; 
} private DefaultPieDataset createPieDataset ( final ChartData chartData ) { 
DefaultPieDataset dataset = new DefaultPieDataset ( ) ; 
List < ParsedCell > categoryList = chartData . getCategoryList ( ) ; 
for ( ChartSeries chartSeries : chartData . getSeriesList ( ) ) { 
List < ParsedCell > valueList = chartSeries . getValueList ( ) ; 
for ( int i = 0 ; i < categoryList . size ( ) ; i ++ ) { 
String sCategory = getParsedCellValue ( 
categoryList . get ( i ) ) ; 
String sValue = getParsedCellValue ( valueList . get ( i ) ) ; 
dataset . setValue ( sCategory , Double . parseDouble ( sValue ) ) ; 
} private String getPieTitle ( final ChartData chartData ) { 
if ( chartSeries != null ) { 
return getParsedCellValue ( chartSeries . getSeriesLabel ( ) ) ; 
} public final void setSeriesStyle ( final JFreeChart chart , 
final int seriesIndex , final String style ) { 
if ( chart != null && style != null ) { 
BasicStroke stroke = ChartUtility . toStroke ( style ) ; 
Plot plot = chart . getPlot ( ) ; 
if ( plot instanceof CategoryPlot ) { 
CategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; 
CategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; 
cir . setSeriesStroke ( seriesIndex , stroke ) ; 
+ Integer . toString ( seriesIndex ) 
} else if ( plot instanceof XYPlot ) { 
XYPlot xyPlot = chart . getXYPlot ( ) ; 
XYItemRenderer xyir = xyPlot . getRenderer ( ) ; 
xyir . setSeriesStroke ( seriesIndex , stroke ) ; 
plot . toString ( ) ) ; 
} public JFreeChart createAreaChart ( final ChartData chartData ) { 
PlotOrientation orientation = PlotOrientation . VERTICAL ; 
final JFreeChart chart = ChartFactory . createAreaChart ( 
chartData . getTitle ( ) , 
chartData . getCatAx ( ) . getTitle ( ) , 
chartData . getValAx ( ) . getTitle ( ) , 
createDataset ( chartData ) , 
orientation , true , 
false , 
false 
setupStyle ( chart , chartData ) ; 
return chart ; 
} public JFreeChart createBarChart ( final ChartData chartData , 
final boolean vertical ) { 
if ( ! vertical ) { 
orientation = PlotOrientation . HORIZONTAL ; 
final JFreeChart chart = ChartFactory . createBarChart ( 
setupBarStyle ( chart , chartData ) ; 
} public JFreeChart createPieChart ( final ChartData chartData ) { 
final JFreeChart chart = ChartFactory . createPieChart ( 
getPieTitle ( chartData ) , 
createPieDataset ( chartData ) , 
true , 
setupPieStyle ( chart , chartData ) ; 
} public JFreeChart createPie3DChart ( final ChartData chartData ) { 
final JFreeChart chart = ChartFactory . createPieChart3D ( 
} private void setupStyle ( final JFreeChart chart , 
final ChartData chartData ) { 
CategoryPlot plot = ( CategoryPlot ) chart . getPlot ( ) ; 
List < ChartSeries > seriesList = chartData . getSeriesList ( ) ; 
BasicStroke bLine = new BasicStroke ( 2.0f ) ; 
for ( int i = 0 ; i < seriesList . size ( ) ; i ++ ) { 
Color cColor = ColorUtility . xssfClrToClr ( 
seriesList . get ( i ) . getSeriesColor ( ) . getXssfColor ( ) ) ; 
plot . getRenderer ( ) . setSeriesPaint ( i , cColor ) ; 
plot . getRenderer ( ) . setSeriesStroke ( i , bLine ) ; 
plot . setBackgroundPaint ( ColorUtility 
. xssfClrToClr ( chartData . getBgColor ( ) . getXssfColor ( ) ) ) ; 
plot . setOutlineVisible ( false ) ; 
plot . setRangeGridlinesVisible ( true ) ; 
plot . setRangeGridlinePaint ( Color . BLACK ) ; 
plot . setRangeGridlineStroke ( 
new BasicStroke ( TieConstants . DEFAULT_BASIC_STROKE ) ) ; 
plot . setRangeAxisLocation ( AxisLocation . BOTTOM_OR_LEFT ) ; 
chart . setBackgroundPaint ( Color . WHITE ) ; 
LegendTitle legend = chart . getLegend ( ) ; 
legend . setPosition ( RectangleEdge . RIGHT ) ; 
legend . setFrame ( BlockBorder . NONE ) ; 
} private void setupPieStyle ( final JFreeChart chart , 
PiePlot plot = ( PiePlot ) chart . getPlot ( ) ; 
ChartSeries chartSeries = seriesList . get ( i ) ; 
List < XColor > valueColorList = chartSeries . getValueColorList ( ) ; 
for ( int index = 0 ; index < categoryList . size ( ) ; index ++ ) { 
categoryList . get ( index ) ) ; 
valueColorList . get ( index ) . getXssfColor ( ) ) ; 
plot . setSectionPaint ( sCategory , cColor ) ; 
plot . setSectionOutlineStroke ( sCategory , bLine ) ; 
plot . setLegendItemShape ( 
new Rectangle ( TieConstants . DEFAULT_LEGENT_ITEM_SHAPE_WIDTH , 
TieConstants . DEFAULT_LEGENT_ITEM_SHAPE_HEIGHT ) ) ; 
} private void setupBarStyle ( final JFreeChart chart , 
BarRenderer renderer = ( BarRenderer ) plot . getRenderer ( ) ; 
renderer . setBarPainter ( new StandardBarPainter ( ) ) ; 
renderer . setItemMargin ( TieConstants . DEFAULT_BAR_STYLE_ITEM_MARGIN ) ; 
plot . setForegroundAlpha ( 
TieConstants . DEFAULT_BARSTYLE_FOREGROUND_ALPHA ) ; 
} private DefaultCategoryDataset createDataset ( 
DefaultCategoryDataset dataset = new DefaultCategoryDataset ( ) ; 
String seriesLabel = getParsedCellValue ( 
chartSeries . getSeriesLabel ( ) ) ; 
dataset . addValue ( Double . parseDouble ( sValue ) , 
seriesLabel , sCategory ) ; 
} private void initXSSFChartsMap ( final XSSFWorkbook wb , 
final ChartsData chartsData ) { 
initAnchorsMap ( wb , chartsData ) ; 
Map < String , ClientAnchor > anchorMap = chartsData 
. getChartAnchorsMap ( ) ; 
Map < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; 
Map < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; 
chartMap . clear ( ) ; 
chartDataMap . clear ( ) ; 
for ( int i = 0 ; i < wb . getNumberOfSheets ( ) ; i ++ ) { 
XSSFSheet sheet = wb . getSheetAt ( i ) ; 
XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; 
List < XSSFChart > charts = drawing . getCharts ( ) ; 
if ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { 
for ( XSSFChart chart : charts ) { 
generateSingleXSSFChart ( chart , 
getChartIdFromParent ( chart , 
sheet . getSheetName ( ) ) , 
sheet , anchorMap , chartMap , chartDataMap ) ; 
} private String getChartIdFromParent ( final XSSFChart chart , 
final String sheetName ) { 
if ( chart . getParent ( ) != null ) { 
for ( RelationPart rp : chart . getParent ( ) . getRelationParts ( ) ) { 
if ( rp . getDocumentPart ( ) == chart ) { 
return sheetName + "!" + rp . getRelationship ( ) . getId ( ) ; 
} private void initAnchorsMap ( final Workbook wb , 
ChartUtility . initXSSFAnchorsMap ( ( XSSFWorkbook ) wb , 
chartsData ) ; 
} private void generateSingleXSSFChart ( final XSSFChart chart , 
final String chartId , final XSSFSheet sheet , 
final Map < String , ClientAnchor > anchorMap , 
final Map < String , BufferedImage > chartMap , 
final Map < String , ChartData > chartDataMap ) { 
ClientAnchor anchor ; 
anchor = anchorMap . get ( chartId ) ; 
if ( anchor != null ) { 
ChartData chartData = ChartUtility 
. initChartDataFromXSSFChart ( chartId , chart , 
( XSSFWorkbook ) parent . getWb ( ) ) ; 
chartDataMap . put ( chartId , chartData ) ; 
JFreeChart jchart = createChart ( chartData ) ; 
if ( jchart != null ) { 
AnchorSize anchorSize = PicturesUtility 
. getAnchorSize ( sheet , null , null , anchor ) ; 
BufferedImage img = jchart . createBufferedImage ( 
anchorSize . getWidth ( ) , anchorSize . getHeight ( ) ) ; 
chartMap . put ( chartId , img ) ; 
public static Collection transformToCollectionObject ( 
final ExpressionEngine engine , final String collectionName , 
final Map < String , Object > context ) { 
Object collectionObject = engine . evaluate ( collectionName , context ) ; 
if ( ! ( collectionObject instanceof Collection ) ) { 
throw new EvaluationException ( 
return ( Collection ) collectionObject ; 
} public static String getFullNameFromRow ( final Row row ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; 
return cell . getStringCellValue ( ) ; 
} public static void reBuildUpperLevelFormula ( 
final ConfigBuildRef configBuildRef , 
final String actionFullName ) { 
Map < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; 
Map < String , List < RowsMapping > > rowsMap = new HashMap < > ( ) ; 
for ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { 
Cell cell = entry . getKey ( ) ; 
String originFormula = entry . getValue ( ) ; 
if ( originFormula != null ) { 
setupUpperLevelFormula ( cell , originFormula , actionFullName , 
rowsMap , configBuildRef ) ; 
} private static void setupUpperLevelFormula ( final Cell cell , 
final String originFormula , final String actionFullName , 
final Map < String , List < RowsMapping > > rowsMap , 
final ConfigBuildRef configBuildRef ) { 
String fullName = getFullNameFromRow ( cell . getRow ( ) ) ; 
if ( actionFullName . startsWith ( fullName + ":" ) ) { 
List < RowsMapping > currentRowsMappingList = rowsMap 
. get ( fullName ) ; 
if ( currentRowsMappingList == null ) { 
currentRowsMappingList = gatherRowsMappingByFullName ( 
configBuildRef , fullName ) ; 
rowsMap . put ( fullName , currentRowsMappingList ) ; 
ShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( 
configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; 
shiftFormulaRef . setFormulaChanged ( 0 ) ; 
buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , 
configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , 
originFormula ) ; 
if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { 
configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; 
} public static void buildCellFormulaForShiftedRows ( final Sheet sheet , 
final XSSFEvaluationWorkbook wbWrapper , 
final ShiftFormulaRef shiftFormulaRef , final Cell cell , 
final String originFormula ) { 
if ( ( shiftFormulaRef . getWatchList ( ) != null ) 
&& ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { 
Ptg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , 
FormulaType . CELL , 
sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; 
Ptg [ ] convertedFormulaPtg = ShiftFormulaUtility 
. convertSharedFormulas ( ptgs , shiftFormulaRef ) ; 
cell . setCellFormula ( FormulaRenderer 
. toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; 
} public static List < RowsMapping > gatherRowsMappingByFullName ( 
final ConfigBuildRef configBuildRef , final String fullName ) { 
List < RowsMapping > list = new ArrayList < > ( ) ; 
Map < String , ConfigRangeAttrs > shiftMap = configBuildRef 
. getShiftMap ( ) ; 
for ( Map . Entry < String , ConfigRangeAttrs > entry : shiftMap 
String fname = entry . getKey ( ) ; 
if ( fname . startsWith ( fullName + ":" ) 
|| fname . equals ( fullName ) ) { 
ConfigRangeAttrs attrs = entry . getValue ( ) ; 
list . add ( attrs . getUnitRowsMapping ( ) ) ; 
} public static void changeIndexNumberInShiftMap ( 
final Map < String , ConfigRangeAttrs > shiftMap , 
final Map < String , String > changeMap ) { 
for ( Map . Entry < String , String > entry : changeMap . entrySet ( ) ) { 
String newKey = entry . getValue ( ) ; 
ConfigRangeAttrs attrs = shiftMap . get ( key ) ; 
if ( attrs != null ) { 
shiftMap . remove ( key ) ; 
shiftMap . put ( newKey , attrs ) ; 
} public static void changeUpperLevelFinalLength ( 
final String addedFullName , final int increasedLength ) { 
String [ ] parts = addedFullName . split ( ":" ) ; 
StringBuilder fname = new StringBuilder ( ) ; 
for ( int i = 0 ; i < ( parts . length - 1 ) ; i ++ ) { 
fname . append ( parts [ i ] ) ; 
fname . append ( ":" ) . append ( parts [ i ] ) ; 
String sname = fname . toString ( ) ; 
shiftMap . get ( sname ) . setFinalLength ( 
shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; 
} public static void changeIndexNumberInHiddenColumn ( 
final ConfigBuildRef configBuildRef , final int startRowIndex , 
final String fullName , final Map < String , String > changeMap , 
final int steps ) { 
String searchName = fullName . substring ( 0 , 
fullName . lastIndexOf ( '.' ) + 1 ) ; 
Sheet sheet = configBuildRef . getSheet ( ) ; 
for ( int i = startRowIndex ; i <= sheet . getLastRowNum ( ) ; i ++ ) { 
Row row = sheet . getRow ( i ) ; 
String fname = getFullNameFromRow ( row ) ; 
if ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { 
int sindex = fname . indexOf ( searchName ) ; 
String snum = fname . substring ( sindex + searchName . length ( ) ) ; 
int sufindex = snum . indexOf ( ':' ) ; 
String suffix = "" ; 
if ( sufindex > 0 ) { 
snum = snum . substring ( 0 , sufindex ) ; 
suffix = ":" ; 
int increaseNum = Integer . parseInt ( snum ) + steps ; 
String realFullName = fname . substring ( sindex ) ; 
String changeName = fname . replace ( 
searchName + snum + suffix , 
searchName + increaseNum + suffix ) ; 
if ( changeMap . get ( realFullName ) == null ) { 
changeMap . put ( realFullName , 
changeName . substring ( sindex ) ) ; 
setFullNameInHiddenColumn ( row , changeName ) ; 
} public static void setFullNameInHiddenColumn ( final Row row , 
final String fullName ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN , 
MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
cell . setCellValue ( fullName ) ; 
} public static int getOriginalRowNumInHiddenColumn ( final Row row ) { 
Cell cell = row . getCell ( 
TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , 
String rowNum = cell . getStringCellValue ( ) ; 
if ( ( rowNum != null ) && ( ! rowNum . isEmpty ( ) ) 
&& ( WebSheetUtility . isNumeric ( rowNum ) ) ) { 
return Integer . parseInt ( rowNum ) ; 
} public static void setOriginalRowNumInHiddenColumn ( final Row row , 
final int rowNum ) { 
cell . setCellValue ( Integer . toString ( rowNum ) ) ; 
cell . setCellType ( CellType . STRING ) ; 
} public static List < RowsMapping > findParentRowsMappingFromShiftMap ( 
final String [ ] parts , 
final Map < String , ConfigRangeAttrs > shiftMap ) { 
StringBuilder fullName = new StringBuilder ( ) ; 
List < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; 
for ( int i = 1 ; i < parts . length - 1 ; i ++ ) { 
String part = parts [ i ] ; 
if ( fullName . length ( ) == 0 ) { 
fullName . append ( part ) ; 
fullName . append ( ":" + part ) ; 
if ( fullName . length ( ) > 0 ) { 
ConfigRangeAttrs rangeAttrs = shiftMap 
. get ( fullName . toString ( ) ) ; 
if ( rangeAttrs != null ) { 
rowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; 
return rowsMappingList ; 
} public static List < RowsMapping > findChildRowsMappingFromShiftMap ( 
final String fullName , 
final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { 
NavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap 
. tailMap ( fullName , false ) ; 
for ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap 
if ( key . startsWith ( fullName ) ) { 
rowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; 
public static Object findItemInCollection ( final Collection collection , 
final int index ) { 
if ( collection instanceof List ) { 
List list = ( List ) collection ; 
return list . get ( index ) ; 
for ( Object object : collection ) { 
if ( i == index ) { 
} public static ConfigRange buildCurrentRange ( 
final ConfigRange sourceConfigRange , final Sheet sheet , 
final int insertPosition ) { 
ConfigRange current = new ConfigRange ( sourceConfigRange ) ; 
int shiftNum = insertPosition 
- sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; 
current . shiftRowRef ( sheet , shiftNum ) ; 
} public static boolean isStaticRow ( final ConfigRange sourceConfigRange , 
final int rowIndex ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) { 
for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) 
. size ( ) ; i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
if ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) 
. getRow ( ) ) 
&& ( rowIndex < ( command . getConfigRange ( ) 
. getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { 
} public static boolean isStaticRowRef ( 
final ConfigRange sourceConfigRange , final Row row ) { 
if ( ( rowIndex >= command . getTopRow ( ) ) 
&& ( rowIndex < ( command . getTopRow ( ) 
+ command . getFinalLength ( ) ) ) ) { 
} public static String getFullDataCollectNameFromFullName ( 
int lastEachCommandPos = fullName 
. lastIndexOf ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX ) ; 
if ( lastEachCommandPos < 0 ) { 
int lastEachCommandIndexPos = fullName . indexOf ( '.' , 
lastEachCommandPos 
+ TieConstants . EACH_COMMAND_FULL_NAME_PREFIX 
. length ( ) ) ; 
if ( lastEachCommandIndexPos < 0 ) { 
return fullName ; 
return fullName . substring ( 0 , lastEachCommandIndexPos ) ; 
} public static String replaceExpressionWithCellValue ( 
final String attrValue , final int rowIndex , final Sheet sheet ) { 
int ibegin = 0 ; 
int ifind ; 
int inameEnd ; 
String tempStr ; 
String findStr ; 
String replaceStr ; 
String returnStr = attrValue ; 
while ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 
ibegin ) ) > 0 ) { 
inameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; 
if ( inameEnd > 0 ) { 
findStr = attrValue . substring ( ifind , inameEnd ) ; 
findStr = attrValue . substring ( ifind ) ; 
if ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) { 
tempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX 
+ ( rowIndex + 1 ) ; 
tempStr = findStr ; 
replaceStr = CellUtility . getCellValueWithoutFormat ( 
WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; 
if ( replaceStr == null ) { 
replaceStr = "" ; 
returnStr = attrValue . replace ( findStr , replaceStr ) ; 
ibegin = ifind + 1 ; 
return returnStr ; 
} public static Map < String , CellRangeAddress > indexMergedRegion ( 
final Sheet sheet1 ) { 
int numRegions = sheet1 . getNumMergedRegions ( ) ; 
Map < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; 
for ( int i = 0 ; i < numRegions ; i ++ ) { 
CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; 
if ( caddress != null ) { 
cellRangeMap . put ( CellUtility . getCellIndexNumberKey ( 
caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , 
caddress ) ; 
return cellRangeMap ; 
} public static List < String > skippedRegionCells ( final Sheet sheet1 ) { 
List < String > skipCellList = new ArrayList < > ( ) ; 
addSkipCellToListInTheRegion ( skipCellList , caddress ) ; 
return skipCellList ; 
} private static void addSkipCellToListInTheRegion ( 
final List < String > skipCellList , 
final CellRangeAddress caddress ) { 
for ( int col = caddress . getFirstColumn ( ) ; col <= caddress 
. getLastColumn ( ) ; col ++ ) { 
for ( int row = caddress . getFirstRow ( ) ; row <= caddress 
. getLastRow ( ) ; row ++ ) { 
if ( ( col == caddress . getFirstColumn ( ) ) 
&& ( row == caddress . getFirstRow ( ) ) ) { 
skipCellList 
. add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; 
} public static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { 
if ( ( tieCommandAliasList == null ) || ( tieCommandAliasList . isEmpty ( ) ) ) { 
buildCellCommentFromalias ( tieCommandAliasList , cell ) ; 
} private static void buildCellCommentFromalias ( List < TieCommandAlias > tieCommandAliasList , Cell cell ) { 
String value = CellUtility . getCellValueWithoutFormat ( cell ) ; 
if ( ( value != null ) && ( ! value . isEmpty ( ) ) ) { 
for ( TieCommandAlias alias : tieCommandAliasList ) { 
Matcher matcher = alias . getPattern ( ) . matcher ( value ) ; 
if ( matcher . find ( ) ) { 
CellUtility . createOrInsertComment ( cell , alias . getCommand ( ) ) ; 
if ( alias . isRemove ( ) ) { 
CellUtility . setCellValue ( cell , ParserUtility . removeCharsFromString ( value , matcher . start ( ) , matcher . end ( ) ) ) ; 
} public final Map < String , SheetConfiguration > buildConfiguration ( ) { 
Map < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; 
List < String > sheetNames = new ArrayList < > ( ) ; 
String sname ; 
for ( int i = 0 ; i < parent . getWb ( ) . getNumberOfSheets ( ) ; i ++ ) { 
sname = parent . getWb ( ) . getSheetName ( i ) ; 
if ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { 
sheetNames . add ( sname ) ; 
for ( String sheetName : sheetNames ) { 
Sheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; 
ConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; 
buildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; 
return sheetConfigMap ; 
} private SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , 
final int sheetRightCol ) { 
SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; 
sheetConfig . setFormName ( formName ) ; 
sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; 
int leftCol = sheet . getLeftCol ( ) ; 
int lastRow = sheet . getLastRowNum ( ) ; 
int firstRow = sheet . getFirstRowNum ( ) ; 
int rightCol = 0 ; 
int maxRow = 0 ; 
if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { 
maxRow = row . getRowNum ( ) ; 
int firstCellNum = row . getFirstCellNum ( ) ; 
if ( firstCellNum >= 0 && firstCellNum < leftCol ) { 
leftCol = firstCellNum ; 
if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { 
int verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; 
if ( verifiedcol > rightCol ) { 
rightCol = verifiedcol ; 
if ( maxRow < lastRow ) { 
lastRow = maxRow ; 
String tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) 
+ WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + "0" ; 
sheetConfig . setFormHeaderRange ( tempStr ) ; 
sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; 
tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) 
+ WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; 
sheetConfig . setFormBodyRange ( tempStr ) ; 
sheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; 
sheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; 
sheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; 
int sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; 
if ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { 
sheetConfig . setHidden ( true ) ; 
return sheetConfig ; 
} private FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { 
int firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
int leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
int lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; 
Cell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
FormCommand fcommand = new FormCommand ( ) ; 
fcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; 
if ( sheetConfig . isHidden ( ) ) { 
fcommand . setHidden ( TieConstants . TRUE_STRING ) ; 
fcommand . setHidden ( TieConstants . FALSE_STRING ) ; 
fcommand . setName ( sheetConfig . getFormName ( ) ) ; 
fcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; 
fcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; 
fcommand . setHeaderLength ( "0" ) ; 
fcommand . setFooterLength ( "0" ) ; 
fcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; 
return fcommand ; 
} private int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { 
int lastCol = sheetRightCol ; 
int col ; 
for ( col = lastCol ; col >= stoppoint ; col -- ) { 
Cell cell = row . getCell ( col ) ; 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { 
return col ; 
} public final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , 
if ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { 
checkAndRepairLastRow ( sheet ) ; 
int sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; 
List < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , 
cellAttributesMap ) ; 
boolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; 
List < String > formList = new ArrayList < > ( ) ; 
buildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; 
matchParentCommand ( commandList ) ; 
matchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; 
initTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; 
} private final void checkAndRepairLastRow ( final Sheet sheet ) { 
Row lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; 
if ( lastrow != null ) { 
for ( Cell cell : lastrow ) { 
if ( ( cell . getCellTypeEnum ( ) != CellType . _NONE ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { 
sheet . removeRow ( lastrow ) ; 
} private void initTemplateForCommand ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , 
final List < String > formList , final boolean hasEachCommand ) { 
for ( String formname : formList ) { 
SheetConfiguration sheetConfig = sheetConfigMap . get ( formname ) ; 
CellRange range = sheetConfig . getBodyCellRange ( ) ; 
for ( int index = range . getTopRow ( ) ; index <= range . getBottomRow ( ) ; index ++ ) { 
Row row = sheet . getRow ( index ) ; 
if ( row == null ) { 
row = sheet . createRow ( index ) ; 
if ( hasEachCommand ) { 
ConfigurationUtility . setOriginalRowNumInHiddenColumn ( row , index ) ; 
copyTemplateForTieCommands ( sheet ) ; 
} private List < ConfigCommand > buildCommandListFromSheetComment ( final XSSFSheet sheet , final int sheetRightCol , 
List < ConfigCommand > commandList = new ArrayList < > ( ) ; 
if ( parent . isSkipConfiguration ( ) ) { 
return commandList ; 
Map < CellAddress , ? extends Comment > comments = null ; 
comments = sheet . getCellComments ( ) ; 
if ( comments == null ) { 
SortedSet < CellAddress > keys = new TreeSet < > ( comments . keySet ( ) ) ; 
for ( CellAddress key : keys ) { 
Cell cell = sheet . getRow ( key . getRow ( ) ) . getCell ( key . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
buildCommandList ( sheet , sheetRightCol , cell , commandList , cellAttributesMap ) ; 
} private void buildSheetConfigMapFromFormCommand ( final Sheet sheet , 
final Map < String , SheetConfiguration > sheetConfigMap , final List < ConfigCommand > commandList , 
final List < String > formList , final int sheetRightCol ) { 
boolean foundForm = false ; 
int minRowNum = sheet . getLastRowNum ( ) ; 
int maxRowNum = sheet . getFirstRowNum ( ) ; 
for ( Command command : commandList ) { 
if ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) ) { 
foundForm = true ; 
FormCommand fcommand = ( FormCommand ) command ; 
sheetConfigMap . put ( fcommand . getName ( ) , 
getSheetConfigurationFromConfigCommand ( sheet , fcommand , sheetRightCol ) ) ; 
formList . add ( fcommand . getName ( ) ) ; 
if ( fcommand . getTopRow ( ) < minRowNum ) { 
minRowNum = fcommand . getTopRow ( ) ; 
if ( fcommand . getLastRow ( ) > maxRowNum ) { 
maxRowNum = fcommand . getLastRow ( ) ; 
if ( ! foundForm ) { 
WebSheetUtility . clearHiddenColumns ( sheet ) ; 
String formName = sheet . getSheetName ( ) ; 
SheetConfiguration sheetConfig = getSheetConfiguration ( sheet , formName , sheetRightCol ) ; 
FormCommand fcommand = buildFormCommandFromSheetConfig ( sheetConfig , sheet ) ; 
commandList . add ( fcommand ) ; 
sheetConfig . setFormCommand ( fcommand ) ; 
sheetConfigMap . put ( formName , sheetConfig ) ; 
formList . add ( formName ) ; 
minRowNum = sheet . getFirstRowNum ( ) ; 
maxRowNum = sheet . getLastRowNum ( ) ; 
SaveAttrsUtility . setSaveAttrsForSheet ( sheet , minRowNum , maxRowNum , 
parent . getCellAttributesMap ( ) . getTemplateCommentMap ( ) . get ( TieConstants . SAVE_COMMENT_KEY_IN_MAP ) ) ; 
} private void matchParentCommand ( final List < ConfigCommand > commandList ) { 
if ( commandList == null ) { 
for ( int i = 0 ; i < commandList . size ( ) ; i ++ ) { 
ConfigCommand child = commandList . get ( i ) ; 
if ( ! child . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) ) { 
setParentForChildCommand ( commandList , i , child ) ; 
} private void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , 
final ConfigCommand child ) { 
int matchIndex = - 1 ; 
ConfigRange matchRange = null ; 
for ( int j = 0 ; j < commandList . size ( ) ; j ++ ) { 
if ( j != i ) { 
Command commandParent = commandList . get ( j ) ; 
if ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) 
&& WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) 
&& ( ( matchRange == null ) 
|| ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { 
matchRange = commandParent . getConfigRange ( ) ; 
matchIndex = j ; 
if ( matchIndex >= 0 ) { 
commandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; 
child . setParentFound ( true ) ; 
} private boolean hasEachCommandInTheList ( final List < ConfigCommand > commandList ) { 
if ( commandList != null ) { 
for ( ConfigCommand command : commandList ) { 
if ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_EACH ) ) { 
} private void matchSheetConfigForm ( final Map < String , SheetConfiguration > sheetConfigMap , 
final List < ConfigCommand > commandList , final List < String > formList ) { 
if ( ! command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) 
&& ( ! command . isParentFound ( ) ) ) { 
matchCommandToSheetConfigForm ( sheetConfigMap , formList , command ) ; 
} private void matchCommandToSheetConfigForm ( final Map < String , SheetConfiguration > sheetConfigMap , 
final List < String > formList , final ConfigCommand command ) { 
if ( WebSheetUtility . insideRange ( command . getConfigRange ( ) , sheetConfig . getFormCommand ( ) . getConfigRange ( ) ) ) { 
sheetConfig . getFormCommand ( ) . getConfigRange ( ) . addCommand ( command ) ; 
} private void copyTemplateForTieCommands ( final Sheet sheet ) { 
Workbook wb = sheet . getWorkbook ( ) ; 
String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; 
if ( wb . getSheet ( copyName ) == null ) { 
Sheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; 
int sheetIndex = wb . getSheetIndex ( newSheet ) ; 
wb . setSheetName ( sheetIndex , copyName ) ; 
wb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; 
} private List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , 
final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { 
Comment comment = cell . getCellComment ( ) ; 
String text = comment . getString ( ) . getString ( ) ; 
String [ ] commentLines = text . split ( "\\n" ) ; 
StringBuilder newComment = new StringBuilder ( ) ; 
for ( String commentLine : commentLines ) { 
String line = commentLine . trim ( ) ; 
if ( ParserUtility . isCommandString ( line ) ) { 
processCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; 
changed = true ; 
} else if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { 
processMethodLine ( cell , line , cellAttributesMap ) ; 
if ( newComment . length ( ) > 0 ) { 
newComment . append ( "\\n" + commentLine ) ; 
newComment . append ( commentLine ) ; 
if ( ! changed ) { 
moveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; 
moveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; 
CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; 
RichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; 
comment . setString ( str ) ; 
cell . removeCellComment ( ) ; 
return cList ; 
} private void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { 
if ( ParserUtility . isWidgetMethodString ( line ) ) { 
ParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; 
} else if ( ParserUtility . isValidateMethodString ( line ) ) { 
ParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; 
moveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; 
} private void processCommandLine ( final Sheet sheet , final Cell cell , final String line , 
final List < ConfigCommand > cList , final int sheetRightCol ) { 
int nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; 
if ( nameEndIndex < 0 ) { 
LOG . severe ( errMsg ) ; 
throw new IllegalStateException ( errMsg ) ; 
String commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; 
Map < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; 
ConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; 
if ( configCommand != null ) { 
cList . add ( configCommand ) ; 
} private void moveCommentToMap ( final Cell cell , final String newComment , 
final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { 
String cellKey = cell . getSheet ( ) . getSheetName ( ) + "!$" + cell . getColumnIndex ( ) + "$" + cell . getRowIndex ( ) ; 
ParserUtility . parseCommentToMap ( cellKey , newComment , sheetCommentMap , normalComment ) ; 
} private ConfigCommand createConfigCommand ( final Sheet sheet , final Cell firstCell , final int sheetRightCol , 
final String commandName , final Map < String , String > attrMap ) { 
@ SuppressWarnings ( "rawtypes" ) 
Class clas = commandMap . get ( commandName ) ; 
if ( clas == null ) { 
ConfigCommand command = ( ConfigCommand ) clas . newInstance ( ) ; 
command . setCommandTypeName ( commandName ) ; 
for ( Map . Entry < String , String > attr : attrMap . entrySet ( ) ) { 
WebSheetUtility . setObjectProperty ( command , attr . getKey ( ) , attr . getValue ( ) , true ) ; 
command . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; 
command . getConfigRange ( ) . setLastRowPlusRef ( sheet , sheetRightCol , command . getLastRow ( ) , true ) ; 
LOG . log ( Level . WARNING , 
} private Map < String , String > buildAttrMap ( final String commandLine , final int nameEndIndex ) { 
int paramsEndIndex = commandLine . lastIndexOf ( TieConstants . ATTR_SUFFIX ) ; 
if ( paramsEndIndex < 0 ) { 
throw new IllegalArgumentException ( errMsg ) ; 
String attrString = commandLine . substring ( nameEndIndex + 1 , paramsEndIndex ) . trim ( ) ; 
return ParserUtility . parseCommandAttributes ( attrString ) ; 
} private SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , 
sheetConfig . setFormName ( fcommand . getName ( ) ) ; 
int leftCol = fcommand . getLeftCol ( ) ; 
int lastRow = fcommand . getLastRow ( ) ; 
setHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
setBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; 
setFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
String hidden = fcommand . getHidden ( ) ; 
if ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) { 
String fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; 
if ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) { 
sheetConfig . setFixedWidthStyle ( true ) ; 
} private void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , 
final int leftCol , final int rightCol ) { 
if ( fcommand . calcFooterLength ( ) == 0 ) { 
+ CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; 
tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 
+ CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; 
sheetConfig . setFormFooterRange ( tempStr ) ; 
sheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; 
} private void setBodyOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , 
final int leftCol , final int lastRow , final int rightCol ) { 
tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + 1 ) 
sheetConfig . setFormBodyType ( TieConstants . FORM_TYPE_FREE ) ; 
} private void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , 
if ( fcommand . calcHeaderLength ( ) == 0 ) { 
public static int addRow ( final ConfigBuildRef configBuildRef , 
final int rowIndex , final Map < String , Object > dataContext ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( 
configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; 
String [ ] parts = fullName . split ( ":" ) ; 
configBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; 
CollectionObject collect = configBuildRef . getCellHelper ( ) 
. getLastCollect ( fullName ) ; 
Collection lastCollection = collect . getLastCollection ( ) ; 
int lastCollectionIndex = collect . getLastCollectionIndex ( ) ; 
EachCommand eachCommand = collect . getEachCommand ( ) ; 
if ( lastCollectionIndex < 0 ) { 
String unitFullName = CommandUtility . insertEmptyObjectInContext ( 
fullName , lastCollection , eachCommand , lastCollectionIndex , 
dataContext ) ; 
RowsMapping unitRowsMapping = new RowsMapping ( ) ; 
ConfigRangeAttrs savedRangeAttrs = configBuildRef . getShiftMap ( ) 
int insertPosition = savedRangeAttrs . getFirstRowRef ( ) . getRowIndex ( ) 
+ savedRangeAttrs . getFinalLength ( ) ; 
configBuildRef . setInsertPosition ( insertPosition ) ; 
CommandUtility . insertEachTemplate ( eachCommand . getConfigRange ( ) , 
configBuildRef , lastCollectionIndex + 1 , insertPosition , 
unitRowsMapping ) ; 
ConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( 
eachCommand . getConfigRange ( ) , configBuildRef . getSheet ( ) , 
insertPosition ) ; 
List < RowsMapping > currentRowsMappingList = ConfigurationUtility 
. findParentRowsMappingFromShiftMap ( parts , 
configBuildRef . getShiftMap ( ) ) ; 
currentRowsMappingList . add ( unitRowsMapping ) ; 
currentRange . getAttrs ( ) . setAllowAdd ( true ) ; 
configBuildRef . setBodyAllowAdd ( true ) ; 
Map < String , String > changeMap = new TreeMap < > ( 
Collections . reverseOrder ( ) ) ; 
ConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , 
currentRange . getAttrs ( ) . getLastRowPlusRef ( ) . getRowIndex ( ) , 
fullName , changeMap , 1 ) ; 
ConfigurationUtility . changeIndexNumberInShiftMap ( 
configBuildRef . getShiftMap ( ) , changeMap ) ; 
configBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , 
int length = currentRange . buildAt ( unitFullName , configBuildRef , 
insertPosition , dataContext , currentRowsMappingList ) ; 
currentRange . getAttrs ( ) . setFinalLength ( length ) ; 
ConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , 
fullName ) ; 
ConfigurationUtility . changeUpperLevelFinalLength ( 
configBuildRef . getShiftMap ( ) , fullName , length ) ; 
currentRowsMappingList . remove ( unitRowsMapping ) ; 
dataContext . remove ( eachCommand . getVar ( ) ) ; 
public static int deleteRow ( final ConfigBuildRef configBuildRef , 
final int rowIndex , final Map < String , Object > dataContext , 
final List < FacesRow > bodyRows ) { 
if ( lastCollection . size ( ) <= 1 ) { 
throw new DeleteRowException ( 
CommandUtility . deleteObjectInContext ( lastCollection , eachCommand , 
lastCollectionIndex , dataContext ) ; 
ConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) 
if ( currentRangeAttrs == null ) { 
int startRow = currentRangeAttrs . getFirstRowIndex ( ) ; 
int length = currentRangeAttrs . getFinalLength ( ) ; 
int endRow = startRow + length - 1 ; 
List < String > removeFullNameList = findRemoveFullNameList ( 
configBuildRef . getSheet ( ) , startRow , endRow ) ; 
removeRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , 
removeFullNameList ) ; 
String var = eachCommand . getVar ( ) ; 
CommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , 
startRow , endRow , configBuildRef . getCachedCells ( ) ) ; 
CommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , 
endRow ) ; 
Map < String , String > changeMap = new TreeMap < > ( ) ; 
startRow , fullName , changeMap , - 1 ) ; 
configBuildRef . getShiftMap ( ) , fullName , - length ) ; 
dataContext . remove ( var ) ; 
} private static void removeRangesFromShiftMap ( 
final NavigableMap < String , ConfigRangeAttrs > shiftMap , 
final List < String > removeFullNameList ) { 
for ( String fname : removeFullNameList ) { 
shiftMap . remove ( fname ) ; 
} private static List < String > findRemoveFullNameList ( final Sheet sheet , 
final int startRow , final int endRow ) { 
List < String > list = new ArrayList < > ( ) ; 
for ( int rowIndex = startRow ; rowIndex <= endRow ; rowIndex ++ ) { 
String fullName = ConfigurationUtility 
. getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; 
if ( ! list . contains ( fullName ) ) { 
list . add ( fullName ) ; 
} public static EachCommand getEachCommandFromPartsName ( 
final Map < String , Command > commandIndexMap , 
final String [ ] varparts ) { 
if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { 
return ( EachCommand ) commandIndexMap 
. get ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX 
+ varparts [ 1 ] ) ; 
private static String insertEmptyObjectInContext ( final String fullName , 
final Collection lastCollection , final EachCommand eachCommand , 
final int lastCollectionIndex , 
final Map < String , Object > dataContext ) { 
if ( ! ( lastCollection instanceof List ) ) { 
List collectionList = ( List ) lastCollection ; 
Object currentObj = collectionList . get ( lastCollectionIndex ) ; 
Object insertObj ; 
insertObj = currentObj . getClass ( ) . newInstance ( ) ; 
collectionList . add ( lastCollectionIndex + 1 , insertObj ) ; 
dataContext . put ( eachCommand . getVar ( ) , insertObj ) ; 
return fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) 
+ ( lastCollectionIndex + 1 ) ; 
throw new EvaluationException ( e ) ; 
private static void deleteObjectInContext ( 
throw new EvaluationException ( eachCommand . getVar ( ) 
+ TieConstants . EACH_COMMAND_INVALID_MSG ) ; 
collectionList . remove ( lastCollectionIndex ) ; 
public static int prepareCollectionDataInContext ( 
final String [ ] varparts , final Collection collection , 
int collectionIndex = Integer . parseInt ( varparts [ 2 ] ) ; 
Object obj = ConfigurationUtility 
. findItemInCollection ( collection , collectionIndex ) ; 
if ( obj != null ) { 
dataContext . put ( varparts [ 1 ] , obj ) ; 
return collectionIndex ; 
} public static void indexCommandRange ( 
final ConfigRange sourceConfigRange , 
final Map < String , Command > indexMap ) { 
indexMap . put ( command . getCommandName ( ) , command ) ; 
command . getConfigRange ( ) . indexCommandRange ( indexMap ) ; 
} public static boolean isRowAllowAdd ( final Row row , 
final SheetConfiguration sheetConfig ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; 
if ( fullName != null ) { 
ConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) 
if ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) && ( row 
. getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) ) { 
} public static void insertEachTemplate ( 
final ConfigBuildRef configBuildRef , final int index , 
final int insertPosition , final RowsMapping unitRowsMapping ) { 
int srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; 
int srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; 
String copyName = TieConstants . COPY_SHEET_PREFIX 
+ sheet . getSheetName ( ) ; 
if ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { 
copyName = copyName . substring ( 0 , 
TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; 
Sheet srcSheet = wb . getSheet ( copyName ) ; 
CellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , 
insertPosition , false , true ) ; 
for ( int rowIndex = srcStartRow ; rowIndex <= srcEndRow ; rowIndex ++ ) { 
if ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) 
&& ( ConfigurationUtility . isStaticRow ( sourceConfigRange , 
rowIndex ) ) ) { 
unitRowsMapping . addRow ( rowIndex , sheet 
. getRow ( insertPosition + rowIndex - srcStartRow ) ) ; 
public static void evaluate ( final Map < String , Object > context , 
final Cell cell , final ExpressionEngine engine ) { 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) { 
String strValue = cell . getStringCellValue ( ) ; 
if ( isUserFormula ( strValue ) ) { 
evaluateUserFormula ( cell , strValue ) ; 
evaluateNormalCells ( cell , strValue , context , engine ) ; 
} public static void evaluateNormalCells ( final Cell cell , 
final String strValue , final Map < String , Object > context , 
final ExpressionEngine engine ) { 
if ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { 
Object evaluationResult = evaluate ( strValue , context , engine ) ; 
if ( evaluationResult == null ) { 
evaluationResult = "" ; 
CellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; 
createTieCell ( cell , context , engine ) ; 
} private static void evaluateUserFormula ( final Cell cell , 
final String strValue ) { 
String formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; 
if ( ( formulaStr != null ) && ( ! formulaStr . isEmpty ( ) ) ) { 
cell . setCellFormula ( formulaStr ) ; 
} private static boolean isUserFormula ( final String str ) { 
return str . startsWith ( TieConstants . USER_FORMULA_PREFIX ) 
&& str . endsWith ( TieConstants . USER_FORMULA_SUFFIX ) ; 
} public static Object evaluate ( final String strValue , 
final Map < String , Object > context , 
int beginExpressionLength = TieConstants . METHOD_PREFIX . length ( ) ; 
int endExpressionLength = TieConstants . METHOD_END . length ( ) ; 
Matcher exprMatcher = TieConstants . EXPRESSION_NOTATION_PATTERN 
. matcher ( strValue ) ; 
String matchedString ; 
String expression ; 
Object lastMatchEvalResult = null ; 
int matchCount = 0 ; 
int endOffset = 0 ; 
while ( exprMatcher . find ( ) ) { 
endOffset = exprMatcher . end ( ) ; 
matchCount ++ ; 
matchedString = exprMatcher . group ( ) ; 
expression = matchedString . substring ( beginExpressionLength , 
matchedString . length ( ) - endExpressionLength ) ; 
lastMatchEvalResult = engine . evaluate ( expression , context ) ; 
exprMatcher . appendReplacement ( sb , 
Matcher . quoteReplacement ( lastMatchEvalResult != null 
? lastMatchEvalResult . toString ( ) : "" ) ) ; 
String lastStringResult = lastMatchEvalResult != null 
? lastMatchEvalResult . toString ( ) : "" ; 
boolean isAppendTail = matchCount == 1 
&& endOffset < strValue . length ( ) ; 
Object evaluationResult = null ; 
if ( matchCount > 1 || isAppendTail ) { 
exprMatcher . appendTail ( sb ) ; 
evaluationResult = sb . toString ( ) ; 
} else if ( matchCount == 1 ) { 
if ( sb . length ( ) > lastStringResult . length ( ) ) { 
evaluationResult = lastMatchEvalResult ; 
} else if ( matchCount == 0 ) { 
evaluationResult = strValue ; 
return evaluationResult ; 
} public static void createCellComment ( final Cell cell , 
final String newComment , 
final Map < Cell , String > finalCommentMap ) { 
if ( newComment != null ) { 
finalCommentMap . put ( cell , newComment ) ; 
} public static boolean evalBoolExpression ( 
final ExpressionEngine expEngine , final String pscript ) { 
script = script . toUpperCase ( ) . replace ( "AND" , "&&" ) ; 
script = script . toUpperCase ( ) . replace ( "OR" , "||" ) ; 
result = expEngine . evaluate ( script ) ; 
return ( ( Boolean ) result ) . booleanValue ( ) ; 
} public static void removeRowsInSheet ( final Sheet sheet , 
final int rowIndexStart , final int rowIndexEnd , 
final Map < Cell , String > cachedMap ) { 
for ( int irow = rowIndexStart ; irow <= rowIndexEnd ; irow ++ ) { 
removeCachedCellForRow ( sheet , irow , cachedMap ) ; 
int irows = rowIndexEnd - rowIndexStart + 1 ; 
if ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { 
int lastRowNum = sheet . getLastRowNum ( ) ; 
if ( rowIndexEnd < lastRowNum ) { 
sheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; 
if ( rowIndexEnd == lastRowNum ) { 
for ( int i = rowIndexEnd ; i >= rowIndexStart ; i -- ) { 
removeSingleRowInSheet ( sheet , rowIndexStart ) ; 
} private static void removeSingleRowInSheet ( final Sheet sheet , 
final int rowIndexStart ) { 
Row removingRow = sheet . getRow ( rowIndexStart ) ; 
if ( removingRow != null ) { 
sheet . removeRow ( removingRow ) ; 
} private static void removeCachedCellForRow ( final Sheet sheet , 
final int rowIndexStart , final Map < Cell , String > cachedMap ) { 
for ( Cell cell : removingRow ) { 
cachedMap . remove ( cell ) ; 
} public static void removeRowsInBody ( 
final List < FacesRow > bodyRows , final int rowIndexStart , 
final int rowIndexEnd ) { 
int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
if ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { 
for ( int rowIndex = rowIndexEnd ; rowIndex >= rowIndexStart ; rowIndex -- ) { 
bodyRows . remove ( rowIndex - top ) ; 
for ( int irow = rowIndexStart - top ; irow < bodyRows 
. size ( ) ; irow ++ ) { 
FacesRow facesrow = bodyRows . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; 
} private String loadPicture ( final int rowIndex , final int colIndex ) { 
FacesCell facesCell = parent . getCellHelper ( ) 
. getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; 
if ( facesCell != null && facesCell . isContainPic ( ) ) { 
String pictureId = facesCell . getPictureId ( ) ; 
String pictureViewId = Integer . toHexString ( 
System . identityHashCode ( parent . getWb ( ) ) ) + pictureId ; 
Map < String , Object > sessionMap = context . getExternalContext ( ) 
. getSessionMap ( ) ; 
if ( sessionMap . get ( pictureViewId ) == null ) { 
sessionMap . put ( pictureViewId , parent . getPicturesMap ( ) 
. get ( pictureId ) . getPictureData ( ) ) ; 
return pictureViewId ; 
} private String loadChart ( final int rowIndex , final int colIndex ) { 
if ( facesCell != null && facesCell . isContainChart ( ) ) { 
String chartId = facesCell . getChartId ( ) ; 
String chartViewId = Integer . toHexString ( 
System . identityHashCode ( parent . getWb ( ) ) ) + chartId ; 
Map < String , Object > sessionMap = context 
. getExternalContext ( ) . getSessionMap ( ) ; 
if ( sessionMap . get ( chartViewId ) == null ) { 
sessionMap . put ( chartViewId , parent . getCharsData ( ) 
. getChartsMap ( ) . get ( chartId ) ) ; 
return chartViewId ; 
public final Object get ( final Object key ) { 
Object result = "" ; 
CellMapKey mkey = new CellMapKey ( ( String ) key ) ; 
if ( ! mkey . isParseSuccess ( ) ) { 
Cell poiCell = parent . getCellHelper ( ) 
. getPoiCellWithRowColFromCurrentPage ( mkey . getRowIndex ( ) , 
mkey . getColIndex ( ) ) ; 
if ( poiCell == null ) { 
if ( mkey . isCharted ( ) ) { 
result = loadChart ( mkey . getRowIndex ( ) , mkey . getColIndex ( ) ) ; 
} else if ( mkey . isPictured ( ) ) { 
result = loadPicture ( mkey . getRowIndex ( ) , 
} else if ( mkey . isFormatted ( ) ) { 
result = CellUtility . getCellValueWithFormat ( poiCell , 
parent . getFormulaEvaluator ( ) , 
parent . getDataFormatter ( ) ) ; 
public final Object put ( final Object key , final Object value ) { 
String oldValue = CellUtility 
. getCellValueWithoutFormat ( poiCell ) ; 
. getFacesCellWithRowColFromCurrentPage ( 
mkey . getRowIndex ( ) , mkey . getColIndex ( ) ) ; 
String newValue = assembleNewValue ( value , facesCell ) ; 
if ( newValue != null && ! newValue . equals ( oldValue ) ) { 
CellUtility . setCellValue ( poiCell , newValue ) ; 
if ( facesCell . isHasSaveAttr ( ) ) { 
parent . getCellHelper ( ) . saveDataInContext ( poiCell , 
CellUtility . copyCell ( poiCell . getSheet ( ) , poiCell . getRow ( ) , poiCell . getRow ( ) , poiCell . getColumnIndex ( ) , false ) ; 
parent . getCellHelper ( ) . reCalc ( ) ; 
} private String assembleNewValue ( final Object value , 
final FacesCell facesCell ) { 
String newValue ; 
if ( value instanceof java . util . Date ) { 
String datePattern = facesCell . getDatePattern ( ) ; 
if ( datePattern == null || datePattern . isEmpty ( ) ) { 
datePattern = parent . getDefaultDatePattern ( ) ; 
Format formatter = new SimpleDateFormat ( datePattern ) ; 
newValue = formatter . format ( value ) ; 
newValue = ( String ) value ; 
if ( "textarea" . equalsIgnoreCase ( facesCell . getInputType ( ) ) 
&& ( newValue != null ) ) { 
newValue = newValue . replace ( "\r\n" , "\n" ) ; 
return newValue ; 
public static String getCellValueWithFormat ( final Cell poiCell , final FormulaEvaluator formulaEvaluator , 
final DataFormatter dataFormatter ) { 
CellType cellType = poiCell . getCellTypeEnum ( ) ; 
if ( cellType == CellType . FORMULA ) { 
cellType = formulaEvaluator . evaluate ( poiCell ) . getCellTypeEnum ( ) ; 
if ( cellType == CellType . ERROR ) { 
result = dataFormatter . formatCellValue ( poiCell , formulaEvaluator ) ; 
public static String getCellValueWithoutFormat ( final Cell poiCell ) { 
if ( poiCell . getCellTypeEnum ( ) == CellType . FORMULA ) { 
return getCellStringValueWithType ( poiCell , poiCell . getCachedFormulaResultTypeEnum ( ) ) ; 
return getCellStringValueWithType ( poiCell , poiCell . getCellTypeEnum ( ) ) ; 
} private static String getCellStringValueWithType ( final Cell poiCell , final CellType cellType ) { 
switch ( cellType ) { 
return getCellStringValueWithBooleanType ( poiCell ) ; 
case NUMERIC : 
return getCellStringValueWithNumberType ( poiCell ) ; 
return poiCell . getStringCellValue ( ) ; 
} private static String getCellStringValueWithNumberType ( final Cell poiCell ) { 
if ( DateUtil . isCellDateFormatted ( poiCell ) ) { 
result = poiCell . getDateCellValue ( ) . toString ( ) ; 
result = BigDecimal . valueOf ( poiCell . getNumericCellValue ( ) ) . toPlainString ( ) ; 
if ( result . endsWith ( ".0" ) ) { 
result = result . substring ( 0 , result . length ( ) - 2 ) ; 
public static Cell setCellValue ( final Cell c , final String value ) { 
if ( value . length ( ) == 0 ) { 
c . setCellType ( CellType . BLANK ) ; 
} else if ( WebSheetUtility . isNumeric ( value ) ) { 
setCellValueNumber ( c , value ) ; 
} else if ( WebSheetUtility . isDate ( value ) ) { 
setCellValueDate ( c , value ) ; 
} else if ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) { 
setCellValueBoolean ( c , value ) ; 
setCellValueString ( c , value ) ; 
} private static void setCellValueString ( final Cell c , final String value ) { 
c . setCellType ( CellType . STRING ) ; 
c . setCellValue ( value ) ; 
} private static void setCellValueBoolean ( final Cell c , final String value ) { 
if ( "Y" . equalsIgnoreCase ( value ) || "Yes" . equalsIgnoreCase ( value ) || "True" . equalsIgnoreCase ( value ) ) { 
c . setCellValue ( true ) ; 
c . setCellValue ( false ) ; 
} private static void setCellValueDate ( final Cell c , final String value ) { 
String date = WebSheetUtility . parseDate ( value ) ; 
setCellValueString ( c , date ) ; 
} private static void setCellValueNumber ( final Cell c , final String value ) { 
double val = Double . parseDouble ( value . replace ( Character . toString ( ',' ) , "" ) ) ; 
c . setCellType ( CellType . NUMERIC ) ; 
c . setCellValue ( val ) ; 
} public static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , 
final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { 
int length = srcRowEnd - srcRowStart + 1 ; 
if ( length <= 0 ) { 
destSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; 
copySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; 
for ( int i = 0 ; i < srcSheet . getNumMergedRegions ( ) ; i ++ ) { 
CellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; 
if ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { 
int targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; 
int targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; 
CellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , 
cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; 
destSheet . addMergedRegion ( newCellRangeAddress ) ; 
} private static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , 
final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { 
Row newRow = destSheet . getRow ( destinationRowNum ) ; 
Row sourceRow = srcSheet . getRow ( sourceRowNum ) ; 
if ( newRow == null ) { 
newRow = destSheet . createRow ( destinationRowNum ) ; 
newRow . setHeight ( sourceRow . getHeight ( ) ) ; 
for ( int i = 0 ; i < sourceRow . getLastCellNum ( ) ; i ++ ) { 
copyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; 
if ( setHiddenColumn ) { 
ConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; 
} public static Cell copyCell ( final Sheet destSheet , final Row sourceRow , final Row newRow , final int cellIndex , 
final boolean checkLock ) { 
Cell sourceCell = sourceRow . getCell ( cellIndex ) ; 
if ( sourceCell == null ) { 
boolean refreshCell = false ; 
if ( sourceRow . equals ( newRow ) && ( sourceCell . getColumnIndex ( ) == cellIndex ) ) { 
sourceRow . removeCell ( sourceCell ) ; 
refreshCell = true ; 
Cell newCell = newRow . createCell ( cellIndex ) ; 
if ( ! refreshCell && ( sourceCell . getCellComment ( ) != null ) ) { 
cloneComment ( sourceCell , newCell ) ; 
copyCellSetStyle ( destSheet , sourceCell , newCell ) ; 
copyCellSetValue ( sourceCell , newCell , checkLock ) ; 
return newCell ; 
private static void copyCellSetValue ( final Cell sourceCell , final Cell newCell , final boolean checkLock ) { 
CellStyle newCellStyle = newCell . getCellStyle ( ) ; 
String name = sourceCell . getCellTypeEnum ( ) . toString ( ) ; 
CellValueType e = Enum . valueOf ( CellValueType . class , name ) ; 
e . setCellValue ( newCell , sourceCell , checkLock , newCellStyle ) ; 
private static void copyCellSetStyle ( final Sheet destSheet , final Cell sourceCell , final Cell newCell ) { 
CellStyle newCellStyle = getCellStyleFromSourceCell ( destSheet , sourceCell ) ; 
newCell . setCellStyle ( newCellStyle ) ; 
if ( sourceCell . getHyperlink ( ) != null ) { 
newCell . setHyperlink ( sourceCell . getHyperlink ( ) ) ; 
newCell . setCellType ( sourceCell . getCellTypeEnum ( ) ) ; 
} public static void cloneComment ( final Cell sourceCell , final Cell newCell ) { 
XSSFSheet sheet = ( XSSFSheet ) newCell . getSheet ( ) ; 
Drawing drawing = sheet . createDrawingPatriarch ( ) ; 
XSSFComment sourceComment = ( XSSFComment ) sourceCell . getCellComment ( ) ; 
ClientAnchor anchor = createCommentAnchor ( newCell , factory ) ; 
Comment comment = drawing . createCellComment ( anchor ) ; 
RichTextString str = factory . createRichTextString ( sourceComment . getString ( ) . toString ( ) ) ; 
comment . setAuthor ( sourceComment . getAuthor ( ) ) ; 
newCell . setCellComment ( comment ) ; 
comment . setColumn ( newCell . getColumnIndex ( ) ) ; 
comment . setRow ( newCell . getRowIndex ( ) ) ; 
matchCommentSettings ( newCell , sourceCell ) ; 
} private static ClientAnchor createCommentAnchor ( final Cell newCell , CreationHelper factory ) { 
ClientAnchor anchor = factory . createClientAnchor ( ) ; 
anchor . setCol1 ( newCell . getColumnIndex ( ) ) ; 
anchor . setCol2 ( newCell . getColumnIndex ( ) + 1 ) ; 
anchor . setRow1 ( newCell . getRowIndex ( ) ) ; 
anchor . setRow2 ( newCell . getRowIndex ( ) + 3 ) ; 
return anchor ; 
} public static void createOrInsertComment ( final Cell cell , final String commentStr ) { 
XSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; 
String originStr = "" ; 
if ( comment == null ) { 
ClientAnchor anchor = createCommentAnchor ( cell , factory ) ; 
comment = drawing . createCellComment ( anchor ) ; 
originStr = comment . getString ( ) . getString ( ) + "\n" ; 
originStr += commentStr ; 
RichTextString str = factory . createRichTextString ( originStr ) ; 
comment . setAuthor ( "" ) ; 
cell . setCellComment ( comment ) ; 
comment . setColumn ( cell . getColumnIndex ( ) ) ; 
comment . setRow ( cell . getRowIndex ( ) ) ; 
} private static void matchCommentSettings ( final Cell newCell , final Cell sourceCell ) { 
XSSFVMLDrawing sourceVml = getVmlDrawingFromCell ( sourceCell ) ; 
XSSFVMLDrawing targetVml = getVmlDrawingFromCell ( newCell ) ; 
CTShape sourceCtShape = getCtShapeFromVml ( sourceCell , sourceVml ) ; 
CTShape targetCtShape = getCtShapeFromVml ( newCell , targetVml ) ; 
targetCtShape . setType ( sourceCtShape . getType ( ) ) ; 
CTClientData sourceClientData = sourceCtShape . getClientDataArray ( 0 ) ; 
CTClientData targetClientData = targetCtShape . getClientDataArray ( 0 ) ; 
String [ ] anchorArray = sourceClientData . getAnchorList ( ) . get ( 0 ) . split ( "," ) ; 
int shiftRows = newCell . getRowIndex ( ) - sourceCell . getRowIndex ( ) ; 
anchorArray [ 2 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 2 ] . trim ( ) ) + shiftRows ) ; 
anchorArray [ 6 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 6 ] . trim ( ) ) + shiftRows ) ; 
targetClientData . getAnchorList ( ) . set ( 0 , FacesUtility . strJoin ( anchorArray , "," ) ) ; 
} private static XSSFVMLDrawing getVmlDrawingFromCell ( final Cell cell ) { 
XSSFSheet sourceSheet = ( XSSFSheet ) cell . getSheet ( ) ; 
for ( POIXMLDocumentPart sourcePart : sourceSheet . getRelations ( ) ) { 
if ( ( sourcePart != null ) && ( sourcePart instanceof XSSFVMLDrawing ) ) { 
return ( XSSFVMLDrawing ) sourcePart ; 
private static CTShape getCtShapeFromVml ( final Cell sourceCell , XSSFVMLDrawing sourceVml ) 
throws ReflectiveOperationException { 
Method findshape ; 
Class [ ] paramInt = new Class [ 2 ] ; 
paramInt [ 0 ] = Integer . TYPE ; 
paramInt [ 1 ] = Integer . TYPE ; 
findshape = sourceVml . getClass ( ) . getDeclaredMethod ( "findCommentShape" , paramInt ) ; 
findshape . setAccessible ( true ) ; 
return ( CTShape ) findshape . invoke ( sourceVml , sourceCell . getRowIndex ( ) , sourceCell . getColumnIndex ( ) ) ; 
} private static CellStyle getCellStyleFromSourceCell ( final Sheet destSheet , final Cell sourceCell ) { 
Workbook wb = destSheet . getWorkbook ( ) ; 
CellStyle newCellStyle = wb . createCellStyle ( ) ; 
newCellStyle . cloneStyleFrom ( sourceCell . getCellStyle ( ) ) ; 
return newCellStyle ; 
} public static String getCellIndexNumberKey ( final Cell cell ) { 
return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + TieConstants . CELL_ADDR_PRE_FIX 
+ cell . getRowIndex ( ) ; 
} public static String getCellIndexNumberKey ( final int columnIndex , final int rowIndex ) { 
return TieConstants . CELL_ADDR_PRE_FIX + columnIndex + TieConstants . CELL_ADDR_PRE_FIX + rowIndex ; 
} public static String getCellIndexLetterKey ( final String columnLetter , final int rowIndex ) { 
return TieConstants . CELL_ADDR_PRE_FIX + columnLetter + TieConstants . CELL_ADDR_PRE_FIX + rowIndex ; 
} public static String getCellIndexLetterKey ( final int columnIndex , final int rowIndex ) { 
return TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( columnIndex ) 
+ TieConstants . CELL_ADDR_PRE_FIX + rowIndex ; 
} public static void convertCell ( final SheetConfiguration sheetConfig , final FacesCell fcell , final Cell poiCell , 
final Map < String , CellRangeAddress > cellRangeMap , final int originRowIndex , 
final CellAttributesMap cellAttributesMap , final String saveAttrs ) { 
CellRangeAddress caddress ; 
String key = getCellIndexNumberKey ( poiCell ) ; 
caddress = cellRangeMap . get ( key ) ; 
fcell . setColspan ( caddress . getLastColumn ( ) - caddress . getFirstColumn ( ) + 1 ) ; 
fcell . setRowspan ( caddress . getLastRow ( ) - caddress . getFirstRow ( ) + 1 ) ; 
CellControlsUtility . setupControlAttributes ( originRowIndex , fcell , poiCell , sheetConfig , cellAttributesMap ) ; 
fcell . setHasSaveAttr ( SaveAttrsUtility . isHasSaveAttr ( poiCell , saveAttrs ) ) ; 
} public static int [ ] getRowColFromComponentAttributes ( final UIComponent target ) { 
int rowIndex = ( Integer ) target . getAttributes ( ) . get ( "data-row" ) ; 
int colIndex = ( Integer ) target . getAttributes ( ) . get ( "data-column" ) ; 
int [ ] list = new int [ 2 ] ; 
list [ 0 ] = rowIndex ; 
list [ 1 ] = colIndex ; 
} public static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { 
int initRows = 1 ; 
if ( "Repeat" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { 
initRows = sheetConfig . getBodyInitialRows ( ) ; 
if ( initRows < 1 ) { 
initRows = 1 ; 
return initRows ; 
} public static FacesRow getFacesRowFromBodyRow ( final int row , final List < FacesRow > bodyRows , final int topRow ) { 
FacesRow frow = null ; 
frow = bodyRows . get ( row - topRow ) ; 
return frow ; 
} public static FacesCell getFacesCellFromBodyRow ( final int row , final int col , final List < FacesRow > bodyRows , 
final int topRow , final int leftCol ) { 
FacesCell cell = null ; 
cell = bodyRows . get ( row - topRow ) . getCells ( ) . get ( col - leftCol ) ; 
return cell ; 
} public static Cell getPoiCellWithRowColFromCurrentPage ( final int rowIndex , final int colIndex , final Workbook wb ) { 
if ( wb != null ) { 
return getPoiCellFromSheet ( rowIndex , colIndex , wb . getSheetAt ( wb . getActiveSheetIndex ( ) ) ) ; 
} public static Cell getPoiCellFromSheet ( final int rowIndex , final int colIndex , final Sheet sheet1 ) { 
if ( ( sheet1 != null ) && ( sheet1 . getRow ( rowIndex ) != null ) ) { 
return sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; 
} public static String getSkeyFromPoiCell ( final Cell poiCell ) { 
return poiCell . getSheet ( ) . getSheetName ( ) + "!" 
+ CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , poiCell . getRowIndex ( ) ) ; 
} public static TieCell getOrAddTieCellInMap ( final Cell poiCell , HashMap < String , TieCell > tieCells ) { 
String skey = CellUtility . getSkeyFromPoiCell ( poiCell ) ; 
TieCell tieCell = tieCells . get ( skey ) ; 
if ( tieCell == null ) { 
tieCell = new TieCell ( ) ; 
tieCell . setSkey ( skey ) ; 
tieCells . put ( skey , tieCell ) ; 
return tieCell ; 
if ( ctObjChart instanceof CTBarChart ) { 
return ( ( CTBarChart ) ctObjChart ) . getSerList ( ) ; 
return emptySerlist ; 
public final CTAxDataSource getCtAxDataSourceFromSerList ( 
final List serList ) { 
if ( ( serList != null ) && ( ! serList . isEmpty ( ) ) 
&& ( serList . get ( 0 ) instanceof CTBarSer ) ) { 
return ( ( CTBarSer ) serList . get ( 0 ) ) . getCat ( ) ; 
if ( ctObjSer instanceof CTBarSer ) { 
return ( ( CTBarSer ) ctObjSer ) . getSpPr ( ) ; 
return ( ( CTBarSer ) ctObjSer ) . getVal ( ) ; 
} public final String getCurrentDataContextName ( ) { 
if ( currentDataContextName == null ) { 
List < String > list = this . getCurrentDataContextNameList ( ) ; 
sb . append ( ":" + list . get ( i ) ) ; 
sb . append ( list . get ( i ) ) ; 
this . setCurrentDataContextName ( sb . toString ( ) ) ; 
return currentDataContextName ; 
} public final Object evaluate ( final String expression , 
JexlContext jexlContext = new MapContext ( context ) ; 
JexlEngine jexl = JEXL_LOCAL . get ( ) ; 
Map < String , Expression > expMap = JEXL_MAP_LOCAL . get ( ) ; 
Expression jexlExpression = expMap . get ( expression ) ; 
if ( jexlExpression == null ) { 
jexlExpression = jexl . createExpression ( expression ) ; 
expMap . put ( expression , jexlExpression ) ; 
return jexlExpression . evaluate ( jexlContext ) ; 
} public final Object evaluate ( final Map < String , Object > context ) { 
return jExpression . evaluate ( jexlContext ) ; 
+ jExpression . getExpression ( ) , e ) ; 
this . rowIndex = this . getRow ( ) . getRowNum ( ) ; 
} public final void addRow ( final Integer sourceRowNum , 
final Row targetRow ) { 
List < SerialRow > mapRowList = rowsMap . get ( sourceRowNum ) ; 
if ( mapRowList == null ) { 
mapRowList = new ArrayList < > ( ) ; 
SerialRow serialTarget = new SerialRow ( targetRow , - 1 ) ; 
if ( ! mapRowList . contains ( serialTarget ) ) { 
mapRowList . add ( serialTarget ) ; 
rowsMap . put ( sourceRowNum , mapRowList ) ; 
} public final void removeRow ( final Integer sourceRowNum , 
if ( mapRowList != null ) { 
mapRowList . remove ( new SerialRow ( targetRow , - 1 ) ) ; 
} public final void mergeMap ( final RowsMapping addMap ) { 
Map < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; 
for ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { 
List < SerialRow > entryRowList = entry . getValue ( ) ; 
if ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) { 
for ( SerialRow row : entryRowList ) { 
this . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; 
} public final void recover ( final Sheet sheet ) { 
for ( Map . Entry < Integer , List < SerialRow > > entry : this . getRowsMap ( ) 
List < SerialRow > listRow = entry . getValue ( ) ; 
for ( SerialRow serialRow : listRow ) { 
serialRow . recover ( sheet ) ; 
} public static ChartType getChartType ( final CTChart ctChart ) { 
CTPlotArea plotArea = ctChart . getPlotArea ( ) ; 
for ( ChartType chartType : ChartType . values ( ) ) { 
if ( chartType . isThisType ( plotArea ) ) { 
return chartType ; 
} public static BasicStroke toStroke ( final String style ) { 
BasicStroke result = null ; 
if ( style != null ) { 
float lineWidth = STROKE_DEFAULT_LINE_WIDTH ; 
float [ ] dash = { STROKE_DEFAULT_DASH_WIDTH } ; 
float [ ] dot = { lineWidth } ; 
if ( style . equalsIgnoreCase ( STYLE_LINE ) ) { 
result = new BasicStroke ( lineWidth ) ; 
} else if ( style . equalsIgnoreCase ( STYLE_DASH ) ) { 
result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , 
BasicStroke . JOIN_MITER , 
STROKE_MITER_LIMIT_STYLE_DASH , dash , 
STROKE_DEFAULT_DASHPHASE ) ; 
} else if ( style . equalsIgnoreCase ( STYLE_DOT ) ) { 
STROKE_MITER_LIMIT_STYLE_DOT , dot , 
} public static ChartData initChartDataFromXSSFChart ( final String chartId , 
final XSSFChart chart , final XSSFWorkbook wb ) { 
ThemesTable themeTable = wb . getStylesSource ( ) . getTheme ( ) ; 
ChartData chartData = new ChartData ( ) ; 
XSSFRichTextString chartTitle = chart . getTitle ( ) ; 
if ( chartTitle != null ) { 
chartData . setTitle ( chartTitle . toString ( ) ) ; 
CTChart ctChart = chart . getCTChart ( ) ; 
ChartType chartType = ChartUtility . getChartType ( ctChart ) ; 
if ( chartType == null ) { 
chartData . setBgColor ( 
ColorUtility . getBgColor ( ctChart . getPlotArea ( ) , themeTable ) ) ; 
chartData . setId ( chartId ) ; 
chartData . setType ( chartType ) ; 
List < CTCatAx > ctCatAxList = ctChart . getPlotArea ( ) . getCatAxList ( ) ; 
if ( ( ctCatAxList != null ) && ( ! ctCatAxList . isEmpty ( ) ) ) { 
chartData . setCatAx ( new ChartAxis ( ctCatAxList . get ( 0 ) ) ) ; 
List < CTValAx > ctValAxList = ctChart . getPlotArea ( ) . getValAxList ( ) ; 
if ( ( ctValAxList != null ) && ( ! ctValAxList . isEmpty ( ) ) ) { 
chartData . setValAx ( new ChartAxis ( ctValAxList . get ( 0 ) ) ) ; 
ChartObject ctObj = chartType . createChartObject ( ) ; 
if ( ctObj == null ) { 
setUpChartData ( chartData , ctChart , themeTable , ctObj ) ; 
return chartData ; 
} public static void setUpChartData ( final ChartData chartData , 
final CTChart ctChart , final ThemesTable themeTable , 
final ChartObject ctObj ) { 
Object chartObj = null ; 
List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; 
if ( plotCharts != null && ( ! plotCharts . isEmpty ( ) ) ) { 
chartObj = plotCharts . get ( 0 ) ; 
if ( chartObj != null ) { 
List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; 
if ( ! AppUtils . emptyList ( bsers ) ) { 
chartData . buildCategoryList ( 
ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; 
chartData . buildSeriesList ( bsers , themeTable , ctObj ) ; 
} public static void initXSSFAnchorsMap ( final XSSFWorkbook wb , 
final ChartsData charsData ) { 
Map < String , ClientAnchor > anchortMap = charsData 
Map < String , String > positionMap = charsData . getChartPositionMap ( ) ; 
anchortMap . clear ( ) ; 
positionMap . clear ( ) ; 
initXSSFAnchorsMapForSheet ( anchortMap , positionMap , 
wb . getSheetAt ( i ) ) ; 
} private static void initXSSFAnchorsMapForSheet ( 
final Map < String , ClientAnchor > anchortMap , 
final Map < String , String > positionMap , final XSSFSheet sheet ) { 
CTDrawing ctDrawing = drawing . getCTDrawing ( ) ; 
if ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { 
List < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; 
for ( int j = 0 ; j < alist . size ( ) ; j ++ ) { 
CTTwoCellAnchor ctanchor = alist . get ( j ) ; 
String singleChartId = getAnchorAssociateChartId ( ctanchor ) ; 
if ( singleChartId != null ) { 
String chartId = sheet . getSheetName ( ) + "!" + singleChartId ; 
int dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; 
int dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; 
int dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; 
int dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; 
int col1 = ctanchor . getFrom ( ) . getCol ( ) ; 
int row1 = ctanchor . getFrom ( ) . getRow ( ) ; 
int col2 = ctanchor . getTo ( ) . getCol ( ) ; 
int row2 = ctanchor . getTo ( ) . getRow ( ) ; 
anchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , 
dy2 , col1 , row1 , col2 , row2 ) ) ; 
positionMap . put ( WebSheetUtility . getFullCellRefName ( 
sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; 
} private static String getAnchorAssociateChartId ( 
final CTTwoCellAnchor ctanchor ) { 
if ( ctanchor . getGraphicFrame ( ) == null ) { 
Node parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) 
. getGraphicData ( ) . getDomNode ( ) ; 
NodeList childNodes = parentNode . getChildNodes ( ) ; 
for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { 
Node childNode = childNodes . item ( i ) ; 
if ( ( childNode != null ) 
&& ( "c:chart" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) 
&& ( childNode . hasAttributes ( ) ) ) { 
String rId = getChartIdFromChildNodeAttributes ( 
childNode . getAttributes ( ) ) ; 
if ( rId != null ) { 
return rId ; 
} private static String getChartIdFromChildNodeAttributes ( 
final NamedNodeMap attrs ) { 
for ( int j = 0 ; j < attrs . getLength ( ) ; j ++ ) { 
Attr attribute = ( Attr ) attrs . item ( j ) ; 
if ( "r:id" . equalsIgnoreCase ( attribute . getName ( ) ) ) { 
return attribute . getValue ( ) ; 
wb . write ( out ) ; 
} public void recover ( ) { 
Map < String , SheetConfiguration > map = this . getSheetConfigMap ( ) ; 
for ( Entry < String , SheetConfiguration > entry : map . entrySet ( ) ) { 
entry . getValue ( ) . recover ( this . getWb ( ) ) ; 
public final int buildAt ( String fullName , 
final ConfigBuildRef configBuildRef , final int atRow , 
fullName = fullName + ":" + this . getCommandName ( ) ; 
Collection itemsCollection = ConfigurationUtility 
. transformToCollectionObject ( configBuildRef . getEngine ( ) , 
this . getItems ( ) , context ) ; 
String objClassName = this . getClassName ( ) ; 
if ( objClassName == null ) { 
objClassName = configBuildRef . getCollectionObjNameMap ( ) 
. get ( this . getVar ( ) ) ; 
if ( configBuildRef . isAddMode ( ) && itemsCollection . isEmpty ( ) ) { 
itemsCollection 
. add ( Class . forName ( objClassName ) . newInstance ( ) ) ; 
int insertPosition = buildEachObjects ( fullName , configBuildRef , 
atRow , context , currentRowsMappingList , itemsCollection , 
objClassName ) ; 
return insertPosition - atRow ; 
private int buildEachObjects ( String fullName , 
final List < RowsMapping > currentRowsMappingList , 
final Collection itemsCollection , final String objClassName ) { 
int insertPosition = atRow ; 
String thisObjClassName = objClassName ; 
for ( Object obj : itemsCollection ) { 
if ( thisObjClassName == null ) { 
thisObjClassName = obj . getClass ( ) . getName ( ) ; 
configBuildRef . getCollectionObjNameMap ( ) . put ( this . var , 
thisObjClassName ) ; 
context . put ( var , obj ) ; 
CommandUtility . insertEachTemplate ( this . getConfigRange ( ) , 
configBuildRef , index , insertPosition , unitRowsMapping ) ; 
ConfigRange currentRange = ConfigurationUtility 
. buildCurrentRange ( this . getConfigRange ( ) , 
configBuildRef . getSheet ( ) , insertPosition ) ; 
String unitFullName = fullName + "." + index ; 
currentRange . getAttrs ( ) . setAllowAdd ( false ) ; 
if ( ( this . allowAdd != null ) 
&& ( "true" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { 
configBuildRef . putShiftAttrs ( unitFullName , 
currentRange . getAttrs ( ) , 
new RowsMapping ( unitRowsMapping ) ) ; 
insertPosition , context , currentRowsMappingList ) ; 
insertPosition += length ; 
context . remove ( var ) ; 
return insertPosition ; 
} public final void saveDataInContext ( final Cell poiCell , 
String saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , this ) ; 
SaveAttrsUtility . saveDataToObjectInContext ( 
parent . getSerialDataContext ( ) . getDataContext ( ) , 
saveAttr , strValue , parent . getExpEngine ( ) ) ; 
parent . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( 
RequestContext . getCurrentInstance ( ) , true ) ; 
} public final void reCalc ( ) { 
parent . getFormulaEvaluator ( ) . clearAllCachedResultValues ( ) ; 
parent . getFormulaEvaluator ( ) . evaluateAll ( ) ; 
} public final Cell getPoiCellWithRowColFromCurrentPage ( 
final int rowIndex , final int colIndex ) { 
return CellUtility . getPoiCellWithRowColFromCurrentPage ( rowIndex , 
colIndex , parent . getWb ( ) ) ; 
} public final Cell getPoiCellWithRowColFromTab ( final int rowIndex , 
final int colIndex , final String tabName ) { 
if ( parent . getWb ( ) != null ) { 
return CellUtility . getPoiCellFromSheet ( rowIndex , colIndex , 
parent . getWb ( ) . getSheet ( parent . getSheetConfigMap ( ) 
. get ( tabName ) . getSheetName ( ) ) ) ; 
} public final FacesCell getFacesCellWithRowColFromCurrentPage ( 
if ( parent . getBodyRows ( ) != null ) { 
int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
int left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
return parent . getBodyRows ( ) . get ( rowIndex - top ) . getCells ( ) 
. get ( colIndex - left ) ; 
} public final void restoreDataContext ( final String fullName ) { 
if ( ! isNeedRestore ( fullName , parts ) ) { 
boolean stopSkip = false ; 
List < String > list = parent . getCurrent ( ) 
. getCurrentDataContextNameList ( ) ; 
int listSize = list . size ( ) ; 
for ( int i = 0 ; i < parts . length ; i ++ ) { 
boolean skip = false ; 
if ( ( ! stopSkip ) && ( i < listSize ) ) { 
String listPart = list . get ( i ) ; 
if ( part . equalsIgnoreCase ( listPart ) ) { 
skip = true ; 
if ( ! skip ) { 
stopSkip = true ; 
startRestoreDataContext ( part ) ; 
if ( stopSkip ) { 
parent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; 
} public final CollectionObject getLastCollect ( final String fullName ) { 
String part = parts [ parts . length - 1 ] ; 
return startRestoreDataContext ( part ) ; 
} private boolean isNeedRestore ( final String fullName , 
final String [ ] parts ) { 
if ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) 
&& ( parent . getCurrent ( ) . getCurrentDataContextName ( ) 
. startsWith ( fullName . toLowerCase ( ) ) ) ) { 
return ( ( parts != null ) && ( parts . length > 1 ) ) ; 
} private CollectionObject startRestoreDataContext ( final String part ) { 
if ( part . startsWith ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX ) ) { 
String [ ] varparts = part . split ( "\\." ) ; 
CollectionObject collect = new CollectionObject ( ) ; 
collect . setEachCommand ( 
CommandUtility 
. getEachCommandFromPartsName ( 
parent . getCurrentSheetConfig ( ) 
. getCommandIndexMap ( ) , 
varparts ) ) ; 
collect . setLastCollection ( ConfigurationUtility 
. transformToCollectionObject ( parent . getExpEngine ( ) , 
collect . getEachCommand ( ) . getItems ( ) , 
parent . getSerialDataContext ( ) 
. getDataContext ( ) ) ) ; 
collect . setLastCollectionIndex ( 
CommandUtility . prepareCollectionDataInContext ( varparts , 
collect . getLastCollection ( ) , 
return collect ; 
} public final void shiftRowRef ( final Sheet sheet , final int shiftnum ) { 
this . setFirstRowRef ( sheet 
. getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) 
. getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , 
MissingCellPolicy . CREATE_NULL_AS_BLANK ) , 
this . setLastRowPlusRef ( sheet , 
attrs . getLastRowPlusAddr ( ) . getColumn ( ) , 
attrs . getLastRowPlusAddr ( ) . getRow ( ) + shiftnum - 1 , 
command . shiftRowRef ( sheet , shiftnum ) ; 
} public final void setFirstRowRef ( final Cell pFirstRowRef , 
final boolean alsoCreateAddr ) { 
this . attrs . setFirstRowRef ( pFirstRowRef ) ; 
if ( alsoCreateAddr ) { 
this . setFirstRowAddr ( new SerialCellAddress ( pFirstRowRef ) ) ; 
} public final void setLastRowPlusRef ( final Sheet sheet , 
final int rightCol , final int lastRow , 
final boolean alsoSetAddr ) { 
if ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) { 
Row row = sheet . getRow ( lastRow + 1 ) ; 
row = sheet . createRow ( lastRow + 1 ) ; 
Cell cell = row . getCell ( rightCol ) ; 
if ( cell == null ) { 
cell = row . getCell ( rightCol , 
this . attrs . setLastCellCreated ( true ) ; 
this . attrs . setLastCellCreated ( false ) ; 
this . attrs . setLastRowPlusRef ( cell ) ; 
if ( alsoSetAddr ) { 
this . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; 
this . attrs . setLastRowPlusRef ( null ) ; 
this . attrs . setLastRowPlusAddr ( null ) ; 
} public final int buildAt ( final String fullName , 
Command command = commandList . get ( i ) ; 
command . setFinalLength ( 0 ) ; 
int populatedLength = command . buildAt ( fullName , 
configBuildRef , 
command . getConfigRange ( ) . getFirstRowRef ( ) 
. getRowIndex ( ) , 
context , currentRowsMappingList ) ; 
command . setFinalLength ( populatedLength ) ; 
buildCells ( fullName , configBuildRef , atRow , context , 
currentRowsMappingList ) ; 
return this . getLastRowPlusRef ( ) . getRowIndex ( ) 
- this . getFirstRowRef ( ) . getRowIndex ( ) ; 
} private void buildCells ( final String fullName , 
final List < RowsMapping > rowsMappingList ) { 
if ( ( context == null ) || context . isEmpty ( ) ) { 
List < RowsMapping > allRowsMappingList = ConfigurationUtility 
. findChildRowsMappingFromShiftMap ( fullName , 
allRowsMappingList . addAll ( rowsMappingList ) ; 
int lastRowPlus = this . getLastRowPlusRef ( ) . getRowIndex ( ) ; 
configBuildRef . getWatchList ( ) , allRowsMappingList ) ; 
for ( int i = atRow ; i < lastRowPlus ; i ++ ) { 
buildCellsForRow ( configBuildRef . getSheet ( ) . getRow ( i ) , fullName , 
context , configBuildRef , shiftFormulaRef ) ; 
} private void buildCellsForRow ( final Row row , final String fullName , 
ShiftFormulaRef shiftFormulaRef ) { 
if ( ( row == null ) 
|| ! ConfigurationUtility . isStaticRowRef ( this , row ) ) { 
buildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; 
ConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; 
} private void buildSingleCell ( final Cell cell , 
CommandUtility . evaluate ( context , cell , 
configBuildRef . getEngine ( ) ) ; 
if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { 
String originFormula = cell . getCellFormula ( ) ; 
ConfigurationUtility . buildCellFormulaForShiftedRows ( 
configBuildRef . getSheet ( ) , 
configBuildRef . getWbWrapper ( ) , shiftFormulaRef , 
cell , cell . getCellFormula ( ) ) ; 
configBuildRef . getCachedCells ( ) . put ( cell , 
this . getAttrs ( ) . recover ( sheet ) ; 
if ( this . commandList != null ) { 
for ( ConfigCommand command : this . commandList ) { 
command . recover ( sheet ) ; 
Gson objGson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; 
this . mapToJson = objGson . toJson ( this . dataContext ) ; 
Type listType = new TypeToken < Map < String , Object > > ( ) { 
} . getType ( ) ; 
this . dataContext = objGson . fromJson ( mapToJson , listType ) ; 
} public final void buildCategoryList ( final CTAxDataSource ctAxDs ) { 
List < ParsedCell > cells = new ArrayList < > ( ) ; 
String fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; 
String sheetName = WebSheetUtility 
. getSheetNameFromFullCellRefName ( fullRangeName ) ; 
CellRangeAddress region = CellRangeAddress . valueOf ( 
WebSheetUtility . removeSheetNameFromFullCellRefName ( 
fullRangeName ) ) ; 
for ( int row = region . getFirstRow ( ) ; row <= region 
for ( int col = region . getFirstColumn ( ) ; col <= region 
cells . add ( new ParsedCell ( sheetName , row , col ) ) ; 
this . setCategoryList ( cells ) ; 
public final void buildSeriesList ( final List bsers , 
final ThemesTable themeTable , final ChartObject ctObj ) { 
List < ChartSeries > lseriesList = new ArrayList < > ( ) ; 
for ( int index = 0 ; index < bsers . size ( ) ; index ++ ) { 
Object ctObjSer = bsers . get ( index ) ; 
ChartSeries ctSer = buildChartSeriesInList ( themeTable , 
ctObj , ctObjSer , index ) ; 
lseriesList . add ( ctSer ) ; 
this . setSeriesList ( lseriesList ) ; 
} private ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , 
final ChartObject ctObj , final Object ctObjSer , final int index ) { 
ChartSeries ctSer = new ChartSeries ( ) ; 
ctSer . setSeriesLabel ( new ParsedCell ( 
ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; 
ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , 
ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , 
themeTable , ctObj . isLineColor ( ) ) ) ; 
String fullRangeName = ( ctObj 
. getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) 
. getF ( ) ; 
CellRangeAddress region = CellRangeAddress 
. valueOf ( WebSheetUtility 
. removeSheetNameFromFullCellRefName ( 
ctSer . setValueList ( cells ) ; 
ctSer . setValueColorList ( getColorListFromDPTWithValueList ( 
ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , 
themeTable , ctObj ) ) ; 
return ctSer ; 
} private List < XColor > getColorListFromDPTWithValueList ( 
final List < CTDPt > dptList , final List < ParsedCell > cells , 
List < XColor > colors = new ArrayList < > ( ) ; 
if ( ( dptList != null ) && ( cells != null ) ) { 
for ( int index = 0 ; index < cells . size ( ) ; index ++ ) { 
CTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; 
CTShapeProperties ctSpPr = null ; 
if ( dpt != null ) { 
ctSpPr = dpt . getSpPr ( ) ; 
colors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , 
return colors ; 
} private CTDPt getDPtFromListWithIndex ( final List < CTDPt > dptList , 
if ( dptList != null ) { 
for ( CTDPt dpt : dptList ) { 
if ( dpt . getIdx ( ) . getVal ( ) == index ) { 
return dpt ; 
} public final void setCommandIndexMap ( 
final Map < String , Command > pcommandIndexMap ) { 
if ( pcommandIndexMap instanceof HashMap ) { 
this . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; 
this . commandIndexMap = new HashMap < > ( ) ; 
this . commandIndexMap . putAll ( pcommandIndexMap ) ; 
} public void recover ( final Workbook wb ) { 
Sheet sheet = wb . getSheet ( this . sheetName ) ; 
this . getSerialCachedCells ( ) . recover ( sheet ) ; 
this . getSerialFinalCommentMap ( ) . recover ( sheet ) ; 
this . getFormCommand ( ) . recover ( sheet ) ; 
if ( this . getShiftMap ( ) != null ) { 
for ( Map . Entry < String , ConfigRangeAttrs > entry : this 
. getShiftMap ( ) . entrySet ( ) ) { 
entry . getValue ( ) . recover ( sheet ) ; 
if ( this . getCommandIndexMap ( ) != null ) { 
for ( Map . Entry < String , Command > entry : this 
. getCommandIndexMap ( ) . entrySet ( ) ) { 
} public static void getPictruesMap ( final Workbook wb , 
final Map < String , Picture > picMap ) { 
getXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; 
} private static void getXSSFPictruesMap ( final XSSFWorkbook wb , 
picMap . clear ( ) ; 
List < XSSFPictureData > pictures = wb . getAllPictures ( ) ; 
if ( pictures . isEmpty ( ) ) { 
for ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { 
indexPictureInMap ( picMap , sheet , dr ) ; 
} private static void indexPictureInMap ( final Map < String , Picture > picMap , 
final XSSFSheet sheet , final POIXMLDocumentPart dr ) { 
if ( dr instanceof XSSFDrawing ) { 
XSSFDrawing drawing = ( XSSFDrawing ) dr ; 
List < XSSFShape > shapes = drawing . getShapes ( ) ; 
for ( XSSFShape shape : shapes ) { 
if ( shape instanceof XSSFPicture ) { 
XSSFPicture pic = ( XSSFPicture ) shape ; 
XSSFClientAnchor anchor = pic . getPreferredSize ( ) ; 
CTMarker ctMarker = anchor . getFrom ( ) ; 
String picIndex = WebSheetUtility . getFullCellRefName ( 
sheet . getSheetName ( ) , ctMarker . getRow ( ) , 
ctMarker . getCol ( ) ) ; 
picMap . put ( picIndex , pic ) ; 
} public static String generatePictureStyle ( final Sheet sheet1 , 
final FacesCell fcell , final Cell cell , final Picture pic ) { 
ClientAnchor anchor = pic . getClientAnchor ( ) ; 
AnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , 
anchor ) ; 
if ( anchorSize != null ) { 
return "MARGIN-LEFT:" 
+ String . format ( "%.2f" , anchorSize . getPercentLeft ( ) ) 
+ "%;MARGIN-TOP:" 
+ String . format ( "%.2f" , anchorSize . getPercentTop ( ) ) 
+ "%;width:" + String . format ( "%.2f" , 
anchorSize . getPercentWidth ( ) ) 
+ "%;" ; 
} public static String generateChartStyle ( final Sheet sheet1 , 
final FacesCell fcell , final Cell cell , final String chartId , 
final Map < String , ClientAnchor > anchorsMap ) { 
ClientAnchor anchor = anchorsMap . get ( chartId ) ; 
+ "%;width:" 
+ String . format ( "%.2f" , 
+ "%;height:135%;" ; 
} public static AnchorSize getAnchorSize ( final Sheet sheet1 , 
final FacesCell fcell , final Cell cell , 
final ClientAnchor anchor ) { 
if ( ! ( sheet1 instanceof XSSFSheet ) ) { 
double picWidth = 0.0 ; 
double picHeight = 0.0 ; 
int left = anchor . getDx1 ( ) 
/ org . apache . poi . util . Units . EMU_PER_PIXEL ; 
int top = ( int ) ( ( double ) anchor . getDy1 ( ) 
/ org . apache . poi . util . Units . EMU_PER_PIXEL 
/ WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; 
int right = anchor . getDx2 ( ) 
int bottom = ( int ) ( ( double ) anchor . getDy2 ( ) 
double cellWidth = 0.0 ; 
double cellHeight = 0.0 ; 
if ( ( cell != null ) && ( fcell != null ) ) { 
for ( int col = cell . getColumnIndex ( ) ; col < cell 
. getColumnIndex ( ) + fcell . getColspan ( ) ; col ++ ) { 
cellWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
double lastCellWidth = sheet1 . getColumnWidthInPixels ( 
cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; 
for ( int rowIndex = cell . getRowIndex ( ) ; rowIndex < cell 
. getRowIndex ( ) + fcell . getRowspan ( ) ; rowIndex ++ ) { 
cellHeight += WebSheetUtility . pointsToPixels ( 
sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; 
double lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 
. getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) 
. getHeightInPoints ( ) ) ; 
picWidth = cellWidth - lastCellWidth + right - left ; 
picHeight = cellHeight - lastCellHeight + bottom - top ; 
for ( short col = anchor . getCol1 ( ) ; col < anchor 
. getCol2 ( ) ; col ++ ) { 
picWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
for ( int rowindex = anchor . getRow1 ( ) ; rowindex < anchor 
. getRow2 ( ) ; rowindex ++ ) { 
Row row = sheet1 . getRow ( rowindex ) ; 
picHeight += WebSheetUtility 
. pointsToPixels ( row . getHeightInPoints ( ) ) ; 
return new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , 
cellWidth , cellHeight ) ; 
} public final void put ( final Cell cell , final CellType formula ) { 
Map < Cell , FormulaMapping > map = cachedMap ; 
if ( ( cell != null ) && ( ( formula == null ) 
|| ( cell . getCellTypeEnum ( ) == formula ) ) ) { 
String value = CellUtility . getCellValueWithFormat ( cell , 
FormulaMapping f = map . get ( cell ) ; 
f = new FormulaMapping ( ) ; 
f . setValue ( value ) ; 
map . put ( cell , f ) ; 
} public final void put ( final Cell cell , final String originFormula ) { 
if ( ( cell != null ) && ( originFormula != null ) ) { 
f . setOriginFormula ( originFormula ) ; 
} public final boolean isValueChanged ( final Cell cell ) { 
String newValue = CellUtility . getCellValueWithFormat ( cell , 
parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) ; 
return isValueChanged ( cell , newValue ) ; 
} public final boolean isValueChanged ( final Cell cell , 
final String pnewValue ) { 
String oldValue = map . get ( cell ) . getValue ( ) ; 
String newValue = pnewValue ; 
if ( oldValue == null ) { 
oldValue = "" ; 
if ( newValue == null ) { 
newValue = "" ; 
return ( ! oldValue . equals ( newValue ) ) ; 
} public Pattern getPattern ( ) { 
if ( ( this . pattern == null ) && ( alias != null ) ) { 
this . pattern = Pattern . compile ( "\\s*" + ParserUtility . wildcardToRegex ( alias ) ) ; 
return pattern ; 
public final void encodeBegin ( final FacesContext context ) 
webSheetBean = ( TieWebSheetBean ) this . getAttributes ( ) 
. get ( TieConstants . ATTRS_WEBSHEETBEAN ) ; 
if ( ( webSheetBean != null ) 
&& ( webSheetBean . getWebFormClientId ( ) == null ) ) { 
webSheetBean . setClientId ( this . getClientId ( ) ) ; 
webSheetBean . setWebFormClientId ( 
this . getClientId ( ) + ":" + TieConstants . COMPONENT_ID ) ; 
String maxrows = ( String ) this . getAttributes ( ) 
. get ( "maxRowsPerPage" ) ; 
if ( ( maxrows != null ) && ( ! maxrows . isEmpty ( ) ) ) { 
webSheetBean . setMaxRowsPerPage ( Integer . valueOf ( maxrows ) ) ; 
Boolean hideSingleSheetTabTitle = ( Boolean ) this . getAttributes ( ) 
. get ( "hideSingleSheetTabTitle" ) ; 
if ( hideSingleSheetTabTitle != null ) { 
webSheetBean . setHideSingleSheetTabTitle ( 
hideSingleSheetTabTitle ) ; 
super . encodeBegin ( context ) ; 
} public StreamedContent getChart ( ) throws IOException { 
String chartId = context . getExternalContext ( ) 
. getRequestParameterMap ( ) . get ( "chartViewId" ) ; 
BufferedImage bufferedImg = ( BufferedImage ) FacesContext 
. getSessionMap ( ) . get ( chartId ) ; 
ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; 
ImageIO . write ( bufferedImg , "png" , os ) ; 
. getSessionMap ( ) . remove ( chartId ) ; 
os . toByteArray ( ) ) , "image/png" ) ; 
this . cellAddr = new SerialCellAddress ( this . cell ) ; 
if ( this . cellAddr != null ) { 
this . setCell ( sheet . getRow ( this . cellAddr . getRow ( ) ) 
. getCell ( this . cellAddr . getColumn ( ) ) ) ; 
} public static String getRowStyle ( final Workbook wb , final Cell poiCell , 
final String inputType , final float rowHeight , 
final int rowspan ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
if ( ( cellStyle != null ) && ( rowspan == 1 ) ) { 
short fontIdx = cellStyle . getFontIndex ( ) ; 
Font font = wb . getFontAt ( fontIdx ) ; 
float maxHeight = rowHeight ; 
if ( ! inputType . isEmpty ( ) ) { 
maxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , 
rowHeight ) ; 
return "height:" + WebSheetUtility . pointsToPixels ( maxHeight ) 
+ "px;" ; 
} public static String getCellFontStyle ( final Workbook wb , 
final Cell poiCell ) { 
StringBuilder webStyle = new StringBuilder ( ) ; 
if ( cellStyle != null ) { 
if ( font . getItalic ( ) ) { 
if ( font . getBold ( ) ) { 
webStyle . append ( 
String decoration = getCellFontDecoration ( font ) ; 
if ( decoration . length ( ) > 0 ) { 
webStyle . append ( "text-decoration:" + decoration + ";" ) ; 
webStyle . append ( getCellFontColor ( font ) ) ; 
return webStyle . toString ( ) ; 
} private static String getCellFontColor ( final Font font ) { 
short [ ] rgbfix = { TieConstants . RGB_MAX , TieConstants . RGB_MAX , 
TieConstants . RGB_MAX } ; 
if ( font instanceof XSSFFont ) { 
XSSFColor color = ( ( XSSFFont ) font ) . getXSSFColor ( ) ; 
rgbfix = ColorUtility . getTripletFromXSSFColor ( color ) ; 
if ( rgbfix [ 0 ] != TieConstants . RGB_MAX ) { 
return "color:rgb(" + FacesUtility . strJoin ( rgbfix , "," ) + ");" ; 
} private static String getCellFontDecoration ( final Font font ) { 
StringBuilder decoration = new StringBuilder ( ) ; 
if ( font . getUnderline ( ) != 0 ) { 
if ( font . getStrikeout ( ) ) { 
return decoration . toString ( ) ; 
} public static String getCellStyle ( final Workbook wb , final Cell poiCell , 
final String inputType ) { 
webStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; 
webStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; 
webStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , 
cellStyle ) ) ; 
} public static String getColumnStyle ( final Workbook wb , 
final float rowHeight ) { 
String inputType = fcell . getInputType ( ) ; 
if ( fcell . isContainPic ( ) || fcell . isContainChart ( ) ) { 
webStyle . append ( getRowStyle ( wb , poiCell , inputType , rowHeight , 
fcell . getRowspan ( ) ) ) ; 
webStyle . append ( getAlignmentFromCellType ( poiCell ) ) ; 
} private static String getAlignmentFromCell ( final Cell poiCell , 
switch ( cellStyle . getAlignmentEnum ( ) ) { 
case LEFT : 
style = TieConstants . TEXT_ALIGN_LEFT ; 
case RIGHT : 
style = TieConstants . TEXT_ALIGN_RIGHT ; 
case CENTER : 
style = TieConstants . TEXT_ALIGN_CENTER ; 
case GENERAL : 
style = getAlignmentFromCellType ( poiCell ) ; 
} private static String getVerticalAlignmentFromCell ( 
switch ( cellStyle . getVerticalAlignmentEnum ( ) ) { 
case TOP : 
style = TieConstants . VERTICAL_ALIGN_TOP ; 
style = TieConstants . VERTICAL_ALIGN_CENTER ; 
case BOTTOM : 
style = TieConstants . VERTICAL_ALIGN_BOTTOM ; 
} public static int calcTotalWidth ( final Sheet sheet1 , final int firstCol , 
final int lastCol , final int additionalWidth ) { 
int totalWidth = additionalWidth ; 
for ( int i = firstCol ; i <= lastCol ; i ++ ) { 
totalWidth += sheet1 . getColumnWidth ( i ) ; 
return totalWidth ; 
} public static int calcTotalHeight ( final Sheet sheet1 , 
final int firstRow , final int lastRow , 
final int additionalHeight ) { 
int totalHeight = additionalHeight ; 
for ( int i = firstRow ; i <= lastRow ; i ++ ) { 
totalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; 
return totalHeight ; 
} public static void setupCellStyle ( final Workbook wb , 
if ( ( cellStyle != null ) && ( ! cellStyle . getLocked ( ) ) ) { 
if ( fcell . getInputType ( ) . isEmpty ( ) ) { 
fcell . setInputType ( 
CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; 
if ( fcell . getControl ( ) . isEmpty ( ) 
&& ( ! fcell . getInputType ( ) . isEmpty ( ) ) ) { 
fcell . setControl ( "text" ) ; 
setInputStyleBaseOnInputType ( fcell , poiCell ) ; 
String webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) 
+ getCellFontStyle ( wb , poiCell ) 
+ getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , 
fcell . getRowspan ( ) ) ; 
fcell . setStyle ( webStyle ) ; 
fcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; 
} static void setInputStyleBaseOnInputType ( final FacesCell fcell , 
if ( ( fcell == null ) || fcell . getInputType ( ) . isEmpty ( ) ) { 
switch ( fcell . getInputType ( ) ) { 
case TieConstants . CELL_INPUT_TYPE_PERCENTAGE : 
fcell . setSymbol ( "%" ) ; 
fcell . setSymbolPosition ( "p" ) ; 
fcell . setDecimalPlaces ( 
CellStyleUtility . getDecimalPlacesFromFormat ( poiCell ) ) ; 
case TieConstants . CELL_INPUT_TYPE_INTEGER : 
fcell . setDecimalPlaces ( ( short ) 0 ) ; 
case TieConstants . CELL_INPUT_TYPE_DOUBLE : 
fcell . setSymbol ( CellStyleUtility . getSymbolFromFormat ( poiCell ) ) ; 
fcell . setSymbolPosition ( 
CellStyleUtility . getSymbolPositionFromFormat ( poiCell ) ) ; 
private static String getInputTypeFromCellType ( final Cell cell ) { 
String inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; 
if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { 
inputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; 
CellStyle style = cell . getCellStyle ( ) ; 
int formatIndex = style . getDataFormat ( ) ; 
String formatString = style . getDataFormatString ( ) ; 
if ( DateUtil . isADateFormat ( formatIndex , formatString ) ) { 
inputType = TieConstants . CELL_INPUT_TYPE_DATE ; 
if ( isAPercentageCell ( formatString ) ) { 
inputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; 
return inputType ; 
} private static short getDecimalPlacesFromFormat ( final Cell cell ) { 
if ( style == null ) { 
if ( formatString == null ) { 
int ipos = formatString . indexOf ( '.' ) ; 
if ( ipos < 0 ) { 
short counter = 0 ; 
for ( int i = ipos + 1 ; i < formatString . length ( ) ; i ++ ) { 
if ( formatString . charAt ( i ) == '0' ) { 
} private static String getSymbolFromFormat ( final Cell cell ) { 
if ( formatString . indexOf ( TieConstants . CELL_ADDR_PRE_FIX ) < 0 ) { 
int ipos = formatString . indexOf ( "[$" ) ; 
return "$" ; 
return formatString . substring ( ipos + 2 , 
formatString . indexOf ( ']' , ipos ) ) ; 
} private static String getSymbolPositionFromFormat ( final Cell cell ) { 
return "p" ; 
int symbolpos = formatString . indexOf ( '$' ) ; 
int numberpos = formatString . indexOf ( '#' ) ; 
if ( numberpos < 0 ) { 
numberpos = formatString . indexOf ( '0' ) ; 
if ( symbolpos < numberpos ) { 
return "s" ; 
} public static Set < String > getResourcePaths ( final FacesContext context , 
final String path ) { 
return context . getExternalContext ( ) . getResourcePaths ( path ) ; 
} public static InputStream getResourceAsStream ( 
final FacesContext context , final String path ) { 
return context . getExternalContext ( ) . getResourceAsStream ( path ) ; 
public static < T > T evaluateExpressionGet ( final FacesContext context , 
final String expression ) { 
if ( expression == null ) { 
return ( T ) context . getApplication ( ) . evaluateExpressionGet ( context , 
expression , Object . class ) ; 
} public static String removePrefixPath ( final String prefix , 
final String resource ) { 
String normalizedResource = resource ; 
if ( normalizedResource . startsWith ( prefix ) ) { 
normalizedResource = normalizedResource 
. substring ( prefix . length ( ) - 1 ) ; 
return normalizedResource ; 
} public static boolean evalInputType ( final String input , 
final String type ) { 
Scanner scanner = new Scanner ( input ) ; 
boolean ireturn = false ; 
if ( "Integer" . equalsIgnoreCase ( type ) ) { 
ireturn = scanner . hasNextInt ( ) ; 
} else if ( "Double" . equalsIgnoreCase ( type ) ) { 
ireturn = scanner . hasNextDouble ( ) ; 
} else if ( "Boolean" . equalsIgnoreCase ( type ) ) { 
ireturn = scanner . hasNextBoolean ( ) ; 
} else if ( "Byte" . equalsIgnoreCase ( type ) ) { 
ireturn = scanner . hasNextByte ( ) ; 
} else if ( type . toLowerCase ( ) . startsWith ( "text" ) ) { 
ireturn = true ; 
scanner . close ( ) ; 
return ireturn ; 
public static < T > T findBean ( final String beanName ) { 
TieConstants . EL_START + beanName + TieConstants . EL_END , 
Object . class ) ; 
} public static < T > T evaluateExpression ( final String expression , 
final Class < ? extends T > expected ) { 
return evaluateExpression ( FacesContext . getCurrentInstance ( ) , 
expression , expected ) ; 
} public static < T > T evaluateExpression ( final FacesContext context , 
final String expression , final Class < ? extends T > expected ) { 
return context . getApplication ( ) . evaluateExpressionGet ( context , 
} public static String strJoin ( final short [ ] aArr , final String sSep ) { 
StringBuilder sbStr = new StringBuilder ( ) ; 
for ( int i = 0 , il = aArr . length ; i < il ; i ++ ) { 
sbStr . append ( sSep ) ; 
sbStr . append ( aArr [ i ] ) ; 
return sbStr . toString ( ) ; 
} public static double round ( final double value , final int places ) { 
if ( places < 0 ) { 
BigDecimal bd = BigDecimal . valueOf ( value ) ; 
bd = bd . setScale ( places , RoundingMode . HALF_UP ) ; 
return bd . doubleValue ( ) ; 
} public String getTabType ( ) { 
int sheetId = webFormTabView . getActiveIndex ( ) ; 
if ( ( sheetId >= 0 ) && ( tabs != null ) ) { 
if ( sheetId >= tabs . size ( ) ) { 
sheetId = 0 ; 
tabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; 
tabType = TieConstants . TAB_TYPE_NONE ; 
return tabType ; 
} public String getTabStyle ( ) { 
String tabStyle = TieConstants . TAB_STYLE_VISIBLE ; 
if ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) { 
tabStyle = TieConstants . TAB_STYLE_INVISIBLE ; 
return tabStyle ; 
} public String getDefaultDatePattern ( ) { 
if ( defaultDatePattern == null ) { 
DateFormat formatter = DateFormat . getDateInstance ( DateFormat . SHORT , Locale . getDefault ( ) ) ; 
defaultDatePattern = ( ( SimpleDateFormat ) formatter ) . toLocalizedPattern ( ) ; 
return defaultDatePattern ; 
} public String getDecimalSeparatorByDefaultLocale ( ) { 
final DecimalFormat nf = ( DecimalFormat ) DecimalFormat . getInstance ( getDefaultLocale ( ) ) ; 
return "" + nf . getDecimalFormatSymbols ( ) . getDecimalSeparator ( ) ; 
} public String getThousandSeparatorByDefaultLocale ( ) { 
return "" + nf . getDecimalFormatSymbols ( ) . getGroupingSeparator ( ) ; 
} public void setTieCommandAliasList ( String aliasListJson ) { 
Gson gson = new Gson ( ) ; 
Type aliasListType = new TypeToken < ArrayList < TieCommandAlias > > ( ) { } . getType ( ) ; 
this . tieCommandAliasList = gson . fromJson ( aliasListJson , aliasListType ) ; 
} private List < Integer > buildFormWatchList ( 
final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { 
List < Integer > watchList = new ArrayList < > ( ) ; 
ConfigRange cRange = this . getConfigRange ( ) ; 
List < ConfigCommand > commandList = cRange . getCommandList ( ) ; 
if ( commandList . isEmpty ( ) ) { 
return watchList ; 
int lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; 
if ( lastStaticRow < 0 ) { 
lastStaticRow = this . getTopRow ( ) ; 
int sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; 
for ( int i = this . getTopRow ( ) ; i <= this . getLastRow ( ) ; i ++ ) { 
buildWatchListForCell ( wbWrapper , sheetIndex , cell , 
watchList , lastStaticRow ) ; 
} private void buildWatchListForCell ( 
final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , 
final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { 
String formula = cell . getCellFormula ( ) ; 
Ptg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , 
FormulaType . CELL , sheetIndex ) ; 
for ( int k = 0 ; k < ptgs . length ; k ++ ) { 
Object ptg = ptgs [ k ] ; 
int areaInt = ShiftFormulaUtility 
. getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( areaInt >= 0 ) { 
addToWatchList ( areaInt , lastStaticRow , watchList ) ; 
cell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula 
+ TieConstants . USER_FORMULA_SUFFIX ) ; 
} private void addToWatchList ( final int addRow , final int lastStaticRow , 
final List < Integer > watchList ) { 
if ( ( addRow > lastStaticRow ) && ! ( watchList . contains ( addRow ) ) ) { 
watchList . add ( addRow ) ; 
List < RowsMapping > currentRowsMappingList ) { 
configBuildRef . setWatchList ( buildFormWatchList ( 
configBuildRef . getWbWrapper ( ) , configBuildRef . getSheet ( ) ) ) ; 
fullName = this . getCommandName ( ) ; 
for ( Integer index : configBuildRef . getWatchList ( ) ) { 
if ( ConfigurationUtility . isStaticRow ( this . getConfigRange ( ) , 
index ) ) { 
unitRowsMapping . addRow ( index , 
configBuildRef . getSheet ( ) . getRow ( index ) ) ; 
currentRowsMappingList = new ArrayList < > ( ) ; 
this . getConfigRange ( ) . getAttrs ( ) . setAllowAdd ( false ) ; 
configBuildRef . putShiftAttrs ( fullName , 
this . getConfigRange ( ) . getAttrs ( ) , 
configBuildRef . setOriginConfigRange ( 
new ConfigRange ( this . getConfigRange ( ) ) ) ; 
configBuildRef . getOriginConfigRange ( ) 
. indexCommandRange ( configBuildRef . getCommandIndexMap ( ) ) ; 
int length = this . getConfigRange ( ) . buildAt ( fullName , configBuildRef , 
atRow , context , currentRowsMappingList ) ; 
this . getConfigRange ( ) . getAttrs ( ) . setFinalLength ( length ) ; 
this . setFinalLength ( length ) ; 
configBuildRef . getSheet ( ) . setColumnHidden ( 
TieConstants . HIDDEN_FULL_NAME_COLUMN , true ) ; 
TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN , true ) ; 
TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , true ) ; 
public final List getSerListFromCtObjChart ( final Object ctObjChart ) { 
if ( ctObjChart instanceof CTLineChart ) { 
return ( ( CTLineChart ) ctObjChart ) . getSerList ( ) ; 
return emptyLinelist ; 
if ( ctObjSer instanceof CTLineSer ) { 
return ( ( CTLineSer ) ctObjSer ) . getSpPr ( ) ; 
return ( ( CTLineSer ) ctObjSer ) . getVal ( ) ; 
} public static boolean isCommandString ( final String str ) { 
return str . startsWith ( TieConstants . COMMAND_PREFIX ) ; 
} public static boolean isMethodString ( final String str ) { 
return str . matches ( TieConstants . METHOD_REGEX ) ; 
} public static boolean isEmptyMethodString ( final String str ) { 
return str . startsWith ( TieConstants . METHOD_PREFIX ) ; 
} public static boolean isWidgetMethodString ( final String str ) { 
return str . startsWith ( TieConstants . METHOD_WIDGET_PREFIX ) ; 
} public static boolean isValidateMethodString ( final String str ) { 
return str . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ; 
} public static void parseWidgetAttributes ( final Cell cell , 
if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { 
int widgetStart = newComment 
. indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; 
int elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; 
if ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { 
String type = newComment . substring ( 
widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , 
elStart ) ; 
String values = getStringBetweenBracket ( newComment ) ; 
String key = getAttributeKeyInMapByCell ( cell ) ; 
cellAttributesMap . getCellInputType ( ) . put ( key , type ) ; 
List < CellFormAttributes > inputs = cellAttributesMap 
. getCellInputAttributes ( ) . get ( key ) ; 
if ( inputs == null ) { 
inputs = new ArrayList < > ( ) ; 
cellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; 
parseInputAttributes ( inputs , values ) ; 
parseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; 
} public static String getAttributeKeyInMapByCell ( final Cell cell ) { 
return cell . getSheet ( ) . getSheetName ( ) + "!" 
+ CellUtility . getCellIndexNumberKey ( cell ) ; 
} public static void parseValidateAttributes ( final Cell cell , 
if ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) { 
List < CellFormAttributes > attrs = cellAttributesMap 
. getCellValidateAttributes ( ) . get ( key ) ; 
if ( attrs == null ) { 
attrs = new ArrayList < > ( ) ; 
cellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; 
parseValidateAttributes ( attrs , values ) ; 
} public static String getStringBetweenBracket ( final String newComment ) { 
if ( newComment == null ) { 
int elEnd = findPairBracketPosition ( newComment , elStart ) ; 
if ( elStart >= elEnd ) { 
return newComment . substring ( elStart + 1 , elEnd ) ; 
} private static int findPairBracketPosition ( final String str , final int startPos ) { 
int bracketNum = 0 ; 
for ( int i = startPos ; i < str . length ( ) ; i ++ ) 
char current = str . charAt ( i ) ; 
if ( current == TieConstants . EL_START_BRACKET ) 
bracketNum ++ ; 
} else if ( current == TieConstants . EL_END ) 
bracketNum -- ; 
if ( bracketNum <= 0 ) { 
} public static Map < String , String > parseCommandAttributes ( 
final String attrString ) { 
Map < String , String > attrMap = new LinkedHashMap < > ( ) ; 
Matcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN 
. matcher ( attrString ) ; 
while ( attrMatcher . find ( ) ) { 
String attrData = attrMatcher . group ( ) ; 
int attrNameEndIndex = attrData . indexOf ( '=' ) ; 
String attrName = attrData . substring ( 0 , attrNameEndIndex ) 
. trim ( ) ; 
String attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) 
String attrValue = attrValuePart . substring ( 1 , 
attrValuePart . length ( ) - 1 ) ; 
attrMap . put ( attrName , attrValue ) ; 
return attrMap ; 
} public static void parseInputAttributes ( 
final List < CellFormAttributes > clist , 
final String controlAttrs ) { 
clist . clear ( ) ; 
if ( controlAttrs != null ) { 
String [ ] cattrs = controlAttrs . split ( 
TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; 
for ( String cattr : cattrs ) { 
String [ ] details = splitByEualSign ( cattr ) ; 
if ( details . length > 1 ) { 
CellFormAttributes attr = new CellFormAttributes ( ) ; 
attr . setType ( details [ 0 ] . trim ( ) ) ; 
attr . setValue ( details [ 1 ] . replaceAll ( "\"" , "" ) ) ; 
clist . add ( attr ) ; 
} public static void parseValidateAttributes ( 
if ( controlAttrs == null ) { 
String [ ] cattrs = controlAttrs 
. split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; 
extractValidationAttributes ( attr , cattr ) ; 
if ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) { 
} private static void extractValidationAttributes ( 
final CellFormAttributes attr , final String cattr ) { 
if ( details [ 0 ] . equalsIgnoreCase ( 
TieConstants . VALIDATION_RULE_TAG ) ) { 
} else if ( details [ 0 ] . equalsIgnoreCase ( 
TieConstants . VALIDATION_ERROR_MSG_TAG ) ) { 
attr . setMessage ( details [ 1 ] . replaceAll ( "\"" , "" ) ) ; 
} private static String [ ] splitByEualSign ( final String attrData ) { 
if ( attrNameEndIndex < 0 ) { 
String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; 
String attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; 
String [ ] rlist = new String [ 2 ] ; 
rlist [ 0 ] = attrName ; 
rlist [ 1 ] = attrValue ; 
return rlist ; 
} public static void parseSpecialAttributes ( final String key , 
final String type , final List < CellFormAttributes > inputs , 
SpecialAttributes sAttr = new SpecialAttributes ( ) ; 
for ( CellFormAttributes attr : inputs ) { 
gatherSpecialAttributes ( type , sAttr , attr ) ; 
if ( sAttr . selectLabels != null ) { 
processSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; 
if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) { 
processCalendarAttributes ( key , cellAttributesMap , sAttr ) ; 
} private static void processCalendarAttributes ( final String key , 
final CellAttributesMap cellAttributesMap , 
final SpecialAttributes sAttr ) { 
cellAttributesMap . getCellDatePattern ( ) . put ( key , 
sAttr . defaultDatePattern ) ; 
} private static void processSelectItemAttributes ( final String key , 
if ( ( sAttr . selectValues == null ) 
|| ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { 
sAttr . selectValues = sAttr . selectLabels ; 
Map < String , String > smap = cellAttributesMap 
. getCellSelectItemsAttributes ( ) . get ( key ) ; 
if ( smap == null ) { 
smap = new LinkedHashMap < > ( ) ; 
smap . clear ( ) ; 
if ( sAttr . defaultSelectLabel != null ) { 
smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; 
for ( int i = 0 ; i < sAttr . selectLabels . length ; i ++ ) { 
smap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; 
cellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; 
} private static void gatherSpecialAttributes ( final String type , 
final SpecialAttributes sAttr , final CellFormAttributes attr ) { 
String attrKey = attr . getType ( ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) { 
sAttr . selectLabels = attr . getValue ( ) . split ( ";" ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) { 
sAttr . selectValues = attr . getValue ( ) . split ( ";" ) ; 
if ( attrKey . equalsIgnoreCase ( 
TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) { 
sAttr . defaultSelectLabel = attr . getValue ( ) ; 
TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) { 
sAttr . defaultSelectValue = attr . getValue ( ) ; 
if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) 
&& attrKey . equalsIgnoreCase ( 
TieConstants . WIDGET_ATTR_PATTERN ) ) { 
sAttr . defaultDatePattern = attr . getValue ( ) ; 
} public static void parseCommentToMap ( final String cellKey , 
final Map < String , Map < String , String > > sheetCommentMap , 
final boolean normalComment ) { 
if ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { 
String commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; 
if ( ! normalComment ) { 
commentKey = newComment . substring ( 0 , 
newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; 
Map < String , String > map = sheetCommentMap . get ( commentKey ) ; 
if ( map == null ) { 
map = new HashMap < > ( ) ; 
map . put ( cellKey , newComment ) ; 
sheetCommentMap . put ( commentKey , map ) ; 
} public static int findFirstNonCellNamePosition ( String input , int startPosition ) { 
for ( int i = startPosition ; i < input . length ( ) ; i ++ ) { 
c = input . charAt ( i ) ; 
if ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { 
} public static String removeCharsFromString ( String inputStr , int start , int end ) { 
StringBuilder sb = new StringBuilder ( inputStr ) ; 
sb . delete ( start , end ) ; 
} public static String getExcelColumnName ( final int pnumber ) { 
StringBuilder converted = new StringBuilder ( ) ; 
int number = pnumber ; 
while ( number >= 0 ) { 
int remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; 
converted . insert ( 0 , ( char ) ( remainder + 'A' ) ) ; 
number = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; 
return converted . toString ( ) ; 
} public static String getFullCellRefName ( final Sheet sheet1 , 
if ( ( sheet1 != null ) && ( cell != null ) ) { 
return sheet1 . getSheetName ( ) + "!$" 
+ getExcelColumnName ( cell . getColumnIndex ( ) ) + "$" 
+ ( cell . getRowIndex ( ) + 1 ) ; 
} public static String getFullCellRefName ( final String sheetName , 
if ( sheetName != null ) { 
return sheetName + "!$" + getExcelColumnName ( colIndex ) + "$" 
} public static String getSheetNameFromFullCellRefName ( 
if ( ( fullName != null ) && ( fullName . contains ( "!" ) ) ) { 
return fullName . substring ( 0 , fullName . indexOf ( '!' ) ) ; 
} public static String removeSheetNameFromFullCellRefName ( 
return fullName . substring ( fullName . indexOf ( '!' ) + 1 ) ; 
} public static int convertColToInt ( final String col ) { 
String name = col . toUpperCase ( ) ; 
int number = 0 ; 
int pow = 1 ; 
for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { 
number += ( name . charAt ( i ) - 'A' + 1 ) * pow ; 
pow *= TieConstants . EXCEL_LETTER_NUMBERS ; 
return number - 1 ; 
} public static Cell getCellByReference ( final String cellRef , 
final Sheet sheet ) { 
Cell c = null ; 
CellReference ref = new CellReference ( cellRef ) ; 
Row r = sheet . getRow ( ref . getRow ( ) ) ; 
c = r . getCell ( ref . getCol ( ) , 
} public static short pixel2WidthUnits ( final int pxs ) { 
short widthUnits = ( short ) ( EXCEL_COLUMN_WIDTH_FACTOR 
* ( pxs / UNIT_OFFSET_LENGTH ) ) ; 
widthUnits += UNIT_OFFSET_MAP [ pxs % UNIT_OFFSET_LENGTH ] ; 
return widthUnits ; 
} public static int widthUnits2Pixel ( final int widthUnits ) { 
int pixels = ( widthUnits / EXCEL_COLUMN_WIDTH_FACTOR ) 
* UNIT_OFFSET_LENGTH ; 
int offsetWidthUnits = widthUnits % EXCEL_COLUMN_WIDTH_FACTOR ; 
pixels += Math . round ( offsetWidthUnits 
/ ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH ) ) ; 
return pixels ; 
} public static int heightUnits2Pixel ( final short heightUnits ) { 
int pixels = heightUnits / EXCEL_ROW_HEIGHT_FACTOR ; 
int offsetHeightUnits = heightUnits % EXCEL_ROW_HEIGHT_FACTOR ; 
pixels += Math . round ( ( float ) offsetHeightUnits 
/ ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH 
/ 2 ) ) ; 
pixels += ( Math . floor ( pixels / PIXEL_HEIGHT_ASPC_ADJUST ) + 1 ) * 4 ; 
} public static boolean isDate ( final String s ) { 
Pattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; 
Matcher matcher ; 
for ( String term : terms ) { 
matcher = pattern . matcher ( term ) ; 
pattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; 
} public static String parseDate ( final String entry ) { 
return matcher . group ( ) ; 
} public static boolean isNumeric ( final String str ) { 
String s = str ; 
if ( s . startsWith ( "-" ) ) { 
int sLen = s . length ( ) ; 
ShouldContinueParameter sPara = new ShouldContinueParameter ( false , 
false , 0 ) ; 
for ( i = 0 ; i < sLen ; i ++ ) { 
c = s . charAt ( i ) ; 
if ( ! shouldContinue ( c , sPara ) ) { 
if ( sPara . isCommaHit ( ) ) { 
sPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; 
} private static boolean shouldContinue ( final char c , 
final ShouldContinueParameter para ) { 
if ( c == '.' && ! para . isDecimalHit ( ) ) { 
para . setDecimalHit ( true ) ; 
if ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) { 
} else if ( c == ',' && ! para . isDecimalHit ( ) ) { 
if ( para . isCommaHit ( ) ) { 
if ( para . getSinceLastComma ( ) != 3 ) { 
para . setSinceLastComma ( 0 ) ; 
para . setCommaHit ( true ) ; 
Method method = obj . getClass ( ) . getMethod ( 
"set" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) 
+ propertyName . substring ( 1 ) , 
new Class [ ] { String . class } ) ; 
method . invoke ( obj , propertyValue ) ; 
LOG . info ( msg ) ; 
} public static int cellCompareTo ( final Cell thisCell , 
final Cell otherCell ) { 
int r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; 
if ( r != 0 ) { 
r = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; 
} public static boolean insideRange ( final ConfigRange child , 
final ConfigRange parent ) { 
return ( ( cellCompareTo ( child . getFirstRowRef ( ) , 
parent . getFirstRowRef ( ) ) >= 0 ) 
&& ( cellCompareTo ( child . getLastRowPlusRef ( ) , 
parent . getLastRowPlusRef ( ) ) <= 0 ) ) ; 
} public static int getSheetRightCol ( final Sheet sheet ) { 
if ( sheet instanceof XSSFSheet ) { 
XSSFSheet xsheet = ( XSSFSheet ) sheet ; 
int rightCol = getSheetRightColFromDimension ( xsheet ) ; 
if ( rightCol > TieConstants . MAX_COLUMNS_IN_SHEET ) { 
clearHiddenColumns ( sheet ) ; 
rightCol = getSheetRightColFromDimension ( xsheet ) ; 
return rightCol ; 
} public static void clearHiddenColumns ( final Sheet sheet ) { 
if ( row . getLastCellNum ( ) > TieConstants . MAX_COLUMNS_IN_SHEET ) { 
deleteHiddenColumnsInRow ( row ) ; 
} private static void deleteHiddenColumnsInRow ( final Row row ) { 
deleteCellFromRow ( row , 
TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; 
TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN ) ; 
TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; 
} private static void deleteCellFromRow ( final Row row , 
final int cellNum ) { 
Cell cell = row . getCell ( cellNum ) ; 
row . removeCell ( cell ) ; 
} private static int getSheetRightColFromDimension ( 
final XSSFSheet xsheet ) { 
CTSheetDimension dimension = xsheet . getCTWorksheet ( ) . getDimension ( ) ; 
String sheetDimensions = dimension . getRef ( ) ; 
if ( sheetDimensions . indexOf ( ':' ) < 0 ) { 
return CellRangeAddress . valueOf ( sheetDimensions ) 
. getLastColumn ( ) ; 
public final String getSeriesLabelFromCTSer ( final Object ctObjSer ) { 
if ( ctObjSer instanceof CTAreaSer ) { 
return ( ( CTAreaSer ) ctObjSer ) . getTx ( ) . getStrRef ( ) . getF ( ) ; 
return ( ( CTAreaSer ) ctObjSer ) . getSpPr ( ) ; 
return ( ( CTAreaSer ) ctObjSer ) . getVal ( ) ; 
public final void processEvent ( final SystemEvent event ) { 
AppUtils . getBuildVersion ( ) ) ; 
} private void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , 
final int formCol , final FacesCell cell , final boolean updateGui ) { 
if ( ! newStatus ) { 
cell . setErrormsg ( "" ) ; 
cell . setInvalid ( newStatus ) ; 
if ( updateGui && ( oldStatus != newStatus ) && ( parent . getWebFormClientId ( ) != null ) ) { 
RequestContext . getCurrentInstance ( ) 
. update ( parent . getWebFormClientId ( ) + ":" + ( formRow ) + ":group" + ( formCol ) ) ; 
} public boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { 
boolean submitMode = parent . getSubmitMode ( ) ; 
boolean passEmptyCheck = ! submitMode ; 
int topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
int leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
boolean pass = true ; 
FacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; 
if ( fRow == null ) { 
return pass ; 
FacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; 
boolean oldStatus = cell . isInvalid ( ) ; 
String value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; 
if ( passEmptyCheck && value . isEmpty ( ) ) { 
refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; 
if ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) 
&& ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; 
List < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( 
parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; 
if ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null 
&& ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , 
sheetConfig , updateGui ) ) { 
if ( cellAttributes != null ) { 
pass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , 
cellAttributes , updateGui ) ; 
if ( pass ) { 
} private boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , 
final FacesCell cell , final String value , boolean updateGui ) { 
if ( parent . getTieWebSheetValidationBean ( ) != null ) { 
String errormsg = null ; 
String fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; 
String saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; 
int row = poiCell . getRowIndex ( ) ; 
int col = poiCell . getColumnIndex ( ) ; 
errormsg = parent . getTieWebSheetValidationBean ( ) . validate ( 
parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility 
. getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , 
row , col , value ) ; 
if ( ( errormsg != null ) && ( ! errormsg . isEmpty ( ) ) ) { 
cell . setErrormsg ( errormsg ) ; 
refreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; 
} private boolean checkErrorMessageFromObjectInContext ( final int formRow , final int formCol , final FacesCell cell , 
final Cell poiCell , final String value , final SheetConfiguration sheetConfig , boolean updateGui ) { 
HashMap < String , TieCell > tieCells = ( HashMap < String , TieCell > ) parent . getSerialDataContext ( ) . getDataContext ( ) 
. get ( "tiecells" ) ; 
if ( tieCells != null ) { 
TieCell tieCell = tieCells . get ( CellUtility . getSkeyFromPoiCell ( poiCell ) ) ; 
if ( tieCell != null && tieCell . getContextObject ( ) != null ) { 
String errorMethod = tieCell . getMethodStr ( ) + parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) ; 
String errorMessage = CellControlsUtility . getObjectPropertyValue ( tieCell . getContextObject ( ) , 
errorMethod , true ) ; 
if ( errorMessage != null && ! errorMessage . isEmpty ( ) ) { 
cell . setErrormsg ( errorMessage ) ; 
new Object [ ] { poiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , 
poiCell . getColumnIndex ( ) , errorMessage } ) ; 
refreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; 
} private boolean validateAllRulesForSingleCell ( final int formRow , final int formCol , final FacesCell cell , 
final Cell poiCell , final String value , final SheetConfiguration sheetConfig , 
final List < CellFormAttributes > cellAttributes , boolean updateGui ) { 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; 
for ( CellFormAttributes attr : cellAttributes ) { 
boolean pass = doValidation ( value , attr , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , sheet1 ) ; 
if ( ! pass ) { 
String errmsg = attr . getMessage ( ) ; 
if ( errmsg == null ) { 
errmsg = TieConstants . DEFALT_MSG_INVALID_INPUT ; 
cell . setErrormsg ( errmsg ) ; 
poiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errmsg } ) ; 
} private boolean doValidation ( final Object value , final CellFormAttributes attr , final int rowIndex , 
final int colIndex , final Sheet sheet ) { 
boolean pass ; 
String attrValue = attr . getValue ( ) ; 
attrValue = attrValue . replace ( "$value" , value . toString ( ) + "" ) . replace ( "$rowIndex" , rowIndex + "" ) 
. replace ( "$colIndex" , colIndex + "" ) . replace ( "$sheetName" , sheet . getSheetName ( ) ) ; 
attrValue = ConfigurationUtility . replaceExpressionWithCellValue ( attrValue , rowIndex , sheet ) ; 
if ( attrValue . contains ( TieConstants . EL_START ) ) { 
Object returnObj = FacesUtility . evaluateExpression ( attrValue , Object . class ) ; 
attrValue = returnObj . toString ( ) ; 
pass = Boolean . parseBoolean ( attrValue ) ; 
pass = parent . getCellHelper ( ) . evalBoolExpression ( attrValue ) ; 
} public final boolean validateCell ( final UIComponent target ) { 
int [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( target ) ; 
return validateWithRowColInCurrentPage ( row , col , true ) ; 
} public final boolean validateCurrentPage ( ) { 
boolean allpass = true ; 
for ( int irow = 0 ; irow < parent . getBodyRows ( ) . size ( ) ; irow ++ ) { 
if ( ! validateRowInCurrentPage ( irow + top , false ) ) { 
allpass = false ; 
return allpass ; 
} public final boolean validateRowInCurrentPage ( final int irow , final boolean updateGui ) { 
return this . validateRow ( irow , sheetConfig , updateGui ) ; 
} private boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { 
if ( sheetConfig == null ) { 
List < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; 
for ( int index = 0 ; index < cellRow . size ( ) ; index ++ ) { 
FacesCell fcell = cellRow . get ( index ) ; 
if ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { 
pass = false ; 
} public void valueChangeEvent ( final AjaxBehaviorEvent event ) { 
FacesContext facesContext = FacesContext . getCurrentInstance ( ) ; 
String tblName = parent . getWebFormClientId ( ) ; 
UIComponent target = event . getComponent ( ) ; 
boolean pass = validateCell ( target ) ; 
validateRowInCurrentPage ( rowcol [ 0 ] , true ) ; 
refreshCachedCellsInCurrentPage ( facesContext , tblName ) ; 
} private void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { 
UIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; 
DataTable webDataTable = ( DataTable ) s ; 
int first = webDataTable . getFirst ( ) ; 
int rowsToRender = webDataTable . getRowsToRender ( ) ; 
int rowCounts = webDataTable . getRowCount ( ) ; 
for ( int i = first ; i <= ( first + rowsToRender ) ; i ++ ) { 
if ( i < rowCounts ) { 
refreshCachedCellsInRow ( tblName , top , left , i ) ; 
} private void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { 
FacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; 
int isize = dataRow . getCells ( ) . size ( ) ; 
for ( int index = 0 ; index < isize ; index ++ ) { 
FacesCell fcell = dataRow . getCells ( ) . get ( index ) ; 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; 
if ( poiCell != null ) { 
parent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; 
} public void setSubmitModeInView ( final Boolean fullflag ) { 
if ( FacesContext . getCurrentInstance ( ) != null ) { 
Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; 
if ( viewMap != null ) { 
Boolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; 
if ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) { 
viewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; 
} public boolean preValidation ( ) { 
String currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; 
String tabName = null ; 
String firstInvalidTabName = null ; 
boolean reload = false ; 
for ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { 
tabName = entry . getKey ( ) ; 
if ( reload || ( ! tabName . equals ( currentTabName ) ) ) { 
parent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; 
reload = true ; 
if ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) && 
( firstInvalidTabName == null ) ) { 
firstInvalidTabName = tabName ; 
if ( firstInvalidTabName != null ) { 
if ( ! tabName . equals ( firstInvalidTabName ) ) { 
parent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; 
} public final void clear ( ) { 
if ( this . templateCommentMap != null ) { 
this . templateCommentMap . clear ( ) ; 
if ( this . cellDatePattern != null ) { 
this . cellDatePattern . clear ( ) ; 
if ( this . cellInputAttributes != null ) { 
this . cellInputAttributes . clear ( ) ; 
if ( this . cellInputType != null ) { 
this . cellInputType . clear ( ) ; 
if ( this . cellSelectItemsAttributes != null ) { 
this . cellSelectItemsAttributes . clear ( ) ; 
} private void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , 
final List < String > skippedRegionCells ) { 
int top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; 
int bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; 
int left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; 
String sheetName = sheetConfig . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
int totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , 
WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; 
RangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; 
if ( sheetConfig . isFixedWidthStyle ( ) ) { 
parent . setTableWidthStyle ( 
parent . setLineNumberColumnWidthStyle ( 
getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; 
parent . setAddRowColumnWidthStyle ( "width:" + parent . getAddRowColumnWidth ( ) + "px;" ) ; 
parent . getHeaderRows ( ) . clear ( ) ; 
if ( top < 0 ) { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; 
parent . setShowLineNumber ( true ) ; 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; 
for ( int i = top ; i <= bottom ; i ++ ) { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , 
cellRangeMap , skippedRegionCells ) ) ; 
parent . setShowLineNumber ( false ) ; 
} private List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , 
final boolean rendered ) { 
int firstCol = rangeBuildRef . getLeft ( ) ; 
int lastCol = rangeBuildRef . getRight ( ) ; 
double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; 
Sheet sheet1 = rangeBuildRef . getSheet ( ) ; 
List < HeaderCell > headercells = new ArrayList < > ( ) ; 
if ( ! sheet1 . isColumnHidden ( i ) ) { 
String style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; 
headercells . add ( 
new HeaderCell ( "1" , "1" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; 
fillToMaxColumns ( headercells ) ; 
return headercells ; 
} private void fillToMaxColumns ( final List < HeaderCell > headercells ) { 
if ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { 
int fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; 
for ( int s = 0 ; s < fills ; s ++ ) { 
headercells . add ( new HeaderCell ( "1" , "1" , "" , "" , "" , false , false ) ) ; 
} private String getHeaderColumnStyle ( final Workbook wb , final Cell cell , final double colWidth , 
final double totalWidth ) { 
String columnstyle = "" ; 
columnstyle += CellStyleUtility . getCellStyle ( wb , cell , "" ) + CellStyleUtility . getCellFontStyle ( wb , cell ) ; 
columnstyle = columnstyle + getWidthStyle ( colWidth , totalWidth ) ; 
return columnstyle ; 
} private String getWidthStyle ( final double colWidth , final double totalWidth ) { 
double percentage = FacesUtility . round ( TieConstants . CELL_FORMAT_PERCENTAGE_VALUE * colWidth / totalWidth , 2 ) ; 
return "width:" + percentage + TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL + ";" ; 
} private List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , 
final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , 
int left = rangeBuildRef . getLeft ( ) ; 
int right = rangeBuildRef . getRight ( ) ; 
Row row = sheet1 . getRow ( currentRow ) ; 
for ( int cindex = left ; cindex <= right ; cindex ++ ) { 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; 
if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { 
Cell cell = null ; 
cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
int originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; 
FacesCell fcell = new FacesCell ( ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , 
parent . getCellAttributesMap ( ) , null ) ; 
parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , 
WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; 
CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; 
fcell . setColumnStyle ( fcell . getColumnStyle ( ) 
+ getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; 
fcell . setColumnIndex ( cindex ) ; 
new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , 
fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , 
parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , 
true , true ) ) ; 
} private String getColumnWidthStyle ( final Sheet sheet1 , final Map < String , CellRangeAddress > cellRangeMap , 
final String cellindex , final int cindex , final double totalWidth ) { 
CellRangeAddress caddress = cellRangeMap . get ( cellindex ) ; 
double colWidth ; 
colWidth = CellStyleUtility . calcTotalWidth ( sheet1 , caddress . getFirstColumn ( ) , caddress . getLastColumn ( ) , 0 ) ; 
colWidth = sheet1 . getColumnWidth ( cindex ) ; 
return getWidthStyle ( colWidth , totalWidth ) ; 
} private void clearWorkbook ( ) { 
parent . setFormulaEvaluator ( null ) ; 
parent . setDataFormatter ( null ) ; 
parent . setSheetConfigMap ( null ) ; 
parent . setTabs ( null ) ; 
parent . getSerialDataContext ( ) . setDataContext ( null ) ; 
parent . setPicturesMap ( null ) ; 
parent . setHeaderRows ( null ) ; 
parent . setBodyRows ( null ) ; 
parent . setWb ( null ) ; 
parent . getBodyRows ( ) . clear ( ) ; 
parent . getCharsData ( ) . getChartsMap ( ) . clear ( ) ; 
parent . getCharsData ( ) . getChartDataMap ( ) . clear ( ) ; 
parent . getCharsData ( ) . getChartAnchorsMap ( ) . clear ( ) ; 
parent . getCharsData ( ) . getChartPositionMap ( ) . clear ( ) ; 
parent . getCellAttributesMap ( ) . clear ( ) ; 
} public final int loadWorkbook ( final InputStream fis , final Map < String , Object > dataContext ) { 
Workbook wb = WorkbookFactory . create ( fis ) ; 
int ireturn = loadWorkbook ( wb , dataContext ) ; 
} public final int loadWorkbook ( final Workbook wb , final Map < String , Object > dataContext ) { 
clearWorkbook ( ) ; 
if ( ! ( wb instanceof XSSFWorkbook ) ) { 
parent . setWb ( wb ) ; 
parent . getSerialDataContext ( ) . setDataContext ( dataContext ) ; 
parent . setSheetConfigMap ( new ConfigurationHandler ( parent ) . buildConfiguration ( ) ) ; 
parent . reCalcMaxColCounts ( ) ; 
parent . getChartHelper ( ) . loadChartsMap ( ) ; 
parent . getPicHelper ( ) . loadPicturesMap ( ) ; 
initSheet ( ) ; 
initTabs ( ) ; 
if ( ! parent . getTabs ( ) . isEmpty ( ) ) { 
loadWorkSheet ( parent . getTabs ( ) . get ( 0 ) . getTitle ( ) ) ; 
} private void initTabs ( ) { 
parent . setTabs ( new ArrayList < TabModel > ( ) ) ; 
if ( parent . getSheetConfigMap ( ) != null ) { 
for ( String key : parent . getSheetConfigMap ( ) . keySet ( ) ) { 
parent . getTabs ( ) . add ( new TabModel ( "form_" + key , key , "form" ) ) ; 
} private void loadData ( ) { 
if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { 
if ( parent . isAdvancedContext ( ) ) { 
parent . getSerialDataContext ( ) . getDataContext ( ) . put ( "tiecells" , new HashMap < String , TieCell > ( ) ) ; 
for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { 
List < RowsMapping > currentRowsMappingList = null ; 
ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , 
parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , 
sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; 
int length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , 
sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , 
sheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; 
sheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; 
sheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; 
sheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; 
sheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; 
sheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; 
sheetConfig . setBodyPopulated ( true ) ; 
} public void refreshData ( ) { 
for ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; irow < sheetConfig . getFormCommand ( ) 
. getLastRow ( ) ; irow ++ ) { 
refreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; 
} private void refreshDataForRow ( Row row ) { 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; 
String [ ] saveAttrs = saveAttrList . split ( "," ) ; 
for ( String fullSaveAttr : saveAttrs ) { 
refreshDataForCell ( row , fullSaveAttr ) ; 
} private void refreshDataForCell ( Row row , String fullSaveAttr ) { 
if ( fullSaveAttr != null ) { 
parent . getCellHelper ( ) . restoreDataContext ( fullName ) ; 
SaveAttrsUtility . refreshSheetRowFromContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , 
fullSaveAttr , row , parent . getExpEngine ( ) ) ; 
} public final int findTabIndexWithName ( final String tabname ) { 
for ( int i = 0 ; i < parent . getTabs ( ) . size ( ) ; i ++ ) { 
if ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { 
} public final void loadWorkSheet ( final String tabName ) { 
prepareWorkShee ( tabName ) ; 
parent . getValidationHandler ( ) . validateCurrentPage ( ) ; 
createDynamicColumns ( tabName ) ; 
setDataTablePage ( 0 ) ; 
parent . getCurrent ( ) . setCurrentDataContextName ( null ) ; 
saveObjs ( ) ; 
if ( ( RequestContext . getCurrentInstance ( ) != null ) && ( parent . getClientId ( ) != null ) ) { 
RequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + ":websheettab" ) ; 
} public final void prepareWorkShee ( final String tabName ) { 
int tabIndex = findTabIndexWithName ( tabName ) ; 
if ( parent . getWebFormTabView ( ) != null ) { 
parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; 
parent . getCurrent ( ) . setCurrentTabName ( tabName ) ; 
String sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; 
parent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; 
parent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; 
parent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; 
loadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
loadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
} private void setDataTablePage ( final int first ) { 
if ( parent . getWebFormClientId ( ) != null ) { 
final DataTable d = ( DataTable ) FacesContext . getCurrentInstance ( ) . getViewRoot ( ) 
. findComponent ( parent . getWebFormClientId ( ) ) ; 
if ( d != null ) { 
d . setFirst ( first ) ; 
} private void saveObjs ( ) { 
viewMap . put ( "currentTabName" , parent . getCurrent ( ) . getCurrentTabName ( ) ) ; 
viewMap . put ( TieConstants . SUBMITMODE , parent . getSubmitMode ( ) ) ; 
} private void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , 
final boolean allowAdd ) { 
facesRow . setAllowAdd ( allowAdd ) ; 
facesRow . setRendered ( ! row . getZeroHeight ( ) ) ; 
facesRow . setRowheight ( row . getHeight ( ) ) ; 
int rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; 
facesRow . setOriginRowIndex ( rowNum ) ; 
facesRow . setRendered ( true ) ; 
facesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; 
facesRow . setOriginRowIndex ( rowIndex ) ; 
} private void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , 
int bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; 
int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
parent . getBodyRows ( ) 
. add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
parent . getCurrent ( ) . setCurrentTopRow ( top ) ; 
parent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; 
} private FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , 
final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , 
FacesRow facesRow = new FacesRow ( rowIndex ) ; 
Row row = sheet1 . getRow ( rowIndex ) ; 
setupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; 
List < FacesCell > bodycells = new ArrayList < > ( ) ; 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , 
parent . getCellAttributesMap ( ) , saveAttrList ) ; 
bodycells . add ( fcell ) ; 
addCache ( cell ) ; 
bodycells . add ( null ) ; 
facesRow . setCells ( bodycells ) ; 
return facesRow ; 
} public final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , 
final FacesCell fcell ) { 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) && ( tblName != null ) ) { 
processRefreshCell ( tblName , i , index , cell , fcell ) ; 
} private void processRefreshCell ( final String tblName , final int i , final int index , final Cell cell , 
String newValue = CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , 
if ( parent . getCachedCells ( ) . isValueChanged ( cell , newValue ) ) { 
if ( fcell . isHasSaveAttr ( ) ) { 
parent . getCellHelper ( ) . saveDataInContext ( cell , newValue ) ; 
RequestContext . getCurrentInstance ( ) . update ( tblName + ":" + i + ":cocalc" + index ) ; 
parent . getCachedCells ( ) . put ( cell , CellType . FORMULA ) ; 
} private void createDynamicColumns ( final String tabName ) { 
parent . getColumns ( ) . clear ( ) ; 
for ( int i = left ; i <= right ; i ++ ) { 
parent . getColumns ( ) . add ( "column" + ( i - left ) ) ; 
} public final void addRepeatRow ( final int rowIndex ) { 
Sheet sheet = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; 
ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , sheet , parent . getExpEngine ( ) , 
parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , 
configBuildRef . setAddMode ( true ) ; 
configBuildRef . setCollectionObjNameMap ( sheetConfig . getCollectionObjNameMap ( ) ) ; 
configBuildRef . setCommandIndexMap ( sheetConfig . getCommandIndexMap ( ) ) ; 
configBuildRef . setShiftMap ( sheetConfig . getShiftMap ( ) ) ; 
configBuildRef . setWatchList ( sheetConfig . getWatchList ( ) ) ; 
int length = CommandUtility . addRow ( configBuildRef , rowIndex , 
parent . getSerialDataContext ( ) . getDataContext ( ) ) ; 
refreshBodyRowsInRange ( configBuildRef . getInsertPosition ( ) , length , sheet , sheetConfig ) ; 
} catch ( AddRowException e ) { 
FacesContext . getCurrentInstance ( ) . addMessage ( null , 
} private void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; 
for ( int irow = insertPosition ; irow < ( insertPosition + length ) ; irow ++ ) { 
parent . getBodyRows ( ) . add ( irow - top , 
assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
for ( int irow = insertPosition + length - top ; irow < parent . getBodyRows ( ) . size ( ) ; irow ++ ) { 
FacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; 
} public void setUnsavedStatus ( final RequestContext requestContext , final Boolean statusFlag ) { 
if ( requestContext != null ) { 
requestContext . execute ( "setUnsavedState(" + statusFlag . toString ( ) + ")" ) ; 
} public final Boolean isUnsavedStatus ( ) { 
Boolean flag = ( Boolean ) viewMap . get ( TieConstants . UNSAVEDSTATE ) ; 
if ( flag == null ) { 
this . getSerialFirstRowRef ( ) . recover ( sheet ) ; 
this . getSerialLastRowPlusRef ( ) . recover ( sheet ) ; 
if ( this . getUnitRowsMapping ( ) != null ) { 
this . getUnitRowsMapping ( ) . recover ( sheet ) ; 
} public static String stringFor ( int n ) 
switch ( n ) 
case CUBLAS_GEMM_DEFAULT : return "CUBLAS_GEMM_DEFAULT" ; 
case CUBLAS_GEMM_ALGO0 : return "CUBLAS_GEMM_ALGO0" ; 
case CUBLAS_GEMM_ALGO1 : return "CUBLAS_GEMM_ALGO1" ; 
case CUBLAS_GEMM_ALGO2 : return "CUBLAS_GEMM_ALGO2" ; 
case CUBLAS_GEMM_ALGO3 : return "CUBLAS_GEMM_ALGO3" ; 
case CUBLAS_GEMM_ALGO4 : return "CUBLAS_GEMM_ALGO4" ; 
case CUBLAS_GEMM_ALGO5 : return "CUBLAS_GEMM_ALGO5" ; 
case CUBLAS_GEMM_ALGO6 : return "CUBLAS_GEMM_ALGO6" ; 
case CUBLAS_GEMM_ALGO7 : return "CUBLAS_GEMM_ALGO7" ; 
case CUBLAS_GEMM_ALGO8 : return "CUBLAS_GEMM_ALGO8" ; 
case CUBLAS_GEMM_ALGO9 : return "CUBLAS_GEMM_ALGO9" ; 
case CUBLAS_GEMM_ALGO10 : return "CUBLAS_GEMM_ALGO10" ; 
case CUBLAS_GEMM_ALGO11 : return "CUBLAS_GEMM_ALGO11" ; 
case CUBLAS_GEMM_ALGO12 : return "CUBLAS_GEMM_ALGO12" ; 
case CUBLAS_GEMM_ALGO13 : return "CUBLAS_GEMM_ALGO13" ; 
case CUBLAS_GEMM_ALGO14 : return "CUBLAS_GEMM_ALGO14" ; 
case CUBLAS_GEMM_ALGO15 : return "CUBLAS_GEMM_ALGO15" ; 
case CUBLAS_GEMM_ALGO16 : return "CUBLAS_GEMM_ALGO16" ; 
case CUBLAS_GEMM_ALGO17 : return "CUBLAS_GEMM_ALGO17" ; 
case CUBLAS_GEMM_ALGO18 : return "CUBLAS_GEMM_ALGO18" ; 
case CUBLAS_GEMM_ALGO19 : return "CUBLAS_GEMM_ALGO19" ; 
case CUBLAS_GEMM_ALGO20 : return "CUBLAS_GEMM_ALGO20" ; 
case CUBLAS_GEMM_ALGO21 : return "CUBLAS_GEMM_ALGO21" ; 
case CUBLAS_GEMM_ALGO22 : return "CUBLAS_GEMM_ALGO22" ; 
case CUBLAS_GEMM_ALGO23 : return "CUBLAS_GEMM_ALGO23" ; 
case CUBLAS_GEMM_DEFAULT_TENSOR_OP : return "CUBLAS_GEMM_DEFAULT_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO0_TENSOR_OP : return "CUBLAS_GEMM_ALGO0_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO1_TENSOR_OP : return "CUBLAS_GEMM_ALGO1_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO2_TENSOR_OP : return "CUBLAS_GEMM_ALGO2_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO3_TENSOR_OP : return "CUBLAS_GEMM_ALGO3_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO4_TENSOR_OP : return "CUBLAS_GEMM_ALGO4_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO5_TENSOR_OP : return "CUBLAS_GEMM_ALGO5_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO6_TENSOR_OP : return "CUBLAS_GEMM_ALGO6_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO7_TENSOR_OP : return "CUBLAS_GEMM_ALGO7_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO8_TENSOR_OP : return "CUBLAS_GEMM_ALGO8_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO9_TENSOR_OP : return "CUBLAS_GEMM_ALGO9_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO10_TENSOR_OP : return "CUBLAS_GEMM_ALGO10_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO11_TENSOR_OP : return "CUBLAS_GEMM_ALGO11_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO12_TENSOR_OP : return "CUBLAS_GEMM_ALGO12_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO13_TENSOR_OP : return "CUBLAS_GEMM_ALGO13_TENSOR_OP" ; 
case CUBLAS_GEMM_ALGO14_TENSOR_OP : return "CUBLAS_GEMM_ALGO14_TENSOR_OP" ; 
case CUBLAS_STATUS_SUCCESS : return "CUBLAS_STATUS_SUCCESS" ; 
case CUBLAS_STATUS_NOT_INITIALIZED : return "CUBLAS_STATUS_NOT_INITIALIZED" ; 
case CUBLAS_STATUS_ALLOC_FAILED : return "CUBLAS_STATUS_ALLOC_FAILED" ; 
case CUBLAS_STATUS_INVALID_VALUE : return "CUBLAS_STATUS_INVALID_VALUE" ; 
case CUBLAS_STATUS_ARCH_MISMATCH : return "CUBLAS_STATUS_ARCH_MISMATCH" ; 
case CUBLAS_STATUS_MAPPING_ERROR : return "CUBLAS_STATUS_MAPPING_ERROR" ; 
case CUBLAS_STATUS_EXECUTION_FAILED : return "CUBLAS_STATUS_EXECUTION_FAILED" ; 
case CUBLAS_STATUS_INTERNAL_ERROR : return "CUBLAS_STATUS_INTERNAL_ERROR" ; 
case CUBLAS_STATUS_NOT_SUPPORTED : return "CUBLAS_STATUS_NOT_SUPPORTED" ; 
case JCUBLAS_STATUS_INTERNAL_ERROR : return "JCUBLAS_STATUS_INTERNAL_ERROR" ; 
} private static int checkResult ( int result ) 
if ( exceptionsEnabled && result != cublasStatus . CUBLAS_STATUS_SUCCESS ) 
throw new CudaException ( cublasStatus . stringFor ( result ) ) ; 
} public static int cublasSetVector ( 
int n , 
int elemSize , 
Pointer x , 
int incx , 
Pointer devicePtr , 
int incy ) 
return checkResult ( cublasSetVectorNative ( n , elemSize , x , incx , devicePtr , incy ) ) ; 
} public static int cublasGetVector ( 
Pointer y , 
return checkResult ( cublasGetVectorNative ( n , elemSize , x , incx , y , incy ) ) ; 
} public static int cublasSetMatrix ( 
int rows , 
int cols , 
Pointer A , 
int lda , 
Pointer B , 
int ldb ) 
return checkResult ( cublasSetMatrixNative ( rows , cols , elemSize , A , lda , B , ldb ) ) ; 
} public static int cublasGetMatrix ( 
return checkResult ( cublasGetMatrixNative ( rows , cols , elemSize , A , lda , B , ldb ) ) ; 
} public static int cublasSetVectorAsync ( 
Pointer hostPtr , 
int incy , 
cudaStream_t stream ) 
return checkResult ( cublasSetVectorAsyncNative ( n , elemSize , hostPtr , incx , devicePtr , incy , stream ) ) ; 
} public static int cublasGetVectorAsync ( 
return checkResult ( cublasGetVectorAsyncNative ( n , elemSize , devicePtr , incx , hostPtr , incy , stream ) ) ; 
} public static int cublasSetMatrixAsync ( 
int ldb , 
return checkResult ( cublasSetMatrixAsyncNative ( rows , cols , elemSize , A , lda , B , ldb , stream ) ) ; 
} public static int cublasGetMatrixAsync ( 
return checkResult ( cublasGetMatrixAsyncNative ( rows , cols , elemSize , A , lda , B , ldb , stream ) ) ; 
} public static int cublasSnrm2 ( 
cublasHandle handle , 
Pointer result ) 
return checkResult ( cublasSnrm2Native ( handle , n , x , incx , result ) ) ; 
} public static int cublasDnrm2 ( 
return checkResult ( cublasDnrm2Native ( handle , n , x , incx , result ) ) ; 
} public static int cublasScnrm2 ( 
return checkResult ( cublasScnrm2Native ( handle , n , x , incx , result ) ) ; 
} public static int cublasDznrm2 ( 
return checkResult ( cublasDznrm2Native ( handle , n , x , incx , result ) ) ; 
} public static int cublasDotEx ( 
int xType , 
int yType , 
Pointer result , 
int resultType , 
int executionType ) 
return checkResult ( cublasDotExNative ( handle , n , x , xType , incx , y , yType , incy , result , resultType , executionType ) ) ; 
} public static int cublasDdot ( 
return checkResult ( cublasDdotNative ( handle , n , x , incx , y , incy , result ) ) ; 
} public static int cublasCdotu ( 
return checkResult ( cublasCdotuNative ( handle , n , x , incx , y , incy , result ) ) ; 
} public static int cublasCdotc ( 
return checkResult ( cublasCdotcNative ( handle , n , x , incx , y , incy , result ) ) ; 
} public static int cublasZdotu ( 
return checkResult ( cublasZdotuNative ( handle , n , x , incx , y , incy , result ) ) ; 
} public static int cublasZdotc ( 
return checkResult ( cublasZdotcNative ( handle , n , x , incx , y , incy , result ) ) ; 
} public static int cublasScalEx ( 
Pointer alpha , 
int alphaType , 
return checkResult ( cublasScalExNative ( handle , n , alpha , alphaType , x , xType , incx , executionType ) ) ; 
} public static int cublasIdamax ( 
return checkResult ( cublasIdamaxNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIcamax ( 
return checkResult ( cublasIcamaxNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIzamax ( 
return checkResult ( cublasIzamaxNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIsamin ( 
return checkResult ( cublasIsaminNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIdamin ( 
return checkResult ( cublasIdaminNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIcamin ( 
return checkResult ( cublasIcaminNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasIzamin ( 
return checkResult ( cublasIzaminNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasSasum ( 
return checkResult ( cublasSasumNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasDasum ( 
return checkResult ( cublasDasumNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasScasum ( 
return checkResult ( cublasScasumNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasDzasum ( 
return checkResult ( cublasDzasumNative ( handle , n , x , incx , result ) ) ; 
} public static int cublasSrot ( 
Pointer c , 
Pointer s ) 
return checkResult ( cublasSrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasDrot ( 
return checkResult ( cublasDrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasCrot ( 
return checkResult ( cublasCrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasCsrot ( 
return checkResult ( cublasCsrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasZrot ( 
return checkResult ( cublasZrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasZdrot ( 
return checkResult ( cublasZdrotNative ( handle , n , x , incx , y , incy , c , s ) ) ; 
} public static int cublasSrotg ( 
Pointer a , 
Pointer b , 
return checkResult ( cublasSrotgNative ( handle , a , b , c , s ) ) ; 
} public static int cublasDrotg ( 
return checkResult ( cublasDrotgNative ( handle , a , b , c , s ) ) ; 
} public static int cublasCrotg ( 
return checkResult ( cublasCrotgNative ( handle , a , b , c , s ) ) ; 
} public static int cublasZrotg ( 
return checkResult ( cublasZrotgNative ( handle , a , b , c , s ) ) ; 
} public static int cublasSrotm ( 
Pointer param ) 
return checkResult ( cublasSrotmNative ( handle , n , x , incx , y , incy , param ) ) ; 
} public static int cublasDrotm ( 
return checkResult ( cublasDrotmNative ( handle , n , x , incx , y , incy , param ) ) ; 
} public static int cublasSrotmg ( 
Pointer d1 , 
Pointer d2 , 
Pointer x1 , 
Pointer y1 , 
return checkResult ( cublasSrotmgNative ( handle , d1 , d2 , x1 , y1 , param ) ) ; 
} public static int cublasDrotmg ( 
return checkResult ( cublasDrotmgNative ( handle , d1 , d2 , x1 , y1 , param ) ) ; 
} public static int cublasSgemv ( 
int trans , 
int m , 
Pointer beta , 
return checkResult ( cublasSgemvNative ( handle , trans , m , n , alpha , A , lda , x , incx , beta , y , incy ) ) ; 
} private static void checkResultBLAS ( ) 
if ( exceptionsEnabled ) 
lastResult = cublasGetErrorNative ( ) ; 
if ( lastResult != cublasStatus . CUBLAS_STATUS_SUCCESS ) 
throw new CudaException ( cublasStatus . stringFor ( lastResult ) ) ; 
} public static int cublasAlloc ( int n , int elemSize , Pointer ptr ) 
return checkResult ( cublasAllocNative ( n , elemSize , ptr ) ) ; 
} public static int cublasSetVector ( int n , cuComplex x [ ] , int offsetx , int incx , Pointer y , int incy ) 
ByteBuffer byteBufferx = ByteBuffer . allocateDirect ( x . length * 4 * 2 ) ; 
byteBufferx . order ( ByteOrder . nativeOrder ( ) ) ; 
FloatBuffer floatBufferx = byteBufferx . asFloatBuffer ( ) ; 
int indexx = offsetx ; 
for ( int i = 0 ; i < n ; i ++ , indexx += incx ) 
floatBufferx . put ( indexx * 2 + 0 , x [ indexx ] . x ) ; 
floatBufferx . put ( indexx * 2 + 1 , x [ indexx ] . y ) ; 
return checkResult ( cublasSetVectorNative ( n , 8 , Pointer . to ( floatBufferx ) . withByteOffset ( offsetx * 4 * 2 ) , incx , y , incy ) ) ; 
} public static int cublasGetVector ( int n , Pointer x , int incx , cuComplex y [ ] , int offsety , int incy ) 
ByteBuffer byteBuffery = ByteBuffer . allocateDirect ( y . length * 4 * 2 ) ; 
byteBuffery . order ( ByteOrder . nativeOrder ( ) ) ; 
FloatBuffer floatBuffery = byteBuffery . asFloatBuffer ( ) ; 
int status = cublasGetVectorNative ( n , 8 , x , incx , Pointer . to ( floatBuffery ) . withByteOffset ( offsety * 4 * 2 ) , incy ) ; 
if ( status == cublasStatus . CUBLAS_STATUS_SUCCESS ) 
floatBuffery . rewind ( ) ; 
int indexy = offsety ; 
for ( int i = 0 ; i < n ; i ++ , indexy += incy ) 
y [ indexy ] . x = floatBuffery . get ( indexy * 2 + 0 ) ; 
y [ indexy ] . y = floatBuffery . get ( indexy * 2 + 1 ) ; 
return checkResult ( status ) ; 
} public static int cublasSetMatrix ( int rows , int cols , cuComplex A [ ] , int offsetA , int lda , Pointer B , int ldb ) 
ByteBuffer byteBufferA = ByteBuffer . allocateDirect ( A . length * 4 * 2 ) ; 
byteBufferA . order ( ByteOrder . nativeOrder ( ) ) ; 
FloatBuffer floatBufferA = byteBufferA . asFloatBuffer ( ) ; 
for ( int i = 0 ; i < A . length ; i ++ ) 
floatBufferA . put ( A [ i ] . x ) ; 
floatBufferA . put ( A [ i ] . y ) ; 
return checkResult ( cublasSetMatrixNative ( rows , cols , 8 , Pointer . to ( floatBufferA ) . withByteOffset ( offsetA * 4 * 2 ) , lda , B , ldb ) ) ; 
} public static int cublasGetMatrix ( int rows , int cols , Pointer A , int lda , cuComplex B [ ] , int offsetB , int ldb ) 
ByteBuffer byteBufferB = ByteBuffer . allocateDirect ( B . length * 4 * 2 ) ; 
byteBufferB . order ( ByteOrder . nativeOrder ( ) ) ; 
FloatBuffer floatBufferB = byteBufferB . asFloatBuffer ( ) ; 
int status = cublasGetMatrixNative ( rows , cols , 8 , A , lda , Pointer . to ( floatBufferB ) . withByteOffset ( offsetB * 4 * 2 ) , ldb ) ; 
floatBufferB . rewind ( ) ; 
for ( int c = 0 ; c < cols ; c ++ ) 
for ( int r = 0 ; r < rows ; r ++ ) 
int index = c * ldb + r + offsetB ; 
B [ index ] . x = floatBufferB . get ( index * 2 + 0 ) ; 
B [ index ] . y = floatBufferB . get ( index * 2 + 1 ) ; 
} public static int cublasSetVector ( int n , cuDoubleComplex x [ ] , int offsetx , int incx , Pointer y , int incy ) 
ByteBuffer byteBufferx = ByteBuffer . allocateDirect ( x . length * 8 * 2 ) ; 
DoubleBuffer doubleBufferx = byteBufferx . asDoubleBuffer ( ) ; 
doubleBufferx . put ( indexx * 2 + 0 , x [ indexx ] . x ) ; 
doubleBufferx . put ( indexx * 2 + 1 , x [ indexx ] . y ) ; 
return checkResult ( cublasSetVectorNative ( n , 16 , Pointer . to ( doubleBufferx ) . withByteOffset ( offsetx * 8 * 2 ) , incx , y , incy ) ) ; 
} public static int cublasGetVector ( int n , Pointer x , int incx , cuDoubleComplex y [ ] , int offsety , int incy ) 
ByteBuffer byteBuffery = ByteBuffer . allocateDirect ( y . length * 8 * 2 ) ; 
DoubleBuffer doubleBuffery = byteBuffery . asDoubleBuffer ( ) ; 
int status = cublasGetVectorNative ( n , 16 , x , incx , Pointer . to ( doubleBuffery ) . withByteOffset ( offsety * 8 * 2 ) , incy ) ; 
doubleBuffery . rewind ( ) ; 
y [ indexy ] . x = doubleBuffery . get ( indexy * 2 + 0 ) ; 
y [ indexy ] . y = doubleBuffery . get ( indexy * 2 + 1 ) ; 
} public static int cublasSetMatrix ( int rows , int cols , cuDoubleComplex A [ ] , int offsetA , int lda , Pointer B , int ldb ) 
ByteBuffer byteBufferA = ByteBuffer . allocateDirect ( A . length * 8 * 2 ) ; 
DoubleBuffer doubleBufferA = byteBufferA . asDoubleBuffer ( ) ; 
doubleBufferA . put ( A [ i ] . x ) ; 
doubleBufferA . put ( A [ i ] . y ) ; 
return checkResult ( cublasSetMatrixNative ( rows , cols , 16 , Pointer . to ( doubleBufferA ) . withByteOffset ( offsetA * 8 * 2 ) , lda , B , ldb ) ) ; 
} public static int cublasGetMatrix ( int rows , int cols , Pointer A , int lda , cuDoubleComplex B [ ] , int offsetB , int ldb ) 
ByteBuffer byteBufferB = ByteBuffer . allocateDirect ( B . length * 8 * 2 ) ; 
DoubleBuffer doubleBufferB = byteBufferB . asDoubleBuffer ( ) ; 
int status = cublasGetMatrixNative ( rows , cols , 16 , A , lda , Pointer . to ( doubleBufferB ) . withByteOffset ( offsetB * 8 * 2 ) , ldb ) ; 
doubleBufferB . rewind ( ) ; 
B [ index ] . x = doubleBufferB . get ( index * 2 + 0 ) ; 
B [ index ] . y = doubleBufferB . get ( index * 2 + 1 ) ; 
} public static void cublasSrotm ( int n , Pointer x , int incx , Pointer y , int incy , float sparam [ ] ) 
cublasSrotmNative ( n , x , incx , y , incy , sparam ) ; 
checkResultBLAS ( ) ; 
} public static void cublasSrotmg ( float sd1 [ ] , float sd2 [ ] , float sx1 [ ] , float sy1 , float sparam [ ] ) 
cublasSrotmgNative ( sd1 , sd2 , sx1 , sy1 , sparam ) ; 
} public static void cublasDrotm ( int n , Pointer x , int incx , Pointer y , int incy , double sparam [ ] ) 
cublasDrotmNative ( n , x , incx , y , incy , sparam ) ; 
} public static void cublasDrotmg ( double sd1 [ ] , double sd2 [ ] , double sx1 [ ] , double sy1 , double sparam [ ] ) 
cublasDrotmgNative ( sd1 , sd2 , sx1 , sy1 , sparam ) ; 
} public static int cublasIsamax ( int n , Pointer x , int incx ) 
int result = cublasIsamaxNative ( n , x , incx ) ; 
} public static int cublasIsamin ( int n , Pointer x , int incx ) 
int result = cublasIsaminNative ( n , x , incx ) ; 
} public static float cublasSasum ( int n , Pointer x , int incx ) 
float result = cublasSasumNative ( n , x , incx ) ; 
} public static void cublasSaxpy ( int n , float alpha , Pointer x , int incx , Pointer y , int incy ) 
cublasSaxpyNative ( n , alpha , x , incx , y , incy ) ; 
} public static void cublasScopy ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasScopyNative ( n , x , incx , y , incy ) ; 
} public static float cublasSdot ( int n , Pointer x , int incx , Pointer y , int incy ) 
float result = cublasSdotNative ( n , x , incx , y , incy ) ; 
} public static float cublasSnrm2 ( int n , Pointer x , int incx ) 
float result = cublasSnrm2Native ( n , x , incx ) ; 
} public static void cublasSrot ( int n , Pointer x , int incx , Pointer y , int incy , float sc , float ss ) 
cublasSrotNative ( n , x , incx , y , incy , sc , ss ) ; 
} public static void cublasSrotg ( Pointer host_sa , Pointer host_sb , Pointer host_sc , Pointer host_ss ) 
cublasSrotgNative ( host_sa , host_sb , host_sc , host_ss ) ; 
} public static void cublasSscal ( int n , float alpha , Pointer x , int incx ) 
cublasSscalNative ( n , alpha , x , incx ) ; 
} public static void cublasSswap ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasSswapNative ( n , x , incx , y , incy ) ; 
} public static void cublasCaxpy ( int n , cuComplex alpha , Pointer x , int incx , Pointer y , int incy ) 
cublasCaxpyNative ( n , alpha , x , incx , y , incy ) ; 
} public static void cublasCcopy ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasCcopyNative ( n , x , incx , y , incy ) ; 
} public static void cublasZcopy ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasZcopyNative ( n , x , incx , y , incy ) ; 
} public static void cublasCscal ( int n , cuComplex alpha , Pointer x , int incx ) 
cublasCscalNative ( n , alpha , x , incx ) ; 
} public static void cublasCrotg ( Pointer host_ca , cuComplex cb , Pointer host_sc , Pointer host_cs ) 
cublasCrotgNative ( host_ca , cb , host_sc , host_cs ) ; 
} public static void cublasCrot ( int n , Pointer x , int incx , Pointer y , int incy , float c , cuComplex s ) 
cublasCrotNative ( n , x , incx , y , incy , c , s ) ; 
} public static void cublasCsrot ( int n , Pointer x , int incx , Pointer y , int incy , float c , float s ) 
cublasCsrotNative ( n , x , incx , y , incy , c , s ) ; 
} public static void cublasCsscal ( int n , float alpha , Pointer x , int incx ) 
cublasCsscalNative ( n , alpha , x , incx ) ; 
} public static void cublasCswap ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasCswapNative ( n , x , incx , y , incy ) ; 
} public static void cublasZswap ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasZswapNative ( n , x , incx , y , incy ) ; 
} public static cuComplex cublasCdotu ( int n , Pointer x , int incx , Pointer y , int incy ) 
cuComplex result = cublasCdotuNative ( n , x , incx , y , incy ) ; 
} public static cuComplex cublasCdotc ( int n , Pointer x , int incx , Pointer y , int incy ) 
cuComplex result = cublasCdotcNative ( n , x , incx , y , incy ) ; 
} public static int cublasIcamax ( int n , Pointer x , int incx ) 
int result = cublasIcamaxNative ( n , x , incx ) ; 
} public static int cublasIcamin ( int n , Pointer x , int incx ) 
int result = cublasIcaminNative ( n , x , incx ) ; 
} public static float cublasScasum ( int n , Pointer x , int incx ) 
float result = cublasScasumNative ( n , x , incx ) ; 
} public static float cublasScnrm2 ( int n , Pointer x , int incx ) 
float result = cublasScnrm2Native ( n , x , incx ) ; 
} public static void cublasZaxpy ( int n , cuDoubleComplex alpha , Pointer x , int incx , Pointer y , int incy ) 
cublasZaxpyNative ( n , alpha , x , incx , y , incy ) ; 
} public static cuDoubleComplex cublasZdotu ( int n , Pointer x , int incx , Pointer y , int incy ) 
cuDoubleComplex result = cublasZdotuNative ( n , x , incx , y , incy ) ; 
} public static cuDoubleComplex cublasZdotc ( int n , Pointer x , int incx , Pointer y , int incy ) 
cuDoubleComplex result = cublasZdotcNative ( n , x , incx , y , incy ) ; 
} public static void cublasZscal ( int n , cuDoubleComplex alpha , Pointer x , int incx ) 
cublasZscalNative ( n , alpha , x , incx ) ; 
} public static void cublasZdscal ( int n , double alpha , Pointer x , int incx ) 
cublasZdscalNative ( n , alpha , x , incx ) ; 
} public static double cublasDznrm2 ( int n , Pointer x , int incx ) 
double result = cublasDznrm2Native ( n , x , incx ) ; 
} public static void cublasZrotg ( Pointer host_ca , cuDoubleComplex cb , Pointer host_sc , Pointer host_cs ) 
cublasZrotgNative ( host_ca , cb , host_sc , host_cs ) ; 
} public static void cublasZrot ( int n , Pointer x , int incx , Pointer y , int incy , double sc , cuDoubleComplex cs ) 
cublasZrotNative ( n , x , incx , y , incy , sc , cs ) ; 
} public static void cublasZdrot ( int n , Pointer x , int incx , Pointer y , int incy , double c , double s ) 
cublasZdrotNative ( n , x , incx , y , incy , c , s ) ; 
} public static int cublasIzamax ( int n , Pointer x , int incx ) 
int result = cublasIzamaxNative ( n , x , incx ) ; 
} public static int cublasIzamin ( int n , Pointer x , int incx ) 
int result = cublasIzaminNative ( n , x , incx ) ; 
} public static double cublasDzasum ( int n , Pointer x , int incx ) 
double result = cublasDzasumNative ( n , x , incx ) ; 
} public static void cublasSgbmv ( char trans , int m , int n , int kl , int ku , float alpha , Pointer A , int lda , Pointer x , int incx , float beta , Pointer y , int incy ) 
cublasSgbmvNative ( trans , m , n , kl , ku , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasSgemv ( char trans , int m , int n , float alpha , Pointer A , int lda , Pointer x , int incx , float beta , Pointer y , int incy ) 
cublasSgemvNative ( trans , m , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasSger ( int m , int n , float alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasSgerNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasSsbmv ( char uplo , int n , int k , float alpha , Pointer A , int lda , Pointer x , int incx , float beta , Pointer y , int incy ) 
cublasSsbmvNative ( uplo , n , k , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasSspmv ( char uplo , int n , float alpha , Pointer AP , Pointer x , int incx , float beta , Pointer y , int incy ) 
cublasSspmvNative ( uplo , n , alpha , AP , x , incx , beta , y , incy ) ; 
} public static void cublasSspr ( char uplo , int n , float alpha , Pointer x , int incx , Pointer AP ) 
cublasSsprNative ( uplo , n , alpha , x , incx , AP ) ; 
} public static void cublasSspr2 ( char uplo , int n , float alpha , Pointer x , int incx , Pointer y , int incy , Pointer AP ) 
cublasSspr2Native ( uplo , n , alpha , x , incx , y , incy , AP ) ; 
} public static void cublasSsymv ( char uplo , int n , float alpha , Pointer A , int lda , Pointer x , int incx , float beta , Pointer y , int incy ) 
cublasSsymvNative ( uplo , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasSsyr ( char uplo , int n , float alpha , Pointer x , int incx , Pointer A , int lda ) 
cublasSsyrNative ( uplo , n , alpha , x , incx , A , lda ) ; 
} public static void cublasSsyr2 ( char uplo , int n , float alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasSsyr2Native ( uplo , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasStbmv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasStbmvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasStbsv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasStbsvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasStpmv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasStpmvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasStpsv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasStpsvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasStrmv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasStrmvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasStrsv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasStrsvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasZtrmv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasZtrmvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasZgbmv ( char trans , int m , int n , int kl , int ku , cuDoubleComplex alpha , Pointer A , int lda , Pointer x , int incx , cuDoubleComplex beta , Pointer y , int incy ) 
cublasZgbmvNative ( trans , m , n , kl , ku , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasZtbmv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasZtbmvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasZtbsv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasZtbsvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasZhemv ( char uplo , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer x , int incx , cuDoubleComplex beta , Pointer y , int incy ) 
cublasZhemvNative ( uplo , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasZhpmv ( char uplo , int n , cuDoubleComplex alpha , Pointer AP , Pointer x , int incx , cuDoubleComplex beta , Pointer y , int incy ) 
cublasZhpmvNative ( uplo , n , alpha , AP , x , incx , beta , y , incy ) ; 
} public static void cublasZgemv ( char trans , int m , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer x , int incx , cuDoubleComplex beta , Pointer y , int incy ) 
cublasZgemvNative ( trans , m , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasZtpmv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasZtpmvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasZtpsv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasZtpsvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasCgemv ( char trans , int m , int n , cuComplex alpha , Pointer A , int lda , Pointer x , int incx , cuComplex beta , Pointer y , int incy ) 
cublasCgemvNative ( trans , m , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasCgbmv ( char trans , int m , int n , int kl , int ku , cuComplex alpha , Pointer A , int lda , Pointer x , int incx , cuComplex beta , Pointer y , int incy ) 
cublasCgbmvNative ( trans , m , n , kl , ku , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasChemv ( char uplo , int n , cuComplex alpha , Pointer A , int lda , Pointer x , int incx , cuComplex beta , Pointer y , int incy ) 
cublasChemvNative ( uplo , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasChbmv ( char uplo , int n , int k , cuComplex alpha , Pointer A , int lda , Pointer x , int incx , cuComplex beta , Pointer y , int incy ) 
cublasChbmvNative ( uplo , n , k , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasCtrmv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasCtrmvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasCtbmv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasCtbmvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasCtpmv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasCtpmvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasCtrsv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasCtrsvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasCtbsv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasCtbsvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasCtpsv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasCtpsvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasCgeru ( int m , int n , cuComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasCgeruNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasCgerc ( int m , int n , cuComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasCgercNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasCher ( char uplo , int n , float alpha , Pointer x , int incx , Pointer A , int lda ) 
cublasCherNative ( uplo , n , alpha , x , incx , A , lda ) ; 
} public static void cublasChpr ( char uplo , int n , float alpha , Pointer x , int incx , Pointer AP ) 
cublasChprNative ( uplo , n , alpha , x , incx , AP ) ; 
} public static void cublasChpr2 ( char uplo , int n , cuComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer AP ) 
cublasChpr2Native ( uplo , n , alpha , x , incx , y , incy , AP ) ; 
} public static void cublasCher2 ( char uplo , int n , cuComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasCher2Native ( uplo , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasSgemm ( char transa , char transb , int m , int n , int k , float alpha , Pointer A , int lda , Pointer B , int ldb , float beta , Pointer C , int ldc ) 
cublasSgemmNative ( transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasSsymm ( char side , char uplo , int m , int n , float alpha , Pointer A , int lda , Pointer B , int ldb , float beta , Pointer C , int ldc ) 
cublasSsymmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasSsyrk ( char uplo , char trans , int n , int k , float alpha , Pointer A , int lda , float beta , Pointer C , int ldc ) 
cublasSsyrkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasSsyr2k ( char uplo , char trans , int n , int k , float alpha , Pointer A , int lda , Pointer B , int ldb , float beta , Pointer C , int ldc ) 
cublasSsyr2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasStrmm ( char side , char uplo , char transa , char diag , int m , int n , float alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasStrmmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasStrsm ( char side , char uplo , char transa , char diag , int m , int n , float alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasStrsmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasCgemm ( char transa , char transb , int m , int n , int k , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuComplex beta , Pointer C , int ldc ) 
cublasCgemmNative ( transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasCsymm ( char side , char uplo , int m , int n , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuComplex beta , Pointer C , int ldc ) 
cublasCsymmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasChemm ( char side , char uplo , int m , int n , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuComplex beta , Pointer C , int ldc ) 
cublasChemmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasCsyrk ( char uplo , char trans , int n , int k , cuComplex alpha , Pointer A , int lda , cuComplex beta , Pointer C , int ldc ) 
cublasCsyrkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasCherk ( char uplo , char trans , int n , int k , float alpha , Pointer A , int lda , float beta , Pointer C , int ldc ) 
cublasCherkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasCsyr2k ( char uplo , char trans , int n , int k , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuComplex beta , Pointer C , int ldc ) 
cublasCsyr2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasCher2k ( char uplo , char trans , int n , int k , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb , float beta , Pointer C , int ldc ) 
cublasCher2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasCtrmm ( char side , char uplo , char transa , char diag , int m , int n , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasCtrmmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasCtrsm ( char side , char uplo , char transa , char diag , int m , int n , cuComplex alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasCtrsmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static double cublasDasum ( int n , Pointer x , int incx ) 
double result = cublasDasumNative ( n , x , incx ) ; 
} public static void cublasDaxpy ( int n , double alpha , Pointer x , int incx , Pointer y , int incy ) 
cublasDaxpyNative ( n , alpha , x , incx , y , incy ) ; 
} public static void cublasDcopy ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasDcopyNative ( n , x , incx , y , incy ) ; 
} public static double cublasDdot ( int n , Pointer x , int incx , Pointer y , int incy ) 
double result = cublasDdotNative ( n , x , incx , y , incy ) ; 
} public static double cublasDnrm2 ( int n , Pointer x , int incx ) 
double result = cublasDnrm2Native ( n , x , incx ) ; 
} public static void cublasDrot ( int n , Pointer x , int incx , Pointer y , int incy , double sc , double ss ) 
cublasDrotNative ( n , x , incx , y , incy , sc , ss ) ; 
} public static void cublasDrotg ( Pointer host_sa , Pointer host_sb , Pointer host_sc , Pointer host_ss ) 
cublasDrotgNative ( host_sa , host_sb , host_sc , host_ss ) ; 
} public static void cublasDscal ( int n , double alpha , Pointer x , int incx ) 
cublasDscalNative ( n , alpha , x , incx ) ; 
} public static void cublasDswap ( int n , Pointer x , int incx , Pointer y , int incy ) 
cublasDswapNative ( n , x , incx , y , incy ) ; 
} public static int cublasIdamax ( int n , Pointer x , int incx ) 
int result = cublasIdamaxNative ( n , x , incx ) ; 
} public static int cublasIdamin ( int n , Pointer x , int incx ) 
int result = cublasIdaminNative ( n , x , incx ) ; 
} public static void cublasDgemv ( char trans , int m , int n , double alpha , Pointer A , int lda , Pointer x , int incx , double beta , Pointer y , int incy ) 
cublasDgemvNative ( trans , m , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasDger ( int m , int n , double alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasDgerNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasDsyr ( char uplo , int n , double alpha , Pointer x , int incx , Pointer A , int lda ) 
cublasDsyrNative ( uplo , n , alpha , x , incx , A , lda ) ; 
} public static void cublasDsyr2 ( char uplo , int n , double alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasDsyr2Native ( uplo , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasDspr ( char uplo , int n , double alpha , Pointer x , int incx , Pointer AP ) 
cublasDsprNative ( uplo , n , alpha , x , incx , AP ) ; 
} public static void cublasDspr2 ( char uplo , int n , double alpha , Pointer x , int incx , Pointer y , int incy , Pointer AP ) 
cublasDspr2Native ( uplo , n , alpha , x , incx , y , incy , AP ) ; 
} public static void cublasDtrsv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasDtrsvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasDtrmv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasDtrmvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasDtbmv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasDtbmvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasDtpmv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasDtpmvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasDtpsv ( char uplo , char trans , char diag , int n , Pointer AP , Pointer x , int incx ) 
cublasDtpsvNative ( uplo , trans , diag , n , AP , x , incx ) ; 
} public static void cublasDtbsv ( char uplo , char trans , char diag , int n , int k , Pointer A , int lda , Pointer x , int incx ) 
cublasDtbsvNative ( uplo , trans , diag , n , k , A , lda , x , incx ) ; 
} public static void cublasDsymv ( char uplo , int n , double alpha , Pointer A , int lda , Pointer x , int incx , double beta , Pointer y , int incy ) 
cublasDsymvNative ( uplo , n , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasDsbmv ( char uplo , int n , int k , double alpha , Pointer A , int lda , Pointer x , int incx , double beta , Pointer y , int incy ) 
cublasDsbmvNative ( uplo , n , k , alpha , A , lda , x , incx , beta , y , incy ) ; 
} public static void cublasDspmv ( char uplo , int n , double alpha , Pointer AP , Pointer x , int incx , double beta , Pointer y , int incy ) 
cublasDspmvNative ( uplo , n , alpha , AP , x , incx , beta , y , incy ) ; 
} public static void cublasDtrsm ( char side , char uplo , char transa , char diag , int m , int n , double alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasDtrsmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasZtrsm ( char side , char uplo , char transa , char diag , int m , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasZtrsmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasDtrmm ( char side , char uplo , char transa , char diag , int m , int n , double alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasDtrmmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasDsymm ( char side , char uplo , int m , int n , double alpha , Pointer A , int lda , Pointer B , int ldb , double beta , Pointer C , int ldc ) 
cublasDsymmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZsymm ( char side , char uplo , int m , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuDoubleComplex beta , Pointer C , int ldc ) 
cublasZsymmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasDsyrk ( char uplo , char trans , int n , int k , double alpha , Pointer A , int lda , double beta , Pointer C , int ldc ) 
cublasDsyrkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasZsyrk ( char uplo , char trans , int n , int k , cuDoubleComplex alpha , Pointer A , int lda , cuDoubleComplex beta , Pointer C , int ldc ) 
cublasZsyrkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasZsyr2k ( char uplo , char trans , int n , int k , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuDoubleComplex beta , Pointer C , int ldc ) 
cublasZsyr2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZher2k ( char uplo , char trans , int n , int k , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb , double beta , Pointer C , int ldc ) 
cublasZher2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZher ( char uplo , int n , double alpha , Pointer x , int incx , Pointer A , int lda ) 
cublasZherNative ( uplo , n , alpha , x , incx , A , lda ) ; 
} public static void cublasZhpr ( char uplo , int n , double alpha , Pointer x , int incx , Pointer AP ) 
cublasZhprNative ( uplo , n , alpha , x , incx , AP ) ; 
} public static void cublasZhpr2 ( char uplo , int n , cuDoubleComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer AP ) 
cublasZhpr2Native ( uplo , n , alpha , x , incx , y , incy , AP ) ; 
} public static void cublasZher2 ( char uplo , int n , cuDoubleComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasZher2Native ( uplo , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasDsyr2k ( char uplo , char trans , int n , int k , double alpha , Pointer A , int lda , Pointer B , int ldb , double beta , Pointer C , int ldc ) 
cublasDsyr2kNative ( uplo , trans , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZgemm ( char transa , char transb , int m , int n , int k , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuDoubleComplex beta , Pointer C , int ldc ) 
cublasZgemmNative ( transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZtrmm ( char side , char uplo , char transa , char diag , int m , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb ) 
cublasZtrmmNative ( side , uplo , transa , diag , m , n , alpha , A , lda , B , ldb ) ; 
} public static void cublasZgeru ( int m , int n , cuDoubleComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasZgeruNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasZgerc ( int m , int n , cuDoubleComplex alpha , Pointer x , int incx , Pointer y , int incy , Pointer A , int lda ) 
cublasZgercNative ( m , n , alpha , x , incx , y , incy , A , lda ) ; 
} public static void cublasZherk ( char uplo , char trans , int n , int k , double alpha , Pointer A , int lda , double beta , Pointer C , int ldc ) 
cublasZherkNative ( uplo , trans , n , k , alpha , A , lda , beta , C , ldc ) ; 
} public static void cublasZhemm ( char side , char uplo , int m , int n , cuDoubleComplex alpha , Pointer A , int lda , Pointer B , int ldb , cuDoubleComplex beta , Pointer C , int ldc ) 
cublasZhemmNative ( side , uplo , m , n , alpha , A , lda , B , ldb , beta , C , ldc ) ; 
} public static void cublasZtrsv ( char uplo , char trans , char diag , int n , Pointer A , int lda , Pointer x , int incx ) 
cublasZtrsvNative ( uplo , trans , diag , n , A , lda , x , incx ) ; 
} public static void cublasZhbmv ( char uplo , int n , int k , cuDoubleComplex alpha , Pointer A , int lda , Pointer x , int incx , cuDoubleComplex beta , Pointer y , int incy ) 
cublasZhbmvNative ( uplo , n , k , alpha , A , lda , x , incx , beta , y , incy ) ; 
public static GenericodeReader < com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC04_CODE_LIST , 
com . helger . genericode . v04 . CodeListDocument . class ) ; 
public static GenericodeReader < com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET , 
com . helger . genericode . v04 . CodeListSetDocument . class ) ; 
public static GenericodeReader < com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC04_COLUMN_SET , 
com . helger . genericode . v04 . ColumnSetDocument . class ) ; 
public static GenericodeReader < com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC10_CODE_LIST , 
com . helger . genericode . v10 . CodeListDocument . class ) ; 
public static GenericodeReader < com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET , 
com . helger . genericode . v10 . CodeListSetDocument . class ) ; 
public static GenericodeReader < com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) 
return new GenericodeReader < > ( EGenericodeDocumentType . GC10_COLUMN_SET , 
com . helger . genericode . v10 . ColumnSetDocument . class ) ; 
public static String getColumnElementID ( @ Nonnull final Object aColumnElement ) 
if ( aColumnElement instanceof ColumnRef ) 
return ( ( ColumnRef ) aColumnElement ) . getId ( ) ; 
if ( aColumnElement instanceof Column ) 
return ( ( Column ) aColumnElement ) . getId ( ) ; 
if ( aColumnElement instanceof Key ) 
final List < KeyColumnRef > aKeyColumnRefs = ( ( Key ) aColumnElement ) . getColumnRef ( ) ; 
final KeyColumnRef aKeyColumnRef = CollectionHelper . getFirstElement ( aKeyColumnRefs ) ; 
if ( aKeyColumnRef == null ) 
final Object aRef = aKeyColumnRef . getRef ( ) ; 
if ( aRef instanceof Column ) 
return ( ( Column ) aRef ) . getId ( ) ; 
aRef + 
ClassHelper . getSafeClassName ( aRef ) ) ; 
aColumnElement + 
ClassHelper . getSafeClassName ( aColumnElement ) ) ; 
public static String getRowValue ( @ Nonnull final Row aRow , @ Nonnull final String sColumnID ) 
for ( final Value aValue : aRow . getValue ( ) ) 
final String sID = getColumnElementID ( aValue . getColumnRef ( ) ) ; 
if ( sID . equals ( sColumnID ) ) 
final SimpleValue aSimpleValue = aValue . getSimpleValue ( ) ; 
return aSimpleValue != null ? aSimpleValue . getValue ( ) : null ; 
@ ReturnsMutableCopy 
public static ICommonsList < Column > getAllColumns ( @ Nonnull final ColumnSet aColumnSet ) 
final ICommonsList < Column > ret = new CommonsArrayList < > ( ) ; 
getAllColumns ( aColumnSet , ret ) ; 
} public static void getAllColumns ( @ Nonnull final ColumnSet aColumnSet , @ Nonnull final Collection < Column > aTarget ) 
CollectionHelper . findAll ( aColumnSet . getColumnChoice ( ) , o -> o instanceof Column , o -> aTarget . add ( ( Column ) o ) ) ; 
public static ICommonsList < String > getAllColumnIDs ( @ Nonnull final ColumnSet aColumnSet ) 
final ICommonsList < String > ret = new CommonsArrayList < > ( ) ; 
getAllColumnIDs ( aColumnSet , ret ) ; 
} public static void getAllColumnIDs ( @ Nonnull final ColumnSet aColumnSet , @ Nonnull final Collection < String > aTarget ) 
CollectionHelper . findAll ( aColumnSet . getColumnChoice ( ) , 
o -> o instanceof Column , 
o -> aTarget . add ( ( ( Column ) o ) . getId ( ) ) ) ; 
public static Column getColumnOfID ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) 
if ( sID != null ) 
for ( final Column aColumn : getAllColumns ( aColumnSet ) ) 
if ( aColumn . getId ( ) . equals ( sID ) ) 
return aColumn ; 
public static ICommonsList < Key > getAllKeys ( @ Nonnull final ColumnSet aColumnSet ) 
final ICommonsList < Key > ret = new CommonsArrayList < > ( ) ; 
getAllKeys ( aColumnSet , ret ) ; 
} public static void getAllKeys ( @ Nonnull final ColumnSet aColumnSet , @ Nonnull final Collection < Key > aTarget ) 
CollectionHelper . findAll ( aColumnSet . getKeyChoice ( ) , o -> o instanceof Key , o -> aTarget . add ( ( Key ) o ) ) ; 
} public static void getAllKeyIDs ( @ Nonnull final ColumnSet aColumnSet , @ Nonnull final Collection < String > aTarget ) 
CollectionHelper . findAll ( aColumnSet . getKeyChoice ( ) , o -> o instanceof Key , o -> aTarget . add ( ( ( Key ) o ) . getId ( ) ) ) ; 
public static Key getKeyOfID ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) 
for ( final Key aKey : getAllKeys ( aColumnSet ) ) 
if ( aKey . getId ( ) . equals ( sID ) ) 
return aKey ; 
} public static boolean isKeyColumn ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sColumnID ) 
if ( sColumnID != null ) 
for ( final KeyColumnRef aColumnRef : aKey . getColumnRef ( ) ) 
if ( aColumnRef . getRef ( ) instanceof Column ) 
if ( ( ( Column ) aColumnRef . getRef ( ) ) . getId ( ) . equals ( sColumnID ) ) 
public static ShortName createShortName ( @ Nullable final String sValue ) 
final ShortName aShortName = s_aFactory . createShortName ( ) ; 
aShortName . setValue ( sValue ) ; 
return aShortName ; 
public static LongName createLongName ( @ Nullable final String sValue ) 
final LongName aLongName = s_aFactory . createLongName ( ) ; 
aLongName . setValue ( sValue ) ; 
return aLongName ; 
public static SimpleValue createSimpleValue ( @ Nullable final String sValue ) 
final SimpleValue aSimpleValue = s_aFactory . createSimpleValue ( ) ; 
aSimpleValue . setValue ( sValue ) ; 
return aSimpleValue ; 
public static KeyColumnRef createKeyColumnRef ( @ Nullable final Column aColumn ) 
final KeyColumnRef aColumnRef = s_aFactory . createKeyColumnRef ( ) ; 
aColumnRef . setRef ( aColumn ) ; 
return aColumnRef ; 
public static Column createColumn ( @ Nonnull @ Nonempty final String sColumnID , 
@ Nonnull final UseType eUseType , 
@ Nonnull @ Nonempty final String sShortName , 
@ Nullable final String sLongName , 
@ Nonnull @ Nonempty final String sDataType ) 
ValueEnforcer . notEmpty ( sColumnID , "ColumnID" ) ; 
ValueEnforcer . notNull ( eUseType , "useType" ) ; 
ValueEnforcer . notEmpty ( sShortName , "ShortName" ) ; 
ValueEnforcer . notEmpty ( sDataType , "DataType" ) ; 
final Column aColumn = s_aFactory . createColumn ( ) ; 
aColumn . setId ( sColumnID ) ; 
aColumn . setUse ( eUseType ) ; 
aColumn . setShortName ( createShortName ( sShortName ) ) ; 
if ( StringHelper . hasText ( sLongName ) ) 
aColumn . getLongName ( ) . add ( createLongName ( sLongName ) ) ; 
final Data aData = s_aFactory . createData ( ) ; 
aData . setType ( sDataType ) ; 
aColumn . setData ( aData ) ; 
public static Key createKey ( @ Nonnull @ Nonempty final String sColumnID , 
@ Nonnull final Column aColumn ) 
ValueEnforcer . notNull ( aColumn , "Column" ) ; 
final Key aKey = s_aFactory . createKey ( ) ; 
aKey . setId ( sColumnID ) ; 
aKey . setShortName ( createShortName ( sShortName ) ) ; 
aKey . getLongName ( ) . add ( createLongName ( sLongName ) ) ; 
aKey . getColumnRef ( ) . add ( createKeyColumnRef ( aColumn ) ) ; 
public ExcelReadOptions < USE_TYPE > setLinesToSkip ( @ Nonnegative final int nLinesToSkip ) 
ValueEnforcer . isGE0 ( nLinesToSkip , "LinesToSkip" ) ; 
m_nLinesToSkip = nLinesToSkip ; 
public ExcelReadOptions < USE_TYPE > addColumn ( @ Nonnegative final int nIndex , 
@ Nonnull @ Nonempty final String sColumnID , 
@ Nonnull final USE_TYPE eUseType , 
@ Nonnull @ Nonempty final String sDataType , 
final boolean bKeyColumn ) 
ValueEnforcer . isGE0 ( nIndex , "Index" ) ; 
final Integer aIndex = Integer . valueOf ( nIndex ) ; 
if ( m_aColumns . containsKey ( aIndex ) ) 
m_aColumns . put ( aIndex , new ExcelReadColumn < > ( nIndex , sColumnID , eUseType , sDataType , bKeyColumn ) ) ; 
public static GenericodeWriter < com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_CODE_LIST ) ; 
public static GenericodeWriter < com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET ) ; 
public static GenericodeWriter < com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_COLUMN_SET ) ; 
public static GenericodeWriter < com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_CODE_LIST ) ; 
public static GenericodeWriter < com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET ) ; 
public static GenericodeWriter < com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) 
return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_COLUMN_SET ) ; 
public static GenericodeValidator < com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_CODE_LIST ) ; 
public static GenericodeValidator < com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET ) ; 
public static GenericodeValidator < com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_COLUMN_SET ) ; 
public static GenericodeValidator < com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_CODE_LIST ) ; 
public static GenericodeValidator < com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET ) ; 
public static GenericodeValidator < com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) 
return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_COLUMN_SET ) ; 
} public void sizeRegion ( Region < ? , ? > region , int numEntries ) { 
if ( region == null ) { 
if ( region instanceof PartitionedRegion ) { 
sizePartitionedRegion ( region , numEntries ) ; 
sizeReplicatedOrLocalRegion ( region , numEntries ) ; 
} private void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { 
Region < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; 
int regionSize = primaryDataSet . size ( ) ; 
if ( numEntries == 0 ) { 
numEntries = primaryDataSet . size ( ) ; 
} else if ( numEntries > regionSize ) { 
numEntries = regionSize ; 
for ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
if ( count == numEntries ) { 
EntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; 
RegionEntry re = entry . getRegionEntry ( ) ; 
dumpSizes ( entry , re ) ; 
dumpTotalAndAverageSizes ( numEntries ) ; 
clearTotals ( ) ; 
} private void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { 
Set < ? > entries = region . entrySet ( ) ; 
int regionSize = entries . size ( ) ; 
numEntries = entries . size ( ) ; 
for ( Iterator < ? > i = entries . iterator ( ) ; i . hasNext ( ) ; ) { 
LocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; 
public String getLocators ( ) 
StringBuilder locatorList = new StringBuilder ( ) ; 
Map < String , ? > credentials = getCredentials ( ) ; 
if ( credentials == null ) 
List < String > locators = ( List < String > ) credentials . get ( "locators" ) ; 
for ( String locator : locators ) 
if ( locatorList . length ( ) != 0 ) 
locatorList . append ( "," ) ; 
locatorList . append ( locator ) ; 
return locatorList . toString ( ) ; 
public List < URI > getLocatorUrlList ( ) 
List < URI > locatorList = new ArrayList < URI > ( ) ; 
List < String > locators = null ; 
if ( credentials != null ) 
locators = ( List < String > ) credentials . get ( "locators" ) ; 
if ( locators == null || locators . isEmpty ( ) ) 
String locatorsConfig = Config . getProperty ( GeodeConfigConstants . LOCATORS_PROP , "" ) ; 
if ( locatorsConfig . length ( ) == 0 ) 
String [ ] parsedLocators = locatorsConfig . split ( "," ) ; 
if ( parsedLocators == null || parsedLocators . length == 0 ) 
locators = Arrays . asList ( parsedLocators ) ; 
Matcher m = regExpPattern . matcher ( locator ) ; 
locatorList . add ( new URI ( "locator://" + m . group ( 1 ) + ":" + m . group ( 2 ) ) ) ; 
return locatorList ; 
} @ SuppressWarnings ( 
{ "unchecked" , "rawtypes" } ) 
public SecuredToken getSecuredToken ( String username , String token ) 
List < Map < String , String > > users = ( List ) credentials . get ( "users" ) ; 
if ( users == null ) 
Map < String , String > map = null ; 
if ( username == null || username . trim ( ) . length ( ) == 0 ) 
map = users . iterator ( ) . next ( ) ; 
map = users . stream ( ) 
. filter ( m -> username . equals ( m . get ( "username" ) ) ) 
. findFirst ( ) . orElse ( null ) ; 
if ( map == null ) 
String password = map . get ( "password" ) ; 
if ( password == null ) 
password = "" ; 
return new UserSecuredCredentials ( map . get ( "username" ) , password . toCharArray ( ) , token ) ; 
} public void constructPoolLocator ( ClientCacheFactory factory ) 
List < URI > list = this . getLocatorUrlList ( ) ; 
if ( list != null && ! list . isEmpty ( ) ) 
for ( URI uri : list ) 
factory . addPoolLocator ( uri . getHost ( ) , uri . getPort ( ) ) ; 
factory . addPoolLocator ( this . host , this . port ) ; 
private List < Map < String , ? > > getGemFireService ( Map services ) 
List < Map < String , ? > > l = ( List ) services . get ( "p-cloudcache" ) ; 
} public SnapshotRecord readSnapshotRecord ( ) throws IOException , ClassNotFoundException { 
byte [ ] key = DataSerializer . readByteArray ( dis ) ; 
byte [ ] value = DataSerializer . readByteArray ( dis ) ; 
return new SnapshotRecord ( key , value ) ; 
public void visitResourceInst ( ResourceInst resourceInst ) 
String name = resourceInst . getName ( ) ; 
ResourceType resourceType = resourceInst . getType ( ) ; 
boolean skip = resourceType == null || resourceType . getName ( ) == null || 
( this . typeName != null && ! resourceType . getName ( ) . toUpperCase ( ) . contains ( this . typeName ) ) ; 
if ( skip ) 
ArrayList < String > values = new ArrayList < String > ( ) ; 
ArrayList < String > headers = new ArrayList < String > ( ) ; 
headers . add ( "name" ) ; 
values . add ( name ) ; 
StatValue [ ] statValues = resourceInst . getStatValues ( ) ; 
if ( statValues == null ) 
for ( StatValue statValue : statValues ) 
String statName = statValue . getDescriptor ( ) . getName ( ) ; 
if ( this . statNames != null && this . statNames . length > 0 ) 
if ( Arrays . binarySearch ( statNames , statName ) < 0 ) 
StatValue dataStoreEntryCount = resourceInst . getStatValue ( statName ) ; 
StatDescriptor statDescriptor = resourceInst . getType ( ) . getStat ( statName ) ; 
values . add ( String . valueOf ( dataStoreEntryCount . getSnapshotsMaximum ( ) ) ) ; 
writeCsv ( resourceInst , headers , values ) ; 
} void writeCsv ( ResourceInst resourceInst , List < String > headers , List < String > values ) 
if ( this . statsFile == null ) 
file = csvFile ; 
file = Paths . get ( this . outputDirectory . toFile ( ) . getAbsolutePath ( ) , this . statsFile . getName ( ) + "." + resourceInst . getType ( ) . getName ( ) + ".csv" ) . toFile ( ) ; 
CsvWriter csvWriter = new CsvWriter ( file ) ; 
csvWriter . writeHeader ( headers ) ; 
csvWriter . appendRow ( values ) ; 
} void dump ( PrintWriter stream ) { 
stream . print ( "[size=" + count ) ; 
if ( i != 0 ) { 
stream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; 
stream . println ( "]" ) ; 
} double [ ] getTimeValuesSinceIdx ( int idx ) { 
int resultSize = this . count - idx ; 
double [ ] result = new double [ resultSize ] ; 
for ( int i = 0 ; i < resultSize ; i ++ ) { 
result [ i ] = getMilliTimeStamp ( idx + i ) ; 
} public UserProfileDetails toUserDetails ( Collection < String > authorities ) 
if ( this . userName == null || this . userName . length ( ) == 0 ) 
if ( password == null || password . length == 0 ) 
if ( authorities == null || authorities . isEmpty ( ) ) 
Collection < GrantedAuthority > grantAuthorities = authorities . stream ( ) 
. map ( a -> new SimpleGrantedAuthority ( a ) ) . collect ( Collectors . toSet ( ) ) ; 
UserProfileDetails user = new UserProfileDetails ( this . userName , String . valueOf ( password ) , 
grantAuthorities ) ; 
user . setEmail ( email ) ; 
user . setFirstName ( firstName ) ; 
user . setLastName ( lastName ) ; 
} public Chart convert ( File file ) 
if ( file . isDirectory ( ) ) 
Set < File > statsFiles = IO . listFileRecursive ( file , "*.gfs" ) ; 
if ( statsFiles == null || statsFiles . isEmpty ( ) ) 
for ( File statFile : statsFiles ) 
GfStatsReader reader = new GfStatsReader ( statFile . getAbsolutePath ( ) ) ; 
reader . accept ( visitor ) ; 
GfStatsReader reader = new GfStatsReader ( file . getAbsolutePath ( ) ) ; 
return visitor . getChart ( ) ; 
} protected void calcStats ( double [ ] values ) { 
if ( statsValid ) { 
size = values . length ; 
min = 0.0 ; 
max = 0.0 ; 
avg = 0.0 ; 
stddev = 0.0 ; 
mostRecent = 0.0 ; 
min = values [ 0 ] ; 
max = values [ 0 ] ; 
mostRecent = values [ values . length - 1 ] ; 
double total = values [ 0 ] ; 
for ( int i = 1 ; i < size ; i ++ ) { 
total += values [ i ] ; 
if ( values [ i ] < min ) { 
min = values [ i ] ; 
} else if ( values [ i ] > max ) { 
max = values [ i ] ; 
avg = total / size ; 
if ( size > 1 ) { 
double dv = values [ i ] - avg ; 
stddev += ( dv * dv ) ; 
stddev /= ( size - 1 ) ; 
stddev = Math . sqrt ( stddev ) ; 
statsValid = true ; 
} public static boolean isReplicatedRegion ( DistributedRegionMXBean distributedRegionMXBean ) 
if ( distributedRegionMXBean == null ) 
String type = distributedRegionMXBean . getRegionType ( ) ; 
return type != null && type . toUpperCase ( Locale . US ) . contains ( "REPLICATE" ) ; 
} public static DistributedRegionMXBean getRegionMBean ( String regionName , JMX jmx ) 
ObjectName on = getRegionObjectName ( regionName , jmx ) ; 
if ( on == null ) 
DistributedRegionMXBean region = jmx . newBean ( DistributedRegionMXBean . class , on ) ; 
return region ; 
} public static synchronized Pool getPoolForServer ( String serverName , JMX jmx ) 
throws InstanceNotFoundException 
Pool pool = PoolManager . find ( serverName ) ; 
PoolFactory poolFactory = PoolManager . createFactory ( ) ; 
ObjectName objectName = new ObjectName ( new StringBuilder ( "GemFire:type=Member,member=" ) . append ( serverName ) . toString ( ) ) ; 
String host = jmx . getAttribute ( objectName , "Host" ) ; 
if ( host == null || host . length ( ) == 0 ) 
host = lookupNetworkHost ( host ) ; 
String findJmxPort = new StringBuilder ( "GemFire:service=CacheServer,port=*,type=Member,member=" ) 
. append ( serverName ) . toString ( ) ; 
Set < ObjectName > objectNames = jmx . searchObjectNames ( findJmxPort ) ; 
if ( objectNames == null || objectNames . isEmpty ( ) ) 
ObjectName portObjectName = objectNames . iterator ( ) . next ( ) ; 
Integer port = jmx . getAttribute ( portObjectName , "Port" ) ; 
if ( port == null ) 
poolFactory = poolFactory . addServer ( host , port . intValue ( ) ) ; 
return poolFactory . create ( serverName ) ; 
catch ( InstanceNotFoundException e ) 
} public static synchronized Pool getPoolForLocator ( JMX jmx ) 
String locatorsPoolName = jmx . getHost ( ) + "[" + jmx . getPort ( ) + "]" ; 
Pool pool = PoolManager . find ( locatorsPoolName ) ; 
int port = getLocatorPort ( jmx ) ; 
poolFactory = poolFactory . addLocator ( jmx . getHost ( ) , port ) ; 
return poolFactory . create ( locatorsPoolName ) ; 
public static < K , V > Region < K , V > getRegion ( String regionName , JMX jmx ) 
Region < K , V > region = getClientCache ( jmx ) . getRegion ( regionName ) ; 
if ( region == null ) 
if ( isExistingRegionOnServer ( regionName , jmx ) ) 
region = ( Region < K , V > ) clientCache . createClientRegionFactory ( 
ClientRegionShortcut . PROXY ) . create ( regionName ) ; 
} public static Collection < Region < ? , ? > > listRootRegions ( String regionPattern , JMX jmx ) 
String regionJmxPattern = String . format ( "GemFire:service=Region,name=/%s,type=Distributed" , regionPattern ) ; 
Set < ObjectName > regionObjNameSet = jmx . searchObjectNames ( regionJmxPattern ) ; 
if ( regionObjNameSet == null || regionObjNameSet . isEmpty ( ) ) 
regionJmxPattern = String . format ( "GemFire:service=Region,name=\"/%s\",type=Distributed" , regionPattern ) ; 
regionObjNameSet = jmx . searchObjectNames ( regionJmxPattern ) ; 
regionObjNameSet = new TreeSet < ObjectName > ( regionObjNameSet ) ; 
ArrayList < Region < ? , ? > > regionSet = new ArrayList < Region < ? , ? > > ( regionObjNameSet . size ( ) ) ; 
String regionName = null ; 
for ( ObjectName regionObjectName : regionObjNameSet ) 
regionName = jmx . getAttribute ( regionObjectName , "Name" ) ; 
if ( regionName . startsWith ( "__" ) ) { 
regionSet . add ( getRegion ( regionName , jmx ) ) ; 
return regionSet ; 
} public static synchronized ClientCache getClientCache ( JMX jmx ) 
if ( clientCache == null || clientCache . isClosed ( ) ) 
clientCache = ClientCacheFactory . getAnyInstance ( ) ; 
catch ( CacheClosedException e ) 
clientCache = null ; 
if ( clientCache != null ) 
return clientCache ; 
String locatorNamePattern = "GemFire:type=Member,member=*" ; 
QueryExp queryExp = Query . eq ( Query . attr ( "Manager" ) , Query . value ( true ) ) ; 
Set < ObjectName > objectNames = jmx . searchObjectNames ( locatorNamePattern , 
queryExp ) ; 
ObjectName locatorJmxMgrObjName = objectNames . iterator ( ) . next ( ) ; 
String locatorMemberName = jmx . getAttribute ( locatorJmxMgrObjName , 
"Member" ) ; 
ObjectName locatorServiceObjName = new ObjectName ( String . format ( 
"GemFire:service=Locator,type=Member,member=%s" , 
locatorMemberName ) ) ; 
int port = jmx . getAttribute ( locatorServiceObjName , "Port" ) ; 
String host = jmx . getAttribute ( locatorJmxMgrObjName , "Host" ) ; 
clientCache = new ClientCacheFactory ( ) . addPoolLocator ( 
host , port ) 
. setPoolSubscriptionEnabled ( false ) 
. setPdxReadSerialized ( 
Boolean . valueOf ( 
System . getProperty ( "PdxReadSerialized" , "false" ) ) 
. booleanValue ( ) 
. create ( ) ; 
catch ( RuntimeException e ) 
} private static boolean isExistingRegionOnServer ( String regionName , JMX jmx ) 
String regionJmxPattern = String . format ( "GemFire:service=Region,name=/%s,type=Distributed" , regionName ) ; 
regionJmxPattern = String . format ( "GemFire:service=Region,name=\"/%s\",type=Distributed" , regionName ) ; 
return regionObjNameSet != null && ! regionObjNameSet . isEmpty ( ) ; 
} private static ObjectName getRegionObjectName ( String regionName , JMX jmx ) 
if ( regionObjNameSet == null ) 
return regionObjNameSet . iterator ( ) . next ( ) ; 
} public static MemberMXBean getMember ( String name , JMX jmx ) 
String pattern = "GemFire:type=Member,member=" + name ; 
Set < ObjectName > objectNames = jmx . searchObjectNames ( pattern ) ; 
ObjectName serverName = new ObjectName ( pattern ) ; 
return jmx . newBean ( MemberMXBean . class , serverName ) ; 
catch ( MalformedObjectNameException e ) 
} static DistributedSystemMXBean getDistributedSystemMXBean ( JMX jmx ) 
DistributedSystemMXBean system = jmx . newBean ( DistributedSystemMXBean . class , 
new ObjectName ( "GemFire:service=System,type=Distributed" ) ) ; 
return system ; 
} public static Collection < GatewayReceiverMXBean > listGatewayReceivers ( JMX jmx ) 
ObjectName [ ] objectNames = system . listGatewayReceiverObjectNames ( ) ; 
if ( objectNames == null ) 
GatewayReceiverMXBean gatewayReceiver = null ; 
ArrayList < GatewayReceiverMXBean > list = new ArrayList < GatewayReceiverMXBean > ( objectNames . length ) ; 
for ( ObjectName objectName : objectNames ) 
gatewayReceiver = jmx . newBean ( GatewayReceiverMXBean . class , objectName ) ; 
list . add ( gatewayReceiver ) ; 
} public static Collection < String > listHosts ( JMX jmx ) 
Set < ObjectName > objectNames = jmx . searchObjectNames ( "GemFire:type=Member,member=*" ) ; 
HashSet < String > hostLists = new HashSet < String > ( objectNames . size ( ) ) ; 
MemberMXBean memberMXBean = null ; 
memberMXBean = jmx . newBean ( MemberMXBean . class , objectName ) ; 
hostLists . add ( memberMXBean . getHost ( ) ) ; 
return hostLists ; 
} static synchronized String lookupNetworkHost ( String host ) 
if ( _bundle == null ) 
URL url = GemFireJmxClient . class . getResource ( hostPropFileName ) ; 
String filePath = null ; 
filePath = hostPropFileName ; 
filePath = url . toString ( ) ; 
. append ( filePath ) . toString ( ) ) ; 
_bundle = ResourceBundle . getBundle ( "host" ) ; 
. append ( hostPropFileName ) . toString ( ) ) ; 
String newHost = _bundle . getString ( host ) ; 
System . out . println ( new StringBuilder ( host ) . append ( "=" ) . append ( newHost ) . toString ( ) ) ; 
return newHost ; 
} public User getUSer ( String email ) 
ExampleFunctionService userService = appContext . getBean ( ExampleFunctionService . class ) ; 
return userService . findUserByEmail ( email ) ; 
appContext . close ( ) ; 
} public static boolean isErrorAndSendException ( ResultSender < Object > resultSender , Object data ) 
if ( data instanceof Throwable ) 
Throwable e = ( Throwable ) data ; 
resultSender . sendException ( e ) ; 
public static < T > Collection < T > exeWithResults ( Execution < ? , ? , ? > execution , Function < ? > function ) 
ResultCollector < ? , ? > resultCollector ; 
resultCollector = execution . execute ( function ) ; 
catch ( FunctionException e ) 
if ( e . getCause ( ) instanceof NullPointerException ) 
Object resultsObject = resultCollector . getResult ( ) ; 
Collection < Object > collectionResults = ( Collection < Object > ) resultsObject ; 
if ( collectionResults . isEmpty ( ) ) 
Collection < Object > list = new ArrayList < Object > ( collectionResults . size ( ) ) ; 
flatten ( collectionResults , list ) ; 
if ( list . isEmpty ( ) ) 
return ( Collection < T > ) list ; 
public static < T > void flatten ( Collection < Object > input , 
Collection < Object > flattenOutput ) 
if ( input == null || input . isEmpty ( ) || flattenOutput == null ) 
for ( Object inputObj : input ) 
if ( inputObj instanceof Exception ) 
throw ( Exception ) inputObj ; 
if ( inputObj == null ) 
if ( inputObj instanceof Collection ) 
flatten ( ( Collection < Object > ) inputObj , flattenOutput ) ; 
flattenOutput . add ( inputObj ) ; 
public static < T > Collection < T > collectResults ( ResultCollector < ? , ? > resultCollector ) 
if ( resultCollector == null ) 
Collection < Object > results = ( Collection ) resultCollector . getResult ( ) ; 
if ( results == null || results . isEmpty ( ) ) 
ArrayList < Object > output = new ArrayList < > ( 10 ) ; 
flatten ( results , output ) ; 
if ( output . isEmpty ( ) ) 
output . trimToSize ( ) ; 
return ( Collection ) output ; 
public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) 
throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException 
SelectResults < ReturnType > selectResults ; 
if ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) 
if ( params == null || params . length == 0 ) 
selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; 
selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; 
if ( selectResults == null || selectResults . isEmpty ( ) ) 
ArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; 
results . addAll ( selectResults . asList ( ) ) ; 
selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; 
selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; 
return selectResults ; 
} public static < K , V > CacheListenerBridge < K , V > forAfterPut ( Consumer < EntryEvent < K , V > > consumer ) 
return new CacheListenerBridge < K , V > ( consumer , null ) ; 
} public static < K , V > CacheListenerBridge < K , V > forAfterDelete ( Consumer < EntryEvent < K , V > > consumer ) 
return new CacheListenerBridge < K , V > ( null , consumer ) ; 
} private void updateRemoveConsumer ( EntryEvent < K , V > event ) 
if ( this . removeConsumers == null || this . removeConsumers . isEmpty ( ) ) 
for ( Consumer < EntryEvent < K , V > > removeConsumer : this . removeConsumers ) 
removeConsumer . accept ( event ) ; 
} private void updatePutConsumer ( EntryEvent < K , V > event ) 
if ( this . putConsumers == null || this . putConsumers . isEmpty ( ) ) 
for ( Consumer < EntryEvent < K , V > > putConsumer : putConsumers ) 
putConsumer . accept ( event ) ; 
} @ PostMapping ( path = "{region}/{type}/{key}" , produces = "application/json" ) 
public String putEntry ( @ PathVariable String region , @ PathVariable String type , @ PathVariable String key , @ RequestBody String value ) 
if ( region == null || region . length ( ) == 0 || key == null || value == null ) 
if ( type == null || type . length ( ) == 0 ) 
Region < String , Object > gemRegion = geode . getRegion ( region ) ; 
Class < ? > clz = Class . forName ( type ) ; 
Object obj = gson . fromJson ( value , clz ) ; 
Object response = gemRegion . put ( key , obj ) ; 
return gson . toJson ( response ) ; 
} @ DeleteMapping ( path = "{regionName}/{key}" , produces = "application/json" ) 
public String delete ( @ PathVariable String regionName , @ PathVariable String key ) 
Region < String , PdxInstance > region = this . geode . getRegion ( regionName ) ; 
PdxInstance pdx = region . remove ( key ) ; 
if ( pdx == null ) 
return JSONFormatter . toJSON ( pdx ) ; 
} @ GetMapping ( path = "{region}/{key}" , produces = "application/json" ) 
String getValueByKey ( @ PathVariable String region , @ PathVariable String key ) 
if ( region == null || region . length ( ) == 0 || key == null ) 
Object value = gemRegion . get ( key ) ; 
return gson . toJson ( value ) ; 
catch ( ServerOperationException serverError ) 
Throwable cause = serverError . getRootCause ( ) ; 
if ( cause instanceof RegionDestroyedException ) 
throw new DataServiceSystemException ( serverError . getMessage ( ) , serverError ) ; 
throw new DataServiceSystemException ( e . getMessage ( ) , e ) ; 
} @ ExceptionHandler ( Exception . class ) 
private DataError handleException ( HttpServletRequest request , HttpServletResponse response , Exception e ) 
return faultAgent . handleException ( request , response , e ) ; 
public void close ( ) 
if ( cqQuery != null ) 
try { cqQuery . close ( ) ; } catch ( Exception e ) { Debugger . println ( e . getMessage ( ) ) ; } 
} public OnRegionFilterKeyFacts [ ] getOnRegionFilterKeyFacts ( ) 
if ( onRegionFilterKeyFacts == null ) 
return Arrays . copyOf ( onRegionFilterKeyFacts , onRegionFilterKeyFacts . length ) ; 
public void execute ( FunctionContext < Object > functionContext ) 
ResultSender < Object > sender = functionContext . getResultSender ( ) ; 
Cache cache = CacheFactory . getAnyInstance ( ) ; 
Logger logWriter = LogManager . getLogger ( getClass ( ) ) ; 
String [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; 
if ( args == null || args . length != 2 ) 
String extensionArg = args [ 0 ] ; 
if ( extensionArg == null || extensionArg . length ( ) == 0 ) 
ExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; 
String regionName = args [ 1 ] ; 
Region < Object , Object > region = cache . getRegion ( regionName ) ; 
sender . lastResult ( null ) ; 
File file = new File ( new StringBuilder ( directoryPath ) . append ( "/" ) . append ( regionName ) 
. append ( "." ) . append ( extensionArg ) . toString ( ) ) ; 
String serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; 
switch ( extension ) 
case gfd : 
new GfdExportFunction ( ) . exportRegion ( region ) ; 
Serializable content = readContent ( file , extension , logWriter ) ; 
Serializable [ ] arrayResults = { serverName , content , file . getAbsolutePath ( ) } ; 
sender . lastResult ( arrayResults ) ; 
String stackTrace = Debugger . stackTrace ( e ) ; 
logWriter . error ( stackTrace ) ; 
throw new FunctionException ( stackTrace ) ; 
} private Serializable readContent ( File file , ExportFileType exportFileType , Logger logWriter ) 
String filePath = file . getAbsolutePath ( ) ; 
switch ( exportFileType ) 
case gfd : return IO . readBinaryFile ( file ) ; 
case json : return IO . readFile ( file . getAbsolutePath ( ) , StandardCharsets . UTF_8 ) ; 
} public UserProfileDetails findUserProfileDetailsByUserName ( String userName ) 
throws UsernameNotFoundException 
UserDetails user = this . loadUserByUsername ( userName ) ; 
return ( UserProfileDetails ) user ; 
} public int compareTo ( Object aOther ) 
FunctionAttribute other = ( FunctionAttribute ) aOther ; 
return other . getName ( ) . compareTo ( this . getName ( ) ) ; 
} public static int size ( Region < ? , ? > region ) 
Set < ? > set = region . keySetOnServer ( ) ; 
if ( set == null || set . isEmpty ( ) ) 
return set . size ( ) ; 
public < ReturnType > Collection < ReturnType > query ( String query , Object ... params ) 
return Querier . query ( query , params ) ; 
} public static Set < String > listHosts ( JMX jmx ) 
Set < ObjectName > memberObjects = jmx . searchObjectNames ( "GemFire:type=Member,member=*" ) ; 
if ( memberObjects == null || memberObjects . isEmpty ( ) ) 
HashSet < String > hostList = new HashSet < String > ( memberObjects . size ( ) ) ; 
MemberMXBean bean = null ; 
for ( ObjectName objectName : memberObjects ) 
bean = jmx . newBean ( MemberMXBean . class , objectName ) ; 
hostList . add ( bean . getHost ( ) ) ; 
catch ( UndeclaredThrowableException e ) 
return hostList ; 
} public static boolean checkMemberStatus ( String serverName , JMX jmx ) 
ObjectName objectName = new ObjectName ( "GemFire:type=Member,member=" + serverName ) ; 
String status = ( String ) jmx . invoke ( objectName , "status" , null , null ) ; 
boolean isOnline = status != null && status . contains ( "online" ) ; 
return isOnline ; 
public void execute ( FunctionContext functionContext ) 
if ( ! ( functionContext instanceof RegionFunctionContext ) ) 
Object args = functionContext . getArguments ( ) ; 
if ( args == null ) 
TextPageCriteria criteria = null ; 
if ( args instanceof PdxInstance ) 
PdxInstance pdxInstance = ( PdxInstance ) args ; 
criteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; 
catch ( PdxSerializationException e ) 
criteria = ( TextPageCriteria ) args ; 
Region < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; 
Region < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; 
GeodePagination pagination = new GeodePagination ( ) ; 
TextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; 
geodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; 
Collection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , 
criteria . isSortDescending ( ) , 
criteria . getBeginIndex ( ) , 
( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; 
if ( collection == null ) 
functionContext . getResultSender ( ) . lastResult ( null ) ; 
PagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; 
functionContext . getResultSender ( ) . lastResult ( pageCollection ) ; 
Logger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; 
logger . error ( Debugger . stackTrace ( e ) ) ; 
public boolean accept ( Entry < Object , Object > entry ) 
return keys != null && keys . contains ( entry . getKey ( ) ) ; 
} public static String getAppName ( ResourceInst [ ] resources ) 
if ( resources == null || resources . length == 0 ) 
ResourceType rt = null ; 
for ( ResourceInst resourceInst : resources ) 
if ( resourceInst == null ) 
rt = resourceInst . getType ( ) ; 
if ( rt == null ) 
if ( ! "CacheServerStats" . equals ( rt . getName ( ) ) ) 
return resourceInst . getName ( ) ; 
} protected static void constructSecurity ( Properties props ) throws IOException 
props . setProperty ( "security-client-auth-init" , GeodeConfigAuthInitialize . class . getName ( ) + ".create" ) ; 
File sslFile = saveEnvFile ( GeodeConfigConstants . SSL_KEYSTORE_CLASSPATH_FILE_PROP ) ; 
System . out . println ( "sslFile:" + sslFile ) ; 
File sslTrustStoreFile = saveEnvFile ( GeodeConfigConstants . SSL_TRUSTSTORE_CLASSPATH_FILE_PROP ) ; 
String sslTrustStoreFilePath = "" ; 
if ( sslTrustStoreFile != null ) 
sslTrustStoreFilePath = sslTrustStoreFile . getAbsolutePath ( ) ; 
props . setProperty ( "ssl-keystore" , ( sslFile != null ) ? sslFile . getAbsolutePath ( ) : "" ) ; 
props . setProperty ( "ssl-keystore-password" , Config . getPropertyEnv ( "ssl-keystore-password" , "" ) ) ; 
props . setProperty ( "ssl-truststore" , sslTrustStoreFilePath ) ; 
props . setProperty ( "ssl-protocols" , Config . getPropertyEnv ( "ssl-protocols" , "" ) ) ; 
props . setProperty ( "ssl-truststore-password" , Config . getPropertyEnv ( "ssl-truststore-password" , "" ) ) ; 
props . setProperty ( "ssl-keystore-type" , Config . getPropertyEnv ( "ssl-keystore-type" , "" ) ) ; 
props . setProperty ( "ssl-ciphers" , Config . getPropertyEnv ( "ssl-ciphers" , "" ) ) ; 
props . setProperty ( "ssl-require-authentication" , Config . getPropertyEnv ( "ssl-require-authentication" , "" ) ) ; 
props . setProperty ( "ssl-enabled-components" , Config . getPropertyEnv ( "ssl-enabled-components" , "" ) ) ; 
} static PdxSerializer createPdxSerializer ( String pdxSerializerClassNm , String ... classPatterns ) 
Object [ ] initArgs = { classPatterns } ; 
return ClassPath . newInstance ( pdxSerializerClassNm , initArgs ) ; 
} public < K , V > Map < K , V > readSearchResultsByPage ( TextPageCriteria criteria , int pageNumber ) 
GeodeLuceneSearch search = new GeodeLuceneSearch ( this . clientCache ) ; 
Region < String , Collection < ? > > pageRegion = this . getRegion ( criteria . getPageRegionName ( ) ) ; 
Region < K , V > region = this . getRegion ( criteria . getRegionName ( ) ) ; 
return search . readResultsByPage ( criteria , pageNumber , region , pageRegion ) ; 
} public Collection < String > clearSearchResultsByPage ( TextPageCriteria criteria ) 
return search . clearSearchResultsByPage ( criteria , this . getRegion ( criteria . getPageRegionName ( ) ) ) ; 
private < K , V > Region < K , V > createRegion ( String regionName ) 
if ( regionName . startsWith ( "/" ) ) 
regionName = regionName . substring ( 1 ) ; 
CacheListenerBridge < K , V > listener = ( CacheListenerBridge ) this . listenerMap . get ( regionName ) ; 
if ( listener != null ) 
ClientRegionFactory < K , V > listenerRegionFactory = null ; 
if ( this . cachingProxy ) 
listenerRegionFactory = this . clientCache . createClientRegionFactory ( ClientRegionShortcut . CACHING_PROXY ) ; 
listenerRegionFactory = this . clientCache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) ; 
listenerRegionFactory . addCacheListener ( ( CacheListener ) listener ) ; 
Region < K , V > region = listenerRegionFactory . create ( regionName ) ; 
region . registerInterestRegex ( ".*" ) ; 
return ( Region < K , V > ) this . cachingRegionfactory . create ( regionName ) ; 
return ( Region < K , V > ) this . proxyRegionfactory . create ( regionName ) ; 
public < K , V > Region < K , V > getRegion ( String regionName ) 
if ( regionName == null || regionName . length ( ) == 0 ) 
Region < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; 
if ( region != null ) 
return ( Region < K , V > ) region ; 
region = ( Region < K , V > ) this . createRegion ( regionName ) ; 
if ( cachingProxy ) 
public static < K , V > Region < K , V > getRegion ( ClientCache clientCache , String regionName ) 
region = ( Region < K , V > ) clientCache 
. createClientRegionFactory ( ClientRegionShortcut . PROXY ) . create ( regionName ) ; 
} public < T > BlockingQueue < T > registerCq ( String cqName , String oql ) 
QueryService queryService = this . clientCache . getQueryService ( ) ; 
CqAttributesFactory cqf = new CqAttributesFactory ( ) ; 
CqQueueListener < T > cqListener = new CqQueueListener < T > ( ) ; 
cqf . addCqListener ( cqListener ) ; 
CqAttributes cqa = cqf . create ( ) ; 
CqQuery cqQuery = queryService . newCq ( cqName , oql , cqa ) ; 
cqListener . setCqQuery ( cqQuery ) ; 
cqQuery . execute ( ) ; 
return cqListener ; 
catch ( CqException | CqClosedException | RegionNotFoundException | QueryInvalidException | CqExistsException e ) 
throw new nyla . solutions . core . exception . SystemException 
public < K , V > void registerAfterPut ( String regionName , Consumer < EntryEvent < K , V > > consumer ) 
if ( listener == null ) 
listener = CacheListenerBridge . forAfterPut ( consumer ) ; 
listener . addAfterPutListener ( consumer ) ; 
this . listenerMap . put ( regionName , listener ) ; 
public < K , V > void registerAfterDelete ( String regionName , Consumer < EntryEvent < K , V > > consumer ) 
listener = CacheListenerBridge . forAfterDelete ( consumer ) ; 
listener . addAfterDeleteListener ( consumer ) ; 
} public void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) 
if ( sourceChecksumMap == null ) 
if ( targetMap != null && ! targetMap . isEmpty ( ) ) 
this . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; 
if ( targetMap == null ) 
this . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; 
BigInteger targetBi = null ; 
BigInteger sourceBi = null ; 
for ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) 
targetBi = targetMap . get ( entrySource . getKey ( ) ) ; 
sourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; 
if ( targetBi == null ) 
keysMissingOnTarget . add ( entrySource . getKey ( ) ) ; 
else if ( ! targetBi . equals ( sourceBi ) ) 
keysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; 
Set < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; 
for ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) 
if ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) 
keysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; 
} public void execute ( FunctionContext < Object > fc ) 
ResultSender < Object > rs = fc . getResultSender ( ) ; 
boolean didExport = false ; 
if ( fc instanceof RegionFunctionContext ) 
didExport = exportOnRegion ( ( RegionFunctionContext ) fc ) ; 
didExport = exportAllRegions ( fc ) ; 
rs . lastResult ( didExport ) ; 
e . printStackTrace ( pw ) ; 
LogManager . getLogger ( getClass ( ) ) . error ( sw . toString ( ) ) ; 
rs . sendException ( e ) ; 
} private boolean exportAllRegions ( FunctionContext < Object > fc ) 
String [ ] args = ( String [ ] ) fc . getArguments ( ) ; 
if ( args == null || args . length == 0 ) 
String regionName = args [ 0 ] ; 
return exportRegion ( region ) ; 
} private boolean exportOnRegion ( RegionFunctionContext rfc ) 
Region < Object , Object > region = rfc . getDataSet ( ) ; 
} private boolean exportRegion ( Region < Object , Object > region ) 
if ( PartitionRegionHelper . isPartitionedRegion ( region ) ) 
region = PartitionRegionHelper . getLocalData ( region ) ; 
mapper . getSerializerProvider ( ) . setNullKeySerializer ( new DefaultNullKeySerializer ( ) ) ; 
mapper . getSerializerProvider ( ) . setDefaultKeySerializer ( new DefaultKeySerializer ( ) ) ; 
Set < Object > keySet = region . keySet ( ) ; 
if ( keySet == null || keySet . isEmpty ( ) ) 
String regionName = region . getName ( ) ; 
Collection < SerializationRegionWrapper > collection = new ArrayList < SerializationRegionWrapper > ( keySet . size ( ) ) ; 
SerializationRegionWrapper serializationWrapper = null ; 
String keyClassName = null ; 
String valueClassName = null ; 
for ( Object key : keySet ) 
keyClassName = key . getClass ( ) . getName ( ) ; 
value = region . get ( key ) ; 
valueClassName = value . getClass ( ) . getName ( ) ; 
serializationWrapper = new SerializationRegionWrapper ( key , keyClassName , value , valueClassName ) ; 
collection . add ( serializationWrapper ) ; 
File resultFile = new File ( new StringBuilder ( this . directoryPath ) 
. append ( fileSeparator ) . append ( regionName ) . append ( suffix ) . toString ( ) ) ; 
mapper . writeValue ( resultFile , collection ) ; 
} protected String getSecurityPassword ( ) 
String password = Config . getProperty ( PASSWORD , Config . getProperty ( "SECURITY_PASSWORD" , "" ) ) ; 
return password ; 
} protected String getSecurityUserName ( ) 
String username = Config . getProperty ( USER_NAME , Config . getProperty ( "SECURITY_USERNAME" , "" ) ) ; 
return username ; 
} private static boolean mustInsert ( int nextIdx , long [ ] valueTimeStamps , 
long tsAtInsertPoint ) { 
return ( nextIdx < valueTimeStamps . length ) 
&& ( valueTimeStamps [ nextIdx ] <= tsAtInsertPoint ) ; 
} private static boolean isClosest ( long ts , long [ ] timeStamps , int curIdx ) { 
if ( curIdx >= ( timeStamps . length - 1 ) ) { 
if ( ts == timeStamps [ curIdx ] ) { 
return closer ( ts , timeStamps [ curIdx ] , timeStamps [ curIdx + 1 ] ) ; 
} protected int getMemoryUsed ( ) { 
for ( SimpleValue value : values ) { 
result += value . getMemoryUsed ( ) ; 
} protected boolean addValueSample ( int statOffset , long statDeltaBits ) { 
if ( this . values != null && this . values [ statOffset ] != null ) { 
this . values [ statOffset ] . prepareNextBits ( statDeltaBits ) ; 
} protected boolean close ( ) { 
if ( isLoaded ( ) ) { 
value . shrink ( ) ; 
} public StatValue getStatValue ( String name ) { 
StatValue result = null ; 
StatDescriptor desc = getType ( ) . getStat ( name ) ; 
if ( desc != null ) { 
result = values [ desc . getOffset ( ) ] ; 
} public boolean update ( boolean doReset ) throws IOException 
if ( ! this . updateOK ) 
if ( doReset ) 
this . dataIn . reset ( ) ; 
int updateTokenCount = 0 ; 
while ( this . readToken ( ) ) 
updateTokenCount ++ ; 
return updateTokenCount != 0 ; 
} public void close ( ) throws IOException 
if ( ! this . closed ) 
this . closed = true ; 
this . is . close ( ) ; 
this . dataIn . close ( ) ; 
this . is = null ; 
this . dataIn = null ; 
int typeCount = 0 ; 
if ( this . resourceTypeTable != null ) 
for ( int i = 0 ; i < this . resourceTypeTable . length ; i ++ ) 
if ( this . resourceTypeTable [ i ] != null ) 
if ( this . resourceTypeTable [ i ] . close ( ) ) 
this . resourceTypeTable [ i ] = null ; 
typeCount ++ ; 
ResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; 
typeCount = 0 ; 
for ( ResourceType aResourceTypeTable : this . resourceTypeTable ) 
if ( aResourceTypeTable != null ) 
newTypeTable [ typeCount ] = aResourceTypeTable ; 
this . resourceTypeTable = newTypeTable ; 
if ( this . resourceInstTable != null ) 
int instCount = 0 ; 
for ( int i = 0 ; i < this . resourceInstTable . length ; i ++ ) 
if ( this . resourceInstTable [ i ] != null ) 
if ( this . resourceInstTable [ i ] . close ( ) ) 
this . resourceInstTable [ i ] = null ; 
instCount ++ ; 
ResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; 
instCount = 0 ; 
for ( ResourceInst aResourceInstTable : this . resourceInstTable ) 
if ( aResourceInstTable != null ) 
newInstTable [ instCount ] = aResourceInstTable ; 
this . resourceInstTable = newInstTable ; 
this . resourceInstSize = instCount ; 
this . timeSeries . shrink ( ) ; 
this . filters = null ; 
} public static void toCvsFiles ( File directory ) 
Set < File > statsFiles = IO . listFileRecursive ( directory , "*.gfs" ) ; 
for ( File archiveFile : statsFiles ) 
GfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; 
reader . dumpCsvFiles ( ) ; 
} public static void main ( String [ ] args ) 
File archiveFile , csvFile ; 
if ( args . length < 1 ) 
archiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; 
if ( archiveFile . isDirectory ( ) ) 
toCvsFiles ( archiveFile ) ; 
if ( args . length < 2 ) 
String typeName = args [ 1 ] ; 
csvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; 
GenericCsvStatsVisitor visitor = null ; 
if ( args . length > 3 ) 
String [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; 
visitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; 
visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; 
System . out . println ( "accepting" ) ; 
} public synchronized static JMX reconnect ( ) 
ClientCache cache = null ; 
cache = ClientCacheFactory . getAnyInstance ( ) ; 
if ( cache != null && ! cache . isClosed ( ) ) 
cache . close ( ) ; 
if ( jmx != null ) 
jmx . dispose ( ) ; 
jmx = null ; 
return getJmx ( ) ; 
} public static synchronized JMX reconnectJMX ( String locatorHost , int locatorPort ) 
SingletonGemFireJmx . setLocatorJmxHost ( locatorHost ) ; 
SingletonGemFireJmx . setLocatorPort ( locatorPort ) ; 
} public synchronized static JMX getJmx ( ) 
if ( jmx == null ) 
jmx = JMX . connect ( locatorJmxHost , locatorJmxPort ) ; 
return jmx ; 
} public static int stopMembersOnHost ( String hostName ) 
JMX jmx = SingletonGemFireJmx . getJmx ( ) ; 
String objectNamePattern = "GemFire:type=Member,member=*" ; 
QueryExp queryExp = null ; 
ValueExp [ ] values = null ; 
InetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; 
InetAddress address = null ; 
if ( addresses != null ) 
values = new ValueExp [ addresses . length ] ; 
for ( int i = 0 ; i < addresses . length ; i ++ ) 
address = addresses [ i ] ; 
values [ i ] = Query . value ( address . getHostAddress ( ) ) ; 
catch ( UnknownHostException e ) 
Debugger . println ( e . getMessage ( ) ) ; 
queryExp = Query . or ( Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) , 
Query . in ( Query . attr ( "Host" ) , values ) ) ; 
queryExp = Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) ; 
Set < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; 
if ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) 
int memberCount = memberObjectNames . size ( ) ; 
MemberMXBean member = null ; 
Collection < String > locators = new ArrayList < String > ( ) ; 
for ( ObjectName objectName : memberObjectNames ) 
member = GemFireJmxClient . getMember ( objectName . getKeyProperty ( "member" ) , SingletonGemFireJmx . getJmx ( ) ) ; 
if ( member . isLocator ( ) ) 
locators . add ( member . getName ( ) ) ; 
shutDownMember ( member . getName ( ) ) ; 
for ( String locatorName : locators ) 
shutDownMember ( locatorName ) ; 
return memberCount ; 
} public static void shutDownMember ( String name ) 
ObjectName serverName = new ObjectName ( "GemFire:type=Member,member=" + name ) ; 
MemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; 
bean . shutDownMember ( ) ; 
while ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) 
Thread . sleep ( shutDownDelay ) ; 
System . out . println ( e . getMessage ( ) ) ; 
} public static void stopLocator ( JMX jmx , String locatorName ) 
ObjectName objectName = new ObjectName ( "GemFire:type=Member,member=" + locatorName ) ; 
MemberMXBean bean = jmx . newBean ( MemberMXBean . class , objectName ) ; 
} public static String [ ] shutDown ( JMX jmx ) 
DistributedSystemMXBean bean = toDistributeSystem ( jmx ) ; 
return bean . shutDownAllMembers ( ) ; 
} private static DistributedSystemMXBean toDistributeSystem ( JMX jmx ) throws MalformedObjectNameException 
ObjectName objectName = new ObjectName ( "GemFire:service=System,type=Distributed" ) ; 
DistributedSystemMXBean bean = jmx . newBean ( DistributedSystemMXBean . class , objectName ) ; 
return bean ; 
} public static void shutDownRedundancyZone ( String redundancyZone ) 
if ( redundancyZone == null || redundancyZone . length ( ) == 0 ) 
QueryExp exp = Query . eq ( Query . attr ( "RedundancyZone" ) , Query . value ( redundancyZone ) ) ; 
Collection < ObjectName > memberObjectNames = SingletonGemFireJmx . getJmx ( ) . searchObjectNames ( objectNamePattern , exp ) ; 
GemFireMgmt . shutDownMember ( objectName . getKeyProperty ( "member" ) ) ; 
public < K , V > List < String > storePaginationMap ( String id , int pageSize , 
Region < String , Collection < K > > pageKeysRegion , 
List < Map . Entry < K , V > > results ) 
List < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; 
int pageIndex = 1 ; 
ArrayList < String > keys = new ArrayList < String > ( pageSize ) ; 
for ( Collection < K > page : pagesCollection ) 
key = toPageKey ( id , pageIndex ++ ) ; 
pageKeysRegion . put ( key , page ) ; 
keys . trimToSize ( ) ; 
} public static String toPageKey ( String id , int pageNumber ) 
return new StringBuilder ( ) . append ( id ) . append ( "-" ) . append ( pageNumber ) . toString ( ) ; 
} public List < String > storePagination ( String sanId , int pageSize , 
Map < String , Collection < ? > > pageKeysRegion , 
Collection < String > keys ) 
if ( keys == null || keys . isEmpty ( ) ) 
List < Collection < String > > pagesCollection = Organizer . toPages ( keys , pageSize ) ; 
ArrayList < String > pageKeys = new ArrayList < String > ( 10 ) ; 
for ( Collection < String > page : pagesCollection ) 
key = new StringBuilder ( ) . append ( sanId ) . append ( "-" ) . append ( pageIndex ++ ) . toString ( ) ; 
pageKeys . add ( key ) ; 
pageKeys . trimToSize ( ) ; 
return pageKeys ; 
} public < K , V > Map < K , V > readResultsByPage ( TextPageCriteria criteria , int pageNumber , Region < K , V > region , Region < String , Collection < ? > > pageRegion ) 
if ( pageRegion == null ) 
Collection < ? > regionKeys = pageRegion . get ( criteria . toPageKey ( pageNumber ) ) ; 
if ( regionKeys == null || regionKeys . isEmpty ( ) ) 
return region . getAll ( regionKeys ) ; 
boolean results = false ; 
results = importOnRegion ( ( RegionFunctionContext ) fc ) ; 
this . importRegion ( regionName ) ; 
rs . lastResult ( results ) ; 
LogManager . getLogger ( getClass ( ) ) . error ( stackTrace ) ; 
} private boolean importRegion ( String regionName ) throws Exception 
return importRegion ( region ) ; 
} protected boolean importOnRegion ( RegionFunctionContext rfc ) throws Exception 
} private boolean importRegion ( Region < Object , Object > region ) 
File file = DataOpsSecretary . determineFile ( ExportFileType . gfd , region . getName ( ) ) ; 
region . getSnapshotService ( ) . load ( file , SnapshotFormat . GEMFIRE ) ; 
} public static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) 
if ( remoteLocators == null || remoteLocators . length ( ) == 0 ) 
if ( remoteLocators . equalsIgnoreCase ( locators ) ) 
String [ ] remoteLocatorsArray = remoteLocators . split ( "," ) ; 
if ( locators == null || locators . length ( ) == 0 ) 
String [ ] locatorsArray = locators . split ( "," ) ; 
String remoteLocatorHost , locatorHost ; 
int remoteLocatorPort , locatorPort ; 
for ( String remoteLocator : remoteLocatorsArray ) 
if ( remoteLocator == null || remoteLocator . length ( ) == 0 ) 
for ( String locator : locatorsArray ) 
if ( locator == null || locator . length ( ) == 0 ) 
remoteLocatorHost = parseLocatorHost ( remoteLocator ) ; 
locatorHost = parseLocatorHost ( locator ) ; 
remoteLocatorPort = parseLocatorPort ( remoteLocator ) ; 
locatorPort = parseLocatorPort ( locator ) ; 
if ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) 
&& remoteLocatorPort == locatorPort ) 
catch ( NumberFormatException e ) 
catch ( IllegalArgumentException e ) 
} private static String parseLocatorHost ( String locator ) 
int i = locator . indexOf ( "[" ) ; 
return locator . substring ( 0 , i ) . trim ( ) ; 
return locator . trim ( ) ; 
} private static int parseLocatorPort ( String locator ) 
int start = locator . indexOf ( "[" ) ; 
String text = null ; 
if ( start > 0 ) 
String results = locator . substring ( start + 1 ) ; 
int end = results . indexOf ( "]" ) ; 
if ( end > 0 ) 
text = results . substring ( 0 , end ) . trim ( ) ; 
return Integer . parseInt ( text ) ; 
if ( ! outDirectory . exists ( ) ) 
try ( SnapshotRecordReader reader = new SnapshotRecordReader ( inFile ) ) 
SnapshotRecord record = null ; 
int batchCount = 1 ; 
File out = createFile ( batchCount ++ ) ; 
SnapshotRecordWriter writer = null ; 
writer = new SnapshotRecordWriter ( out , regionName ) ; 
while ( ( record = reader . readSnapshotRecord ( ) ) != null ) 
writer . writeSnapshotEntry ( record ) ; 
if ( cnt >= batchSize ) 
out = createFile ( batchCount ++ ) ; 
if ( writer != null ) 
catch ( ClassNotFoundException | IOException e ) 
} private Class < ? > forClassName ( String className ) 
throws ClassNotFoundException 
if ( className == null || className . length ( ) == 0 ) 
return Class . forName ( className ) ; 
int result = 4 + 8 + 8 + 8 + 4 + 4 + 4 ; 
if ( intervals != null ) { 
result += 4 * intervals . length ; 
for ( int i = 0 ; i <= intervalIdx ; i ++ ) { 
result += intervals [ i ] . getMemoryUsed ( ) ; 
} public double [ ] getValuesEx ( int typeCode , int samplesToSkip , 
int resultSize ) { 
int firstInterval = 0 ; 
while ( samplesToSkip > 0 
&& firstInterval <= intervalIdx 
&& intervals [ firstInterval ] . getSampleCount ( ) <= samplesToSkip ) { 
samplesToSkip -= intervals [ firstInterval ] . getSampleCount ( ) ; 
firstInterval ++ ; 
for ( int i = firstInterval ; i <= intervalIdx ; i ++ ) { 
idx += intervals [ i ] . fill ( result , idx , typeCode , samplesToSkip ) ; 
samplesToSkip = 0 ; 
if ( currentCount != 0 ) { 
idx += BitInterval . create ( currentStartBits , currentInterval , 
currentCount ) . fill ( result , idx , typeCode , samplesToSkip ) ; 
if ( idx != resultSize ) { 
} void shrink ( ) { 
int currentSize = intervalIdx + 1 ; 
if ( currentSize < intervals . length ) { 
BitInterval [ ] tmp = new BitInterval [ currentSize ] ; 
System . arraycopy ( intervals , 0 , tmp , 0 , currentSize ) ; 
intervals = tmp ; 
didExport = exportRegion ( region ) ; 
didExport = false ; 
FunctionException functionException = new FunctionException ( stackTrace ) ; 
rs . sendException ( functionException ) ; 
throw functionException ; 
} protected boolean exportRegion ( Region < Object , Object > region ) 
Logger logger = LogManager . getLogger ( getClass ( ) ) ; 
File resultFile = DataOpsSecretary . determineFile ( ExportFileType . gfd , regionName ) ; 
boolean wasDeleted = resultFile . delete ( ) ; 
logger . info ( "delete:" + wasDeleted ) ; 
RegionSnapshotService < ? , ? > regionSnapshotService = region . getSnapshotService ( ) ; 
SnapshotOptionsImpl < ? , ? > options = ( SnapshotOptionsImpl < ? , ? > ) regionSnapshotService . createOptions ( ) ; 
options . setParallelMode ( true ) ; 
regionSnapshotService . save ( resultFile , SnapshotFormat . GEMFIRE ) ; 
} public void execute ( FunctionContext < String [ ] > fc ) 
String [ ] args = fc . getArguments ( ) ; 
didExport = this . exportRegion ( ( ( RegionFunctionContext ) fc ) . getDataSet ( ) , 
Organizer . at ( 0 , args ) ) ; 
didExport = exportRegionByArg ( fc ) ; 
} private boolean exportRegionByArg ( FunctionContext < String [ ] > fc ) 
String regionName = Organizer . at ( 0 , args ) ; 
return exportRegion ( region , Organizer . at ( 1 , args ) ) ; 
} public Collection < String > saveSearchResultsWithPageKeys ( TextPageCriteria criteria , Region < String , Collection < ? > > pageKeysRegion ) 
if ( criteria == null ) 
if ( criteria . getQuery ( ) == null || criteria . getQuery ( ) . length ( ) == 0 ) 
if ( criteria . getIndexName ( ) == null || criteria . getIndexName ( ) . length ( ) == 0 ) 
if ( criteria . getId ( ) == null || criteria . getId ( ) . length ( ) == 0 ) 
if ( criteria . getDefaultField ( ) == null || criteria . getDefaultField ( ) . length ( ) == 0 ) 
LuceneQuery < Object , Object > luceneQuery = luceneService . createLuceneQueryFactory ( ) 
. create ( criteria . getIndexName ( ) , 
criteria . getRegionName ( ) , 
criteria . getQuery ( ) , criteria . getDefaultField ( ) ) ; 
List < LuceneResultStruct < Object , Object > > list = luceneQuery . findResults ( ) ; 
luceneQuery . findPages ( ) ; 
if ( list == null || list . isEmpty ( ) ) 
String sortField = criteria . getSortField ( ) ; 
BeanComparator beanComparator = null ; 
Collection < Map . Entry < Object , Object > > results = null ; 
if ( sortField != null && sortField . trim ( ) . length ( ) > 0 ) 
beanComparator = new BeanComparator ( sortField , criteria . isSortDescending ( ) ) ; 
Collection < Map . Entry < Object , Object > > set = new TreeSet < Map . Entry < Object , Object > > ( beanComparator ) ; 
list . parallelStream ( ) . forEach ( e -> set . add ( new MapEntry < Object , Object > ( e . getKey ( ) , e . getValue ( ) ) ) ) ; 
results = set ; 
results = list . stream ( ) . map ( e -> new MapEntry < > ( e . getKey ( ) , e . getValue ( ) ) ) . collect ( Collectors . toList ( ) ) ; 
List < Collection < Object > > pagesCollection = Organizer . toKeyPages ( results , criteria . getEndIndex ( ) - criteria . getBeginIndex ( ) ) ; 
int pageIndex = 0 ; 
ArrayList < String > keys = new ArrayList < String > ( 10 ) ; 
for ( Collection < Object > page : pagesCollection ) 
key = new StringBuilder ( ) . append ( criteria . getId ( ) ) . append ( "-" ) . append ( pageIndex ++ ) . toString ( ) ; 
catch ( LuceneQueryException e ) 
} public Collection < String > clearSearchResultsByPage ( TextPageCriteria criteria , Region < String , Collection < ? > > pageRegion ) 
pageRegion . removeAll ( pageKeys ) ; 
public < T > Collection < T > search ( String indexName , String regionName , String queryString , String defaultField ) 
Region < ? , ? > region = GeodeClient . connect ( ) . getRegion ( regionName ) ; 
String [ ] args = { indexName , regionName , queryString , defaultField } ; 
return GemFireIO . exeWithResults ( FunctionService . onRegion ( region ) . setArguments ( args ) . setArguments ( args ) , new SimpleLuceneSearchFunction ( ) ) ; 
results = importAllRegions ( fc ) ; 
} private boolean importAllRegions ( FunctionContext < Object > fc ) throws Exception 
if ( args == null || args . length == 0 ) { 
JsonNode node , keyNode , valueNode , keyClassName , valueClassName ; 
Object key , value ; 
String filePath = new StringBuilder ( this . directoryPath ) 
. append ( fileSeparator ) . append ( region . getName ( ) ) . append ( suffix ) 
File file = new File ( filePath ) ; 
LogManager . getLogger ( getClass ( ) ) 
try ( Reader reader = Files . newBufferedReader ( file . toPath ( ) , StandardCharsets . UTF_8 ) ) 
JsonNode tree = mapper . readTree ( reader ) ; 
Iterator < JsonNode > children = tree . elements ( ) ; 
if ( children == null || ! children . hasNext ( ) ) { 
while ( children . hasNext ( ) ) 
node = children . next ( ) ; 
keyNode = node . get ( "key" ) ; 
valueNode = node . get ( "value" ) ; 
keyClassName = node . get ( "keyClassName" ) ; 
valueClassName = node . get ( "valueClassName" ) ; 
key = mapper . readValue ( keyNode . traverse ( ) , 
forClassName ( keyClassName ) ) ; 
value = mapper . readValue ( valueNode . traverse ( ) , 
forClassName ( valueClassName ) ) ; 
region . put ( key , value ) ; 
} public void startCluster ( ) 
IO . mkdir ( Paths . get ( runtimeDir + "/locator" ) . toFile ( ) ) ; 
IO . mkdir ( Paths . get ( runtimeDir + "/server" ) . toFile ( ) ) ; 
Shell shell = new Shell ( ) ; 
System . out . println ( pi . exitValue ) ; 
System . out . println ( pi . output ) ; 
System . out . println ( pi . error ) ; 
pi = shell . execute ( location + "/gfsh" , 
System . out . println ( "OUTPUT:" + pi . output ) ; 
System . out . println ( "ERROR:" + pi . error ) ; 
} public void shutdown ( ) 
try ( JMX jmx = JMX . connect ( "localhost" , 1099 ) ) 
String [ ] members = GemFireMgmt . shutDown ( jmx ) ; 
Debugger . println ( "members:" + Debugger . toString ( members ) ) ; 
GemFireMgmt . stopLocator ( jmx , "locator" ) ; 
IO . delete ( Paths . get ( runtimeDir + "/server" ) . toFile ( ) ) ; 
catch ( IOException e ) { Debugger . printWarn ( e ) ; } 
IO . delete ( Paths . get ( runtimeDir + "/locator" ) . toFile ( ) ) ; 
} public void waitForMemberStart ( String member , JMX jmx ) 
boolean isRunning = false ; 
boolean printedStartMember = false ; 
while ( ! isRunning ) 
try { isRunning = GemFireInspector . checkMemberStatus ( member , jmx ) ; } 
catch ( Exception e ) { Debugger . printWarn ( e ) ; } 
if ( ! printedStartMember ) 
printedStartMember = true ; 
try { delay ( ) ; } catch ( Exception e ) { } 
if ( count > retryCount ) 
} public void waitForMemberStop ( String member , JMX jmx ) throws InterruptedException 
boolean isRunning = true ; 
while ( isRunning && count < retryCount ) 
isRunning = GemFireInspector . checkMemberStatus ( member , jmx ) ; 
delay ( ) ; 
if ( isRunning ) 
} public < K , V > Collection < String > saveSearchResultsWithPageKeys ( TextPageCriteria criteria , LuceneQueryProvider queryProvider , Predicate < LuceneResultStruct < K , V > > filter , Region < String , Collection < K > > pageKeysRegion ) 
return saveSearchResultsWithPageKeys ( criteria , queryProvider . toString ( ) , filter , pageKeysRegion ) ; 
} public < K , V > Collection < String > saveSearchResultsWithPageKeys ( TextPageCriteria criteria , String query , Predicate < LuceneResultStruct < K , V > > filter , Region < String , Collection < K > > pageKeysRegion ) 
pagination . clearSearchResultsByPage ( criteria , pageKeysRegion ) ; 
List < Map . Entry < K , V > > results = executeQuery ( criteria , query , filter ) ; 
List < String > keys = pagination . storePaginationMap ( criteria . getId ( ) , criteria . getEndIndex ( ) - criteria . getBeginIndex ( ) , pageKeysRegion , 
results ) ; 
throw new FunctionException ( e ) ; 
Region < Serializable , Object > region = CacheFactory . getAnyInstance ( ) . getRegion ( regionName ) ; 
functionContext . getResultSender ( ) . lastResult ( buildCheckSumMap ( region ) ) ; 
String stack = Debugger . stackTrace ( e ) ; 
LogManager . getLogger ( getClass ( ) ) . error ( stack ) ; 
throw new FunctionException ( stack ) ; 
} HashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) 
if ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) 
Set < Serializable > keySet = region . keySet ( ) ; 
HashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; 
Object object = null ; 
Object tmp = null ; 
for ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) 
object = entry . getValue ( ) ; 
if ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) 
tmp = ( ( PdxInstance ) object ) . getObject ( ) ; 
if ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) 
object = tmp ; 
if ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) 
regionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; 
regionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; 
return regionCheckSumMap ; 
} @ PostMapping ( path = "/" , produces = "application/json" ) 
public String query ( @ RequestBody String query ) 
return queryLimit ( query , - 1 ) ; 
} @ PostMapping ( path = "{limit}" , produces = "application/json" ) 
public String queryLimit ( @ RequestBody String query , @ PathVariable int limit ) 
if ( query == null || query . length ( ) == 0 ) 
query = this . appendLimit ( query , limit ) ; 
Collection < Object > results = querierService . query ( query ) ; 
if ( results == null ) 
return gson . toJson ( results , Collection . class ) ; 
for ( int i = 0 ; i < stats . length ; i ++ ) { 
if ( stats [ i ] != null ) { 
if ( ! stats [ i ] . isLoaded ( ) ) { 
stats [ i ] = null ; 
} private Object valueOf ( String columnName , Object value ) { 
java . lang . reflect . Field field ; 
field = tableObject . getDeclaredField ( columnName ) ; 
return field . getType ( ) == String . class ? String . format ( "\'%s\'" , value ) : value ; 
} boolean isTypeOf ( TypeMirror typeMirror ) { 
if ( integerKinds . contains ( typeMirror . getKind ( ) ) ) { 
if ( integerObjects . contains ( typeMirror . toString ( ) ) ) { 
} public static < T > byte [ ] serialize ( T object ) { 
ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; 
ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; 
objectOutputStream . writeObject ( object ) ; 
return byteArrayOutputStream . toByteArray ( ) ; 
} public static < K > K deserialize ( byte [ ] bytes ) { 
ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream ( bytes ) ; 
ObjectInputStream objectInputStream = new ObjectInputStream ( byteArrayInputStream ) ; 
@ SuppressWarnings ( "unchecked" ) final K k = ( K ) objectInputStream . readObject ( ) ; 
return k ; 
public static < T > T createInstance ( Class < T > clazz ) { 
if ( clazz == List . class ) { 
return ( T ) new ArrayList ( ) ; 
} else if ( clazz == Map . class ) { 
return ( T ) new HashMap ( ) ; 
ObjectInstantiator instantiator = OBJENESIS . getInstantiatorOf ( clazz ) ; 
return ( T ) instantiator . newInstance ( ) ; 
} private void checkForTableId ( TableObject tableObject , Element element ) { 
Id idAnnotation = element . getAnnotation ( Id . class ) ; 
if ( idAnnotation != null ) { 
if ( element . asType ( ) . getKind ( ) != TypeKind . LONG && ! ( "java.lang.Long" . equals ( 
element . asType ( ) . toString ( ) ) ) ) { 
String columnName = Strings . isBlank ( idAnnotation . name ( ) ) 
? element . getSimpleName ( ) . toString ( ) 
: idAnnotation . name ( ) ; 
final TableColumn idColumn = new TableColumn ( columnName , element . getSimpleName ( ) . toString ( ) , 
element . asType ( ) . toString ( ) , SqliteType . INTEGER ) ; 
tableObject . setIdColumn ( idColumn ) ; 
} private void checkForFields ( TableObject tableObject , Element columnElement ) { 
Column columnAnnotation = columnElement . getAnnotation ( Column . class ) ; 
if ( columnAnnotation == null ) return ; 
final Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; 
final String type = typeElement == null ? columnElement . asType ( ) . toString ( ) 
: elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; 
TableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; 
if ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { 
String columnType = columnElement . asType ( ) . toString ( ) ; 
if ( ! checkForSuperType ( columnElement , Serializable . class ) 
&& ! columnType . equals ( "java.lang.Byte[]" ) 
&& ! columnType . startsWith ( "java.util.Map" ) 
&& ! columnType . startsWith ( "java.util.List" ) ) { 
logger . e ( String . format ( 
columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; 
} else if ( tableColumn . isOneToMany ( ) ) { 
TypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; 
if ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { 
tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; 
oneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; 
TypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; 
tableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; 
} else if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { 
@ SuppressWarnings ( "ConstantConditions" ) Table annotation = 
typeElement . getAnnotation ( Table . class ) ; 
if ( annotation == null ) { 
tableColumn . setOneToOne ( true ) ; 
tableObject . addColumn ( tableColumn ) ; 
} private boolean checkForSuperType ( Element element , Class type ) { 
List < ? extends TypeMirror > superTypes = typeUtils . directSupertypes ( element . asType ( ) ) ; 
for ( TypeMirror superType : superTypes ) { 
if ( superType . toString ( ) . equals ( type . getName ( ) ) ) { 
} private String getSchema ( ) { 
Iterator < TableColumn > iterator = columns . iterator ( ) ; 
TableColumn column = iterator . next ( ) ; 
if ( column . isOneToMany ( ) ) { 
if ( ! iterator . hasNext ( ) ) { 
int length = sb . length ( ) ; 
sb . replace ( length - 2 , length , "" ) ; 
sb . append ( column ) ; 
if ( iterator . hasNext ( ) ) { 
String idCol = idColumn == null ? "id_missing" : idColumn . getColumnName ( ) ; 
return String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; 
} void brewJava ( Writer writer ) throws IOException { 
logger . d ( "brewJava" ) ; 
JavaWriter javaWriter = new JavaWriter ( writer ) ; 
javaWriter . setCompressingTypes ( false ) ; 
. emitPackage ( classPackage ) 
. emitImports ( "android.content.ContentValues" , "android.database.Cursor" , 
"android.database.DatabaseUtils" , "android.database.sqlite.SQLiteDatabase" ) 
. emitImports ( ShillelaghUtil . class , ByteArrayInputStream . class , ByteArrayOutputStream . class , 
IOException . class , ObjectInputStream . class , ObjectOutputStream . class , LinkedList . class , 
Date . class , List . class ) 
. beginType ( className , "class" , EnumSet . of ( PUBLIC , FINAL ) ) ; 
if ( this . isChildTable ) { 
emitParentInsert ( javaWriter ) ; 
emitSelectAll ( javaWriter ) ; 
emitInsert ( javaWriter ) ; 
emitOneToOneInsert ( javaWriter ) ; 
emitGetId ( javaWriter ) ; 
emitCreateTable ( javaWriter ) ; 
emitDropTable ( javaWriter ) ; 
emitUpdate ( javaWriter ) ; 
emitUpdateColumnId ( javaWriter ) ; 
emitDeleteWithId ( javaWriter ) ; 
emitDeleteWithObject ( javaWriter ) ; 
emitMapCursorToObject ( javaWriter ) ; 
emitSingleMap ( javaWriter ) ; 
emitSelectById ( javaWriter ) ; 
javaWriter . endType ( ) ; 
} private void emitGetId ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitGetId" ) ; 
javaWriter . beginMethod ( "long" , GET_ID_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , getTargetClass ( ) , 
} private void emitCreateTable ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitCreateTable" ) ; 
javaWriter . beginMethod ( "void" , $$CREATE_TABLE_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
"SQLiteDatabase" , "db" ) . emitStatement ( "db.execSQL(\"%s\")" , getSchema ( ) ) . endMethod ( ) ; 
} private void emitDropTable ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitDropTable" ) ; 
javaWriter . beginMethod ( "void" , $$DROP_TABLE_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
"SQLiteDatabase" , "db" ) 
. endMethod ( ) ; 
} private void emitInsert ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitInsert" ) ; 
String tableName = getTableName ( ) ; 
javaWriter . beginMethod ( "void" , $$INSERT_OBJECT_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
getTargetClass ( ) , "element" , "SQLiteDatabase" , "db" ) 
List < TableColumn > childColumns = Lists . newLinkedList ( ) ; 
for ( TableColumn column : columns ) { 
String columnName = column . getColumnName ( ) ; 
String memberName = column . getMemberName ( ) ; 
if ( column . isBlob ( ) && ! column . isByteArray ( ) ) { 
SERIALIZE_FUNCTION , memberName ) ; 
} else if ( column . isOneToOne ( ) ) { 
INSERT_ONE_TO_ONE , column . getColumnName ( ) ) 
$$SUFFIX , GET_ID_FUNCTION , memberName ) ; 
} else if ( column . isDate ( ) ) { 
memberName ) ; 
} else if ( column . isOneToMany ( ) ) { 
childColumns . add ( column ) ; 
} else if ( ! column . isOneToManyChild ( ) ) { 
if ( ! childColumns . isEmpty ( ) ) { 
for ( TableColumn childColumn : childColumns ) { 
PARENT_INSERT_FUNCTION , childColumn . getMemberName ( ) ) ; 
javaWriter . endMethod ( ) ; 
} private void emitUpdate ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitUpdate" ) ; 
javaWriter . beginMethod ( "void" , $$UPDATE_OBJECT_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
if ( column . getSqlType ( ) == SqliteType . BLOB && ! column . isByteArray ( ) ) { 
column . getType ( ) , $$SUFFIX , GET_ID_FUNCTION , memberName ) ; 
column . getType ( ) . replace ( "$" , "." ) , column . getColumnName ( ) ) 
$$UPDATE_OBJECT_FUNCTION ) 
} else if ( column . isOneToManyChild ( ) ) { 
getTableName ( ) , idColumn . getColumnName ( ) , idColumn . getMemberName ( ) ) ; 
} private void emitUpdateColumnId ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitUpdateColumnId" ) ; 
javaWriter . beginMethod ( "void" , $$UPDATE_ID_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
String . format ( GET_ID_OF_LAST_INSERTED_ROW_SQL , getTableName ( ) ) ) 
} private void emitDeleteWithId ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitDeleteWithId" ) ; 
javaWriter . beginMethod ( "void" , $$DELETE_OBJECT_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , "Long" , 
"id" , "SQLiteDatabase" , "db" ) 
idColumn . getColumnName ( ) ) 
} private void emitDeleteWithObject ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitDeleteWithObject" ) ; 
javaWriter . beginMethod ( "void" , $$DELETE_OBJECT_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , 
} private void emitMapCursorToObject ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitMapCursorToObject" ) ; 
final String targetClass = getTargetClass ( ) ; 
javaWriter . beginMethod ( "List<" + targetClass + ">" , $$MAP_OBJECT_FUNCTION , 
EnumSet . of ( PUBLIC , STATIC ) , "Cursor" , "cursor" , "SQLiteDatabase" , "db" ) 
. emitStatement ( "tableObjects.add(tableObject)" ) 
. emitStatement ( "cursor.moveToNext()" ) 
. endControlFlow ( ) 
} private void emitSelectById ( JavaWriter javaWriter ) throws IOException { 
logger . d ( "emitSelectById" ) ; 
javaWriter . beginMethod ( getTargetClass ( ) , $$GET_OBJECT_BY_ID , EnumSet . of ( PUBLIC , STATIC ) , "long" , 
getTableName ( ) , idColumn . getColumnName ( ) ) 
. emitStatement ( "cursor.close()" ) 
} public final Observable < T > toObservable ( ) { 
if ( ! HAS_RX_JAVA ) { 
return shillelagh . getObservable ( tableObject , new CursorLoader ( ) { 
@ Override public Cursor getCursor ( ) { 
return shillelagh . rawQuery ( query . toString ( ) ) ; 
} final void checkColumnName ( String columnName ) { 
tableObject . getDeclaredField ( columnName ) ; 
} static String valueOrDefault ( String string , String defaultString ) { 
return isBlank ( string ) ? defaultString : string ; 
} static String capitalize ( String string ) { 
if ( isBlank ( string ) ) { 
char first = string . charAt ( 0 ) ; 
if ( Character . isUpperCase ( first ) ) { 
return Character . toUpperCase ( first ) + string . substring ( 1 ) ; 
if ( realKinds . contains ( typeMirror . getKind ( ) ) ) { 
if ( realObjects . contains ( typeMirror . toString ( ) ) ) { 
} public Builder < T > descending ( ) { 
return new Builder < T > ( shillelagh , tableObject , query ) ; 
} public float readTemperature ( ) throws IOException { 
byte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , "w1_slave" ) . toPath ( ) ) ; 
String tmp = new String ( encoded ) ; 
int tmpIndex = tmp . indexOf ( "t=" ) ; 
if ( tmpIndex < 0 ) { 
return Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; 
} public static String get ( String type ) { 
final String returnValue = SUPPORTED_CURSOR_METHODS . get ( type ) ; 
return returnValue != null ? returnValue : SUPPORTED_CURSOR_METHODS . get ( BLOB ) ; 
} void d ( String message , Object ... args ) { 
messenger . printMessage ( NOTE , formatString ( message , args ) ) ; 
} void n ( String message , Object ... args ) { 
} void e ( String message , Object ... args ) { 
messenger . printMessage ( ERROR , formatString ( message , args ) ) ; 
public DataPoint nextPoint ( final float h ) 
m_fY += h * m_aEquation . at ( m_fX , m_fY ) ; 
m_fX += h ; 
return new DataPoint ( m_fX , m_fY ) ; 
} public void addDataPoint ( final DataPoint dataPoint ) 
if ( m_nDataPoints >= m_aData . length ) 
m_aData [ m_nDataPoints ] = dataPoint ; 
m_aDivDiff [ m_nDataPoints ] [ 0 ] = dataPoint . getY ( ) ; 
++ m_nDataPoints ; 
for ( int order = 1 ; order < m_nDataPoints ; ++ order ) 
final int bottom = m_nDataPoints - order - 1 ; 
final float numerator = m_aDivDiff [ bottom + 1 ] [ order - 1 ] - m_aDivDiff [ bottom ] [ order - 1 ] ; 
final float denominator = m_aData [ bottom + order ] . getX ( ) - m_aData [ bottom ] . getX ( ) ; 
m_aDivDiff [ bottom ] [ order ] = numerator / denominator ; 
} public float at ( final float x ) 
if ( m_nDataPoints < 2 ) 
return Float . NaN ; 
float y = m_aDivDiff [ 0 ] [ 0 ] ; 
float xFactor = 1 ; 
xFactor = xFactor * ( x - m_aData [ order - 1 ] . getX ( ) ) ; 
y = y + xFactor * m_aDivDiff [ 0 ] [ order ] ; 
return y ; 
} public VLayout createSldEditorLayout ( ) { 
final VLayout vLayout = new VLayout ( ) ; 
toolStrip = new ToolStrip ( ) ; 
toolStrip . setWidth100 ( ) ; 
codeMirrorPanel = new CodeMirrorPanel ( ) ; 
WidgetCanvas canvas = new WidgetCanvas ( codeMirrorPanel ) ; 
canvas . setWidth100 ( ) ; 
canvas . setHeight100 ( ) ; 
vLayout . addMember ( toolStrip ) ; 
vLayout . addMember ( canvas ) ; 
ToolStripButton saveButton = new ToolStripButton ( ) ; 
saveButton . setIcon ( "[ISOMORPHIC]/" + "icons/silk/disk.png" ) ; 
saveButton . setTitle ( msg . saveButtonTitle ( ) ) ; 
saveButton . setTooltip ( msg . saveButtonTooltip ( ) ) ; 
saveButton . addClickHandler ( new ClickHandler ( ) { 
public void onClick ( ClickEvent clickEvent ) { 
presenter . onSaveButton ( ) ; 
ToolStripButton cancelButton = new ToolStripButton ( ) ; 
cancelButton . setIcon ( "[ISOMORPHIC]/" + "icons/silk/cancel.png" ) ; 
cancelButton . setTitle ( msg . cancelButtonTitle ( ) ) ; 
cancelButton . addClickHandler ( new ClickHandler ( ) { 
presenter . onCancelButton ( ) ; 
ToolStripButton validateButton = new ToolStripButton ( ) ; 
validateButton . setIcon ( "[ISOMORPHIC]/" + "icons/silk/tick.png" ) ; 
validateButton . setTitle ( msg . validateButtonTitle ( ) ) ; 
validateButton . setTooltip ( msg . validateButtonTooltip ( ) ) ; 
validateButton . addClickHandler ( new ClickHandler ( ) { 
presenter . onValidateButton ( ) ; 
ToolStripButton formatBtn = new ToolStripButton ( ) ; 
formatBtn . setIcon ( "[ISOMORPHIC]/" + "icons/silk/text_align_left.png" ) ; 
formatBtn . setTitle ( msg . formatButtonTitle ( ) ) ; 
formatBtn . setTooltip ( msg . formatButtonTooltip ( ) ) ; 
formatBtn . addClickHandler ( new ClickHandler ( ) { 
public void onClick ( ClickEvent event ) { 
presenter . onFormatButton ( ) ; 
selectTemplate = new SelectItem ( ) ; 
selectTemplate . setTitle ( msg . templateSelectTitle ( ) ) ; 
selectTemplate . setTooltip ( msg . templateSelectTooltip ( ) ) ; 
selectTemplate . setWidth ( 200 ) ; 
selectTemplate . addChangeHandler ( new ChangeHandler ( ) { 
public void onChange ( ChangeEvent changeEvent ) { 
presenter . onTemplateSelect ( ( String ) changeEvent . getValue ( ) ) ; 
toolStrip . addFormItem ( selectTemplate ) ; 
toolStrip . addButton ( saveButton ) ; 
toolStrip . addButton ( validateButton ) ; 
toolStrip . addButton ( formatBtn ) ; 
toolStrip . addFill ( ) ; 
toolStrip . addButton ( cancelButton ) ; 
return vLayout ; 
} private HTMLFlow getBackgroundDecoration ( ) { 
HTMLFlow htmlFlow = new HTMLFlow ( ) ; 
htmlFlow . setWidth100 ( ) ; 
htmlFlow . setHeight100 ( ) ; 
String contents = 
htmlFlow . setContents ( contents ) ; 
return htmlFlow ; 
} public static double raise ( final double px , final int pexponent ) 
double x = px ; 
int exponent = pexponent ; 
if ( exponent < 0 ) 
return 1 / raise ( x , - exponent ) ; 
double power = 1 ; 
while ( exponent > 0 ) 
if ( ( exponent & 1 ) == 1 ) 
power *= x ; 
x *= x ; 
exponent >>= 1 ; 
return power ; 
} public float [ ] copyValues1D ( ) 
final float v [ ] = new float [ m_nRows ] ; 
for ( int r = 0 ; r < m_nRows ; ++ r ) 
v [ r ] = m_aValues [ r ] [ 0 ] ; 
} protected void set ( final float values [ ] ) 
this . m_nRows = values . length ; 
this . m_nCols = 1 ; 
this . m_aValues = new float [ m_nRows ] [ 1 ] ; 
this . m_aValues [ r ] [ 0 ] = values [ r ] ; 
} public float norm ( ) 
double t = 0 ; 
final float v = m_aValues [ r ] [ 0 ] ; 
t += v * v ; 
return ( float ) Math . sqrt ( t ) ; 
} public void print ( ) 
} public static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) 
BigDecimal x = px ; 
long exponent = pexponent ; 
return BigDecimal . ONE . divide ( intPower ( x , - exponent , scale ) , scale , RoundingMode . HALF_EVEN ) ; 
BigDecimal power = BigDecimal . ONE ; 
power = power . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
x = x . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} public static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) 
if ( x . signum ( ) < 0 ) 
final int sp1 = scale + 1 ; 
final BigDecimal n = x ; 
final BigDecimal i = BigDecimal . valueOf ( index ) ; 
final BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; 
final BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; 
BigDecimal xPrev ; 
x = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; 
final BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; 
final BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
xPrev = x ; 
x = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; 
} while ( x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) > 0 ) ; 
} public static BigDecimal exp ( final BigDecimal x , final int scale ) 
if ( x . signum ( ) == 0 ) 
return BigDecimal . ONE ; 
if ( x . signum ( ) == - 1 ) 
return BigDecimal . ONE . divide ( exp ( x . negate ( ) , scale ) , scale , RoundingMode . HALF_EVEN ) ; 
BigDecimal xWhole = x . setScale ( 0 , RoundingMode . DOWN ) ; 
if ( xWhole . signum ( ) == 0 ) 
return _expTaylor ( x , scale ) ; 
final BigDecimal xFraction = x . subtract ( xWhole ) ; 
final BigDecimal z = BigDecimal . ONE . add ( xFraction . divide ( xWhole , scale , RoundingMode . HALF_EVEN ) ) ; 
final BigDecimal t = _expTaylor ( z , scale ) ; 
final BigDecimal maxLong = BigDecimal . valueOf ( Long . MAX_VALUE ) ; 
BigDecimal result = BigDecimal . ONE ; 
while ( xWhole . compareTo ( maxLong ) >= 0 ) 
result = result . multiply ( intPower ( t , Long . MAX_VALUE , scale ) ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
xWhole = xWhole . subtract ( maxLong ) ; 
return result . multiply ( intPower ( t , xWhole . longValue ( ) , scale ) ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} private static BigDecimal _expTaylor ( final BigDecimal x , final int scale ) 
BigDecimal factorial = BigDecimal . ONE ; 
BigDecimal xPower = x ; 
BigDecimal sumPrev ; 
BigDecimal sum = x . add ( BigDecimal . ONE ) ; 
int i = 2 ; 
xPower = xPower . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
factorial = factorial . multiply ( BigDecimal . valueOf ( i ) ) ; 
final BigDecimal term = xPower . divide ( factorial , scale , RoundingMode . HALF_EVEN ) ; 
sumPrev = sum ; 
sum = sum . add ( term ) ; 
} while ( sum . compareTo ( sumPrev ) != 0 ) ; 
} public static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) 
if ( x . signum ( ) <= 0 ) 
final int magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; 
if ( magnitude < 3 ) 
return _lnNewton ( x , scale ) ; 
final BigDecimal root = intRoot ( x , magnitude , scale ) ; 
final BigDecimal lnRoot = _lnNewton ( root , scale ) ; 
return BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} private static BigDecimal _lnNewton ( @ Nonnull final BigDecimal px , final int scale ) 
BigDecimal term ; 
final BigDecimal eToX = exp ( x , sp1 ) ; 
term = eToX . subtract ( n ) . divide ( eToX , sp1 , RoundingMode . DOWN ) ; 
x = x . subtract ( term ) ; 
} while ( term . compareTo ( tolerance ) > 0 ) ; 
return x . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} public static BigDecimal arctan ( @ Nonnull final BigDecimal x , final int scale ) 
if ( x . abs ( ) . compareTo ( BigDecimal . ONE ) >= 0 ) 
return arctan ( x . negate ( ) , scale ) . negate ( ) ; 
return _arctanTaylor ( x , scale ) ; 
} private static BigDecimal _arctanTaylor ( final BigDecimal x , final int scale ) 
boolean addFlag = false ; 
BigDecimal power = x ; 
BigDecimal sum = x ; 
power = power . multiply ( x ) . multiply ( x ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
term = power . divide ( BigDecimal . valueOf ( i ) , sp1 , RoundingMode . HALF_EVEN ) ; 
sum = addFlag ? sum . add ( term ) : sum . subtract ( term ) ; 
addFlag = ! addFlag ; 
} public static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) 
final BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; 
final int bits = ( n . bitLength ( ) + 1 ) > > 1 ; 
BigInteger ix = n . shiftRight ( bits ) ; 
BigInteger ixPrev ; 
ixPrev = ix ; 
ix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; 
} while ( ix . compareTo ( ixPrev ) != 0 ) ; 
return new BigDecimal ( ix , scale ) ; 
} protected void printPi ( final String piString ) 
int index = 2 ; 
int line = 0 ; 
int group = 0 ; 
final int length = piString . length ( ) ; 
while ( index + 5 < length ) 
index += 5 ; 
if ( ++ group == 10 ) 
if ( ++ line == 10 ) 
line = 0 ; 
group = 0 ; 
if ( index < length ) 
System . out . println ( piString . substring ( index ) ) ; 
} protected String timestamp ( final long time ) 
final LocalDateTime aLDT = PDTFactory . getCurrentLocalDateTime ( ) ; 
final LocalDateTime aOld = PDTFactory . createLocalDateTime ( time ) ; 
} public void setLimits ( final float rMin , final float rMax ) 
this . m_fMin = rMin ; 
this . m_fMax = rMax ; 
this . m_fWidth = ( rMax - rMin ) / m_n ; 
} public void put ( final float r ) 
if ( ( r < m_fMin ) || ( r > m_fMax ) ) 
final int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; 
++ m_aCounters [ i ] ; 
int maxCount = 0 ; 
for ( int i = 0 ; i < m_n ; ++ i ) 
maxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; 
final float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; 
final int b = m_aCounters [ i ] ; 
m_aAlignRight . print ( i , 2 ) ; 
m_aAlignRight . print ( b , 7 ) ; 
final int length = Math . round ( factor * b ) ; 
for ( int j = 0 ; j < length ; ++ j ) 
System . out . print ( "*" ) ; 
} public Complex add ( final Complex z ) 
return new Complex ( m_fReal + z . real ( ) , m_fImaginary + z . imaginary ( ) ) ; 
} public Complex subtract ( final Complex z ) 
return new Complex ( m_fReal - z . real ( ) , m_fImaginary - z . imaginary ( ) ) ; 
} public Complex multiply ( final Complex z ) 
return new Complex ( m_fReal * z . real ( ) - 
m_fImaginary * z . imaginary ( ) , 
m_fReal * z . imaginary ( ) + m_fImaginary * z . real ( ) ) ; 
} public Complex divide ( final Complex z ) 
final float denom = z . real ( ) * z . real ( ) + z . imaginary ( ) * z . imaginary ( ) ; 
final float qr = ( m_fReal * z . real ( ) + m_fImaginary * z . imaginary ( ) ) / denom ; 
final float qi = ( m_fImaginary * z . real ( ) - m_fReal * z . imaginary ( ) ) / denom ; 
return new Complex ( qr , qi ) ; 
public float [ ] copyValues1D ( ) 
final float v [ ] = new float [ m_nCols ] ; 
for ( int c = 0 ; c < m_nCols ; ++ c ) 
v [ c ] = m_aValues [ 0 ] [ c ] ; 
} private void _set ( final Matrix m ) 
m_nRows = 1 ; 
m_nCols = m . m_nCols ; 
m_aValues = m . m_aValues ; 
final float v = m_aValues [ 0 ] [ c ] ; 
} public float at ( final int r , final int c ) throws MatrixException 
if ( ( r < 0 ) || ( r >= m_nRows ) || ( c < 0 ) || ( c >= m_nCols ) ) 
throw new MatrixException ( MatrixException . INVALID_INDEX ) ; 
return m_aValues [ r ] [ c ] ; 
} public RowVector getRow ( final int r ) throws MatrixException 
if ( ( r < 0 ) || ( r >= m_nRows ) ) 
final RowVector rv = new RowVector ( m_nCols ) ; 
rv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; 
return rv ; 
} public ColumnVector getColumn ( final int c ) throws MatrixException 
if ( ( c < 0 ) || ( c >= m_nCols ) ) 
final ColumnVector cv = new ColumnVector ( m_nRows ) ; 
cv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; 
return cv ; 
} public float [ ] [ ] copyValues2D ( ) 
final float v [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
v [ r ] [ c ] = m_aValues [ r ] [ c ] ; 
} public void set ( final int r , final int c , final float value ) throws MatrixException 
m_aValues [ r ] [ c ] = value ; 
} protected void set ( final float values [ ] [ ] ) 
m_nRows = values . length ; 
m_nCols = values [ 0 ] . length ; 
m_aValues = values ; 
for ( int r = 1 ; r < m_nRows ; ++ r ) 
m_nCols = Math . min ( m_nCols , values [ r ] . length ) ; 
} public void setRow ( final RowVector rv , final int r ) throws MatrixException 
if ( m_nCols != rv . m_nCols ) 
throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
m_aValues [ r ] [ c ] = rv . m_aValues [ 0 ] [ c ] ; 
} public void setColumn ( final ColumnVector cv , final int c ) throws MatrixException 
if ( m_nRows != cv . m_nRows ) 
m_aValues [ r ] [ c ] = cv . m_aValues [ r ] [ 0 ] ; 
} public Matrix transpose ( ) 
final float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; 
tv [ c ] [ r ] = m_aValues [ r ] [ c ] ; 
return new Matrix ( tv ) ; 
} public Matrix add ( final Matrix m ) throws MatrixException 
if ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) 
final float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
sv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; 
return new Matrix ( sv ) ; 
} public Matrix subtract ( final Matrix m ) throws MatrixException 
final float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
dv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; 
return new Matrix ( dv ) ; 
} public Matrix multiply ( final float k ) 
final float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
pv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; 
return new Matrix ( pv ) ; 
} public Matrix multiply ( final Matrix m ) throws MatrixException 
if ( m_nCols != m . m_nRows ) 
final float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; 
for ( int c = 0 ; c < m . m_nCols ; ++ c ) 
float dot = 0 ; 
for ( int k = 0 ; k < m_nCols ; ++ k ) 
dot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; 
pv [ r ] [ c ] = dot ; 
} public ColumnVector multiply ( final ColumnVector cv ) throws MatrixException 
final float pv [ ] = new float [ m_nRows ] ; 
dot += m_aValues [ r ] [ c ] * cv . m_aValues [ c ] [ 0 ] ; 
pv [ r ] = dot ; 
return new ColumnVector ( pv ) ; 
} public RowVector multiply ( final RowVector rv ) throws MatrixException 
dot += rv . m_aValues [ 0 ] [ r ] * m_aValues [ r ] [ c ] ; 
pv [ c ] = dot ; 
return new RowVector ( pv ) ; 
} public void print ( final int width , @ Nonnull final PrintStream aPS ) 
final SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; 
ar . print ( r + 1 , 2 ) ; 
ar . print ( ":" , 0 ) ; 
ar . print ( m_aValues [ r ] [ c ] , width ) ; 
ar . println ( ) ; 
protected void computeNextPosition ( ) 
m_fFn = m_fFnp1 ; 
m_fFpn = m_aFunction . derivativeAt ( m_fXn ) ; 
m_fPrevXnp1 = m_fXnp1 ; 
m_fXnp1 = m_fXn - m_fFn / m_fFpn ; 
m_fFnp1 = m_aFunction . at ( m_fXnp1 ) ; 
protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException 
if ( EqualsHelper . equals ( m_fXnp1 , m_fPrevXnp1 ) ) 
throw new AbstractRootFinder . PositionUnchangedException ( ) ; 
} public void setResource ( ImageResource imageResource ) { 
Image img = new Image ( imageResource ) ; 
DOM . insertChild ( getElement ( ) , img . getElement ( ) , 0 ) ; 
m_dSumX += dataPoint . getX ( ) ; 
m_dSumY += dataPoint . getY ( ) ; 
m_dSumXX += dataPoint . getX ( ) * dataPoint . getX ( ) ; 
m_dSumXY += dataPoint . getX ( ) * dataPoint . getY ( ) ; 
m_bCoefsValid = false ; 
} private void _validateCoefficients ( ) 
if ( m_bCoefsValid ) 
if ( m_nDataPoints >= 2 ) 
final float xBar = ( float ) m_dSumX / m_nDataPoints ; 
final float yBar = ( float ) m_dSumY / m_nDataPoints ; 
m_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; 
m_fA0 = yBar - m_fA1 * xBar ; 
m_fA0 = m_fA1 = Float . NaN ; 
m_bCoefsValid = true ; 
m_fPrevXn = m_fXn ; 
m_fXn = m_fGn ; 
m_fGn = m_aFunction . at ( m_fXn ) ; 
rawSld = new RawSld ( ) ; 
dirty = false ; 
template = null ; 
sldDescriptor = null ; 
} public RawSld toXml ( StyledLayerDescriptorInfo sldi ) throws SldException { 
if ( sldi . getVersion ( ) == null ) { 
sldi . setVersion ( "1.0.0" ) ; 
return parseSldI ( sldi ) ; 
} catch ( JiBXException e ) { 
} public StyledLayerDescriptorInfo toSldI ( RawSld sld ) throws SldException { 
return parseXml ( sld . getName ( ) , sld . getXml ( ) ) ; 
} public void validate ( StyledLayerDescriptorInfo sld ) throws SldException { 
parseSldI ( sld ) ; 
} public boolean validate ( RawSld sld ) throws SldException { 
parseXml ( "" , sld . getXml ( ) ) ; 
} private StyledLayerDescriptorInfo parseXml ( String name , String raw ) throws JiBXException { 
IBindingFactory bfact = BindingDirectory . getFactory ( StyledLayerDescriptorInfo . class ) ; 
IUnmarshallingContext uctx = bfact . createUnmarshallingContext ( ) ; 
Object object = uctx . unmarshalDocument ( new StringReader ( raw ) ) ; 
StyledLayerDescriptorInfo sld = ( StyledLayerDescriptorInfo ) object ; 
if ( sld . getName ( ) == null ) { 
sld . setName ( name ) ; 
if ( sld . getTitle ( ) == null ) { 
sld . setTitle ( getTitle ( sld , name ) ) ; 
if ( sld . getVersion ( ) == null ) { 
sld . setVersion ( "1.0.0" ) ; 
return sld ; 
final float predictor = m_fY + Math . abs ( h ) * m_aEquation . at ( m_fX ) ; 
final float avgSlope = ( m_aEquation . at ( m_fX , m_fY ) + m_aEquation . at ( m_fX + h , predictor ) ) / 2 ; 
m_fY += h * avgSlope ; 
} public float integrate ( final float a , final float b , final int intervals ) 
if ( b <= a ) 
final float h = ( b - a ) / intervals ; 
float totalArea = 0 ; 
for ( int i = 0 ; i < intervals ; ++ i ) 
final float x1 = a + i * h ; 
totalArea += _areaOf ( x1 , h ) ; 
return totalArea ; 
} private float _areaOf ( final float x1 , final float h ) 
final float x2 = x1 + h ; 
final float y1 = m_aIntegrand . at ( x1 ) ; 
final float y2 = m_aIntegrand . at ( x2 ) ; 
final float area = h * ( y1 + y2 ) / 2 ; 
return area ; 
this . m_nRows = this . m_nCols = Math . min ( m . m_nRows , m . m_nCols ) ; 
this . m_aValues = m . m_aValues ; 
protected void set ( final float values [ ] [ ] ) 
super . set ( values ) ; 
m_nRows = m_nCols = Math . min ( m_nRows , m_nCols ) ; 
} public static void fireSave ( HasHandlers source ) { 
SldCloseEvent eventInstance = new SldCloseEvent ( true ) ; 
source . fireEvent ( eventInstance ) ; 
} public static void fire ( HasHandlers source ) { 
SldCloseEvent eventInstance = new SldCloseEvent ( false ) ; 
} public InvertibleMatrix inverse ( ) throws MatrixException 
final InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; 
final IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; 
final ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; 
inverse . setColumn ( col , c ) ; 
return inverse ; 
} public float determinant ( ) throws MatrixException 
decompose ( ) ; 
float determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; 
for ( int i = 0 ; i < m_nRows ; ++ i ) 
final int pi = m_aPermutation [ i ] ; 
determinant *= m_aLU . at ( pi , i ) ; 
return determinant ; 
float sum = 0 ; 
final float v = m_aValues [ r ] [ c ] ; 
sum += v * v ; 
return ( float ) Math . sqrt ( sum ) ; 
public void set ( final int r , final int c , final float value ) throws MatrixException 
super . set ( r , c , value ) ; 
public void setRow ( final RowVector rv , final int r ) throws MatrixException 
super . setRow ( rv , r ) ; 
public void setColumn ( final ColumnVector cv , final int c ) throws MatrixException 
super . setColumn ( cv , c ) ; 
} public ColumnVector solve ( final ColumnVector b , final boolean improve ) throws MatrixException 
if ( b . m_nRows != m_nRows ) 
final ColumnVector y = _forwardSubstitution ( b ) ; 
final ColumnVector x = _backSubstitution ( y ) ; 
if ( improve ) 
_improve ( b , x ) ; 
} public void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException 
final int pr = m_aPermutation [ r ] ; 
ar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; 
} protected void decompose ( ) throws MatrixException 
if ( m_aLU != null ) 
m_aLU = new SquareMatrix ( this . copyValues2D ( ) ) ; 
m_aPermutation = new int [ m_nRows ] ; 
final float scales [ ] = new float [ m_nRows ] ; 
m_aPermutation [ r ] = r ; 
float largestRowElmt = 0 ; 
for ( int c = 0 ; c < m_nRows ; ++ c ) 
final float elmt = Math . abs ( m_aLU . at ( r , c ) ) ; 
if ( largestRowElmt < elmt ) 
largestRowElmt = elmt ; 
if ( largestRowElmt != 0 ) 
scales [ r ] = 1 / largestRowElmt ; 
throw new MatrixException ( MatrixException . ZERO_ROW ) ; 
_forwardElimination ( scales ) ; 
if ( m_aLU . at ( m_aPermutation [ m_nRows - 1 ] , m_nRows - 1 ) == 0 ) 
throw new MatrixException ( MatrixException . SINGULAR ) ; 
} private void _forwardElimination ( final float scales [ ] ) throws MatrixException 
for ( int rPivot = 0 ; rPivot < m_nRows - 1 ; ++ rPivot ) 
float largestScaledElmt = 0 ; 
int rLargest = 0 ; 
for ( int r = rPivot ; r < m_nRows ; ++ r ) 
final float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; 
final float scaledElmt = absElmt * scales [ pr ] ; 
if ( largestScaledElmt < scaledElmt ) 
largestScaledElmt = scaledElmt ; 
rLargest = r ; 
if ( largestScaledElmt == 0 ) 
if ( rLargest != rPivot ) 
final int temp = m_aPermutation [ rPivot ] ; 
m_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; 
m_aPermutation [ rLargest ] = temp ; 
++ m_nExchangeCount ; 
final int prPivot = m_aPermutation [ rPivot ] ; 
final float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; 
for ( int r = rPivot + 1 ; r < m_nRows ; ++ r ) 
final float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; 
m_aLU . set ( pr , rPivot , multiple ) ; 
if ( multiple != 0 ) 
for ( int c = rPivot + 1 ; c < m_nCols ; ++ c ) 
float elmt = m_aLU . at ( pr , c ) ; 
elmt -= multiple * m_aLU . at ( prPivot , c ) ; 
m_aLU . set ( pr , c , elmt ) ; 
} private ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException 
final ColumnVector y = new ColumnVector ( m_nRows ) ; 
for ( int c = 0 ; c < r ; ++ c ) 
dot += m_aLU . at ( pr , c ) * y . at ( c ) ; 
y . set ( r , b . at ( pr ) - dot ) ; 
} private ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException 
final ColumnVector x = new ColumnVector ( m_nRows ) ; 
for ( int r = m_nRows - 1 ; r >= 0 ; -- r ) 
for ( int c = r + 1 ; c < m_nRows ; ++ c ) 
dot += m_aLU . at ( pr , c ) * x . at ( c ) ; 
x . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; 
} private void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException 
float largestX = 0 ; 
final float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; 
if ( largestX < absX ) 
largestX = absX ; 
if ( largestX == 0 ) 
final ColumnVector residuals = new ColumnVector ( m_nRows ) ; 
for ( int iter = 0 ; iter < MAX_ITER ; ++ iter ) 
double dot = 0 ; 
final double elmt = at ( r , c ) ; 
dot += elmt * x . at ( c ) ; 
final double value = b . at ( r ) - dot ; 
residuals . set ( r , ( float ) value ) ; 
final ColumnVector z = solve ( residuals , false ) ; 
float largestDiff = 0 ; 
final float oldX = x . at ( r ) ; 
x . set ( r , oldX + z . at ( r ) ) ; 
final float diff = Math . abs ( x . at ( r ) - oldX ) ; 
if ( largestDiff < diff ) 
largestDiff = diff ; 
if ( largestDiff < largestX * TOLERANCE ) 
throw new MatrixException ( MatrixException . NO_CONVERGENCE ) ; 
} public static void convert ( final SquareMatrix sm ) 
for ( int r = 0 ; r < sm . m_nRows ; ++ r ) 
for ( int c = 0 ; c < sm . m_nCols ; ++ c ) 
sm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; 
} public float nextVonNeumann ( ) 
int n ; 
float u1 ; 
n = 1 ; 
u1 = GENERATOR . nextFloat ( ) ; 
float u = u1 ; 
float uPrev = Float . NaN ; 
uPrev = u ; 
u = GENERATOR . nextFloat ( ) ; 
if ( u > uPrev ) 
if ( ( n & 1 ) == 0 ) 
return u1 + k ; 
++ k ; 
++ n ; 
final float k1 = m_aEquation . at ( m_fX , m_fY ) ; 
final float k2 = m_aEquation . at ( m_fX + h / 2 , m_fY + k1 * h / 2 ) ; 
final float k3 = m_aEquation . at ( m_fX + h / 2 , m_fY + k2 * h / 2 ) ; 
final float k4 = m_aEquation . at ( m_fX + h , m_fY + k3 * h ) ; 
m_fY += ( k1 + 2 * ( k2 + k3 ) + k4 ) * h / 6 ; 
protected void doIterationProcedure ( final int n ) 
if ( n == 1 ) 
if ( m_fFalse < 0 ) 
m_fXNeg = m_fXFalse ; 
m_fNeg = m_fFalse ; 
m_fXPos = m_fXFalse ; 
m_fPos = m_fFalse ; 
m_fPrevXFalse = m_fXFalse ; 
m_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; 
m_fFalse = m_aFunction . at ( m_fXFalse ) ; 
if ( EqualsHelper . equals ( m_fXFalse , m_fPrevXFalse ) ) 
m_fPrevFFalse = m_fFalse ; 
m_bDecreasePos = m_bDecreaseNeg = false ; 
if ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) 
m_bDecreasePos = true ; 
m_bDecreaseNeg = true ; 
} public void checkInterval ( final float x1 , final float x2 ) throws InvalidIntervalException 
final float y1 = m_aFunction . at ( x1 ) ; 
final float y2 = m_aFunction . at ( x2 ) ; 
if ( y1 * y2 > 0 ) 
throw new InvalidIntervalException ( ) ; 
} public void add ( final float addend ) 
m_fCorrectedAddend = addend + m_fCorrection ; 
final float tempSum = m_fSum + m_fCorrectedAddend ; 
m_fCorrection = m_fCorrectedAddend - ( tempSum - m_fSum ) ; 
m_fSum = tempSum ; 
} public static int multiply ( final int pa , final int pb , final int m ) 
int a = pa ; 
int b = pb ; 
int product = 0 ; 
while ( a > 0 ) 
if ( ( a & 1 ) == 1 ) 
product += b ; 
product %= m ; 
b <<= 1 ; 
b %= m ; 
a >>= 1 ; 
} public static int raise ( final int pbase , final int pexponent , final int m ) 
int base = pbase ; 
int power = 1 ; 
power = multiply ( power , base , m ) ; 
base = multiply ( base , base , m ) ; 
m_fXnm1 = m_fXn ; 
m_fXn = m_fXnp1 ; 
m_fFnm1 = m_fFn ; 
m_fXnp1 = m_fXn - m_fFn * ( m_fXnm1 - m_fXn ) / ( m_fFnm1 - m_fFn ) ; 
} public SldManager getSldManager ( ) { 
if ( sldManager == null ) { 
sldManager = new SldManagerImpl ( getEventBus ( ) , getSldEditorServiceFactory ( ) . createSldGwtServiceAsync ( ) ) ; 
return sldManager ; 
} private static char [ ] _toCharBitArray ( final long pvalue , final int size ) 
long value = pvalue ; 
final char bits [ ] = new char [ size ] ; 
for ( int i = size - 1 ; i >= 0 ; -- i ) 
bits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; 
value >>>= 1 ; 
} private void _decompose ( final char [ ] bits , 
final int bias , 
final int reserved , 
final int signIndex , 
final int signSize , 
final int exponentIndex , 
final int exponentSize , 
final int fractionIndex , 
final int fractionSize ) 
this . m_nBias = bias ; 
m_sSignBit = new String ( bits , signIndex , signSize ) ; 
m_sExponentBits = new String ( bits , exponentIndex , exponentSize ) ; 
m_sFractionBits = new String ( bits , fractionIndex , fractionSize ) ; 
m_nBiased = Integer . parseInt ( m_sExponentBits , 2 ) ; 
m_nFraction = Long . parseLong ( m_sFractionBits , 2 ) ; 
catch ( final NumberFormatException ex ) 
{ } 
m_bIsZero = ( m_nBiased == 0 ) && ( m_nFraction == 0 ) ; 
m_bIsDenormalized = ( m_nBiased == 0 ) && ( m_nFraction != 0 ) ; 
m_bIsReserved = ( m_nBiased == reserved ) ; 
m_sImpliedBit = m_bIsDenormalized || m_bIsZero || m_bIsReserved ? "0" : "1" ; 
} public void print ( @ Nonnull final PrintStream aPW ) 
aPW . println ( "------------------------------" ) ; 
if ( isDouble ( ) ) 
aPW . print ( "sign=" + signBit ( ) ) ; 
if ( isZero ( ) ) 
if ( isExponentReserved ( ) ) 
if ( isDenormalized ( ) ) 
aPW . println ( "significand=" + significandBits ( ) ) ; 
} public static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception 
if ( ( biased < 0 ) || ( biased > IEEE754Constants . FLOAT_EXPONENT_RESERVED ) ) 
IEEE754Constants . FLOAT_EXPONENT_RESERVED + 
} public static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception 
if ( ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) ) 
- ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + 
IEEE754Constants . FLOAT_EXPONENT_BIAS + 
} public static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception 
if ( ( biased < 0 ) || ( biased > IEEE754Constants . DOUBLE_EXPONENT_RESERVED ) ) 
IEEE754Constants . DOUBLE_EXPONENT_RESERVED + 
} public static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception 
if ( ( unbiased < - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . DOUBLE_EXPONENT_BIAS ) ) 
- ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + 
IEEE754Constants . DOUBLE_EXPONENT_BIAS + 
} public SldGwtServiceAsync createSldGwtServiceAsync ( ) { 
this . service = GWT . create ( SldGwtService . class ) ; 
ServiceDefTarget endpoint = ( ServiceDefTarget ) service ; 
endpoint . setServiceEntryPoint ( GWT . getHostPageBaseURL ( ) + "d/sldTemplates" ) ; 
return service ; 
} public float nextCentral ( ) 
float sum = 0.0f ; 
for ( int j = 0 ; j < 12 ; ++ j ) 
sum += GENERATOR . nextFloat ( ) ; 
return m_fStddev * ( sum - 6 ) + m_fMean ; 
} public float nextPolar ( ) 
if ( m_bHaveNextPolar ) 
m_bHaveNextPolar = false ; 
return m_fNextPolar ; 
float u1 , u2 , r ; 
u1 = 2 * GENERATOR . nextFloat ( ) - 1 ; 
u2 = 2 * GENERATOR . nextFloat ( ) - 1 ; 
r = u1 * u1 + u2 * u2 ; 
} while ( r >= 1 ) ; 
final float factor = ( float ) ( m_fStddev * Math . sqrt ( - 2 * Math . log ( r ) / r ) ) ; 
final float v1 = factor * u1 + m_fMean ; 
final float v2 = factor * u2 + m_fMean ; 
m_fNextPolar = v1 ; 
m_bHaveNextPolar = true ; 
} public float nextRatio ( ) 
float u , v , x , xx ; 
while ( ( u = GENERATOR . nextFloat ( ) ) == 0 ) 
v = GENERATOR . nextFloat ( ) ; 
final float y = C1 * ( v - 0.5f ) ; 
x = y / u ; 
xx = x * x ; 
} while ( ( xx > 5f - C2 * u ) && 
( ( xx >= C3 / u + 1.4f ) || 
( xx > ( float ) ( - 4 * Math . log ( u ) ) ) ) 
return m_fStddev * x + m_fMean ; 
} public static boolean [ ] primeSieve ( final int n ) 
final int halfN = ( n + 1 ) > > 1 ; 
final boolean sieve [ ] = new boolean [ n + 1 ] ; 
for ( int i = 2 ; i <= n ; ++ i ) 
sieve [ i ] = true ; 
int prime = 2 ; 
while ( prime < halfN ) 
for ( int composite = prime << 1 ; composite <= n ; composite += prime ) 
sieve [ composite ] = false ; 
while ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) 
return sieve ; 
} public static int [ ] factorsOf ( final int pn ) 
int n = pn ; 
final boolean isPrime [ ] = primeSieve ( n ) ; 
final ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; 
for ( int factor = 2 ; n > 1 ; ++ factor ) 
if ( isPrime [ factor ] && ( n % factor == 0 ) ) 
v . add ( Integer . valueOf ( factor ) ) ; 
n /= factor ; 
} while ( n % factor == 0 ) ; 
final int factors [ ] = new int [ v . size ( ) ] ; 
for ( int i = 0 ; i < v . size ( ) ; ++ i ) 
factors [ i ] = v . get ( i ) . intValue ( ) ; 
if ( m_fMid < 0 ) 
m_fXNeg = m_fXMid ; 
m_fNeg = m_fMid ; 
m_fXPos = m_fXMid ; 
m_fPos = m_fMid ; 
m_fPrevXMid = m_fXMid ; 
m_fXMid = ( m_fXNeg + m_fXPos ) / 2 ; 
m_fMid = m_aFunction . at ( m_fXMid ) ; 
if ( EqualsHelper . equals ( m_fXMid , m_fPrevXMid ) ) 
public JSONObject toJsonObject ( ) throws JSONException 
JSONObject returnVal = super . toJsonObject ( ) ; 
if ( this . getFluidItem ( ) != null ) 
returnVal . put ( JSONMapping . FLUID_ITEM , 
this . getFluidItem ( ) . toJsonObject ( ) ) ; 
if ( this . getFlowStepRule ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP_RULE , 
this . getFlowStepRule ( ) . toJsonObject ( ) ) ; 
return returnVal ; 
if ( this . getKey ( ) != null ) 
returnVal . put ( JSONMapping . KEY , this . getKey ( ) ) ; 
if ( this . getValue ( ) != null ) 
returnVal . put ( JSONMapping . VALUE , this . getValue ( ) ) ; 
} public List < Collaboration > createCollaboration ( 
List < Collaboration > collaborationsParam 
CollaborationListing collaborationListing = new CollaborationListing ( ) ; 
collaborationListing . setListing ( collaborationsParam ) ; 
if ( this . serviceTicket != null ) { 
collaborationListing . setServiceTicket ( this . serviceTicket ) ; 
return new CollaborationListing ( this . putJson ( 
collaborationListing , WS . Path . Collaboration . Version1 . collaborationCreate ( ) ) ) . getListing ( ) ; 
} public List < Collaboration > getAllToByLoggedIn ( ) { 
return new CollaborationListing ( this . postJson ( 
collaborationListing , WS . Path . Collaboration . Version1 . getAllToByLoggedIn ( ) ) ) . getListing ( ) ; 
} public List < Collaboration > getAllToByForm ( Form formParam ) { 
if ( formParam != null && this . serviceTicket != null ) { 
formParam . setServiceTicket ( this . serviceTicket ) ; 
formParam , WS . Path . Collaboration . Version1 . getAllToByForm ( ) ) ) . getListing ( ) ; 
if ( this . getFormContainer ( ) != null ) 
returnVal . put ( JSONMapping . FORM_CONTAINER , 
this . getFormContainer ( ) . toJsonObject ( ) ) ; 
if ( this . getParentFormContainer ( ) != null ) 
returnVal . put ( JSONMapping . PARENT_FORM_CONTAINER , 
this . getParentFormContainer ( ) . toJsonObject ( ) ) ; 
if ( this . getParentFormField ( ) != null ) 
returnVal . put ( JSONMapping . PARENT_FORM_FIELD , 
this . getParentFormField ( ) . toJsonObject ( ) ) ; 
public JSONObject toJsonObject ( ) throws JSONException { 
if ( this . isCanCreateAndModify ( ) != null ) 
returnVal . put ( JSONMapping . CAN_CREATE_AND_MODIFY , 
this . isCanCreateAndModify ( ) . booleanValue ( ) ) ; 
if ( this . isCanView ( ) != null ) 
returnVal . put ( JSONMapping . CAN_VIEW , 
this . isCanView ( ) . booleanValue ( ) ) ; 
if ( this . getFormFieldToFormDefinition ( ) != null ) 
returnVal . put ( JSONMapping . FORM_FIELD_TO_FORM_DEFINITION , 
this . getFormFieldToFormDefinition ( ) . toJsonObject ( ) ) ; 
JSONObject returnVal = new JSONObject ( ) ; 
if ( this . getTemplateName ( ) != null ) 
returnVal . put ( JSONMapping . TEMPLATE_NAME , 
this . getTemplateName ( ) ) ; 
if ( this . getTemplateDescription ( ) != null ) 
returnVal . put ( JSONMapping . TEMPLATE_DESCRIPTION , 
this . getTemplateDescription ( ) ) ; 
if ( this . getTemplateComment ( ) != null ) 
returnVal . put ( JSONMapping . TEMPLATE_COMMENT , 
this . getTemplateComment ( ) ) ; 
if ( this . getFormsAndFields ( ) != null && ! this . getFormsAndFields ( ) . isEmpty ( ) ) 
JSONArray jsonArray = new JSONArray ( ) ; 
for ( Form form : this . getFormsAndFields ( ) ) 
jsonArray . put ( form . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FORMS_AND_FIELDS , jsonArray ) ; 
if ( this . getUserQueries ( ) != null && ! this . getUserQueries ( ) . isEmpty ( ) ) 
for ( UserQuery userQuery : this . getUserQueries ( ) ) 
jsonArray . put ( userQuery . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_QUERIES , jsonArray ) ; 
if ( this . getFlows ( ) != null && ! this . getFlows ( ) . isEmpty ( ) ) 
for ( Flow flow : this . getFlows ( ) ) 
jsonArray . put ( flow . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FLOWS , jsonArray ) ; 
if ( this . getThirdPartyLibraries ( ) != null && 
! this . getThirdPartyLibraries ( ) . isEmpty ( ) ) 
for ( ThirdPartyLibrary thirdPartyLibrary : this . getThirdPartyLibraries ( ) ) 
jsonArray . put ( thirdPartyLibrary . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . THIRD_PARTY_LIBRARIES , jsonArray ) ; 
if ( this . getUserFields ( ) != null && ! this . getUserFields ( ) . isEmpty ( ) ) 
for ( Field field : this . getUserFields ( ) ) 
jsonArray . put ( field . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_FIELDS , jsonArray ) ; 
if ( this . getRouteFields ( ) != null && ! this . getRouteFields ( ) . isEmpty ( ) ) 
JSONArray fieldsArr = new JSONArray ( ) ; 
for ( Field toAdd : this . getRouteFields ( ) ) 
fieldsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROUTE_FIELDS , fieldsArr ) ; 
if ( this . getGlobalFields ( ) != null && ! this . getGlobalFields ( ) . isEmpty ( ) ) 
for ( Field toAdd : this . getGlobalFields ( ) ) 
returnVal . put ( JSONMapping . GLOBAL_FIELDS , fieldsArr ) ; 
if ( this . getName ( ) != null ) 
returnVal . put ( JSONMapping . NAME , this . getName ( ) ) ; 
if ( this . getDescription ( ) != null ) 
returnVal . put ( JSONMapping . DESCRIPTION , this . getDescription ( ) ) ; 
if ( this . getFlowSteps ( ) != null && ! this . getFlowSteps ( ) . isEmpty ( ) ) 
for ( FlowStep rule : this . getFlowSteps ( ) ) 
jsonArray . put ( rule . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FLOW_STEPS , jsonArray ) ; 
if ( this . getDateCreated ( ) != null ) 
returnVal . put ( JSONMapping . DATE_CREATED , this . getDateAsLongFromJson ( 
this . getDateCreated ( ) ) ) ; 
if ( this . getDateLastUpdated ( ) != null ) 
returnVal . put ( JSONMapping . DATE_LAST_UPDATED , this . getDateAsLongFromJson ( 
this . getDateLastUpdated ( ) ) ) ; 
} protected String getMetaDataForDecimalAs ( 
String metaDataPrefixParam , 
double minParam , 
double maxParam , 
double stepFactorParam , 
String prefixParam 
StringBuffer returnBuffer = new StringBuffer ( ) ; 
if ( metaDataPrefixParam != null && ! metaDataPrefixParam . isEmpty ( ) ) { 
returnBuffer . append ( metaDataPrefixParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . MIN ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; 
